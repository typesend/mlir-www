<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">17.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1detail.html">detail</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mlir::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Detect if any of the given parameter types has a sub-element handler.  
<a href="namespacemlir_1_1detail.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1detail_1_1analysis__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail_1_1analysis__impl.html">analysis_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1detail_1_1pass__options"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail_1_1pass__options.html">pass_options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1detail_1_1pdl__function__builder"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail_1_1pdl__function__builder.html">pdl_function_builder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1detail_1_1storage__user__base__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail_1_1storage__user__base__impl.html">storage_user_base_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1detail_1_1StorageUserTrait"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail_1_1StorageUserTrait.html">StorageUserTrait</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AliasAnalysisTraits.html">AliasAnalysisTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains various internal trait classes used by the main <a class="el" href="classmlir_1_1AliasAnalysis.html" title="This class represents the main alias analysis interface in MLIR.">AliasAnalysis</a> class below.  <a href="structmlir_1_1detail_1_1AliasAnalysisTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1CallbackOstream.html">CallbackOstream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple raw ostream subclass that forwards write_impl calls to the user-supplied callback together with opaque user-supplied data.  <a href="classmlir_1_1detail_1_1CallbackOstream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1Vector1D.html">Vector1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1Vector1D_3_01T_00_01Dim_00_01true_01_4.html">Vector1D&lt; T, Dim, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1Vector1D_3_01T_00_01Dim_00_01false_01_4.html">Vector1D&lt; T, Dim, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1AttributeUniquer.html">AttributeUniquer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1is__tuple.html">is_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1is__tuple_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4.html">is_tuple&lt; std::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1op__filter__iterator.html">op_filter_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility iterator that filters out operations that are not 'OpT'.  <a href="classmlir_1_1detail_1_1op__filter__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1op__iterator.html">op_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides iteration over the held operations of a block for a specific operation type.  <a href="classmlir_1_1detail_1_1op__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1ElementsAttrIndexer.html">ElementsAttrIndexer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides support for indexing into the element range of an ElementsAttr.  <a href="structmlir_1_1detail_1_1ElementsAttrIndexer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1ElementsAttrIterator.html">ElementsAttrIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a generic iterator for ElementsAttr.  <a href="classmlir_1_1detail_1_1ElementsAttrIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1ElementsAttrRange.html">ElementsAttrRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides iterator utilities for an ElementsAttr range.  <a href="classmlir_1_1detail_1_1ElementsAttrRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DenseElementIndexedIteratorImpl.html">DenseElementIndexedIteratorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impl iterator for indexed <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a> iterators that records a data pointer and data index that is adjusted for the case of a splat attribute.  <a href="classmlir_1_1detail_1_1DenseElementIndexedIteratorImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1is__complex__t.html">is_complex_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> trait detector that checks if a given type T is a complex type.  <a href="structmlir_1_1detail_1_1is__complex__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1is__complex__t_3_01std_1_1complex_3_01T_01_4_01_4.html">is_complex_t&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">DenseArrayAttrImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for DenseArrayAttr that is instantiated and specialized for each supported element type below.  <a href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">DenseResourceElementsAttrBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="classDenseResourceElementsAttr.html">DenseResourceElementsAttr</a> that is instantiated and specialized for each supported element type below.  <a href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DialectInterfaceBase.html">DialectInterfaceBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class used for all derived interface types.  <a href="classmlir_1_1detail_1_1DialectInterfaceBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DialectInterfaceCollectionBase.html">DialectInterfaceCollectionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the base class for a collection of instances for a specific interface kind.  <a href="classmlir_1_1detail_1_1DialectInterfaceCollectionBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DominanceInfoBase.html">DominanceInfoBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1attr__value__binder.html">attr_value_binder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a certain kind of <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> and binds the value inside the <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>.  <a href="structmlir_1_1detail_1_1attr__value__binder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__op__matcher.html">constant_op_matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches operations that have the <code>ConstantLike</code> trait.  <a href="structmlir_1_1detail_1_1constant__op__matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1NameOpMatcher.html">NameOpMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches operations that have the specified op name.  <a href="structmlir_1_1detail_1_1NameOpMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AttrOpMatcher.html">AttrOpMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches operations that have the specified attribute name.  <a href="structmlir_1_1detail_1_1AttrOpMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__op__binder.html">constant_op_binder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches operations that have the <code>ConstantLike</code> trait, and binds the folded attribute value.  <a href="structmlir_1_1detail_1_1constant__op__binder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AttrOpBinder.html">AttrOpBinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches operations that have the specified attribute name, and binds the attribute value.  <a href="structmlir_1_1detail_1_1AttrOpBinder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__float__op__binder.html">constant_float_op_binder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a constant scalar / vector splat / tensor splat float operation and binds the constant float value.  <a href="structmlir_1_1detail_1_1constant__float__op__binder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">constant_float_predicate_matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a given target constant scalar / vector splat / tensor splat float value that fulfills a predicate.  <a href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__int__op__binder.html">constant_int_op_binder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a constant scalar / vector splat / tensor splat integer operation and binds the constant integer value.  <a href="structmlir_1_1detail_1_1constant__int__op__binder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">constant_int_predicate_matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a given target constant scalar / vector splat / tensor splat integer value that fulfills a predicate.  <a href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">op_matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a certain kind of op.  <a href="structmlir_1_1detail_1_1op__matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AnyValueMatcher.html">AnyValueMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminal matcher, always returns true.  <a href="structmlir_1_1detail_1_1AnyValueMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AnyCapturedValueMatcher.html">AnyCapturedValueMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminal matcher, always returns true.  <a href="structmlir_1_1detail_1_1AnyCapturedValueMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1PatternMatcherValue.html">PatternMatcherValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds to a specific value and matches it.  <a href="structmlir_1_1detail_1_1PatternMatcherValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1RecursivePatternMatcher.html">RecursivePatternMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1detail_1_1RecursivePatternMatcher.html" title="RecursivePatternMatcher that composes.">RecursivePatternMatcher</a> that composes.  <a href="structmlir_1_1detail_1_1RecursivePatternMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1OperandStorage.html">OperandStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class handles the management of operation operands.  <a href="classmlir_1_1detail_1_1OperandStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1OpOrInterfaceRewritePatternBase.html">OpOrInterfaceRewritePatternBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1detail_1_1OpOrInterfaceRewritePatternBase.html" title="OpOrInterfaceRewritePatternBase is a wrapper around RewritePattern that allows for matching and rewri...">OpOrInterfaceRewritePatternBase</a> is a wrapper around <a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements.">RewritePattern</a> that allows for matching and rewriting against an instance of a derived operation class or <a class="el" href="classmlir_1_1detail_1_1Interface.html" title="This class represents an abstract interface.">Interface</a>.  <a href="structmlir_1_1detail_1_1OpOrInterfaceRewritePatternBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserTraitBase.html">StorageUserTraitBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for implementing traits for storage classes.  <a href="classmlir_1_1detail_1_1StorageUserTraitBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">StorageUserBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for implementing users of storage classes uniqued by a <a class="el" href="classmlir_1_1StorageUniquer.html" title="A utility class to get or create instances of &quot;storage classes&quot;.">StorageUniquer</a>.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1TypeUniquer.html">TypeUniquer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to get, or create, unique instances of types within an <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a>.  <a href="structmlir_1_1detail_1_1TypeUniquer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1IROperandBase.html">IROperandBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the base for <a class="el" href="classmlir_1_1IROperand.html" title="A reference to a value, suitable for use as an operand of an operation.">IROperand</a>, and provides all of the non-templated facilities for operand use management.  <a href="classmlir_1_1detail_1_1IROperandBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1ValueImpl.html">ValueImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for all derived <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> classes.  <a href="classmlir_1_1detail_1_1ValueImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1BlockArgumentImpl.html">BlockArgumentImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal implementation of a <a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a>.  <a href="classmlir_1_1detail_1_1BlockArgumentImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1OpResultImpl.html">OpResultImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the implementation for an operation result.  <a href="classmlir_1_1detail_1_1OpResultImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1InlineOpResult.html">InlineOpResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the implementation for an operation result whose index can be represented "inline" in the underlying <a class="el" href="classmlir_1_1detail_1_1ValueImpl.html" title="The base class for all derived Value classes.">ValueImpl</a>.  <a href="structmlir_1_1detail_1_1InlineOpResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1OutOfLineOpResult.html">OutOfLineOpResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the implementation for an operation result whose index cannot be represented "inline", and thus requires an additional index field.  <a href="classmlir_1_1detail_1_1OutOfLineOpResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1TypedValue.html">TypedValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1detail_1_1TypedValue.html" title="TypedValue is a Value with a statically know type.">TypedValue</a> is a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> with a statically know type.  <a href="structmlir_1_1detail_1_1TypedValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PreservedAnalyses.html">PreservedAnalyses</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to represent the analyses that are known to be preserved.  <a href="classmlir_1_1detail_1_1PreservedAnalyses.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AnalysisConcept.html">AnalysisConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract polymorphic base class representing an analysis.  <a href="structmlir_1_1detail_1_1AnalysisConcept.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AnalysisModel.html">AnalysisModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A derived analysis model used to hold a specific analysis object.  <a href="structmlir_1_1detail_1_1AnalysisModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1AnalysisMap.html">AnalysisMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a cache of analyses for a single operation.  <a href="classmlir_1_1detail_1_1AnalysisMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1NestedAnalysisMap.html">NestedAnalysisMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An analysis map that contains a map for the current operation, and a set of maps for any child operations.  <a href="structmlir_1_1detail_1_1NestedAnalysisMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1PassExecutionState.html">PassExecutionState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The state for a single execution of a pass.  <a href="structmlir_1_1detail_1_1PassExecutionState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PassOptions.html">PassOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base container class and manager for all pass options.  <a href="classmlir_1_1detail_1_1PassOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Interface.html">Interface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an abstract interface.  <a href="classmlir_1_1detail_1_1Interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1count__if__t__impl.html">count_if_t_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template utility that computes the number of elements within <code>T</code> that satisfy the given predicate.  <a href="structmlir_1_1detail_1_1count__if__t__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1count__if__t__impl_3_01Pred_00_01N_00_01T_00_01Us_8_8_8_01_4.html">count_if_t_impl&lt; Pred, N, T, Us... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1InterfaceMap.html">InterfaceMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an efficient mapping between a given <code><a class="el" href="classmlir_1_1detail_1_1Interface.html" title="This class represents an abstract interface.">Interface</a></code> type, and a particular implementation of its concept.  <a href="classmlir_1_1detail_1_1InterfaceMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1FallbackTypeIDResolver.html">FallbackTypeIDResolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a fallback for resolving TypeIDs.  <a href="classmlir_1_1detail_1_1FallbackTypeIDResolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1TypeIDResolver.html">TypeIDResolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a resolver for getting the ID for a given class T.  <a href="classmlir_1_1detail_1_1TypeIDResolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1InlineTypeIDResolver.html">InlineTypeIDResolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides utilities for resolving the <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a> of a class that provides a <code>static <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a> <a class="el" href="structmlir_1_1detail_1_1InlineTypeIDResolver.html#a94343b857aec8e86b6000bbd453f786b">resolveTypeID()</a></code> method.  <a href="structmlir_1_1detail_1_1InlineTypeIDResolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1TypeIDResolver_3_01T_00_01std_1_1enable__if__t_3_01InlineTypeIDResolver_1d0aed3a2268b37a1e2af8caec7ea91e4.html">TypeIDResolver&lt; T, std::enable_if_t&lt; InlineTypeIDResolver::has_resolve_typeid&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a resolver for getting the ID for a given class T, when the class provides a <code>static <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a> <a class="el" href="classmlir_1_1detail_1_1TypeIDResolver_3_01T_00_01std_1_1enable__if__t_3_01InlineTypeIDResolver_1d0aed3a2268b37a1e2af8caec7ea91e4.html#a44f66ca9f3d85b18a223313feb90f7e7">resolveTypeID()</a></code> method.  <a href="classmlir_1_1detail_1_1TypeIDResolver_3_01T_00_01std_1_1enable__if__t_3_01InlineTypeIDResolver_1d0aed3a2268b37a1e2af8caec7ea91e4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1AsmParserImpl.html">AsmParserImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the implementation of the generic parser methods within <a class="el" href="classmlir_1_1AsmParser.html" title="This base class exposes generic asm parser hooks, usable across the various derived parsers.">AsmParser</a>.  <a href="classmlir_1_1detail_1_1AsmParserImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html">Parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implement support for parsing global entities like attributes and types.  <a href="classmlir_1_1detail_1_1Parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1SymbolState.html">SymbolState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains record of any parsed top-level symbols.  <a href="structmlir_1_1detail_1_1SymbolState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1ParserState.html">ParserState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class refers to all of the state maintained globally by the parser, such as the current lexer position etc.  <a href="structmlir_1_1detail_1_1ParserState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineExprStorage.html">AffineExprStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base storage class appearing in an affine expression.  <a href="structmlir_1_1detail_1_1AffineExprStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineBinaryOpExprStorage.html">AffineBinaryOpExprStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A binary operation appearing in an affine expression.  <a href="structmlir_1_1detail_1_1AffineBinaryOpExprStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineDimExprStorage.html">AffineDimExprStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimensional or symbolic identifier appearing in an affine expression.  <a href="structmlir_1_1detail_1_1AffineDimExprStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineConstantExprStorage.html">AffineConstantExprStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer constant appearing in affine expression.  <a href="structmlir_1_1detail_1_1AffineConstantExprStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineMapStorage.html">AffineMapStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1AsmStateImpl.html">AsmStateImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DenseElementsAttributeStorage.html">DenseElementsAttributeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute representing a reference to a dense vector or tensor object.  <a href="structmlir_1_1detail_1_1DenseElementsAttributeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DenseIntOrFPElementsAttrStorage.html">DenseIntOrFPElementsAttrStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute representing a reference to a dense vector or tensor object.  <a href="structmlir_1_1detail_1_1DenseIntOrFPElementsAttrStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DenseStringElementsAttrStorage.html">DenseStringElementsAttrStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute representing a reference to a dense vector or tensor object containing strings.  <a href="structmlir_1_1detail_1_1DenseStringElementsAttrStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1StringAttrStorage.html">StringAttrStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DiagnosticEngineImpl.html">DiagnosticEngineImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1SourceMgrDiagnosticHandlerImpl.html">SourceMgrDiagnosticHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1ExpectedDiag.html">ExpectedDiag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an expected output diagnostic.  <a href="structmlir_1_1detail_1_1ExpectedDiag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1SourceMgrDiagnosticVerifierHandlerImpl.html">SourceMgrDiagnosticVerifierHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1ParallelDiagnosticHandlerImpl.html">ParallelDiagnosticHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DynamicTypeStorage.html">DynamicTypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage of <a class="el" href="classmlir_1_1DynamicType.html" title="A dynamic type instance.">DynamicType</a>.  <a href="structmlir_1_1detail_1_1DynamicTypeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DynamicAttrStorage.html">DynamicAttrStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage of <a class="el" href="classmlir_1_1DynamicAttr.html" title="A dynamic attribute instance.">DynamicAttr</a>.  <a href="structmlir_1_1detail_1_1DynamicAttrStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1IntegerSetStorage.html">IntegerSetStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1IntegerTypeStorage.html">IntegerTypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> Storage and Uniquing.  <a href="structmlir_1_1detail_1_1IntegerTypeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1FunctionTypeStorage.html">FunctionTypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> Storage and Uniquing.  <a href="structmlir_1_1detail_1_1FunctionTypeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1TupleTypeStorage.html">TupleTypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type representing a collection of other types.  <a href="structmlir_1_1detail_1_1TupleTypeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1OpPassManagerImpl.html">OpPassManagerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1PassInstrumentorImpl.html">PassInstrumentorImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1RecoveryReproducerContext.html">RecoveryReproducerContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the context for generating a recovery reproducer.  <a href="structmlir_1_1detail_1_1RecoveryReproducerContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1OpToOpPassAdaptor.html">OpToOpPassAdaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptor pass used to run operation passes over nested operations.  <a href="classmlir_1_1detail_1_1OpToOpPassAdaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PassCrashReproducerGenerator.html">PassCrashReproducerGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1PassPipelineCLParserImpl.html">PassPipelineCLParserImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PDLByteCodePattern.html">PDLByteCodePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">All of the data pertaining to a specific pattern within the bytecode.  <a href="classmlir_1_1detail_1_1PDLByteCodePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PDLByteCodeMutableState.html">PDLByteCodeMutableState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains the mutable state of a bytecode instance.  <a href="classmlir_1_1detail_1_1PDLByteCodeMutableState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PDLByteCode.html">PDLByteCode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bytecode class is also the interpreter.  <a href="classmlir_1_1detail_1_1PDLByteCode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1StorageUniquerImpl.html">StorageUniquerImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the implementation of the <a class="el" href="classmlir_1_1StorageUniquer.html" title="A utility class to get or create instances of &quot;storage classes&quot;.">StorageUniquer</a> class.  <a href="structmlir_1_1detail_1_1StorageUniquerImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1TimingManagerImpl.html">TimingManagerImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private implementation details of the <code><a class="el" href="classmlir_1_1TimingManager.html" title="This class represents facilities to measure execution time.">TimingManager</a></code>.  <a href="classmlir_1_1detail_1_1TimingManagerImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DefaultTimingManagerImpl.html">DefaultTimingManagerImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation details of the <code><a class="el" href="classmlir_1_1DefaultTimingManager.html" title="Facilities for time measurement and report printing to an output stream.">DefaultTimingManager</a></code>.  <a href="classmlir_1_1detail_1_1DefaultTimingManagerImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1ConversionPatternRewriterImpl.html">ConversionPatternRewriterImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6674e02b9acfc220caf0a47e6dbab6ea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6674e02b9acfc220caf0a47e6dbab6ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a6674e02b9acfc220caf0a47e6dbab6ea">has_default_sub_element_handler_t</a> = decltype(T::DefaultHandlerTag)</td></tr>
<tr class="separator:a6674e02b9acfc220caf0a47e6dbab6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec637be4fc5a4b359ff417c0f44350b4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:aec637be4fc5a4b359ff417c0f44350b4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#aec637be4fc5a4b359ff417c0f44350b4">has_get_method</a> = decltype(T::get(std::declval&lt; Ts &gt;()...))</td></tr>
<tr class="separator:aec637be4fc5a4b359ff417c0f44350b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c91ce05af5c861e1d789201346c457c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a3c91ce05af5c861e1d789201346c457c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a3c91ce05af5c861e1d789201346c457c">has_get_as_key</a> = decltype(std::declval&lt; T &gt;().getAsKey())</td></tr>
<tr class="separator:a3c91ce05af5c861e1d789201346c457c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912e3cd5feea0574a2f3fce7c34dcefd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a912e3cd5feea0574a2f3fce7c34dcefd">DenseIterPtrAndSplat</a> = std::pair&lt; const char *, bool &gt;</td></tr>
<tr class="memdesc:a912e3cd5feea0574a2f3fce7c34dcefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pair of raw pointer and a boolean flag of whether the pointer holds a splat,.  <a href="namespacemlir_1_1detail.html#a912e3cd5feea0574a2f3fce7c34dcefd">More...</a><br /></td></tr>
<tr class="separator:a912e3cd5feea0574a2f3fce7c34dcefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea4de026e8ae1a9a190b47a066df22f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abea4de026e8ae1a9a190b47a066df22f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#abea4de026e8ae1a9a190b47a066df22f">has_push_back_t</a> = decltype(std::declval&lt; T &gt;().push_back(std::declval&lt; typename T::value_type &amp;&amp; &gt;()))</td></tr>
<tr class="separator:abea4de026e8ae1a9a190b47a066df22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d607e4b534651dbd796b895db9e07b3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename OperationOrValue &gt; </td></tr>
<tr class="memitem:a0d607e4b534651dbd796b895db9e07b3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a0d607e4b534651dbd796b895db9e07b3">has_operation_or_value_matcher_t</a> = decltype(std::declval&lt; T &gt;().match(std::declval&lt; OperationOrValue &gt;()))</td></tr>
<tr class="memdesc:a0d607e4b534651dbd796b895db9e07b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check whether T provides a 'match' method with type <code>OperationOrValue</code>.  <a href="namespacemlir_1_1detail.html#a0d607e4b534651dbd796b895db9e07b3">More...</a><br /></td></tr>
<tr class="separator:a0d607e4b534651dbd796b895db9e07b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b75c9bae3caf1909b6d6277fb6ea61"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2b75c9bae3caf1909b6d6277fb6ea61"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ae2b75c9bae3caf1909b6d6277fb6ea61">first_argument</a> = decltype(<a class="el" href="namespacemlir_1_1detail.html#a63c39ecb3618964551c0b29bc356b675">first_argument_type</a>(std::declval&lt; T &gt;()))</td></tr>
<tr class="memdesc:ae2b75c9bae3caf1909b6d6277fb6ea61"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> definition of the first argument to the given callable 'T'.  <a href="namespacemlir_1_1detail.html#ae2b75c9bae3caf1909b6d6277fb6ea61">More...</a><br /></td></tr>
<tr class="separator:ae2b75c9bae3caf1909b6d6277fb6ea61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5258e43cc82e8e9a4c2c605f10a16461"><td class="memTemplParams" colspan="2">template&lt;typename FnT &gt; </td></tr>
<tr class="memitem:a5258e43cc82e8e9a4c2c605f10a16461"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a5258e43cc82e8e9a4c2c605f10a16461">walkResultType</a> = decltype(<a class="el" href="namespacemlir_1_1detail.html#a152b851682ac1cad31c84dc1a6fc38cb">walk</a>(nullptr, std::declval&lt; FnT &gt;()))</td></tr>
<tr class="memdesc:a5258e43cc82e8e9a4c2c605f10a16461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to provide the return type of a templated walk method.  <a href="namespacemlir_1_1detail.html#a5258e43cc82e8e9a4c2c605f10a16461">More...</a><br /></td></tr>
<tr class="separator:a5258e43cc82e8e9a4c2c605f10a16461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbea31f5f9034714e29d3a49cae75a4"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class Pred, typename... Ts&gt; </td></tr>
<tr class="memitem:aabbea31f5f9034714e29d3a49cae75a4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#aabbea31f5f9034714e29d3a49cae75a4">count_if_t</a> = <a class="el" href="structmlir_1_1detail_1_1count__if__t__impl.html">count_if_t_impl</a>&lt; Pred, 0, Ts... &gt;</td></tr>
<tr class="separator:aabbea31f5f9034714e29d3a49cae75a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf60d55489c71894501becbfaa8c21c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:addf60d55489c71894501becbfaa8c21c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#addf60d55489c71894501becbfaa8c21c">is_interface_t</a> = decltype(<a class="el" href="namespacemlir_1_1detail.html#a493be0c467bac528a100115486f3ec69">isInterfaceImpl</a>(std::declval&lt; T &amp; &gt;()))</td></tr>
<tr class="separator:addf60d55489c71894501becbfaa8c21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b5779c5d7667528bc58cd2f184f180"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae9b5779c5d7667528bc58cd2f184f180"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ae9b5779c5d7667528bc58cd2f184f180">IsInterface</a> = llvm::is_detected&lt; <a class="el" href="namespacemlir_1_1detail.html#addf60d55489c71894501becbfaa8c21c">is_interface_t</a>, T &gt;</td></tr>
<tr class="separator:ae9b5779c5d7667528bc58cd2f184f180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be2dcfec91412eb27290aab9294b4cc"><td class="memTemplParams" colspan="2">template&lt;typename ImplTy , typename... Args&gt; </td></tr>
<tr class="memitem:a1be2dcfec91412eb27290aab9294b4cc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a1be2dcfec91412eb27290aab9294b4cc">has_impltype_getkey_t</a> = decltype(ImplTy::getKey(std::declval&lt; Args &gt;()...))</td></tr>
<tr class="memdesc:a1be2dcfec91412eb27290aab9294b4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if ImplTy provides a 'getKey' method with types 'Args'.  <a href="namespacemlir_1_1detail.html#a1be2dcfec91412eb27290aab9294b4cc">More...</a><br /></td></tr>
<tr class="separator:a1be2dcfec91412eb27290aab9294b4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2713c77027515db7c2d5f698d0f33c"><td class="memTemplParams" colspan="2">template&lt;typename ImplTy , typename T &gt; </td></tr>
<tr class="memitem:afb2713c77027515db7c2d5f698d0f33c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#afb2713c77027515db7c2d5f698d0f33c">has_impltype_hash_t</a> = decltype(ImplTy::hashKey(std::declval&lt; T &gt;()))</td></tr>
<tr class="memdesc:afb2713c77027515db7c2d5f698d0f33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if ImplTy provides a 'hashKey' method for 'T'.  <a href="namespacemlir_1_1detail.html#afb2713c77027515db7c2d5f698d0f33c">More...</a><br /></td></tr>
<tr class="separator:afb2713c77027515db7c2d5f698d0f33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ac2de9a9d0eebfe67eb5e4db2084f1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ab5ac2de9a9d0eebfe67eb5e4db2084f1">ByteCodeField</a> = uint16_t</td></tr>
<tr class="memdesc:ab5ac2de9a9d0eebfe67eb5e4db2084f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use generic bytecode types.  <a href="namespacemlir_1_1detail.html#ab5ac2de9a9d0eebfe67eb5e4db2084f1">More...</a><br /></td></tr>
<tr class="separator:ab5ac2de9a9d0eebfe67eb5e4db2084f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9ab167043a2e4cd4d0e666853d6170"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a1d9ab167043a2e4cd4d0e666853d6170">ByteCodeAddr</a> = uint32_t</td></tr>
<tr class="separator:a1d9ab167043a2e4cd4d0e666853d6170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34799170e951dbbdab0628a01e97344"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#af34799170e951dbbdab0628a01e97344">OwningOpRange</a> = llvm::OwningArrayRef&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;</td></tr>
<tr class="separator:af34799170e951dbbdab0628a01e97344"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a78296380781bb5c3af2dd2ad9b70c26f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a78296380781bb5c3af2dd2ad9b70c26f">OpProperties</a> : char </td></tr>
<tr class="memdesc:a78296380781bb5c3af2dd2ad9b70c26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a "tag" used for mapping the properties storage in llvm::TrailingObjects.  <a href="namespacemlir_1_1detail.html#a78296380781bb5c3af2dd2ad9b70c26f">More...</a><br /></td></tr>
<tr class="separator:a78296380781bb5c3af2dd2ad9b70c26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1e92b3730d5a0d2e1c4f704cb4674d1e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a1e92b3730d5a0d2e1c4f704cb4674d1e">isPowerOf2</a> (int n)</td></tr>
<tr class="separator:a1e92b3730d5a0d2e1c4f704cb4674d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a50c1b52f8e20f12e77716d79a5868"><td class="memItemLeft" align="right" valign="top">constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a69a50c1b52f8e20f12e77716d79a5868">nextPowerOf2</a> (int n)</td></tr>
<tr class="separator:a69a50c1b52f8e20f12e77716d79a5868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48e4040142437e45b8fe0f83b837ad9"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:ab48e4040142437e45b8fe0f83b837ad9"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; int64_t, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ab48e4040142437e45b8fe0f83b837ad9">makeStrides</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape)</td></tr>
<tr class="memdesc:ab48e4040142437e45b8fe0f83b837ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a shape with sizes greater than 0 along all dimensions, returns the distance, in number of elements, between a slice in a dimension and the next slice in the same dimension.  <a href="namespacemlir_1_1detail.html#ab48e4040142437e45b8fe0f83b837ad9">More...</a><br /></td></tr>
<tr class="separator:ab48e4040142437e45b8fe0f83b837ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8eaeb3d7b3be7839ef146f1f82a313"><td class="memTemplParams" colspan="2">template&lt;int N, typename T &gt; </td></tr>
<tr class="memitem:ada8eaeb3d7b3be7839ef146f1f82a313"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(N &gt;=1), <a class="el" href="structStridedMemRefType.html">StridedMemRefType</a>&lt; T, N &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ada8eaeb3d7b3be7839ef146f1f82a313">makeStridedMemRefDescriptor</a> (T *ptr, T *alignedPtr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shapeAlloc)</td></tr>
<tr class="memdesc:ada8eaeb3d7b3be7839ef146f1f82a313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <code>StridedMemRefDescriptor&lt;T, N&gt;</code> that matches the MLIR ABI.  <a href="namespacemlir_1_1detail.html#ada8eaeb3d7b3be7839ef146f1f82a313">More...</a><br /></td></tr>
<tr class="separator:ada8eaeb3d7b3be7839ef146f1f82a313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a76d14b47a24b32bcb01c58dced65f8"><td class="memTemplParams" colspan="2">template&lt;int N, typename T &gt; </td></tr>
<tr class="memitem:a1a76d14b47a24b32bcb01c58dced65f8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(N==0), <a class="el" href="structStridedMemRefType.html">StridedMemRefType</a>&lt; T, 0 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a1a76d14b47a24b32bcb01c58dced65f8">makeStridedMemRefDescriptor</a> (T *ptr, T *alignedPtr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shapeAlloc={})</td></tr>
<tr class="memdesc:a1a76d14b47a24b32bcb01c58dced65f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <code>StridedMemRefDescriptor&lt;T, 0&gt;</code> that matches the MLIR ABI.  <a href="namespacemlir_1_1detail.html#a1a76d14b47a24b32bcb01c58dced65f8">More...</a><br /></td></tr>
<tr class="separator:a1a76d14b47a24b32bcb01c58dced65f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae964b04f941d43593051e7ffd751e6c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae964b04f941d43593051e7ffd751e6c1"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; T *, T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ae964b04f941d43593051e7ffd751e6c1">allocAligned</a> (size_t nElements, <a class="el" href="namespacemlir.html#ac9afb3b6f82b256aea9f20e913e8afd5">AllocFunType</a> allocFun=&amp;::malloc, std::optional&lt; uint64_t &gt; alignment=std::optional&lt; uint64_t &gt;())</td></tr>
<tr class="memdesc:ae964b04f941d43593051e7ffd751e6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align <code>nElements</code> of type T with an optional <code>alignment</code>.  <a href="namespacemlir_1_1detail.html#ae964b04f941d43593051e7ffd751e6c1">More...</a><br /></td></tr>
<tr class="separator:ae964b04f941d43593051e7ffd751e6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083757618e89b0f53d587541eccf53e0"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a083757618e89b0f53d587541eccf53e0">getBranchSuccessorArgument</a> (const <a class="el" href="classmlir_1_1SuccessorOperands.html">SuccessorOperands</a> &amp;operands, unsigned operandIndex, <a class="el" href="classmlir_1_1Block.html">Block</a> *successor)</td></tr>
<tr class="memdesc:a083757618e89b0f53d587541eccf53e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <code><a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a></code> corresponding to operand <code>operandIndex</code> in some successor if <code>operandIndex</code> is within the range of <code>operands</code>, or std::nullopt if <code>operandIndex</code> isn't a successor operand index.  <a href="namespacemlir_1_1detail.html#a083757618e89b0f53d587541eccf53e0">More...</a><br /></td></tr>
<tr class="separator:a083757618e89b0f53d587541eccf53e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2f4d4cb24fe5f60b359e5962ad5498"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a2e2f4d4cb24fe5f60b359e5962ad5498">verifyBranchSuccessorOperands</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, unsigned succNo, const <a class="el" href="classmlir_1_1SuccessorOperands.html">SuccessorOperands</a> &amp;operands)</td></tr>
<tr class="memdesc:a2e2f4d4cb24fe5f60b359e5962ad5498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that the given operands match those of the given successor block.  <a href="namespacemlir_1_1detail.html#a2e2f4d4cb24fe5f60b359e5962ad5498">More...</a><br /></td></tr>
<tr class="separator:a2e2f4d4cb24fe5f60b359e5962ad5498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4afbba3aecdff992f5fb31b086f9c12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ae4afbba3aecdff992f5fb31b086f9c12">verifyTypesAlongControlFlowEdges</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ae4afbba3aecdff992f5fb31b086f9c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that types match along control flow edges described the given op.  <a href="namespacemlir_1_1detail.html#ae4afbba3aecdff992f5fb31b086f9c12">More...</a><br /></td></tr>
<tr class="separator:ae4afbba3aecdff992f5fb31b086f9c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f192c53dfd75f982a0f688bb068021"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ae4f192c53dfd75f982a0f688bb068021">getDefaultTypeSize</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a> params)</td></tr>
<tr class="memdesc:ae4f192c53dfd75f982a0f688bb068021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the type size request.  <a href="namespacemlir_1_1detail.html#ae4f192c53dfd75f982a0f688bb068021">More...</a><br /></td></tr>
<tr class="separator:ae4f192c53dfd75f982a0f688bb068021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25f7d3f6449026adc3574694e6ebf14"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ac25f7d3f6449026adc3574694e6ebf14">getDefaultTypeSizeInBits</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a> params)</td></tr>
<tr class="memdesc:ac25f7d3f6449026adc3574694e6ebf14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the type size in bits request.  <a href="namespacemlir_1_1detail.html#ac25f7d3f6449026adc3574694e6ebf14">More...</a><br /></td></tr>
<tr class="separator:ac25f7d3f6449026adc3574694e6ebf14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7b80c166d5e934716eab0cc1dde085"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a2d7b80c166d5e934716eab0cc1dde085">getDefaultABIAlignment</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DataLayoutEntryInterface &gt; params)</td></tr>
<tr class="memdesc:a2d7b80c166d5e934716eab0cc1dde085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the required alignemnt request.  <a href="namespacemlir_1_1detail.html#a2d7b80c166d5e934716eab0cc1dde085">More...</a><br /></td></tr>
<tr class="separator:a2d7b80c166d5e934716eab0cc1dde085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f841e410185c44a1c45a10e3838c9ca"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a0f841e410185c44a1c45a10e3838c9ca">getDefaultPreferredAlignment</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DataLayoutEntryInterface &gt; params)</td></tr>
<tr class="memdesc:a0f841e410185c44a1c45a10e3838c9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the preferred alignemnt request.  <a href="namespacemlir_1_1detail.html#a0f841e410185c44a1c45a10e3838c9ca">More...</a><br /></td></tr>
<tr class="separator:a0f841e410185c44a1c45a10e3838c9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d624115ea61e5b456d4c613a770631"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a04d624115ea61e5b456d4c613a770631">getDefaultAllocaMemorySpace</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:a04d624115ea61e5b456d4c613a770631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for alloca memory space request.  <a href="namespacemlir_1_1detail.html#a04d624115ea61e5b456d4c613a770631">More...</a><br /></td></tr>
<tr class="separator:a04d624115ea61e5b456d4c613a770631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1317f982611171e2b5cd01994df30bb"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ab1317f982611171e2b5cd01994df30bb">getDefaultStackAlignment</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:ab1317f982611171e2b5cd01994df30bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the stack alignment request.  <a href="namespacemlir_1_1detail.html#ab1317f982611171e2b5cd01994df30bb">More...</a><br /></td></tr>
<tr class="separator:ab1317f982611171e2b5cd01994df30bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d3a751d105f957d43b5ee8ad6ab047"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a72a4f77607d05cf551b24ceb9362c034">DataLayoutEntryList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a31d3a751d105f957d43b5ee8ad6ab047">filterEntriesForType</a> (<a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a> entries, <a class="el" href="classmlir_1_1TypeID.html">TypeID</a> typeID)</td></tr>
<tr class="memdesc:a31d3a751d105f957d43b5ee8ad6ab047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of data layout entries, returns a new list containing the entries with keys having the given type ID, i.e.  <a href="namespacemlir_1_1detail.html#a31d3a751d105f957d43b5ee8ad6ab047">More...</a><br /></td></tr>
<tr class="separator:a31d3a751d105f957d43b5ee8ad6ab047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ddc54fc9b6e82cf3b6a797a6bfefca"><td class="memItemLeft" align="right" valign="top">DataLayoutEntryInterface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#af7ddc54fc9b6e82cf3b6a797a6bfefca">filterEntryForIdentifier</a> (<a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a> entries, StringAttr id)</td></tr>
<tr class="memdesc:af7ddc54fc9b6e82cf3b6a797a6bfefca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of data layout entries, returns the entry that has the given identifier as key, if such an entry exists in the list.  <a href="namespacemlir_1_1detail.html#af7ddc54fc9b6e82cf3b6a797a6bfefca">More...</a><br /></td></tr>
<tr class="separator:af7ddc54fc9b6e82cf3b6a797a6bfefca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3b9d7e0a9cd00a32827f48d4536850"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#aee3b9d7e0a9cd00a32827f48d4536850">verifyDataLayoutOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:aee3b9d7e0a9cd00a32827f48d4536850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the operation implementing the data layout interface, or a module operation, is valid.  <a href="namespacemlir_1_1detail.html#aee3b9d7e0a9cd00a32827f48d4536850">More...</a><br /></td></tr>
<tr class="separator:aee3b9d7e0a9cd00a32827f48d4536850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a791a52efb3f0b9d61ca353b635e95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#af3a791a52efb3f0b9d61ca353b635e95">verifyDataLayoutSpec</a> (DataLayoutSpecInterface spec, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:af3a791a52efb3f0b9d61ca353b635e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that a data layout spec is valid.  <a href="namespacemlir_1_1detail.html#af3a791a52efb3f0b9d61ca353b635e95">More...</a><br /></td></tr>
<tr class="separator:af3a791a52efb3f0b9d61ca353b635e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3a9033156fc6f0f4ee40b16eaa835c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#abc3a9033156fc6f0f4ee40b16eaa835c">verifyDestinationStyleOpInterface</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:abc3a9033156fc6f0f4ee40b16eaa835c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that <code>op</code> conforms to the invariants of DestinationStyleOpInterface.  <a href="namespacemlir_1_1detail.html#abc3a9033156fc6f0f4ee40b16eaa835c">More...</a><br /></td></tr>
<tr class="separator:abc3a9033156fc6f0f4ee40b16eaa835c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e0fca47214fbc553a9b8ec2139ffc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#af5e0fca47214fbc553a9b8ec2139ffc4">inferReturnTensorTypes</a> (<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *, std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; location, <a class="el" href="classmlir_1_1ValueShapeRange.html">ValueShapeRange</a> operands, DictionaryAttr attributes, <a class="el" href="classmlir_1_1OpaqueProperties.html">OpaqueProperties</a> properties, <a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a> regions, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1ShapedTypeComponents.html">ShapedTypeComponents</a> &gt; &amp;retComponents)&gt; componentTypeFn, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; location, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, DictionaryAttr attributes, <a class="el" href="classmlir_1_1OpaqueProperties.html">OpaqueProperties</a> properties, <a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a> regions, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;inferredReturnTypes)</td></tr>
<tr class="separator:af5e0fca47214fbc553a9b8ec2139ffc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad276c5acc7f5d475d0e1987a456a59e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ad276c5acc7f5d475d0e1987a456a59e0">verifyInferredResultTypes</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ad276c5acc7f5d475d0e1987a456a59e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the inferred result types match the actual result types for the op.  <a href="namespacemlir_1_1detail.html#ad276c5acc7f5d475d0e1987a456a59e0">More...</a><br /></td></tr>
<tr class="separator:ad276c5acc7f5d475d0e1987a456a59e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb95161c63d16d49aa77026b304564f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a1cb95161c63d16d49aa77026b304564f">verifyParallelCombiningOpInterface</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a1cb95161c63d16d49aa77026b304564f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819d12bc01c2443cfc1b72c4824bfaba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a819d12bc01c2443cfc1b72c4824bfaba">verifyShapedDimOpInterface</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a819d12bc01c2443cfc1b72c4824bfaba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify invariants of ops that implement the ShapedDimOpInterface.  <a href="namespacemlir_1_1detail.html#a819d12bc01c2443cfc1b72c4824bfaba">More...</a><br /></td></tr>
<tr class="separator:a819d12bc01c2443cfc1b72c4824bfaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebb54d50bfcc329f59aee2490b27c07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#afebb54d50bfcc329f59aee2490b27c07">verifyOffsetSizeAndStrideOp</a> (OffsetSizeAndStrideOpInterface op)</td></tr>
<tr class="separator:afebb54d50bfcc329f59aee2490b27c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0caa43784c57086534e1833f66eaecfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a0caa43784c57086534e1833f66eaecfc">sameOffsetsSizesAndStrides</a> (OffsetSizeAndStrideOpInterface a, OffsetSizeAndStrideOpInterface b, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>)&gt; cmp)</td></tr>
<tr class="separator:a0caa43784c57086534e1833f66eaecfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad693ba34552063984c6685f93500c79f"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ad693ba34552063984c6685f93500c79f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ad693ba34552063984c6685f93500c79f">bindDims</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="separator:ad693ba34552063984c6685f93500c79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc67b3a3dac2996cc431f90b8658f6e6"><td class="memTemplParams" colspan="2">template&lt;int N, typename AffineExprTy , typename... AffineExprTy2&gt; </td></tr>
<tr class="memitem:adc67b3a3dac2996cc431f90b8658f6e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#adc67b3a3dac2996cc431f90b8658f6e6">bindDims</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, AffineExprTy &amp;e, AffineExprTy2 &amp;...exprs)</td></tr>
<tr class="separator:adc67b3a3dac2996cc431f90b8658f6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb63088be1c8bff57b28cc3be96701b"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:addb63088be1c8bff57b28cc3be96701b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#addb63088be1c8bff57b28cc3be96701b">bindSymbols</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="separator:addb63088be1c8bff57b28cc3be96701b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0f1dec3bae54bd6eecd9e5abb59e4c"><td class="memTemplParams" colspan="2">template&lt;int N, typename AffineExprTy , typename... AffineExprTy2&gt; </td></tr>
<tr class="memitem:a2b0f1dec3bae54bd6eecd9e5abb59e4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a2b0f1dec3bae54bd6eecd9e5abb59e4c">bindSymbols</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, AffineExprTy &amp;e, AffineExprTy2 &amp;...exprs)</td></tr>
<tr class="separator:a2b0f1dec3bae54bd6eecd9e5abb59e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc750046567479d1fdfa425bac17b32"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2bc750046567479d1fdfa425bac17b32"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a2bc750046567479d1fdfa425bac17b32">unwrapForCustomParse</a> (<a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; T &gt; &amp;failureOr)</td></tr>
<tr class="separator:a2bc750046567479d1fdfa425bac17b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0ecdf07e5bd3e5496db1048d6b0beb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d0ecdf07e5bd3e5496db1048d6b0beb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a9d0ecdf07e5bd3e5496db1048d6b0beb">walkImmediateSubElementsImpl</a> (T derived, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt; walkAttrsFn, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Type.html">Type</a>)&gt; walkTypesFn)</td></tr>
<tr class="memdesc:a9d0ecdf07e5bd3e5496db1048d6b0beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides the underlying implementation for the SubElementInterface walk method, using the key type of the derived attribute/type to interact with the individual parameters.  <a href="namespacemlir_1_1detail.html#a9d0ecdf07e5bd3e5496db1048d6b0beb">More...</a><br /></td></tr>
<tr class="separator:a9d0ecdf07e5bd3e5496db1048d6b0beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451d8dc61974032518997d3f9935e53a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a451d8dc61974032518997d3f9935e53a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a451d8dc61974032518997d3f9935e53a">constructSubElementReplacement</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, Ts &amp;&amp;...params)</td></tr>
<tr class="memdesc:a451d8dc61974032518997d3f9935e53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function invokes the proper <code>get</code> method for a type <code>T</code> with the given values.  <a href="namespacemlir_1_1detail.html#a451d8dc61974032518997d3f9935e53a">More...</a><br /></td></tr>
<tr class="separator:a451d8dc61974032518997d3f9935e53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af776eda51700256b7c60deadcb4d25"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8af776eda51700256b7c60deadcb4d25"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a8af776eda51700256b7c60deadcb4d25">replaceImmediateSubElementsImpl</a> (T derived, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; &amp;replAttrs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;replTypes)</td></tr>
<tr class="memdesc:a8af776eda51700256b7c60deadcb4d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides the underlying implementation for the SubElementInterface replace method, using the key type of the derived attribute/type to interact with the individual parameters.  <a href="namespacemlir_1_1detail.html#a8af776eda51700256b7c60deadcb4d25">More...</a><br /></td></tr>
<tr class="separator:a8af776eda51700256b7c60deadcb4d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3315ae7edc12bed53da6a26424d047"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ada3315ae7edc12bed53da6a26424d047">verifyAffineMapAsLayout</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> m, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="separator:ada3315ae7edc12bed53da6a26424d047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89f30621d3ef50b9cae42521269a88a"><td class="memTemplParams" colspan="2">template&lt;typename MatcherClass &gt; </td></tr>
<tr class="memitem:ab89f30621d3ef50b9cae42521269a88a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; llvm::is_detected&lt; <a class="el" href="namespacemlir_1_1detail.html#a0d607e4b534651dbd796b895db9e07b3">detail::has_operation_or_value_matcher_t</a>, MatcherClass, <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ab89f30621d3ef50b9cae42521269a88a">matchOperandOrValueAtIndex</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, unsigned idx, MatcherClass &amp;matcher)</td></tr>
<tr class="memdesc:ab89f30621d3ef50b9cae42521269a88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically switch to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> matcher.  <a href="namespacemlir_1_1detail.html#ab89f30621d3ef50b9cae42521269a88a">More...</a><br /></td></tr>
<tr class="separator:ab89f30621d3ef50b9cae42521269a88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f316751af53ab7a9419b8f613623c3"><td class="memTemplParams" colspan="2">template&lt;typename MatcherClass &gt; </td></tr>
<tr class="memitem:a18f316751af53ab7a9419b8f613623c3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; llvm::is_detected&lt; <a class="el" href="namespacemlir_1_1detail.html#a0d607e4b534651dbd796b895db9e07b3">detail::has_operation_or_value_matcher_t</a>, MatcherClass, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a18f316751af53ab7a9419b8f613623c3">matchOperandOrValueAtIndex</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, unsigned idx, MatcherClass &amp;matcher)</td></tr>
<tr class="memdesc:a18f316751af53ab7a9419b8f613623c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically switch to an <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> matcher.  <a href="namespacemlir_1_1detail.html#a18f316751af53ab7a9419b8f613623c3">More...</a><br /></td></tr>
<tr class="separator:a18f316751af53ab7a9419b8f613623c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7baf9bf03348723f8d037a39800d69a7"><td class="memTemplParams" colspan="2">template&lt;typename TupleT , class CallbackT , std::size_t... Is&gt; </td></tr>
<tr class="memitem:a7baf9bf03348723f8d037a39800d69a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a7baf9bf03348723f8d037a39800d69a7">enumerateImpl</a> (TupleT &amp;&amp;tuple, CallbackT &amp;&amp;callback, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="separator:a7baf9bf03348723f8d037a39800d69a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7146031ab7f6bb4cdacc53c4f1e96aac"><td class="memTemplParams" colspan="2">template&lt;typename... Tys, typename CallbackT &gt; </td></tr>
<tr class="memitem:a7146031ab7f6bb4cdacc53c4f1e96aac"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a7146031ab7f6bb4cdacc53c4f1e96aac">enumerate</a> (std::tuple&lt; Tys... &gt; &amp;tuple, CallbackT &amp;&amp;callback)</td></tr>
<tr class="separator:a7146031ab7f6bb4cdacc53c4f1e96aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9dddc7a1f6dc8aa95eaa5b7910c76d5"><td class="memItemLeft" align="right" valign="top">llvm::unique_function&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ac9dddc7a1f6dc8aa95eaa5b7910c76d5">getDefaultDiagnosticEmitFn</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:ac9dddc7a1f6dc8aa95eaa5b7910c76d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to generate a callback that can be used to generate a diagnostic when checking the construction invariants of a storage object.  <a href="namespacemlir_1_1detail.html#ac9dddc7a1f6dc8aa95eaa5b7910c76d5">More...</a><br /></td></tr>
<tr class="separator:ac9dddc7a1f6dc8aa95eaa5b7910c76d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3379fc459c08af37eb4a514b0eadef2d"><td class="memItemLeft" align="right" valign="top">llvm::unique_function&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a3379fc459c08af37eb4a514b0eadef2d">getDefaultDiagnosticEmitFn</a> (const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;loc)</td></tr>
<tr class="separator:a3379fc459c08af37eb4a514b0eadef2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9f7283021fca39df8cf99bbd90cf4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#aea9f7283021fca39df8cf99bbd90cf4a">verifySymbolTable</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:aea9f7283021fca39df8cf99bbd90cf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e42f84b57ed10b489c12a7236bb356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ae8e42f84b57ed10b489c12a7236bb356">verifySymbol</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:ae8e42f84b57ed10b489c12a7236bb356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f65c29b00af55fbdff5cf2a1bfbbe17"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Arg , typename... Rest&gt; </td></tr>
<tr class="memitem:a6f65c29b00af55fbdff5cf2a1bfbbe17"><td class="memTemplItemLeft" align="right" valign="top">Arg&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a6f65c29b00af55fbdff5cf2a1bfbbe17">first_argument_type</a> (Ret(*)(Arg, Rest...))</td></tr>
<tr class="memdesc:a6f65c29b00af55fbdff5cf2a1bfbbe17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper templates to deduce the first argument of a callback parameter.  <a href="namespacemlir_1_1detail.html#a6f65c29b00af55fbdff5cf2a1bfbbe17">More...</a><br /></td></tr>
<tr class="separator:a6f65c29b00af55fbdff5cf2a1bfbbe17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b5b18be8ea226e9d3606f21c1a7a7e"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename F , typename Arg , typename... Rest&gt; </td></tr>
<tr class="memitem:ae4b5b18be8ea226e9d3606f21c1a7a7e"><td class="memTemplItemLeft" align="right" valign="top">Arg&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ae4b5b18be8ea226e9d3606f21c1a7a7e">first_argument_type</a> (Ret(F::*)(Arg, Rest...))</td></tr>
<tr class="separator:ae4b5b18be8ea226e9d3606f21c1a7a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152b851682ac1cad31c84dc1a6fc38cb"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a152b851682ac1cad31c84dc1a6fc38cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a152b851682ac1cad31c84dc1a6fc38cb">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="memdesc:a152b851682ac1cad31c84dc1a6fc38cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the regions, blocks, or operations nested under (and including) the given operation.  <a href="namespacemlir_1_1detail.html#a152b851682ac1cad31c84dc1a6fc38cb">More...</a><br /></td></tr>
<tr class="separator:a152b851682ac1cad31c84dc1a6fc38cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b337bcade50e3cd7191efec879db837"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a5b337bcade50e3cd7191efec879db837"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a5b337bcade50e3cd7191efec879db837">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Block.html">Block</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="separator:a5b337bcade50e3cd7191efec879db837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adcd8424919a733a4cce559560e5dd9"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a3adcd8424919a733a4cce559560e5dd9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a3adcd8424919a733a4cce559560e5dd9">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="separator:a3adcd8424919a733a4cce559560e5dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08eda9acbea0f5326d02db4b99814395"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a08eda9acbea0f5326d02db4b99814395"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a08eda9acbea0f5326d02db4b99814395">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="memdesc:a08eda9acbea0f5326d02db4b99814395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the regions, blocks, or operations nested under (and including) the given operation.  <a href="namespacemlir_1_1detail.html#a08eda9acbea0f5326d02db4b99814395">More...</a><br /></td></tr>
<tr class="separator:a08eda9acbea0f5326d02db4b99814395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac791c882fa374a53b6a7ec0387586f59"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ac791c882fa374a53b6a7ec0387586f59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ac791c882fa374a53b6a7ec0387586f59">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Block.html">Block</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="separator:ac791c882fa374a53b6a7ec0387586f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e61da15ae81a346c6b060103d0ed54"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ab4e61da15ae81a346c6b060103d0ed54"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ab4e61da15ae81a346c6b060103d0ed54">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="separator:ab4e61da15ae81a346c6b060103d0ed54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfa95ca210821ec266a0257fe9fe74f"><td class="memTemplParams" colspan="2">template&lt;WalkOrder Order = WalkOrder::PostOrder, typename Iterator  = ForwardIterator, typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </td></tr>
<tr class="memitem:addfa95ca210821ec266a0257fe9fe74f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; llvm::is_one_of&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt;::value, RetT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#addfa95ca210821ec266a0257fe9fe74f">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:addfa95ca210821ec266a0257fe9fe74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the regions, blocks, or operations nested under (and including) the given operation.  <a href="namespacemlir_1_1detail.html#addfa95ca210821ec266a0257fe9fe74f">More...</a><br /></td></tr>
<tr class="separator:addfa95ca210821ec266a0257fe9fe74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b0cddf03280b10bdeecbfa002f2f4d"><td class="memTemplParams" colspan="2">template&lt;WalkOrder Order = WalkOrder::PostOrder, typename Iterator  = ForwardIterator, typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </td></tr>
<tr class="memitem:a50b0cddf03280b10bdeecbfa002f2f4d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; !llvm::is_one_of&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt;::value &amp;&amp;std::is_same&lt; RetT, void &gt;::value, RetT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a50b0cddf03280b10bdeecbfa002f2f4d">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:a50b0cddf03280b10bdeecbfa002f2f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the operations of type 'ArgT' nested under and including the given operation.  <a href="namespacemlir_1_1detail.html#a50b0cddf03280b10bdeecbfa002f2f4d">More...</a><br /></td></tr>
<tr class="separator:a50b0cddf03280b10bdeecbfa002f2f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206f36bc38bdb9160771da18b198fa37"><td class="memTemplParams" colspan="2">template&lt;WalkOrder Order = WalkOrder::PostOrder, typename Iterator  = ForwardIterator, typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </td></tr>
<tr class="memitem:a206f36bc38bdb9160771da18b198fa37"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; !llvm::is_one_of&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt;::value &amp;&amp;std::is_same&lt; RetT, <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> &gt;::value, RetT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a206f36bc38bdb9160771da18b198fa37">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:a206f36bc38bdb9160771da18b198fa37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the operations of type 'ArgT' nested under and including the given operation.  <a href="namespacemlir_1_1detail.html#a206f36bc38bdb9160771da18b198fa37">More...</a><br /></td></tr>
<tr class="separator:a206f36bc38bdb9160771da18b198fa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7626abe27e64a0a166feedf7e829c968"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a7626abe27e64a0a166feedf7e829c968">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, const <a class="el" href="classmlir_1_1WalkStage.html">WalkStage</a> &amp;stage)&gt; callback)</td></tr>
<tr class="memdesc:a7626abe27e64a0a166feedf7e829c968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic walkers with stage aware callbacks.  <a href="namespacemlir_1_1detail.html#a7626abe27e64a0a166feedf7e829c968">More...</a><br /></td></tr>
<tr class="separator:a7626abe27e64a0a166feedf7e829c968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2adf6127282c5d8cd497d1eff1013c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#aa2adf6127282c5d8cd497d1eff1013c1">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, const <a class="el" href="classmlir_1_1WalkStage.html">WalkStage</a> &amp;stage)&gt; callback)</td></tr>
<tr class="memdesc:aa2adf6127282c5d8cd497d1eff1013c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all the operations nested under (and including) the given operation, with the callback being invoked on each operation N+1 times, where N is the number of regions attached to the operation.  <a href="namespacemlir_1_1detail.html#aa2adf6127282c5d8cd497d1eff1013c1">More...</a><br /></td></tr>
<tr class="separator:aa2adf6127282c5d8cd497d1eff1013c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01044a915c1ef676b33a6720e791b8e"><td class="memTemplParams" colspan="2">template&lt;typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </td></tr>
<tr class="memitem:ab01044a915c1ef676b33a6720e791b8e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::value, RetT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ab01044a915c1ef676b33a6720e791b8e">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:ab01044a915c1ef676b33a6720e791b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the operations nested under and including the given operation.  <a href="namespacemlir_1_1detail.html#ab01044a915c1ef676b33a6720e791b8e">More...</a><br /></td></tr>
<tr class="separator:ab01044a915c1ef676b33a6720e791b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeeca5f48ddcfddf532f009990fa9875"><td class="memTemplParams" colspan="2">template&lt;typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </td></tr>
<tr class="memitem:afeeca5f48ddcfddf532f009990fa9875"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_same&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::value &amp;&amp;std::is_same&lt; RetT, void &gt;::value, RetT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#afeeca5f48ddcfddf532f009990fa9875">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:afeeca5f48ddcfddf532f009990fa9875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the operations of type 'ArgT' nested under and including the given operation.  <a href="namespacemlir_1_1detail.html#afeeca5f48ddcfddf532f009990fa9875">More...</a><br /></td></tr>
<tr class="separator:afeeca5f48ddcfddf532f009990fa9875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f69e037f4b2603ccae8184e60301649"><td class="memTemplParams" colspan="2">template&lt;typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </td></tr>
<tr class="memitem:a7f69e037f4b2603ccae8184e60301649"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_same&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::value &amp;&amp;std::is_same&lt; RetT, <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> &gt;::value, RetT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a7f69e037f4b2603ccae8184e60301649">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:a7f69e037f4b2603ccae8184e60301649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the operations of type 'ArgT' nested under and including the given operation.  <a href="namespacemlir_1_1detail.html#a7f69e037f4b2603ccae8184e60301649">More...</a><br /></td></tr>
<tr class="separator:a7f69e037f4b2603ccae8184e60301649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c95cf9bfd21b06e858fb98892946015"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT &gt; </td></tr>
<tr class="memitem:a0c95cf9bfd21b06e858fb98892946015"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a0c95cf9bfd21b06e858fb98892946015">constructContainerOpForParserIfNecessary</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *parsedBlock, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1Location.html">Location</a> sourceFileLoc)</td></tr>
<tr class="memdesc:a0c95cf9bfd21b06e858fb98892946015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a block containing operations that have just been parsed, if the block contains a single operation of <code>ContainerOpT</code> type then remove it from the block and return it.  <a href="namespacemlir_1_1detail.html#a0c95cf9bfd21b06e858fb98892946015">More...</a><br /></td></tr>
<tr class="separator:a0c95cf9bfd21b06e858fb98892946015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6940e065f3d177504ccb642f8b611b"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT , typename... ParserArgs&gt; </td></tr>
<tr class="memitem:a6c6940e065f3d177504ccb642f8b611b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a6c6940e065f3d177504ccb642f8b611b">parseSourceFile</a> (const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config, ParserArgs &amp;&amp;...args)</td></tr>
<tr class="memdesc:a6c6940e065f3d177504ccb642f8b611b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal implementation of the templated <code>parseSourceFile</code> methods below, that simply forwards to the non-templated version.  <a href="namespacemlir_1_1detail.html#a6c6940e065f3d177504ccb642f8b611b">More...</a><br /></td></tr>
<tr class="separator:a6c6940e065f3d177504ccb642f8b611b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493be0c467bac528a100115486f3ec69"><td class="memTemplParams" colspan="2">template&lt;typename ConcreteType , typename ValueT , typename Traits , typename BaseType , template&lt; typename, template&lt; typename &gt; class &gt; class BaseTrait&gt; </td></tr>
<tr class="memitem:a493be0c467bac528a100115486f3ec69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a493be0c467bac528a100115486f3ec69">isInterfaceImpl</a> (<a class="el" href="classmlir_1_1detail_1_1Interface.html">Interface</a>&lt; ConcreteType, ValueT, Traits, <a class="el" href="classBaseType.html">BaseType</a>, <a class="el" href="classBaseTrait.html">BaseTrait</a> &gt; &amp;)</td></tr>
<tr class="separator:a493be0c467bac528a100115486f3ec69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930d7a8089745af25248145b612493b4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a930d7a8089745af25248145b612493b4">getDenseElementBitWidth</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> eltType)</td></tr>
<tr class="memdesc:a930d7a8089745af25248145b612493b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bit width which <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a> should use for this type.  <a href="namespacemlir_1_1detail.html#a930d7a8089745af25248145b612493b4">More...</a><br /></td></tr>
<tr class="separator:a930d7a8089745af25248145b612493b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4714fdeb9f7fa11cf2bd472a5ab6d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#aae4714fdeb9f7fa11cf2bd472a5ab6d3">isSupportedMemorySpace</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace)</td></tr>
<tr class="memdesc:aae4714fdeb9f7fa11cf2bd472a5ab6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the memorySpace has supported <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> type.  <a href="namespacemlir_1_1detail.html#aae4714fdeb9f7fa11cf2bd472a5ab6d3">More...</a><br /></td></tr>
<tr class="separator:aae4714fdeb9f7fa11cf2bd472a5ab6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f32721e9d15092545cf9ea586d6d7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a37f32721e9d15092545cf9ea586d6d7e">wrapIntegerMemorySpace</a> (unsigned memorySpace, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:a37f32721e9d15092545cf9ea586d6d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps deprecated integer memory space to the new <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> form.  <a href="namespacemlir_1_1detail.html#a37f32721e9d15092545cf9ea586d6d7e">More...</a><br /></td></tr>
<tr class="separator:a37f32721e9d15092545cf9ea586d6d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38aedb222d8f61891a51c10805e286c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ab38aedb222d8f61891a51c10805e286c">skipDefaultMemorySpace</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace)</td></tr>
<tr class="memdesc:ab38aedb222d8f61891a51c10805e286c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces default memorySpace (integer == <code>0</code>) with empty <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>.  <a href="namespacemlir_1_1detail.html#ab38aedb222d8f61891a51c10805e286c">More...</a><br /></td></tr>
<tr class="separator:ab38aedb222d8f61891a51c10805e286c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec833993e8780c005c1c18d054273b4"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a3ec833993e8780c005c1c18d054273b4">getMemorySpaceAsInt</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace)</td></tr>
<tr class="memdesc:a3ec833993e8780c005c1c18d054273b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">[deprecated] Returns the memory space in old raw integer representation.  <a href="namespacemlir_1_1detail.html#a3ec833993e8780c005c1c18d054273b4">More...</a><br /></td></tr>
<tr class="separator:a3ec833993e8780c005c1c18d054273b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a63c39ecb3618964551c0b29bc356b675"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a63c39ecb3618964551c0b29bc356b675"><td class="memTemplItemLeft" align="right" valign="top">decltype(first_argument_type(&amp;F::operator()))&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a63c39ecb3618964551c0b29bc356b675">first_argument_type</a> (F)</td></tr>
<tr class="separator:a63c39ecb3618964551c0b29bc356b675"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Detect if any of the given parameter types has a sub-element handler. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a1d9ab167043a2e4cd4d0e666853d6170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9ab167043a2e4cd4d0e666853d6170">&#9670;&nbsp;</a></span>ByteCodeAddr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#a1d9ab167043a2e4cd4d0e666853d6170">mlir::detail::ByteCodeAddr</a> = typedef uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ByteCode_8h_source.html#l00030">30</a> of file <a class="el" href="ByteCode_8h_source.html">ByteCode.h</a>.</p>

</div>
</div>
<a id="ab5ac2de9a9d0eebfe67eb5e4db2084f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ac2de9a9d0eebfe67eb5e4db2084f1">&#9670;&nbsp;</a></span>ByteCodeField</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#ab5ac2de9a9d0eebfe67eb5e4db2084f1">mlir::detail::ByteCodeField</a> = typedef uint16_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use generic bytecode types. </p>
<p>ByteCodeField refers to the actual bytecode entries. ByteCodeAddr refers to size of indices into the bytecode. </p>

<p class="definition">Definition at line <a class="el" href="ByteCode_8h_source.html#l00029">29</a> of file <a class="el" href="ByteCode_8h_source.html">ByteCode.h</a>.</p>

</div>
</div>
<a id="aabbea31f5f9034714e29d3a49cae75a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbea31f5f9034714e29d3a49cae75a4">&#9670;&nbsp;</a></span>count_if_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Pred, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#aabbea31f5f9034714e29d3a49cae75a4">mlir::detail::count_if_t</a> = typedef <a class="el" href="structmlir_1_1detail_1_1count__if__t__impl.html">count_if_t_impl</a>&lt;Pred, 0, Ts...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InterfaceSupport_8h_source.html#l00153">153</a> of file <a class="el" href="InterfaceSupport_8h_source.html">InterfaceSupport.h</a>.</p>

</div>
</div>
<a id="a912e3cd5feea0574a2f3fce7c34dcefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912e3cd5feea0574a2f3fce7c34dcefd">&#9670;&nbsp;</a></span>DenseIterPtrAndSplat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#a912e3cd5feea0574a2f3fce7c34dcefd">mlir::detail::DenseIterPtrAndSplat</a> = typedef std::pair&lt;const char *, bool&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pair of raw pointer and a boolean flag of whether the pointer holds a splat,. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00040">40</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="ae2b75c9bae3caf1909b6d6277fb6ea61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b75c9bae3caf1909b6d6277fb6ea61">&#9670;&nbsp;</a></span>first_argument</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#ae2b75c9bae3caf1909b6d6277fb6ea61">mlir::detail::first_argument</a> = typedef decltype(<a class="el" href="namespacemlir_1_1detail.html#a63c39ecb3618964551c0b29bc356b675">first_argument_type</a>(std::declval&lt;T&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> definition of the first argument to the given callable 'T'. </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00125">125</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<a id="a6674e02b9acfc220caf0a47e6dbab6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6674e02b9acfc220caf0a47e6dbab6ea">&#9670;&nbsp;</a></span>has_default_sub_element_handler_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#a6674e02b9acfc220caf0a47e6dbab6ea">mlir::detail::has_default_sub_element_handler_t</a> = typedef decltype(T::DefaultHandlerTag)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00314">314</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

</div>
</div>
<a id="a3c91ce05af5c861e1d789201346c457c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c91ce05af5c861e1d789201346c457c">&#9670;&nbsp;</a></span>has_get_as_key</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#a3c91ce05af5c861e1d789201346c457c">mlir::detail::has_get_as_key</a> = typedef decltype(std::declval&lt;T&gt;().getAsKey())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00406">406</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

</div>
</div>
<a id="aec637be4fc5a4b359ff417c0f44350b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec637be4fc5a4b359ff417c0f44350b4">&#9670;&nbsp;</a></span>has_get_method</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#aec637be4fc5a4b359ff417c0f44350b4">mlir::detail::has_get_method</a> = typedef decltype(T::get(std::declval&lt;Ts&gt;()...))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00404">404</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

</div>
</div>
<a id="a1be2dcfec91412eb27290aab9294b4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be2dcfec91412eb27290aab9294b4cc">&#9670;&nbsp;</a></span>has_impltype_getkey_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ImplTy , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#a1be2dcfec91412eb27290aab9294b4cc">mlir::detail::has_impltype_getkey_t</a> = typedef decltype(ImplTy::getKey(std::declval&lt;Args&gt;()...))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait to check if ImplTy provides a 'getKey' method with types 'Args'. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00026">26</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

</div>
</div>
<a id="afb2713c77027515db7c2d5f698d0f33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2713c77027515db7c2d5f698d0f33c">&#9670;&nbsp;</a></span>has_impltype_hash_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ImplTy , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#afb2713c77027515db7c2d5f698d0f33c">mlir::detail::has_impltype_hash_t</a> = typedef decltype(ImplTy::hashKey(std::declval&lt;T&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait to check if ImplTy provides a 'hashKey' method for 'T'. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00030">30</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

</div>
</div>
<a id="a0d607e4b534651dbd796b895db9e07b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d607e4b534651dbd796b895db9e07b3">&#9670;&nbsp;</a></span>has_operation_or_value_matcher_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename OperationOrValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#a0d607e4b534651dbd796b895db9e07b3">mlir::detail::has_operation_or_value_matcher_t</a> = typedef decltype(std::declval&lt;T&gt;().match(std::declval&lt;OperationOrValue&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait to check whether T provides a 'match' method with type <code>OperationOrValue</code>. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00208">208</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="abea4de026e8ae1a9a190b47a066df22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea4de026e8ae1a9a190b47a066df22f">&#9670;&nbsp;</a></span>has_push_back_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#abea4de026e8ae1a9a190b47a066df22f">mlir::detail::has_push_back_t</a> = typedef decltype(std::declval&lt;T&gt;().push_back( std::declval&lt;typename T::value_type &amp;&amp;&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectImplementation_8h_source.html#l00145">145</a> of file <a class="el" href="DialectImplementation_8h_source.html">DialectImplementation.h</a>.</p>

</div>
</div>
<a id="addf60d55489c71894501becbfaa8c21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf60d55489c71894501becbfaa8c21c">&#9670;&nbsp;</a></span>is_interface_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#addf60d55489c71894501becbfaa8c21c">mlir::detail::is_interface_t</a> = typedef decltype(<a class="el" href="namespacemlir_1_1detail.html#a493be0c467bac528a100115486f3ec69">isInterfaceImpl</a>(std::declval&lt;T &amp;&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InterfaceSupport_8h_source.html#l00274">274</a> of file <a class="el" href="InterfaceSupport_8h_source.html">InterfaceSupport.h</a>.</p>

</div>
</div>
<a id="ae9b5779c5d7667528bc58cd2f184f180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b5779c5d7667528bc58cd2f184f180">&#9670;&nbsp;</a></span>IsInterface</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#ae9b5779c5d7667528bc58cd2f184f180">mlir::detail::IsInterface</a> = typedef llvm::is_detected&lt;<a class="el" href="namespacemlir_1_1detail.html#addf60d55489c71894501becbfaa8c21c">is_interface_t</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InterfaceSupport_8h_source.html#l00277">277</a> of file <a class="el" href="InterfaceSupport_8h_source.html">InterfaceSupport.h</a>.</p>

</div>
</div>
<a id="af34799170e951dbbdab0628a01e97344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34799170e951dbbdab0628a01e97344">&#9670;&nbsp;</a></span>OwningOpRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#af34799170e951dbbdab0628a01e97344">mlir::detail::OwningOpRange</a> = typedef llvm::OwningArrayRef&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ByteCode_8h_source.html#l00031">31</a> of file <a class="el" href="ByteCode_8h_source.html">ByteCode.h</a>.</p>

</div>
</div>
<a id="a5258e43cc82e8e9a4c2c605f10a16461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5258e43cc82e8e9a4c2c605f10a16461">&#9670;&nbsp;</a></span>walkResultType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FnT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#a5258e43cc82e8e9a4c2c605f10a16461">mlir::detail::walkResultType</a> = typedef decltype(<a class="el" href="namespacemlir_1_1detail.html#a152b851682ac1cad31c84dc1a6fc38cb">walk</a>(nullptr, std::declval&lt;FnT&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to provide the return type of a templated walk method. </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00466">466</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a78296380781bb5c3af2dd2ad9b70c26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78296380781bb5c3af2dd2ad9b70c26f">&#9670;&nbsp;</a></span>OpProperties</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1detail.html#a78296380781bb5c3af2dd2ad9b70c26f">mlir::detail::OpProperties</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a "tag" used for mapping the properties storage in llvm::TrailingObjects. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Operation_8h_source.html#l00028">28</a> of file <a class="el" href="IR_2Operation_8h_source.html">Operation.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae964b04f941d43593051e7ffd751e6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae964b04f941d43593051e7ffd751e6c1">&#9670;&nbsp;</a></span>allocAligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;T *, T *&gt; mlir::detail::allocAligned </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#ac9afb3b6f82b256aea9f20e913e8afd5">AllocFunType</a>&#160;</td>
          <td class="paramname"><em>allocFun</em> = <code>&amp;::malloc</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>alignment</em> = <code>std::optional&lt;uint64_t&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Align <code>nElements</code> of type T with an optional <code>alignment</code>. </p>
<p>This replaces a portable <code>posix_memalign</code>. <code>alignment</code> must be a power of 2 and greater than the size of T. By default the alignment is sizeof(T). </p>

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00103">103</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

<p class="reference">References <a class="el" href="CRunnerUtils_8h_source.html#l00049">nextPowerOf2()</a>.</p>

</div>
</div>
<a id="ad693ba34552063984c6685f93500c79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad693ba34552063984c6685f93500c79f">&#9670;&nbsp;</a></span>bindDims() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::bindDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00307">307</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00310">bindDims()</a>, and <a class="el" href="HoistPadding_8cpp_source.html#l00511">buildLoopIterationCount()</a>.</p>

</div>
</div>
<a id="adc67b3a3dac2996cc431f90b8658f6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc67b3a3dac2996cc431f90b8658f6e6">&#9670;&nbsp;</a></span>bindDims() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename AffineExprTy , typename... AffineExprTy2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::bindDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy2 &amp;...&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00310">310</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00307">bindDims()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00502">mlir::getAffineDimExpr()</a>.</p>

</div>
</div>
<a id="addb63088be1c8bff57b28cc3be96701b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb63088be1c8bff57b28cc3be96701b">&#9670;&nbsp;</a></span>bindSymbols() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::bindSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00316">316</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00319">bindSymbols()</a>, and <a class="el" href="HoistPadding_8cpp_source.html#l00511">buildLoopIterationCount()</a>.</p>

</div>
</div>
<a id="a2b0f1dec3bae54bd6eecd9e5abb59e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0f1dec3bae54bd6eecd9e5abb59e4c">&#9670;&nbsp;</a></span>bindSymbols() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename AffineExprTy , typename... AffineExprTy2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::bindSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy2 &amp;...&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00319">319</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00316">bindSymbols()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00512">mlir::getAffineSymbolExpr()</a>.</p>

</div>
</div>
<a id="a0c95cf9bfd21b06e858fb98892946015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c95cf9bfd21b06e858fb98892946015">&#9670;&nbsp;</a></span>constructContainerOpForParserIfNecessary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ContainerOpT&gt; mlir::detail::constructContainerOpForParserIfNecessary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>parsedBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a block containing operations that have just been parsed, if the block contains a single operation of <code>ContainerOpT</code> type then remove it from the block and return it. </p>
<p>If the block does not contain just that operation, create a new operation instance of <code>ContainerOpT</code> and move all of the operations within <code>parsedBlock</code> into the first block of the first region. <code>ContainerOpT</code> is required to have a single region containing a single block, and must implement the <code>SingleBlockImplicitTerminator</code> trait. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00038">38</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

</div>
</div>
<a id="a451d8dc61974032518997d3f9935e53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451d8dc61974032518997d3f9935e53a">&#9670;&nbsp;</a></span>constructSubElementReplacement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::detail::constructSubElementReplacement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function invokes the proper <code>get</code> method for a type <code>T</code> with the given values. </p>

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00433">433</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>.</p>

</div>
</div>
<a id="a7146031ab7f6bb4cdacc53c4f1e96aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7146031ab7f6bb4cdacc53c4f1e96aac">&#9670;&nbsp;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Tys, typename CallbackT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mlir::detail::enumerate </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Tys... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00262">262</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00254">enumerateImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerVectorContract_8cpp_source.html#l00056">adjustIter()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01272">mlir::alignAffineMapWithValues()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00118">mlir::bufferization::allocateTensorForShapedValue()</a>, <a class="el" href="PatternApplicator_8cpp_source.html#l00052">mlir::PatternApplicator::applyCostModel()</a>, <a class="el" href="Utils_2IndexingUtils_8h_source.html#l00187">mlir::applyPermutationToVector()</a>, <a class="el" href="Transforms_2Utils_2OneToNTypeConversion_8cpp_source.html#l00219">mlir::OneToNPatternRewriter::applySignatureConversion()</a>, <a class="el" href="PredicateTree_8cpp_source.html#l00402">buildCostGraph()</a>, <a class="el" href="IRCore_8cpp_source.html#l01414">mlir::python::PyOpView::buildGeneric()</a>, <a class="el" href="PredicateTree_8cpp_source.html#l00594">buildPredicateList()</a>, <a class="el" href="Transforms_2Utils_2OneToNTypeConversion_8cpp_source.html#l00177">buildUnrealizedBackwardsCasts()</a>, <a class="el" href="VectorDropLeadUnitDim_8cpp_source.html#l00285">mlir::vector::castAwayContractionLeadingOneDim()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01418">mlir::linalg::collapseGenericOpIterationDims()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01125">composeAffineMapAndOperands()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00965">computeMemRefRankReductionMask()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00536">mlir::LLVM::detail::connectPHINodes()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00155">constifyIndexValues()</a>, <a class="el" href="Arith_2Transforms_2EmulateWideInt_8cpp_source.html#l00182">constructResultVector()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00223">mlir::LLVMTypeConverter::convertFunctionSignature()</a>, <a class="el" href="NVGPUToNVVM_8cpp_source.html#l00068">convertIntrinsicResult()</a>, <a class="el" href="Transforms_2Utils_2OneToNTypeConversion_8cpp_source.html#l00055">mlir::OneToNTypeMapping::convertLocations()</a>, <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00140">convertOperationImpl()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00072">mlir::tensor::createDimValues()</a>, <a class="el" href="Linalg_2Utils_2IndexingUtils_8cpp_source.html#l00061">mlir::linalg::createDynamicDimensions()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00044">mlir::tensor::createDynamicDimValues()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02665">createFullTiles()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00200">mlir::ConvertToLLVMPattern::createMemRefDescriptor()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00023">mlir::tensor::createPadHighOp()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00088">deduceCanonicalResource()</a>, <a class="el" href="Promotion_8cpp_source.html#l00083">defaultAllocBufferCallBack()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00393">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00077">doubleBuffer()</a>, <a class="el" href="DropEquivalentBufferResults_8cpp_source.html#l00070">mlir::bufferization::dropEquivalentBufferResults()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00595">mlir::affine::ComputationSliceState::dump()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00515">elementwiseMatchAndRewriteHelper()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00053">mlir::findPositionsOfType()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00140">forEachIJPairInAllBuffers()</a>, <a class="el" href="Fusion_8cpp_source.html#l00193">fuse()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00277">mlir::linalg::fuseElementwiseOps()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01379">generateCollapsedIndexingRegion()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00153">generateFusedElementwiseOpRegion()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00116">generateTileLoopNest()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00258">mlir::sparse_tensor::genReshapeDstShape()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01095">getCollapsableIterationSpaceDims()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00948">getDimMap()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00125">getDroppedDims()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00144">getDynamicSizes()</a>, <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html#l00023">getExpandedDimToCollapsedDimMap()</a>, <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html#l00077">getExpandedOutputDimFromInputShape()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00293">mlir::getLinearizedDimensions()</a>, <a class="el" href="TensorOps_8cpp_source.html#l03574">getPackOpResultTypeShape()</a>, <a class="el" href="Transforms_8cpp_source.html#l01249">getPackUnpackNormalizedPerm()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00485">getPHISourceValue()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00966">mlir::linalg::getReassociationMapForFoldingUnitDims()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00947">getSemiAffineExprFromFlatForm()</a>, <a class="el" href="ControlFlowSinkUtils_8cpp_source.html#l00135">mlir::getSinglyExecutedRegionsToSink()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00853">getTensorExtractMemoryAccessPattern()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00038">getTiledSliceDims()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00140">getTypeNumBytes()</a>, <a class="el" href="IRNumbering_8cpp_source.html#l00062">groupByDialectPerByte()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00161">handleArgumentImpl()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00089">handleMultidimensionalVectors()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00188">handleResultImpl()</a>, <a class="el" href="Transforms_2Utils_2OneToNTypeConversion_8cpp_source.html#l00066">mlir::OneToNTypeMapping::hasNonIdentityConversion()</a>, <a class="el" href="SubsetHoisting_8cpp_source.html#l00462">mlir::linalg::hoistRedundantSubsetExtractInsert()</a>, <a class="el" href="IRInterfaces_8cpp_source.html#l00189">mlir::python::PyInferTypeOpInterface::inferReturnTypes()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l03176">inferTransposeResultType()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00051">injectGpuIndexOperations()</a>, <a class="el" href="MemoryPromotion_8cpp_source.html#l00032">insertCopyLoops()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00667">mlir::inversePermutation()</a>, <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00194">mlir::invertPermutationVector()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01007">isDimSequencePreserved()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00124">mlir::AffineMap::isMinorIdentityWithBroadcasting()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00373">mlir::affine::isOpwiseShiftValid()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00164">mlir::AffineMap::isPermutationOfMinorIdentityWithBroadcasting()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00197">mlir::isReassociationValid()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02996">isTrivialSubViewOp()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00787">mlir::spirv::linearizeIndex()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00225">lowerAsEntryFunction()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01752">mlir::makeStridedLinearLayoutMap()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00379">VectorizationState::maskOperation()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00020">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00385">mlir::GPUPrintfOpToVPrintfLowering::matchAndRewrite()</a>, <a class="el" href="VectorDistribute_8cpp_source.html#l00192">moveRegionToNewWarpOpAndAppendReturns()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00172">outlineKernelFuncImpl()</a>, <a class="el" href="ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00144">packFunctionArguments()</a>, <a class="el" href="Transforms_8cpp_source.html#l00285">mlir::linalg::padAndHoistLinalgOp()</a>, <a class="el" href="Transforms_8cpp_source.html#l00056">padOperandToSmallestStaticBoundingBox()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01661">parseOptionalKeywordAlternative()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01420">mlir::affine::permuteLoops()</a>, <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00119">permuteValues()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l01144">printAttributions()</a>, <a class="el" href="PassStatistics_8cpp_source.html#l00059">printResultsAsList()</a>, <a class="el" href="Promotion_8cpp_source.html#l00213">mlir::linalg::promoteSubviewAsNewBuffer()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01210">mlir::detail::ConversionPatternRewriterImpl::remapValues()</a>, <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00102">replaceAndPropagateMemRefType()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00314">mlir::sparse_tensor::reshapeCvs()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00227">mlir::reshapeLikeShapesAreCompatible()</a>, <a class="el" href="Transforms_8cpp_source.html#l00184">mlir::linalg::rewriteAsPaddedOp()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01168">mlir::transform::detail::setApplyToOneResults()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00943">simplifyMinOrMaxExprWithOperands()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00118">sizesForTensor()</a>, <a class="el" href="VectorUnroll_8cpp_source.html#l00101">sliceTransferIndices()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00618">mlir::sparse_tensor::storeAll()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00645">mlir::scf::tileConsumerAndFuseProducerGreedilyUsingSCFForOp()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00275">mlir::linalg::TileLoopNest::tileRootOp()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00240">updateDestinationOperandsForTiledOp()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00048">updateFuncOp()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01159">vectorizeAsLinalgGeneric()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00119">wrapForExternalCallers()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00180">yieldTiledValues()</a>.</p>

</div>
</div>
<a id="a7baf9bf03348723f8d037a39800d69a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7baf9bf03348723f8d037a39800d69a7">&#9670;&nbsp;</a></span>enumerateImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleT , class CallbackT , std::size_t... Is&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mlir::detail::enumerateImpl </td>
          <td>(</td>
          <td class="paramtype">TupleT &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00254">254</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Matchers_8h_source.html#l00262">enumerate()</a>.</p>

</div>
</div>
<a id="a31d3a751d105f957d43b5ee8ad6ab047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d3a751d105f957d43b5ee8ad6ab047">&#9670;&nbsp;</a></span>filterEntriesForType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a72a4f77607d05cf551b24ceb9362c034">DataLayoutEntryList</a> mlir::detail::filterEntriesForType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a>&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td>
          <td class="paramname"><em>typeID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of data layout entries, returns a new list containing the entries with keys having the given type ID, i.e. </p>
<p>belonging to the same type class. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00240">240</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

</div>
</div>
<a id="af7ddc54fc9b6e82cf3b6a797a6bfefca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ddc54fc9b6e82cf3b6a797a6bfefca">&#9670;&nbsp;</a></span>filterEntryForIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataLayoutEntryInterface mlir::detail::filterEntryForIdentifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a>&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of data layout entries, returns the entry that has the given identifier as key, if such an entry exists in the list. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00250">250</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

</div>
</div>
<a id="a6f65c29b00af55fbdff5cf2a1bfbbe17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f65c29b00af55fbdff5cf2a1bfbbe17">&#9670;&nbsp;</a></span>first_argument_type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename Arg , typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Arg mlir::detail::first_argument_type </td>
          <td>(</td>
          <td class="paramtype">Ret(*)(Arg, Rest...)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper templates to deduce the first argument of a callback parameter. </p>

</div>
</div>
<a id="ae4b5b18be8ea226e9d3606f21c1a7a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b5b18be8ea226e9d3606f21c1a7a7e">&#9670;&nbsp;</a></span>first_argument_type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename F , typename Arg , typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Arg mlir::detail::first_argument_type </td>
          <td>(</td>
          <td class="paramtype">Ret(F::*)(Arg, Rest...)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a083757618e89b0f53d587541eccf53e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083757618e89b0f53d587541eccf53e0">&#9670;&nbsp;</a></span>getBranchSuccessorArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt; mlir::detail::getBranchSuccessorArgument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SuccessorOperands.html">SuccessorOperands</a> &amp;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>operandIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>successor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <code><a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a></code> corresponding to operand <code>operandIndex</code> in some successor if <code>operandIndex</code> is within the range of <code>operands</code>, or std::nullopt if <code>operandIndex</code> isn't a successor operand index. </p>
<p>Returns the <code><a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a></code> corresponding to operand <code>operandIndex</code> in some successor if 'operandIndex' is within the range of 'operands', or std::nullopt if <code>operandIndex</code> isn't a successor operand index. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00040">40</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00118">mlir::Block::getArgument()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00393">mlir::OperandRange::getBeginOperandIndex()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00083">mlir::SuccessorOperands::getForwardedOperands()</a>, and <a class="el" href="ControlFlowInterfaces_8h_source.html#l00065">mlir::SuccessorOperands::getProducedOperandCount()</a>.</p>

</div>
</div>
<a id="a2d7b80c166d5e934716eab0cc1dde085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7b80c166d5e934716eab0cc1dde085">&#9670;&nbsp;</a></span>getDefaultABIAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::detail::getDefaultABIAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DataLayoutEntryInterface &gt;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the required alignemnt request. </p>
<p>Computes results for built-in types and dispatches to the DataLayoutTypeInterface for other types. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00133">133</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00311">mlir::Type::dyn_cast()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00035">mlir::Type::getContext()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00124">getFloatTypeABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00037">getIndexBitwidth()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00112">getIntegerTypeABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00460">mlir::DataLayout::getTypeABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00436">mlir::DataLayout::getTypeSize()</a>, <a class="el" href="IR_2Types_8h_source.html#l00301">mlir::Type::isa()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00026">reportMissingDataLayout()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00460">mlir::DataLayout::getTypeABIAlignment()</a>.</p>

</div>
</div>
<a id="a04d624115ea61e5b456d4c613a770631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d624115ea61e5b456d4c613a770631">&#9670;&nbsp;</a></span>getDefaultAllocaMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::getDefaultAllocaMemorySpace </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for alloca memory space request. </p>
<p>Dispatches to the DataLayoutInterface if specified, otherwise returns the default. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00220">220</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00484">mlir::DataLayout::getAllocaMemorySpace()</a>.</p>

</div>
</div>
<a id="a3379fc459c08af37eb4a514b0eadef2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3379fc459c08af37eb4a514b0eadef2d">&#9670;&nbsp;</a></span>getDefaultDiagnosticEmitFn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::unique_function&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; mlir::detail::getDefaultDiagnosticEmitFn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MLIRContext_8cpp_source.html#l01186">1186</a> of file <a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>.</p>

</div>
</div>
<a id="ac9dddc7a1f6dc8aa95eaa5b7910c76d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9dddc7a1f6dc8aa95eaa5b7910c76d5">&#9670;&nbsp;</a></span>getDefaultDiagnosticEmitFn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::unique_function&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; mlir::detail::getDefaultDiagnosticEmitFn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to generate a callback that can be used to generate a diagnostic when checking the construction invariants of a storage object. </p>
<p>This is defined out-of-line to avoid the need to include <a class="el" href="Location_8h.html">Location.h</a>. </p>

<p class="definition">Definition at line <a class="el" href="MLIRContext_8cpp_source.html#l01182">1182</a> of file <a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, and <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ExtensibleDialect_8cpp_source.html#l00128">mlir::DynamicType::get()</a>, <a class="el" href="StorageUniquerSupport_8h_source.html#l00171">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::get()</a>, and <a class="el" href="StorageUniquerSupport_8h_source.html#l00183">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::getChecked()</a>.</p>

</div>
</div>
<a id="a0f841e410185c44a1c45a10e3838c9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f841e410185c44a1c45a10e3838c9ca">&#9670;&nbsp;</a></span>getDefaultPreferredAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::detail::getDefaultPreferredAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DataLayoutEntryInterface &gt;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the preferred alignemnt request. </p>
<p>Computes results for built-in types and dispatches to the DataLayoutTypeInterface for other types. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00186">186</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00311">mlir::Type::dyn_cast()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00035">mlir::Type::getContext()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00177">getFloatTypePreferredAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00037">getIndexBitwidth()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00167">getIntegerTypePreferredAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00460">mlir::DataLayout::getTypeABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00472">mlir::DataLayout::getTypePreferredAlignment()</a>, <a class="el" href="IR_2Types_8h_source.html#l00301">mlir::Type::isa()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00026">reportMissingDataLayout()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00051">getDefaultTypeSizeInBits()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00472">mlir::DataLayout::getTypePreferredAlignment()</a>.</p>

</div>
</div>
<a id="ab1317f982611171e2b5cd01994df30bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1317f982611171e2b5cd01994df30bb">&#9670;&nbsp;</a></span>getDefaultStackAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::detail::getDefaultStackAlignment </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the stack alignment request. </p>
<p>Dispatches to the DataLayoutInterface if specified, otherwise returns the default. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00231">231</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00500">mlir::DataLayout::getStackAlignment()</a>.</p>

</div>
</div>
<a id="ae4f192c53dfd75f982a0f688bb068021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f192c53dfd75f982a0f688bb068021">&#9670;&nbsp;</a></span>getDefaultTypeSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::detail::getDefaultTypeSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a>&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the type size request. </p>
<p>Computes results for built-in types and dispatches to the DataLayoutTypeInterface for other types. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00045">45</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00051">getDefaultTypeSizeInBits()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00436">mlir::DataLayout::getTypeSize()</a>.</p>

</div>
</div>
<a id="ac25f7d3f6449026adc3574694e6ebf14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25f7d3f6449026adc3574694e6ebf14">&#9670;&nbsp;</a></span>getDefaultTypeSizeInBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::detail::getDefaultTypeSizeInBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a>&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the type size in bits request. </p>
<p>Computes results for built-in types and dispatches to the DataLayoutTypeInterface for other types. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00051">51</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00311">mlir::Type::dyn_cast()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00035">mlir::Type::getContext()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00186">getDefaultPreferredAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00037">getIndexBitwidth()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00112">mlir::Type::getIntOrFloatBitWidth()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00436">mlir::DataLayout::getTypeSize()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00448">mlir::DataLayout::getTypeSizeInBits()</a>, <a class="el" href="IR_2Types_8h_source.html#l00301">mlir::Type::isa()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00026">reportMissingDataLayout()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00045">getDefaultTypeSize()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00448">mlir::DataLayout::getTypeSizeInBits()</a>.</p>

</div>
</div>
<a id="a930d7a8089745af25248145b612493b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930d7a8089745af25248145b612493b4">&#9670;&nbsp;</a></span>getDenseElementBitWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t mlir::detail::getDenseElementBitWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>eltType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the bit width which <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a> should use for this type. </p>

<p class="definition">Definition at line <a class="el" href="AttributeDetail_8h_source.html#l00034">34</a> of file <a class="el" href="AttributeDetail_8h_source.html">AttributeDetail.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00311">mlir::Type::dyn_cast()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00112">mlir::Type::getIntOrFloatBitWidth()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00049">mlir::Type::isIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01234">mlir::DenseElementsAttr::bitcast()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00890">mlir::DenseElementsAttr::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00444">getDenseElementStorageWidth()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00086">mlir::detail::DenseIntOrFPElementsAttrStorage::getKey()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01098">isValidIntOrFloat()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01426">mappingHelper()</a>.</p>

</div>
</div>
<a id="a3ec833993e8780c005c1c18d054273b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec833993e8780c005c1c18d054273b4">&#9670;&nbsp;</a></span>getMemorySpaceAsInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::detail::getMemorySpaceAsInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>[deprecated] Returns the memory space in old raw integer representation. </p>
<p>New <code><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> getMemorySpace()</code> method should be used instead. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00488">488</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Attributes_8h_source.html#l00176">mlir::Attribute::cast()</a>, and <a class="el" href="IR_2Attributes_8h_source.html#l00156">mlir::Attribute::isa()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00150">mlir::affine::AffineDmaStartOp::getDstMemorySpace()</a>, and <a class="el" href="AffineOps_8h_source.html#l00129">mlir::affine::AffineDmaStartOp::getSrcMemorySpace()</a>.</p>

</div>
</div>
<a id="af5e0fca47214fbc553a9b8ec2139ffc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e0fca47214fbc553a9b8ec2139ffc4">&#9670;&nbsp;</a></span>inferReturnTensorTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::inferReturnTensorTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *, std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; location, <a class="el" href="classmlir_1_1ValueShapeRange.html">ValueShapeRange</a> operands, DictionaryAttr attributes, <a class="el" href="classmlir_1_1OpaqueProperties.html">OpaqueProperties</a> properties, <a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a> regions, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1ShapedTypeComponents.html">ShapedTypeComponents</a> &gt; &amp;retComponents)&gt;&#160;</td>
          <td class="paramname"><em>componentTypeFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DictionaryAttr&#160;</td>
          <td class="paramname"><em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpaqueProperties.html">OpaqueProperties</a>&#160;</td>
          <td class="paramname"><em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a>&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inferredReturnTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00219">219</a> of file <a class="el" href="InferTypeOpInterface_8cpp_source.html">InferTypeOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InferTypeOpInterface_8h_source.html#l00282">mlir::OpTrait::InferTensorType&lt; ConcreteType &gt;::inferReturnTypes()</a>.</p>

</div>
</div>
<a id="a493be0c467bac528a100115486f3ec69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493be0c467bac528a100115486f3ec69">&#9670;&nbsp;</a></span>isInterfaceImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , typename ValueT , typename Traits , typename BaseType , template&lt; typename, template&lt; typename &gt; class &gt; class BaseTrait&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::isInterfaceImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1detail_1_1Interface.html">Interface</a>&lt; ConcreteType, ValueT, Traits, <a class="el" href="classBaseType.html">BaseType</a>, <a class="el" href="classBaseTrait.html">BaseTrait</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e92b3730d5a0d2e1c4f704cb4674d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e92b3730d5a0d2e1c4f704cb4674d1e">&#9670;&nbsp;</a></span>isPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mlir::detail::isPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CRunnerUtils_8h_source.html#l00047">47</a> of file <a class="el" href="CRunnerUtils_8h_source.html">CRunnerUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CRunnerUtils_8h_source.html#l00049">nextPowerOf2()</a>.</p>

</div>
</div>
<a id="aae4714fdeb9f7fa11cf2bd472a5ab6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4714fdeb9f7fa11cf2bd472a5ab6d3">&#9670;&nbsp;</a></span>isSupportedMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::detail::isSupportedMemorySpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the memorySpace has supported <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00456">456</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Attributes_8h_source.html#l00071">mlir::Attribute::getDialect()</a>, and <a class="el" href="IR_2Attributes_8h_source.html#l00156">mlir::Attribute::isa()</a>.</p>

</div>
</div>
<a id="ada8eaeb3d7b3be7839ef146f1f82a313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8eaeb3d7b3be7839ef146f1f82a313">&#9670;&nbsp;</a></span>makeStridedMemRefDescriptor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(N &gt;= 1), <a class="el" href="structStridedMemRefType.html">StridedMemRefType</a>&lt;T, N&gt; &gt;::type mlir::detail::makeStridedMemRefDescriptor </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>alignedPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shapeAlloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <code>StridedMemRefDescriptor&lt;T, N&gt;</code> that matches the MLIR ABI. </p>
<p>This is an implementation detail that is kept in sync with MLIR codegen conventions. Additionally takes a <code>shapeAlloc</code> array which is used instead of <code>shape</code> to allocate "more aligned" data and compute the corresponding strides. </p>

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00065">65</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

<p class="reference">References <a class="el" href="CRunnerUtils_8h_source.html#l00132">StridedMemRefType&lt; T, N &gt;::basePtr</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00071">copy()</a>, <a class="el" href="CRunnerUtils_8h_source.html#l00133">StridedMemRefType&lt; T, N &gt;::data</a>, <a class="el" href="CRunnerUtils_8h_source.html#l00134">StridedMemRefType&lt; T, N &gt;::offset</a>, <a class="el" href="CRunnerUtils_8h_source.html#l00135">StridedMemRefType&lt; T, N &gt;::sizes</a>, and <a class="el" href="CRunnerUtils_8h_source.html#l00136">StridedMemRefType&lt; T, N &gt;::strides</a>.</p>

</div>
</div>
<a id="a1a76d14b47a24b32bcb01c58dced65f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a76d14b47a24b32bcb01c58dced65f8">&#9670;&nbsp;</a></span>makeStridedMemRefDescriptor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(N == 0), <a class="el" href="structStridedMemRefType.html">StridedMemRefType</a>&lt;T, 0&gt; &gt;::type mlir::detail::makeStridedMemRefDescriptor </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>alignedPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shapeAlloc</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <code>StridedMemRefDescriptor&lt;T, 0&gt;</code> that matches the MLIR ABI. </p>
<p>This is an implementation detail that is kept in sync with MLIR codegen conventions. Additionally takes a <code>shapeAlloc</code> array which is used instead of <code>shape</code> to allocate "more aligned" data and compute the corresponding strides. </p>

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00086">86</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

</div>
</div>
<a id="ab48e4040142437e45b8fe0f83b837ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48e4040142437e45b8fe0f83b837ad9">&#9670;&nbsp;</a></span>makeStrides()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;int64_t, N&gt; mlir::detail::makeStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a shape with sizes greater than 0 along all dimensions, returns the distance, in number of elements, between a slice in a dimension and the next slice in the same dimension. </p>
<p>e.g. shape[3, 4, 5] -&gt; strides[20, 5, 1] </p>

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00046">46</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

</div>
</div>
<a id="ab89f30621d3ef50b9cae42521269a88a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89f30621d3ef50b9cae42521269a88a">&#9670;&nbsp;</a></span>matchOperandOrValueAtIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatcherClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;llvm::is_detected&lt;<a class="el" href="namespacemlir_1_1detail.html#a0d607e4b534651dbd796b895db9e07b3">detail::has_operation_or_value_matcher_t</a>, MatcherClass, <a class="el" href="classmlir_1_1Value.html">Value</a>&gt;::value, bool&gt; mlir::detail::matchOperandOrValueAtIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatcherClass &amp;&#160;</td>
          <td class="paramname"><em>matcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically switch to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> matcher. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00216">216</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a18f316751af53ab7a9419b8f613623c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f316751af53ab7a9419b8f613623c3">&#9670;&nbsp;</a></span>matchOperandOrValueAtIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatcherClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;llvm::is_detected&lt;<a class="el" href="namespacemlir_1_1detail.html#a0d607e4b534651dbd796b895db9e07b3">detail::has_operation_or_value_matcher_t</a>, MatcherClass, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;::value, bool&gt; mlir::detail::matchOperandOrValueAtIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatcherClass &amp;&#160;</td>
          <td class="paramname"><em>matcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically switch to an <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> matcher. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00225">225</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a69a50c1b52f8e20f12e77716d79a5868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a50c1b52f8e20f12e77716d79a5868">&#9670;&nbsp;</a></span>nextPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned mlir::detail::nextPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CRunnerUtils_8h_source.html#l00049">49</a> of file <a class="el" href="CRunnerUtils_8h_source.html">CRunnerUtils.h</a>.</p>

<p class="reference">References <a class="el" href="CRunnerUtils_8h_source.html#l00047">isPowerOf2()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00103">allocAligned()</a>, <a class="el" href="CRunnerUtils_8h_source.html#l00058">mlir::detail::Vector1D&lt; T, Dim, true &gt;::Vector1D()</a>, and <a class="el" href="CRunnerUtils_8h_source.html#l00073">mlir::detail::Vector1D&lt; T, Dim, false &gt;::Vector1D()</a>.</p>

</div>
</div>
<a id="a6c6940e065f3d177504ccb642f8b611b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6940e065f3d177504ccb642f8b611b">&#9670;&nbsp;</a></span>parseSourceFile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT , typename... ParserArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ContainerOpT&gt; mlir::detail::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParserArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The internal implementation of the templated <code>parseSourceFile</code> methods below, that simply forwards to the non-templated version. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00155">155</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, and <a class="el" href="AsmState_8h_source.html#l00472">mlir::ParserConfig::getContext()</a>.</p>

</div>
</div>
<a id="a8af776eda51700256b7c60deadcb4d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af776eda51700256b7c60deadcb4d25">&#9670;&nbsp;</a></span>replaceImmediateSubElementsImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::detail::replaceImmediateSubElementsImpl </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>derived</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>replAttrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>replTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides the underlying implementation for the SubElementInterface replace method, using the key type of the derived attribute/type to interact with the individual parameters. </p>

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00451">451</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

<p class="reference">References <a class="el" href="AttrTypeSubElements_8h_source.html#l00317">mlir::has_sub_attr_or_type_v</a>, and <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StorageUniquerSupport_8h_source.html#l00142">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::getReplaceImmediateSubElementsFn()</a>.</p>

</div>
</div>
<a id="a0caa43784c57086534e1833f66eaecfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0caa43784c57086534e1833f66eaecfc">&#9670;&nbsp;</a></span>sameOffsetsSizesAndStrides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::detail::sameOffsetsSizesAndStrides </td>
          <td>(</td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>)&gt;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00151">151</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

</div>
</div>
<a id="ab38aedb222d8f61891a51c10805e286c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38aedb222d8f61891a51c10805e286c">&#9670;&nbsp;</a></span>skipDefaultMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::skipDefaultMemorySpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces default memorySpace (integer == <code>0</code>) with empty <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00480">480</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Attributes_8h_source.html#l00171">mlir::Attribute::dyn_cast_or_null()</a>.</p>

</div>
</div>
<a id="a2bc750046567479d1fdfa425bac17b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc750046567479d1fdfa425bac17b32">&#9670;&nbsp;</a></span>unwrapForCustomParse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) mlir::detail::unwrapForCustomParse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>failureOr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttributeSupport_8h_source.html#l00302">302</a> of file <a class="el" href="AttributeSupport_8h_source.html">AttributeSupport.h</a>.</p>

</div>
</div>
<a id="ada3315ae7edc12bed53da6a26424d047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3315ae7edc12bed53da6a26424d047">&#9670;&nbsp;</a></span>verifyAffineMapAsLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::verifyAffineMapAsLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00077">77</a> of file <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html">BuiltinAttributeInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00324">mlir::AffineMap::getNumDims()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a2e2f4d4cb24fe5f60b359e5962ad5498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2f4d4cb24fe5f60b359e5962ad5498">&#9670;&nbsp;</a></span>verifyBranchSuccessorOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::verifyBranchSuccessorOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>succNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SuccessorOperands.html">SuccessorOperands</a> &amp;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that the given operands match those of the given successor block. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00061">61</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

</div>
</div>
<a id="aee3b9d7e0a9cd00a32827f48d4536850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3b9d7e0a9cd00a32827f48d4536850">&#9670;&nbsp;</a></span>verifyDataLayoutOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::verifyDataLayoutOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies that the operation implementing the data layout interface, or a module operation, is valid. </p>
<p>This calls the verifier of the spec attribute and checks if the layout is compatible with specs attached to the enclosing operations. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00334">334</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

</div>
</div>
<a id="af3a791a52efb3f0b9d61ca353b635e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a791a52efb3f0b9d61ca353b635e95">&#9670;&nbsp;</a></span>verifyDataLayoutSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::verifyDataLayoutSpec </td>
          <td>(</td>
          <td class="paramtype">DataLayoutSpecInterface&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies that a data layout spec is valid. </p>
<p>This dispatches to individual entry verifiers, and then to the verifiers implemented by the relevant type and dialect interfaces for type and identifier keys respectively. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00531">531</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="abc3a9033156fc6f0f4ee40b16eaa835c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3a9033156fc6f0f4ee40b16eaa835c">&#9670;&nbsp;</a></span>verifyDestinationStyleOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::verifyDestinationStyleOpInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that <code>op</code> conforms to the invariants of DestinationStyleOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="DestinationStyleOpInterface_8cpp_source.html#l00025">25</a> of file <a class="el" href="DestinationStyleOpInterface_8cpp_source.html">DestinationStyleOpInterface.cpp</a>.</p>

</div>
</div>
<a id="ad276c5acc7f5d475d0e1987a456a59e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad276c5acc7f5d475d0e1987a456a59e0">&#9670;&nbsp;</a></span>verifyInferredResultTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::verifyInferredResultTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies that the inferred result types match the actual result types for the op. </p>
<p>Precondition: op implements InferTypeOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00249">249</a> of file <a class="el" href="InferTypeOpInterface_8cpp_source.html">InferTypeOpInterface.cpp</a>.</p>

</div>
</div>
<a id="afebb54d50bfcc329f59aee2490b27c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afebb54d50bfcc329f59aee2490b27c07">&#9670;&nbsp;</a></span>verifyOffsetSizeAndStrideOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::verifyOffsetSizeAndStrideOp </td>
          <td>(</td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00040">40</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

</div>
</div>
<a id="a1cb95161c63d16d49aa77026b304564f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb95161c63d16d49aa77026b304564f">&#9670;&nbsp;</a></span>verifyParallelCombiningOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::verifyParallelCombiningOpInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ParallelCombiningOpInterface_8cpp_source.html#l00018">18</a> of file <a class="el" href="ParallelCombiningOpInterface_8cpp_source.html">ParallelCombiningOpInterface.cpp</a>.</p>

</div>
</div>
<a id="a819d12bc01c2443cfc1b72c4824bfaba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819d12bc01c2443cfc1b72c4824bfaba">&#9670;&nbsp;</a></span>verifyShapedDimOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::verifyShapedDimOpInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify invariants of ops that implement the ShapedDimOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="ShapedOpInterfaces_8cpp_source.html#l00017">17</a> of file <a class="el" href="ShapedOpInterfaces_8cpp_source.html">ShapedOpInterfaces.cpp</a>.</p>

</div>
</div>
<a id="ae8e42f84b57ed10b489c12a7236bb356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e42f84b57ed10b489c12a7236bb356">&#9670;&nbsp;</a></span>verifySymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::verifySymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SymbolTable_8cpp_source.html#l00454">454</a> of file <a class="el" href="SymbolTable_8cpp_source.html">SymbolTable.cpp</a>.</p>

</div>
</div>
<a id="aea9f7283021fca39df8cf99bbd90cf4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9f7283021fca39df8cf99bbd90cf4a">&#9670;&nbsp;</a></span>verifySymbolTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::verifySymbolTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SymbolTable_8cpp_source.html#l00413">413</a> of file <a class="el" href="SymbolTable_8cpp_source.html">SymbolTable.cpp</a>.</p>

</div>
</div>
<a id="ae4afbba3aecdff992f5fb31b086f9c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4afbba3aecdff992f5fb31b086f9c12">&#9670;&nbsp;</a></span>verifyTypesAlongControlFlowEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::verifyTypesAlongControlFlowEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that types match along control flow edges described the given op. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00152">152</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

</div>
</div>
<a id="a5b337bcade50e3cd7191efec879db837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b337bcade50e3cd7191efec879db837">&#9670;&nbsp;</a></span>walk() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Block.html">Block</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00154">154</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<a id="a3adcd8424919a733a4cce559560e5dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adcd8424919a733a4cce559560e5dd9">&#9670;&nbsp;</a></span>walk() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00171">171</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<a id="a7626abe27e64a0a166feedf7e829c968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7626abe27e64a0a166feedf7e829c968">&#9670;&nbsp;</a></span>walk() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, const <a class="el" href="classmlir_1_1WalkStage.html">WalkStage</a> &amp;stage)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic walkers with stage aware callbacks. </p>
<p>Walk all the operations nested under (and including) the given operation, with the callback being invoked on each operation N+1 times, where N is the number of regions attached to the operation. The <code>stage</code> input to the callback indicates the current walk stage. This method is invoked for void returning callbacks. </p>

</div>
</div>
<a id="a152b851682ac1cad31c84dc1a6fc38cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152b851682ac1cad31c84dc1a6fc38cb">&#9670;&nbsp;</a></span>walk() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the regions, blocks, or operations nested under (and including) the given operation. </p>
<p>The order in which regions, blocks and operations at the same nesting level are visited (e.g., lexicographical or reverse lexicographical order) is determined by 'Iterator'. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'order'. These methods are invoked for void-returning callbacks. A callback on a block or operation is allowed to erase that block or operation only if the walk is in post-order. See non-void method for pre-order erasure. </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00137">137</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="DebugTranslation_8cpp_source.html#l00061">mlir::LLVM::detail::DebugTranslation::translate()</a>, <a class="el" href="AttrTypeSubElements_8h_source.html#l00346">mlir::AttrTypeSubElementHandler&lt; ArrayRef&lt; T &gt;, std::enable_if_t&lt; has_sub_attr_or_type_v&lt; T &gt; &gt; &gt;::walk()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01118">JamBlockGatherer::walk()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00766">mlir::Operation::walk()</a>, <a class="el" href="Location_8cpp_source.html#l00040">mlir::LocationAttr::walk()</a>, <a class="el" href="PatternApplicator_8cpp_source.html#l00113">mlir::PatternApplicator::walkAllPatterns()</a>, and <a class="el" href="AttrTypeSubElements_8h_source.html#l00412">walkImmediateSubElementsImpl()</a>.</p>

</div>
</div>
<a id="ac791c882fa374a53b6a7ec0387586f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac791c882fa374a53b6a7ec0387586f59">&#9670;&nbsp;</a></span>walk() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Block.html">Block</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00229">229</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<a id="ab4e61da15ae81a346c6b060103d0ed54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e61da15ae81a346c6b060103d0ed54">&#9670;&nbsp;</a></span>walk() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00257">257</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<a id="aa2adf6127282c5d8cd497d1eff1013c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2adf6127282c5d8cd497d1eff1013c1">&#9670;&nbsp;</a></span>walk() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, const <a class="el" href="classmlir_1_1WalkStage.html">WalkStage</a> &amp;stage)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all the operations nested under (and including) the given operation, with the callback being invoked on each operation N+1 times, where N is the number of regions attached to the operation. </p>
<p>The <code>stage</code> input to the callback indicates the current walk stage. This method is invoked for skippable or interruptible callbacks. </p>

</div>
</div>
<a id="a08eda9acbea0f5326d02db4b99814395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08eda9acbea0f5326d02db4b99814395">&#9670;&nbsp;</a></span>walk() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the regions, blocks, or operations nested under (and including) the given operation. </p>
<p>The order in which regions, blocks and operations at the same nesting level are visited (e.g., lexicographical or reverse lexicographical order) is determined by 'Iterator'. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'order'. This method is invoked for skippable or interruptible callbacks. A callback on a block or operation is allowed to erase that block or operation if either:</p><ul>
<li>the walk is in post-order, or</li>
<li>the walk is in pre-order and the walk is skipped after the erasure. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00201">201</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<a id="addfa95ca210821ec266a0257fe9fe74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfa95ca210821ec266a0257fe9fe74f">&#9670;&nbsp;</a></span>walk() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;WalkOrder Order = WalkOrder::PostOrder, typename Iterator  = ForwardIterator, typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;llvm::is_one_of&lt;ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> *&gt;::value, RetT&gt; mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the regions, blocks, or operations nested under (and including) the given operation. </p>
<p>The order in which regions, blocks and operations at the same nesting level are visited (e.g., lexicographical or reverse lexicographical order) is determined by 'Iterator'. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'Order' (post-order by default). A callback on a block or operation is allowed to erase that block or operation if either:</p><ul>
<li>the walk is in post-order, or</li>
<li>the walk is in pre-order and the walk is skipped after the erasure. This method is selected for callbacks that operate on Region*, Block*, and Operation*.</li>
</ul>
<p>Example: op-&gt;walk([](<a class="el" href="classmlir_1_1Region.html" title="This class contains a list of basic blocks and a link to the parent operation it is attached to.">Region</a> *r) { ... }); op-&gt;walk([](<a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a> *b) { ... }); op-&gt;walk([](<a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> *op) { ... }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00312">312</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<a id="a50b0cddf03280b10bdeecbfa002f2f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b0cddf03280b10bdeecbfa002f2f4d">&#9670;&nbsp;</a></span>walk() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;WalkOrder Order = WalkOrder::PostOrder, typename Iterator  = ForwardIterator, typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; !llvm::is_one_of&lt;ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> *&gt;::value &amp;&amp; std::is_same&lt;RetT, void&gt;::value, RetT&gt; mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the operations of type 'ArgT' nested under and including the given operation. </p>
<p>The order in which regions, blocks and operations at the same nesting are visited (e.g., lexicographical or reverse lexicographical order) is determined by 'Iterator'. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'order' (post-order by default). This method is selected for void-returning callbacks that operate on a specific derived operation type. A callback on an operation is allowed to erase that operation only if the walk is in post-order. See non-void method for pre-order erasure.</p>
<p>Example: op-&gt;walk([](ReturnOp op) { ... }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00336">336</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<a id="a206f36bc38bdb9160771da18b198fa37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206f36bc38bdb9160771da18b198fa37">&#9670;&nbsp;</a></span>walk() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;WalkOrder Order = WalkOrder::PostOrder, typename Iterator  = ForwardIterator, typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; !llvm::is_one_of&lt;ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> *&gt;::value &amp;&amp; std::is_same&lt;RetT, <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&gt;::value, RetT&gt; mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the operations of type 'ArgT' nested under and including the given operation. </p>
<p>The order in which regions, blocks and operations at the same nesting are visited (e.g., lexicographical or reverse lexicographical order) is determined by 'Iterator'. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'Order' (post-order by default). This method is selected for WalkReturn returning skippable or interruptible callbacks that operate on a specific derived operation type. A callback on an operation is allowed to erase that operation if either:</p><ul>
<li>the walk is in post-order, or</li>
<li>the walk is in pre-order and the walk is skipped after the erasure.</li>
</ul>
<p>Example: op-&gt;walk([](ReturnOp op) { if (some_invariant) return <a class="el" href="classmlir_1_1WalkResult.html#a693d2ecca6f15d4d492c6ff2bea148d0">WalkResult::skip()</a>; if (another_invariant) return <a class="el" href="classmlir_1_1WalkResult.html#abab80dca5987e18f9abf08162cd3faaa">WalkResult::interrupt()</a>; return <a class="el" href="classmlir_1_1WalkResult.html#a97a7015a793bb5d2a97f08e358f42797">WalkResult::advance()</a>; }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00373">373</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<a id="ab01044a915c1ef676b33a6720e791b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01044a915c1ef676b33a6720e791b8e">&#9670;&nbsp;</a></span>walk() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_same&lt;ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;::value, RetT&gt; mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the operations nested under and including the given operation. </p>
<p>This method is selected for stage-aware callbacks that operate on Operation*.</p>
<p>Example: op-&gt;walk([](<a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> *op, const <a class="el" href="classmlir_1_1WalkStage.html" title="A utility class to encode the current walk stage for &quot;generic&quot; walkers.">WalkStage</a> &amp;stage) { ... }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00412">412</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<a id="afeeca5f48ddcfddf532f009990fa9875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeeca5f48ddcfddf532f009990fa9875">&#9670;&nbsp;</a></span>walk() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_same&lt;ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;::value &amp;&amp; std::is_same&lt;RetT, void&gt;::value, RetT&gt; mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the operations of type 'ArgT' nested under and including the given operation. </p>
<p>This method is selected for void returning callbacks that operate on a specific derived operation type.</p>
<p>Example: op-&gt;walk([](ReturnOp op, const <a class="el" href="classmlir_1_1WalkStage.html" title="A utility class to encode the current walk stage for &quot;generic&quot; walkers.">WalkStage</a> &amp;stage) { ... }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00429">429</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<a id="a7f69e037f4b2603ccae8184e60301649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f69e037f4b2603ccae8184e60301649">&#9670;&nbsp;</a></span>walk() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_same&lt;ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;::value &amp;&amp; std::is_same&lt;RetT, <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&gt;::value, RetT&gt; mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the operations of type 'ArgT' nested under and including the given operation. </p>
<p>This method is selected for WalkReturn returning interruptible callbacks that operate on a specific derived operation type.</p>
<p>Example: op-&gt;walk(op, [](ReturnOp op, const <a class="el" href="classmlir_1_1WalkStage.html" title="A utility class to encode the current walk stage for &quot;generic&quot; walkers.">WalkStage</a> &amp;stage) { if (some_invariant) return <a class="el" href="classmlir_1_1WalkResult.html#abab80dca5987e18f9abf08162cd3faaa">WalkResult::interrupt()</a>; return <a class="el" href="classmlir_1_1WalkResult.html#a97a7015a793bb5d2a97f08e358f42797">WalkResult::advance()</a>; }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00454">454</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<a id="a9d0ecdf07e5bd3e5496db1048d6b0beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0ecdf07e5bd3e5496db1048d6b0beb">&#9670;&nbsp;</a></span>walkImmediateSubElementsImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::walkImmediateSubElementsImpl </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>derived</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt;&#160;</td>
          <td class="paramname"><em>walkAttrsFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Type.html">Type</a>)&gt;&#160;</td>
          <td class="paramname"><em>walkTypesFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides the underlying implementation for the SubElementInterface walk method, using the key type of the derived attribute/type to interact with the individual parameters. </p>

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00412">412</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

<p class="reference">References <a class="el" href="AttrTypeSubElements_8h_source.html#l00317">mlir::has_sub_attr_or_type_v</a>, and <a class="el" href="Visitors_8h_source.html#l00137">walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StorageUniquerSupport_8h_source.html#l00132">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::getWalkImmediateSubElementsFn()</a>.</p>

</div>
</div>
<a id="a37f32721e9d15092545cf9ea586d6d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f32721e9d15092545cf9ea586d6d7e">&#9670;&nbsp;</a></span>wrapIntegerMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::wrapIntegerMemorySpace </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>memorySpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps deprecated integer memory space to the new <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> form. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00472">472</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a63c39ecb3618964551c0b29bc356b675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c39ecb3618964551c0b29bc356b675">&#9670;&nbsp;</a></span>first_argument_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(first_argument_type(&amp;F::operator())) mlir::detail::first_argument_type(F) </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00121">121</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 4 2023 20:34:12 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
