<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Affine/Transforms/LoopFusion.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">17.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_30022079959872f4a1874dfcab7bb1fc.html">Affine</a></li><li class="navelem"><a class="el" href="dir_20e768baa5d01a8ee51c7c9b68e644ce.html">Transforms</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">LoopFusion.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Dialect_2Affine_2Passes_8h_source.html">mlir/Dialect/Affine/Passes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineStructures_8h_source.html">mlir/Dialect/Affine/Analysis/AffineStructures.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LoopAnalysis_8h_source.html">mlir/Dialect/Affine/Analysis/LoopAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">mlir/Dialect/Affine/Analysis/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LoopFusionUtils_8h_source.html">mlir/Dialect/Affine/LoopFusionUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LoopUtils_8h_source.html">mlir/Dialect/Affine/LoopUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Affine_2Utils_8h_source.html">mlir/Dialect/Affine/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">mlir/IR/AffineExpr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2AffineMap_8h_source.html">mlir/IR/AffineMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Builders_8h_source.html">mlir/IR/Builders.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Transforms_2Passes_8h_source.html">mlir/Transforms/Passes.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/DenseMap.h&quot;</code><br />
<code>#include &quot;llvm/ADT/DenseSet.h&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SetVector.h&quot;</code><br />
<code>#include &quot;llvm/Support/CommandLine.h&quot;</code><br />
<code>#include &quot;llvm/Support/Debug.h&quot;</code><br />
<code>#include &quot;llvm/Support/raw_ostream.h&quot;</code><br />
<code>#include &lt;iomanip&gt;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &quot;mlir/Dialect/Affine/Passes.h.inc&quot;</code><br />
</div>
<p><a href="LoopFusion_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html">mlir</a></td></tr>
<tr class="memdesc:namespacemlir"><td class="mdescLeft">&#160;</td><td class="mdescRight">This header declares functions that assit transformations in the MemRef dialect. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1affine"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html">mlir::affine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a5625d45190429949682e481ca9e71fa3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#a5625d45190429949682e481ca9e71fa3">GEN_PASS_DEF_AFFINELOOPFUSION</a></td></tr>
<tr class="separator:a5625d45190429949682e481ca9e71fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;affine-loop-fusion&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a54bdcc2ea9724eccec35a1849839b8fb"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#a54bdcc2ea9724eccec35a1849839b8fb">canRemoveSrcNodeAfterFusion</a> (unsigned srcId, unsigned dstId, const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;fusionSlice, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *fusedLoopInsPoint, const <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;escapingMemRefs, <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> *mdg)</td></tr>
<tr class="memdesc:a54bdcc2ea9724eccec35a1849839b8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if node 'srcId' can be removed after fusing it with node 'dstId'.  <a href="LoopFusion_8cpp.html#a54bdcc2ea9724eccec35a1849839b8fb">More...</a><br /></td></tr>
<tr class="separator:a54bdcc2ea9724eccec35a1849839b8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcce320be7618ee54347adf6b42edc41"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#afcce320be7618ee54347adf6b42edc41">getProducerCandidates</a> (unsigned dstId, <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> *mdg, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; unsigned &gt; &amp;srcIdCandidates)</td></tr>
<tr class="memdesc:afcce320be7618ee54347adf6b42edc41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'srcIdCandidates' the producer fusion candidates for consumer 'dstId'.  <a href="LoopFusion_8cpp.html#afcce320be7618ee54347adf6b42edc41">More...</a><br /></td></tr>
<tr class="separator:afcce320be7618ee54347adf6b42edc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316a349f1e6c7b1c0d2cb09237de0e4f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#a316a349f1e6c7b1c0d2cb09237de0e4f">gatherProducerConsumerMemrefs</a> (unsigned srcId, unsigned dstId, <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> *mdg, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;producerConsumerMemrefs)</td></tr>
<tr class="memdesc:a316a349f1e6c7b1c0d2cb09237de0e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'producerConsumerMemrefs' the memrefs involved in a producer-consumer dependence between 'srcId' and 'dstId'.  <a href="LoopFusion_8cpp.html#a316a349f1e6c7b1c0d2cb09237de0e4f">More...</a><br /></td></tr>
<tr class="separator:a316a349f1e6c7b1c0d2cb09237de0e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6dcdb4f38b90b6d61e0a4e56d754d0a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#aa6dcdb4f38b90b6d61e0a4e56d754d0a">isEscapingMemref</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> memref, <a class="el" href="classmlir_1_1Block.html">Block</a> *block)</td></tr>
<tr class="memdesc:aa6dcdb4f38b90b6d61e0a4e56d754d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memref escapes in the context of the fusion pass if either:  <a href="LoopFusion_8cpp.html#aa6dcdb4f38b90b6d61e0a4e56d754d0a">More...</a><br /></td></tr>
<tr class="separator:aa6dcdb4f38b90b6d61e0a4e56d754d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cfcd1bdc74f83a7af1c1b54eafc4d3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#aa8cfcd1bdc74f83a7af1c1b54eafc4d3">gatherEscapingMemrefs</a> (unsigned id, <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> *mdg, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;escapingMemRefs)</td></tr>
<tr class="memdesc:aa8cfcd1bdc74f83a7af1c1b54eafc4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'escapingMemRefs' the memrefs from affine store ops in node 'id' that escape the block or are accessed in a non-affine way.  <a href="LoopFusion_8cpp.html#aa8cfcd1bdc74f83a7af1c1b54eafc4d3">More...</a><br /></td></tr>
<tr class="separator:aa8cfcd1bdc74f83a7af1c1b54eafc4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea7018d373460b6bd2c29760b2c4390"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#aeea7018d373460b6bd2c29760b2c4390">sinkSequentialLoops</a> (<a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">MemRefDependenceGraph::Node</a> *node)</td></tr>
<tr class="separator:aeea7018d373460b6bd2c29760b2c4390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88d54c13cd5a49dd0d0e6ac446f953f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#af88d54c13cd5a49dd0d0e6ac446f953f">createPrivateMemRef</a> (AffineForOp forOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *srcStoreOpInst, unsigned dstLoopDepth, std::optional&lt; unsigned &gt; fastMemorySpace, uint64_t localBufSizeThreshold)</td></tr>
<tr class="separator:af88d54c13cd5a49dd0d0e6ac446f953f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45bc64635d5ba4737064460e7f416de"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#aa45bc64635d5ba4737064460e7f416de">hasNonAffineUsersOnThePath</a> (unsigned srcId, unsigned dstId, <a class="el" href="classmlir_1_1Value.html">Value</a> memref, <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> *mdg)</td></tr>
<tr class="memdesc:aa45bc64635d5ba4737064460e7f416de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walking from node 'srcId' to node 'dstId' (exclusive of 'srcId' and 'dstId'), if there is any non-affine operation accessing 'memref', return true.  <a href="LoopFusion_8cpp.html#aa45bc64635d5ba4737064460e7f416de">More...</a><br /></td></tr>
<tr class="separator:aa45bc64635d5ba4737064460e7f416de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199e357b9ed4e8224f86dabd136432e4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#a199e357b9ed4e8224f86dabd136432e4">hasNonAffineUsersOnThePath</a> (unsigned srcId, unsigned dstId, <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> *mdg)</td></tr>
<tr class="memdesc:a199e357b9ed4e8224f86dabd136432e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a memref value in node 'srcId' has a non-affine that is between node 'srcId' and node 'dstId' (exclusive of 'srcNode' and 'dstNode').  <a href="LoopFusion_8cpp.html#a199e357b9ed4e8224f86dabd136432e4">More...</a><br /></td></tr>
<tr class="separator:a199e357b9ed4e8224f86dabd136432e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112e980152ba80e1c1e972884ee7986e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#a112e980152ba80e1c1e972884ee7986e">isFusionProfitable</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *srcOpInst, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *srcStoreOpInst, AffineForOp dstForOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &gt; depthSliceUnions, unsigned maxLegalFusionDepth, unsigned *dstLoopDepth, double computeToleranceThreshold)</td></tr>
<tr class="separator:a112e980152ba80e1c1e972884ee7986e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;affine-loop-fusion&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00045">45</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

</div>
</div>
<a id="a5625d45190429949682e481ca9e71fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5625d45190429949682e481ca9e71fa3">&#9670;&nbsp;</a></span>GEN_PASS_DEF_AFFINELOOPFUSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GEN_PASS_DEF_AFFINELOOPFUSION</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00040">40</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a54bdcc2ea9724eccec35a1849839b8fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bdcc2ea9724eccec35a1849839b8fb">&#9670;&nbsp;</a></span>canRemoveSrcNodeAfterFusion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool canRemoveSrcNodeAfterFusion </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>srcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dstId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;&#160;</td>
          <td class="paramname"><em>fusionSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>fusedLoopInsPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>escapingMemRefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> *&#160;</td>
          <td class="paramname"><em>mdg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if node 'srcId' can be removed after fusing it with node 'dstId'. </p>
<p>The node can be removed if any of the following conditions are met:</p><ol type="1">
<li>'srcId' has no output dependences after fusion and no escaping memrefs.</li>
<li>'srcId' has no output dependences after fusion, has escaping memrefs and the fusion slice is maximal.</li>
<li>'srcId' has output dependences after fusion, the fusion slice is maximal and the fusion insertion point dominates all the dependences. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00083">83</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00108">mlir::affine::MemRefDependenceGraph::getNode()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00367">mlir::Operation::isBeforeInBlock()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00760">mlir::affine::ComputationSliceState::isMaximal()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00063">mlir::affine::MemRefDependenceGraph::Node::op</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00113">mlir::affine::MemRefDependenceGraph::outEdges</a>.</p>

</div>
</div>
<a id="af88d54c13cd5a49dd0d0e6ac446f953f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88d54c13cd5a49dd0d0e6ac446f953f">&#9670;&nbsp;</a></span>createPrivateMemRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> createPrivateMemRef </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>srcStoreOpInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dstLoopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>fastMemorySpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>localBufSizeThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00370">370</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00916">mlir::affine::MemRefRegion::compute()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="MathExtras_8h_source.html#l00033">mlir::floorDiv()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01135">mlir::AffineMap::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00347">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00339">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00814">mlir::affine::MemRefRegion::getConstantBoundingSizeAndShape()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00471">mlir::affine::MemRefRegion::getConstraints()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01068">mlir::affine::getMemRefIntOrFloatEltSizeInBytes()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00177">mlir::presburger::IntegerRelation::getNumCols()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00174">mlir::presburger::IntegerRelation::getNumVars()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00230">mlir::Operation::getParentRegion()</a>, <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00332">mlir::FlatLinearValueConstraints::getValues()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01291">mlir::affine::replaceAllMemRefUsesWith()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01407">mlir::simplifyAffineExpr()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>.</p>

</div>
</div>
<a id="aa8cfcd1bdc74f83a7af1c1b54eafc4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cfcd1bdc74f83a7af1c1b54eafc4d3">&#9670;&nbsp;</a></span>gatherEscapingMemrefs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gatherEscapingMemrefs </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> *&#160;</td>
          <td class="paramname"><em>mdg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>escapingMemRefs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns in 'escapingMemRefs' the memrefs from affine store ops in node 'id' that escape the block or are accessed in a non-affine way. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00221">221</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00212">mlir::affine::MemRefDependenceGraph::block</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00108">mlir::affine::MemRefDependenceGraph::getNode()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l00194">isEscapingMemref()</a>.</p>

</div>
</div>
<a id="a316a349f1e6c7b1c0d2cb09237de0e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316a349f1e6c7b1c0d2cb09237de0e4f">&#9670;&nbsp;</a></span>gatherProducerConsumerMemrefs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gatherProducerConsumerMemrefs </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>srcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dstId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> *&#160;</td>
          <td class="paramname"><em>mdg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>producerConsumerMemrefs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns in 'producerConsumerMemrefs' the memrefs involved in a producer-consumer dependence between 'srcId' and 'dstId'. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00178">178</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopFusionUtils_8cpp_source.html#l00642">mlir::affine::gatherProducerConsumerMemrefs()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00108">mlir::affine::MemRefDependenceGraph::getNode()</a>.</p>

</div>
</div>
<a id="afcce320be7618ee54347adf6b42edc41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcce320be7618ee54347adf6b42edc41">&#9670;&nbsp;</a></span>getProducerCandidates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void getProducerCandidates </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dstId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> *&#160;</td>
          <td class="paramname"><em>mdg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>srcIdCandidates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns in 'srcIdCandidates' the producer fusion candidates for consumer 'dstId'. </p>
<p>Candidates are sorted by node id order. This order corresponds to the program order when the 'mdg' is created. However, program order is not guaranteed and must not be required by the client. Program order won't be held if the 'mdg' is reused from a previous fusion step or if the node creation order changes in the future to support more advance cases. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00142">142</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00108">mlir::affine::MemRefDependenceGraph::getNode()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00111">mlir::affine::MemRefDependenceGraph::inEdges</a>.</p>

</div>
</div>
<a id="a199e357b9ed4e8224f86dabd136432e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199e357b9ed4e8224f86dabd136432e4">&#9670;&nbsp;</a></span>hasNonAffineUsersOnThePath() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hasNonAffineUsersOnThePath </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>srcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dstId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> *&#160;</td>
          <td class="paramname"><em>mdg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a memref value in node 'srcId' has a non-affine that is between node 'srcId' and node 'dstId' (exclusive of 'srcNode' and 'dstNode'). </p>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00508">508</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00108">mlir::affine::MemRefDependenceGraph::getNode()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00063">mlir::affine::MemRefDependenceGraph::Node::op</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00738">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="aa45bc64635d5ba4737064460e7f416de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45bc64635d5ba4737064460e7f416de">&#9670;&nbsp;</a></span>hasNonAffineUsersOnThePath() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hasNonAffineUsersOnThePath </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>srcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dstId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>memref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> *&#160;</td>
          <td class="paramname"><em>mdg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Walking from node 'srcId' to node 'dstId' (exclusive of 'srcId' and 'dstId'), if there is any non-affine operation accessing 'memref', return true. </p>
<p>Otherwise, return false. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00474">474</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00108">mlir::affine::MemRefDependenceGraph::getNode()</a>, <a class="el" href="Value_8h_source.html#l00217">mlir::Value::getUsers()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00109">mlir::affine::MemRefDependenceGraph::nodes</a>.</p>

</div>
</div>
<a id="aa6dcdb4f38b90b6d61e0a4e56d754d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6dcdb4f38b90b6d61e0a4e56d754d0a">&#9670;&nbsp;</a></span>isEscapingMemref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isEscapingMemref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>memref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A memref escapes in the context of the fusion pass if either: </p>
<ol type="1">
<li>it (or its alias) is a block argument, or</li>
<li>created by an op not known to guarantee alias freedom,</li>
<li>it (or its alias) are used by ops other than affine dereferencing ops (e.g., by call op, memref load/store ops, alias creating ops, unknown ops, terminator ops, etc.); such ops do not deference the memref in an affine way. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00194">194</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, and <a class="el" href="Value_8h_source.html#l00217">mlir::Value::getUsers()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00221">gatherEscapingMemrefs()</a>.</p>

</div>
</div>
<a id="a112e980152ba80e1c1e972884ee7986e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112e980152ba80e1c1e972884ee7986e">&#9670;&nbsp;</a></span>isFusionProfitable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isFusionProfitable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>srcOpInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>srcStoreOpInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>dstForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &gt;&#160;</td>
          <td class="paramname"><em>depthSliceUnions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxLegalFusionDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>dstLoopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>computeToleranceThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00568">568</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00916">mlir::affine::MemRefRegion::compute()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00505">mlir::affine::getAffineForIVs()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00559">mlir::affine::getComputeCost()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00570">mlir::affine::getFusionComputeCost()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00470">mlir::affine::getLoopNestStats()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01825">mlir::affine::getMemoryFootprintBytes()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01087">mlir::affine::MemRefRegion::getRegionSize()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00292">mlir::affine::ComputationSliceState::isEmpty()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00199">max()</a>.</p>

</div>
</div>
<a id="aeea7018d373460b6bd2c29760b2c4390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea7018d373460b6bd2c29760b2c4390">&#9670;&nbsp;</a></span>sinkSequentialLoops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sinkSequentialLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">MemRefDependenceGraph::Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00359">359</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00063">mlir::affine::MemRefDependenceGraph::Node::op</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01490">mlir::affine::sinkSequentialLoops()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 4 2023 20:34:09 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
