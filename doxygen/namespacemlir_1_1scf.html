<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::scf Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">17.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1scf.html">scf</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::scf Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1scf_1_1ForLoopPipeliningPattern.html">ForLoopPipeliningPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html">SCFTilingOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to use to control tiling.  <a href="structmlir_1_1scf_1_1SCFTilingOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1SCFTilingResult.html">SCFTilingResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation information returned after tiling.  <a href="structmlir_1_1scf_1_1SCFTilingResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1SCFTileAndFuseOptions.html">SCFTileAndFuseOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options used to control tile + fuse.  <a href="structmlir_1_1scf_1_1SCFTileAndFuseOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1SCFFuseProducerOfSliceResult.html">SCFFuseProducerOfSliceResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse the producer of the source of <code>candidateSliceOp</code> by computing the required slice of the producer in-place.  <a href="structmlir_1_1scf_1_1SCFFuseProducerOfSliceResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1SCFTileAndFuseResult.html">SCFTileAndFuseResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation information returned after tile and fuse.  <a href="structmlir_1_1scf_1_1SCFTileAndFuseResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1SCFReductionTilingResult.html">SCFReductionTilingResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation information returned after reduction tiling.  <a href="structmlir_1_1scf_1_1SCFReductionTilingResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1PipeliningOption.html">PipeliningOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to dictate how loops should be pipelined.  <a href="structmlir_1_1scf_1_1PipeliningOption.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad6f872db0f4e9807f280f5a3c5537863"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#ad6f872db0f4e9807f280f5a3c5537863">ValueVector</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td></tr>
<tr class="memdesc:ad6f872db0f4e9807f280f5a3c5537863"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning vector of values, handy to return from functions.  <a href="namespacemlir_1_1scf.html#ad6f872db0f4e9807f280f5a3c5537863">More...</a><br /></td></tr>
<tr class="separator:ad6f872db0f4e9807f280f5a3c5537863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3842c061f73ca294f3975a35ec3f5470"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a3842c061f73ca294f3975a35ec3f5470">LoopVector</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; scf::ForOp &gt;</td></tr>
<tr class="separator:a3842c061f73ca294f3975a35ec3f5470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac096a5c42de8c50d86a1615f03c43770"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#ac096a5c42de8c50d86a1615f03c43770">SCFTileSizeComputationFunction</a> = std::function&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td></tr>
<tr class="separator:ac096a5c42de8c50d86a1615f03c43770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6c2254ed26543c85602925d8007821"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#abb6c2254ed26543c85602925d8007821">LoopMatcherFn</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;)&gt;</td></tr>
<tr class="memdesc:abb6c2254ed26543c85602925d8007821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match "for loop"-like operations: If the first parameter is an iteration variable, return lower/upper bounds via the second/third parameter and the step size via the last parameter.  <a href="namespacemlir_1_1scf.html#abb6c2254ed26543c85602925d8007821">More...</a><br /></td></tr>
<tr class="separator:abb6c2254ed26543c85602925d8007821"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a601f846f06f5959b1a052e975eae8ec1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a601f846f06f5959b1a052e975eae8ec1">buildTerminatedBody</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a601f846f06f5959b1a052e975eae8ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default callback for IfOp builders. Inserts a yield without arguments.  <a href="namespacemlir_1_1scf.html#a601f846f06f5959b1a052e975eae8ec1">More...</a><br /></td></tr>
<tr class="separator:a601f846f06f5959b1a052e975eae8ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888e692b007039a6d2172e34bb0bc429"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a888e692b007039a6d2172e34bb0bc429">ensureLoopTerminator</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="separator:a888e692b007039a6d2172e34bb0bc429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4957ac11a0c4d95f6a1494c808b392"><td class="memItemLeft" align="right" valign="top">ForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a7e4957ac11a0c4d95f6a1494c808b392">getForInductionVarOwner</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a7e4957ac11a0c4d95f6a1494c808b392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the loop parent of an induction variable.  <a href="namespacemlir_1_1scf.html#a7e4957ac11a0c4d95f6a1494c808b392">More...</a><br /></td></tr>
<tr class="separator:a7e4957ac11a0c4d95f6a1494c808b392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13caec83d2c9665221580ea507c6e68b"><td class="memItemLeft" align="right" valign="top">ParallelOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a13caec83d2c9665221580ea507c6e68b">getParallelForInductionVarOwner</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a13caec83d2c9665221580ea507c6e68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parallel loop parent of an induction variable.  <a href="namespacemlir_1_1scf.html#a13caec83d2c9665221580ea507c6e68b">More...</a><br /></td></tr>
<tr class="separator:a13caec83d2c9665221580ea507c6e68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc06395336be1b229e2eb4198aed9790"><td class="memItemLeft" align="right" valign="top">ForallOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#acc06395336be1b229e2eb4198aed9790">getForallOpThreadIndexOwner</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:acc06395336be1b229e2eb4198aed9790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ForallOp parent of an thread index variable.  <a href="namespacemlir_1_1scf.html#acc06395336be1b229e2eb4198aed9790">More...</a><br /></td></tr>
<tr class="separator:acc06395336be1b229e2eb4198aed9790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68717bb14a63ffb8d9266322283d253f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a68717bb14a63ffb8d9266322283d253f">insideMutuallyExclusiveBranches</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *a, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *b)</td></tr>
<tr class="memdesc:a68717bb14a63ffb8d9266322283d253f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if ops a and b (or their ancestors) are in mutually exclusive regions/blocks of an IfOp.  <a href="namespacemlir_1_1scf.html#a68717bb14a63ffb8d9266322283d253f">More...</a><br /></td></tr>
<tr class="separator:a68717bb14a63ffb8d9266322283d253f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a269a61256ef02f60885be4f2b3fff9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a2a269a61256ef02f60885be4f2b3fff9">promoteIfSingleIteration</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, scf::ForallOp forallOp)</td></tr>
<tr class="memdesc:a2a269a61256ef02f60885be4f2b3fff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes the loop body of a scf::ForallOp to its containing block if the loop was known to have a single iteration.  <a href="namespacemlir_1_1scf.html#a2a269a61256ef02f60885be4f2b3fff9">More...</a><br /></td></tr>
<tr class="separator:a2a269a61256ef02f60885be4f2b3fff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5438942b90e34c26a8df526af7c55431"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a5438942b90e34c26a8df526af7c55431">promote</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, scf::ForallOp forallOp)</td></tr>
<tr class="memdesc:a5438942b90e34c26a8df526af7c55431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes the loop body of a scf::ForallOp to its containing block.  <a href="namespacemlir_1_1scf.html#a5438942b90e34c26a8df526af7c55431">More...</a><br /></td></tr>
<tr class="separator:a5438942b90e34c26a8df526af7c55431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d89db573aefd9edf2c31fe8e7d5fe1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a63d89db573aefd9edf2c31fe8e7d5fe1">buildLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> steps, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> iterArgs, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="namespacemlir_1_1scf.html#ad6f872db0f4e9807f280f5a3c5537863">ValueVector</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilder=nullptr)</td></tr>
<tr class="memdesc:a63d89db573aefd9edf2c31fe8e7d5fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a perfect nest of "for" loops, i.e.  <a href="namespacemlir_1_1scf.html#a63d89db573aefd9edf2c31fe8e7d5fe1">More...</a><br /></td></tr>
<tr class="separator:a63d89db573aefd9edf2c31fe8e7d5fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6304a6715d1cc43d3035323cfb4cd78a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a6304a6715d1cc43d3035323cfb4cd78a">buildLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> steps, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilder=nullptr)</td></tr>
<tr class="memdesc:a6304a6715d1cc43d3035323cfb4cd78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience version for building loop nests without iteration arguments (like for reductions).  <a href="namespacemlir_1_1scf.html#a6304a6715d1cc43d3035323cfb4cd78a">More...</a><br /></td></tr>
<tr class="separator:a6304a6715d1cc43d3035323cfb4cd78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68ad1a4a71bfedc1d4ebd46101cd31e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#ad68ad1a4a71bfedc1d4ebd46101cd31e">registerValueBoundsOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:ad68ad1a4a71bfedc1d4ebd46101cd31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131df27a14db6c8a12e643fa2a0a5603"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a131df27a14db6c8a12e643fa2a0a5603">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a131df27a14db6c8a12e643fa2a0a5603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30aa77e8423a12af795fd7c5fcbc562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#af30aa77e8423a12af795fd7c5fcbc562">registerBufferizableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:af30aa77e8423a12af795fd7c5fcbc562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41079f935412040a2d9d1cec5ab42e8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; ForOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a41079f935412040a2d9d1cec5ab42e8d">pipelineForLoop</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, ForOp forOp, const <a class="el" href="structmlir_1_1scf_1_1PipeliningOption.html">PipeliningOption</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a41079f935412040a2d9d1cec5ab42e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pipelined version of the scf.for loop based on the schedule given as option.  <a href="namespacemlir_1_1scf.html#a41079f935412040a2d9d1cec5ab42e8d">More...</a><br /></td></tr>
<tr class="separator:a41079f935412040a2d9d1cec5ab42e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc0d8bddd6ca8cbfbde8bdef46228f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1scf_1_1SCFTilingResult.html">SCFTilingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#addc0d8bddd6ca8cbfbde8bdef46228f0">tileUsingSCFForOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface op, const <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html">SCFTilingOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:addc0d8bddd6ca8cbfbde8bdef46228f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to tile an op that implements the <code>TilingInterface</code> using <code>scf.for</code> for iterating over the tiles.  <a href="namespacemlir_1_1scf.html#addc0d8bddd6ca8cbfbde8bdef46228f0">More...</a><br /></td></tr>
<tr class="separator:addc0d8bddd6ca8cbfbde8bdef46228f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95864a410e0459ac1d33da677423144a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structmlir_1_1scf_1_1SCFFuseProducerOfSliceResult.html">SCFFuseProducerOfSliceResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a95864a410e0459ac1d33da677423144a">tileAndFuseProducerOfSlice</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::ExtractSliceOp candidateSliceOp, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt; loops)</td></tr>
<tr class="memdesc:a95864a410e0459ac1d33da677423144a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of fusing producer of a single slice by computing the slice of the producer in-place.  <a href="namespacemlir_1_1scf.html#a95864a410e0459ac1d33da677423144a">More...</a><br /></td></tr>
<tr class="separator:a95864a410e0459ac1d33da677423144a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd54c3e5cc3446b284e2829b853ce8ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#acd54c3e5cc3446b284e2829b853ce8ac">yieldReplacementForFusedProducer</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::ExtractSliceOp sliceOp, <a class="el" href="structmlir_1_1scf_1_1SCFFuseProducerOfSliceResult.html">scf::SCFFuseProducerOfSliceResult</a> fusedProducerInfo, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt; loops)</td></tr>
<tr class="memdesc:acd54c3e5cc3446b284e2829b853ce8ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstruct the fused producer from within the tiled-and-fused code.  <a href="namespacemlir_1_1scf.html#acd54c3e5cc3446b284e2829b853ce8ac">More...</a><br /></td></tr>
<tr class="separator:acd54c3e5cc3446b284e2829b853ce8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d9e17330fb4a1d9cca3c928993d9cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1scf_1_1SCFTileAndFuseResult.html">SCFTileAndFuseResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#ae6d9e17330fb4a1d9cca3c928993d9cb">tileConsumerAndFuseProducerGreedilyUsingSCFForOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface consumer, const <a class="el" href="structmlir_1_1scf_1_1SCFTileAndFuseOptions.html">SCFTileAndFuseOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:ae6d9e17330fb4a1d9cca3c928993d9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to tile and fuse a sequence of operations, by tiling the consumer and fusing its producers.  <a href="namespacemlir_1_1scf.html#ae6d9e17330fb4a1d9cca3c928993d9cb">More...</a><br /></td></tr>
<tr class="separator:ae6d9e17330fb4a1d9cca3c928993d9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923f55dccab8af632622d7efa517f6d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; scf::ForOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a923f55dccab8af632622d7efa517f6d2">lowerToLoopsUsingSCFForOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface op)</td></tr>
<tr class="memdesc:a923f55dccab8af632622d7efa517f6d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to lower an <code>op</code> that implements the <code>TilingInterface</code> to loops/scalars.  <a href="namespacemlir_1_1scf.html#a923f55dccab8af632622d7efa517f6d2">More...</a><br /></td></tr>
<tr class="separator:a923f55dccab8af632622d7efa517f6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3234ceb84be81b01ee005ce901cea8bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1scf_1_1SCFReductionTilingResult.html">scf::SCFReductionTilingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a3234ceb84be81b01ee005ce901cea8bb">tileReductionUsingScf</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, PartialReductionOpInterface op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSize)</td></tr>
<tr class="memdesc:a3234ceb84be81b01ee005ce901cea8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to tile a reduction and generate a parallel op within a serial loop.  <a href="namespacemlir_1_1scf.html#a3234ceb84be81b01ee005ce901cea8bb">More...</a><br /></td></tr>
<tr class="separator:a3234ceb84be81b01ee005ce901cea8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac316a00289a9c7b41712aa0a0de2ea0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#ac316a00289a9c7b41712aa0a0de2ea0c">naivelyFuseParallelOps</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:ac316a00289a9c7b41712aa0a0de2ea0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuses all adjacent scf.parallel operations with identical bounds and step into one scf.parallel operations.  <a href="namespacemlir_1_1scf.html#ac316a00289a9c7b41712aa0a0de2ea0c">More...</a><br /></td></tr>
<tr class="separator:ac316a00289a9c7b41712aa0a0de2ea0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e793e622ecb45a3c5ff79b66939191"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a55e793e622ecb45a3c5ff79b66939191">peelForLoopAndSimplifyBounds</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, ForOp forOp, scf::ForOp &amp;partialIteration)</td></tr>
<tr class="memdesc:a55e793e622ecb45a3c5ff79b66939191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a for loop with bounds/step that potentially do not divide evenly into a for loop where the step divides the iteration space evenly, followed by another scf.for for the last (partial) iteration (if any; returned via <code>partialIteration</code>).  <a href="namespacemlir_1_1scf.html#a55e793e622ecb45a3c5ff79b66939191">More...</a><br /></td></tr>
<tr class="separator:a55e793e622ecb45a3c5ff79b66939191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac87521511b3088f00423de46226c32c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; ParallelOp, ParallelOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#aac87521511b3088f00423de46226c32c">tileParallelLoop</a> (ParallelOp op, <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; int64_t &gt; tileSizes, bool noMinMaxBounds)</td></tr>
<tr class="memdesc:aac87521511b3088f00423de46226c32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile a parallel loop of the form scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4, arg5)  <a href="namespacemlir_1_1scf.html#aac87521511b3088f00423de46226c32c">More...</a><br /></td></tr>
<tr class="separator:aac87521511b3088f00423de46226c32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699a6b066e35f218deec9bf3b59f25c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a699a6b066e35f218deec9bf3b59f25c2">populateSCFStructuralTypeConversionsAndLegality</a> (<a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a699a6b066e35f218deec9bf3b59f25c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns for SCF structural type conversions and sets up the provided <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target.">ConversionTarget</a> with the appropriate legality configuration for the ops to get converted properly.  <a href="namespacemlir_1_1scf.html#a699a6b066e35f218deec9bf3b59f25c2">More...</a><br /></td></tr>
<tr class="separator:a699a6b066e35f218deec9bf3b59f25c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8915020cb011e315b6832d111e789f32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a8915020cb011e315b6832d111e789f32">populateSCFStructuralOneToNTypeConversions</a> (<a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a8915020cb011e315b6832d111e789f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the provided pattern set with patterns that do 1:N type conversions on (some) SCF ops.  <a href="namespacemlir_1_1scf.html#a8915020cb011e315b6832d111e789f32">More...</a><br /></td></tr>
<tr class="separator:a8915020cb011e315b6832d111e789f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331c5d2ebecbdc149e0d0637ce2a65c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a331c5d2ebecbdc149e0d0637ce2a65c7">populateSCFLoopPipeliningPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="structmlir_1_1scf_1_1PipeliningOption.html">PipeliningOption</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a331c5d2ebecbdc149e0d0637ce2a65c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns for SCF software pipelining transformation.  <a href="namespacemlir_1_1scf.html#a331c5d2ebecbdc149e0d0637ce2a65c7">More...</a><br /></td></tr>
<tr class="separator:a331c5d2ebecbdc149e0d0637ce2a65c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd982adcd3c785d3417107be92fee3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#acbd982adcd3c785d3417107be92fee3a">populateSCFForLoopCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:acbd982adcd3c785d3417107be92fee3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns for canonicalizing operations inside SCF loop bodies.  <a href="namespacemlir_1_1scf.html#acbd982adcd3c785d3417107be92fee3a">More...</a><br /></td></tr>
<tr class="separator:acbd982adcd3c785d3417107be92fee3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b7bd4317bfc1ab0b1852783218019c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a37b7bd4317bfc1ab0b1852783218019c">matchForLikeLoop</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> iv, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;lb, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;ub, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;step)</td></tr>
<tr class="memdesc:a37b7bd4317bfc1ab0b1852783218019c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match "for loop"-like operations from the SCF dialect.  <a href="namespacemlir_1_1scf.html#a37b7bd4317bfc1ab0b1852783218019c">More...</a><br /></td></tr>
<tr class="separator:a37b7bd4317bfc1ab0b1852783218019c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb8274cb04c9dffedfc6a3a7a9da758"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a6eb8274cb04c9dffedfc6a3a7a9da758">addLoopRangeConstraints</a> (<a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">affine::FlatAffineValueConstraints</a> &amp;cstr, <a class="el" href="classmlir_1_1Value.html">Value</a> iv, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> lb, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ub, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> step)</td></tr>
<tr class="memdesc:a6eb8274cb04c9dffedfc6a3a7a9da758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given constraint set with induction variable constraints of a "for" loop with the given range and step.  <a href="namespacemlir_1_1scf.html#a6eb8274cb04c9dffedfc6a3a7a9da758">More...</a><br /></td></tr>
<tr class="separator:a6eb8274cb04c9dffedfc6a3a7a9da758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e23c408a018f8aa464d703cd7d2ed3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a3e23c408a018f8aa464d703cd7d2ed3a">canonicalizeMinMaxOpInLoop</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir_1_1scf.html#abb6c2254ed26543c85602925d8007821">LoopMatcherFn</a> loopMatcher)</td></tr>
<tr class="memdesc:a3e23c408a018f8aa464d703cd7d2ed3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to canonicalize the given affine.min/max operation in the context of for <code>loops</code> with a known range.  <a href="namespacemlir_1_1scf.html#a3e23c408a018f8aa464d703cd7d2ed3a">More...</a><br /></td></tr>
<tr class="separator:a3e23c408a018f8aa464d703cd7d2ed3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673d966447761363e8583d22bbf08169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a673d966447761363e8583d22bbf08169">rewritePeeledMinMaxOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Value.html">Value</a> iv, <a class="el" href="classmlir_1_1Value.html">Value</a> ub, <a class="el" href="classmlir_1_1Value.html">Value</a> step, bool insideLoop)</td></tr>
<tr class="memdesc:a673d966447761363e8583d22bbf08169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to simplify the given affine.min/max operation <code>op</code> after loop peeling.  <a href="namespacemlir_1_1scf.html#a673d966447761363e8583d22bbf08169">More...</a><br /></td></tr>
<tr class="separator:a673d966447761363e8583d22bbf08169"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="abb6c2254ed26543c85602925d8007821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6c2254ed26543c85602925d8007821">&#9670;&nbsp;</a></span>LoopMatcherFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1scf.html#abb6c2254ed26543c85602925d8007821">mlir::scf::LoopMatcherFn</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>( <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Match "for loop"-like operations: If the first parameter is an iteration variable, return lower/upper bounds via the second/third parameter and the step size via the last parameter. </p>
<p>The function should return <code>success</code> in that case. If the first parameter is not an iteration variable, return <code>failure</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineCanonicalizationUtils_8h_source.html#l00041">41</a> of file <a class="el" href="AffineCanonicalizationUtils_8h_source.html">AffineCanonicalizationUtils.h</a>.</p>

</div>
</div>
<a id="a3842c061f73ca294f3975a35ec3f5470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3842c061f73ca294f3975a35ec3f5470">&#9670;&nbsp;</a></span>LoopVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1scf.html#a3842c061f73ca294f3975a35ec3f5470">mlir::scf::LoopVector</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;scf::ForOp&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2SCF_2IR_2SCF_8h_source.html#l00075">75</a> of file <a class="el" href="mlir_2Dialect_2SCF_2IR_2SCF_8h_source.html">SCF.h</a>.</p>

</div>
</div>
<a id="ac096a5c42de8c50d86a1615f03c43770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac096a5c42de8c50d86a1615f03c43770">&#9670;&nbsp;</a></span>SCFTileSizeComputationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1scf.html#ac096a5c42de8c50d86a1615f03c43770">mlir::scf::SCFTileSizeComputationFunction</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8h_source.html#l00028">28</a> of file <a class="el" href="TileUsingInterface_8h_source.html">TileUsingInterface.h</a>.</p>

</div>
</div>
<a id="ad6f872db0f4e9807f280f5a3c5537863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f872db0f4e9807f280f5a3c5537863">&#9670;&nbsp;</a></span>ValueVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1scf.html#ad6f872db0f4e9807f280f5a3c5537863">mlir::scf::ValueVector</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An owning vector of values, handy to return from functions. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2SCF_2IR_2SCF_8h_source.html#l00074">74</a> of file <a class="el" href="mlir_2Dialect_2SCF_2IR_2SCF_8h_source.html">SCF.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6eb8274cb04c9dffedfc6a3a7a9da758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb8274cb04c9dffedfc6a3a7a9da758">&#9670;&nbsp;</a></span>addLoopRangeConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::scf::addLoopRangeConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">affine::FlatAffineValueConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>cstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given constraint set with induction variable constraints of a "for" loop with the given range and step. </p>

<p class="definition">Definition at line <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00079">79</a> of file <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html">AffineCanonicalizationUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00215">mlir::affine::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00283">mlir::presburger::IntegerRelation::addInequality()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00880">mlir::FlatLinearValueConstraints::appendDimVar()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00885">mlir::FlatLinearValueConstraints::appendSymbolVar()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="MathExtras_8h_source.html#l00033">mlir::floorDiv()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01135">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00347">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00343">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00117">mlir::getConstantIntValue()</a>, <a class="el" href="Value_8h_source.html#l00125">mlir::Value::getContext()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00177">mlir::presburger::IntegerRelation::getNumCols()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00170">mlir::presburger::IntegerRelation::getNumDimVars()</a>, and <a class="el" href="IntegerRelation_8h_source.html#l00167">mlir::presburger::IntegerRelation::getNumSymbolVars()</a>.</p>

</div>
</div>
<a id="a6304a6715d1cc43d3035323cfb4cd78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6304a6715d1cc43d3035323cfb4cd78a">&#9670;&nbsp;</a></span>buildLoopNest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a> mlir::scf::buildLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilder</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience version for building loop nests without iteration arguments (like for reductions). </p>
<p>Does not take the initial value of reductions or expect the body building functions to return their current value. The built nested scf::For are captured in <code>capturedLoops</code> when non-null. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00667">667</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00594">buildLoopNest()</a>.</p>

</div>
</div>
<a id="a63d89db573aefd9edf2c31fe8e7d5fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d89db573aefd9edf2c31fe8e7d5fe1">&#9670;&nbsp;</a></span>buildLoopNest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a> mlir::scf::buildLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>iterArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="namespacemlir_1_1scf.html#ad6f872db0f4e9807f280f5a3c5537863">ValueVector</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilder</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a perfect nest of "for" loops, i.e. </p>
<p>all loops but the innermost contain only another loop and a terminator. The lower, upper bounds and steps are provided as <code>lbs</code>, <code>ubs</code> and <code>steps</code>, which are expected to be of the same size. <code>iterArgs</code> points to the initial values of the loop iteration arguments, which will be forwarded through the nest to the innermost loop. The body of the loop is populated using <code>bodyBuilder</code>, which accepts an ordered list of induction variables of all loops, followed by a list of iteration arguments of the innermost loop, in the same order as provided to <code>iterArgs</code>. This function is expected to return as many values as <code>iterArgs</code>, of the same type and in the same order, that will be treated as yielded from the loop body and forwarded back through the loop nest. If the function is not provided, the loop nest is not expected to have iteration arguments, the body of the innermost loop will be left empty, containing only the zero-operand terminator. Returns the <a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a> containing the list of perfectly nest scf::ForOp build during the call. If bound arrays are empty, the body builder will be called once to construct the IR outside of the loop with an empty list of induction variables. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00594">594</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00071">copy()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8h_source.html#l00417">mlir::OpBuilder::setInsertionPointToEnd()</a>, and <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00667">buildLoopNest()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00393">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00467">mlir::sparse_tensor::genDenseTensorOrSparseConstantIterLoop()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00489">mlir::linalg::generateParallelLoopNest()</a>, and <a class="el" href="MemoryPromotion_8cpp_source.html#l00032">insertCopyLoops()</a>.</p>

</div>
</div>
<a id="a601f846f06f5959b1a052e975eae8ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601f846f06f5959b1a052e975eae8ec1">&#9670;&nbsp;</a></span>buildTerminatedBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::buildTerminatedBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default callback for IfOp builders. Inserts a yield without arguments. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00079">79</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>.</p>

</div>
</div>
<a id="a3e23c408a018f8aa464d703cd7d2ed3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e23c408a018f8aa464d703cd7d2ed3a">&#9670;&nbsp;</a></span>canonicalizeMinMaxOpInLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::scf::canonicalizeMinMaxOpInLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1scf.html#abb6c2254ed26543c85602925d8007821">LoopMatcherFn</a>&#160;</td>
          <td class="paramname"><em>loopMatcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to canonicalize the given affine.min/max operation in the context of for <code>loops</code> with a known range. </p>
<p>Canonicalize min/max operations in the context of for loops with a known range.</p>
<p><code>loopMatcher</code> is used to retrieve loop bounds and the step size for a given iteration variable.</p>
<p>Note: <code>loopMatcher</code> allows this function to be used with any "for loop"-like operation (scf.for, scf.parallel and even ops defined in other dialects).</p>
<p>Call <code>canonicalizeMinMaxOp</code> and add the following constraints to the constraint system (along with the missing dimensions):</p>
<ul>
<li>iv &gt;= lb</li>
<li>iv &lt; lb + step * ((ub - lb - 1) floorDiv step) + 1</li>
</ul>
<p>Note: Due to limitations of IntegerPolyhedron, only constant step sizes are currently supported. </p>

<p class="definition">Definition at line <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00147">147</a> of file <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html">AffineCanonicalizationUtils.cpp</a>.</p>

</div>
</div>
<a id="a888e692b007039a6d2172e34bb0bc429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888e692b007039a6d2172e34bb0bc429">&#9670;&nbsp;</a></span>ensureLoopTerminator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::ensureLoopTerminator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc06395336be1b229e2eb4198aed9790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc06395336be1b229e2eb4198aed9790">&#9670;&nbsp;</a></span>getForallOpThreadIndexOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ForallOp mlir::scf::getForallOpThreadIndexOwner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ForallOp parent of an thread index variable. </p>
<p>If the provided value is not a thread index variable, then return nullptr. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l01447">1447</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00103">mlir::Value::dyn_cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00033">matchForLikeLoop()</a>.</p>

</div>
</div>
<a id="a7e4957ac11a0c4d95f6a1494c808b392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4957ac11a0c4d95f6a1494c808b392">&#9670;&nbsp;</a></span>getForInductionVarOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ForOp mlir::scf::getForInductionVarOwner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the loop parent of an induction variable. </p>
<p>If the provided value is not an induction variable, then return nullptr. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00497">497</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00103">mlir::Value::dyn_cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00033">matchForLikeLoop()</a>.</p>

</div>
</div>
<a id="a13caec83d2c9665221580ea507c6e68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13caec83d2c9665221580ea507c6e68b">&#9670;&nbsp;</a></span>getParallelForInductionVarOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParallelOp mlir::scf::getParallelForInductionVarOwner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the parallel loop parent of an induction variable. </p>
<p>If the provided value is not an induction variable, then return nullptr. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l02820">2820</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00103">mlir::Value::dyn_cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00033">matchForLikeLoop()</a>.</p>

</div>
</div>
<a id="a68717bb14a63ffb8d9266322283d253f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68717bb14a63ffb8d9266322283d253f">&#9670;&nbsp;</a></span>insideMutuallyExclusiveBranches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::scf::insideMutuallyExclusiveBranches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if ops a and b (or their ancestors) are in mutually exclusive regions/blocks of an IfOp. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l01759">1759</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00238">mlir::Operation::getParentOfType()</a>.</p>

</div>
</div>
<a id="a923f55dccab8af632622d7efa517f6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923f55dccab8af632622d7efa517f6d2">&#9670;&nbsp;</a></span>lowerToLoopsUsingSCFForOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; scf::ForOp &gt; &gt; mlir::scf::lowerToLoopsUsingSCFForOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to lower an <code>op</code> that implements the <code>TilingInterface</code> to loops/scalars. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00724">724</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

</div>
</div>
<a id="a37b7bd4317bfc1ab0b1852783218019c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b7bd4317bfc1ab0b1852783218019c">&#9670;&nbsp;</a></span>matchForLikeLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::scf::matchForLikeLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Match "for loop"-like operations from the SCF dialect. </p>

<p class="definition">Definition at line <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00033">33</a> of file <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html">AffineCanonicalizationUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l01447">getForallOpThreadIndexOwner()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00497">getForInductionVarOwner()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l02820">getParallelForInductionVarOwner()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="ac316a00289a9c7b41712aa0a0de2ea0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac316a00289a9c7b41712aa0a0de2ea0c">&#9670;&nbsp;</a></span>naivelyFuseParallelOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::naivelyFuseParallelOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fuses all adjacent scf.parallel operations with identical bounds and step into one scf.parallel operations. </p>
<p>Uses a naive aliasing and dependency analysis. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00138">138</a> of file <a class="el" href="ParallelLoopFusion_8cpp_source.html">ParallelLoopFusion.cpp</a>.</p>

</div>
</div>
<a id="a55e793e622ecb45a3c5ff79b66939191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e793e622ecb45a3c5ff79b66939191">&#9670;&nbsp;</a></span>peelForLoopAndSimplifyBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::scf::peelForLoopAndSimplifyBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp &amp;&#160;</td>
          <td class="paramname"><em>partialIteration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite a for loop with bounds/step that potentially do not divide evenly into a for loop where the step divides the iteration space evenly, followed by another scf.for for the last (partial) iteration (if any; returned via <code>partialIteration</code>). </p>
<p>This transformation is called "loop peeling".</p>
<p>This transformation is beneficial for a wide range of transformations such as vectorization or loop tiling: It enables additional canonicalizations inside the peeled loop body such as rewriting masked loads into unmaked loads.</p>
<p>E.g., assuming a lower bound of 0 (for illustration purposes): </p><div class="fragment"><div class="line">scf.for %iv = %c0 to %ub step %c4 {</div>
<div class="line">  (loop body)</div>
<div class="line">}</div>
</div><!-- fragment --><p> is rewritten into the following pseudo IR: </p><div class="fragment"><div class="line">%newUb = %ub - (%ub <a class="code" href="namespacemlir.html#afca33cad5b0cd935568ea0fc0a439abd">mod</a> %c4)</div>
<div class="line">scf.for %iv = %c0 to %newUb step %c4 {</div>
<div class="line">  (loop body)</div>
<div class="line">}</div>
<div class="line">scf.for %iv2 = %newUb to %ub {</div>
<div class="line">  (loop body)</div>
<div class="line">}</div>
<div class="ttc" id="anamespacemlir_html_afca33cad5b0cd935568ea0fc0a439abd"><div class="ttname"><a href="namespacemlir.html#afca33cad5b0cd935568ea0fc0a439abd">mlir::mod</a></div><div class="ttdeci">int64_t mod(int64_t lhs, int64_t rhs)</div><div class="ttdoc">Returns MLIR's mod operation on constants.</div><div class="ttdef"><b>Definition:</b> <a href="MathExtras_8h_source.html#l00045">MathExtras.h:45</a></div></div>
</div><!-- fragment --><p>After loop peeling, this function tries to simplify affine.min and affine.max ops in the body of the peeled loop and in the body of the partial iteration loop, taking advantage of the fact that the peeled loop has only "full" iterations. This simplification is expected to enable further canonicalization opportunities through other patterns.</p>
<p>The return value indicates whether the loop was rewritten or not. Loops are not rewritten if:</p><ul>
<li>Loop step size is 1 or</li>
<li>Loop bounds and step size are static, and step already divides the iteration space evenly.</li>
</ul>
<p>Note: This function rewrites the given scf.for loop in-place and creates a new scf.for operation for the last iteration. It replaces all uses of the unpeeled loop with the results of the newly generated scf.for. </p>

</div>
</div>
<a id="a41079f935412040a2d9d1cec5ab42e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41079f935412040a2d9d1cec5ab42e8d">&#9670;&nbsp;</a></span>pipelineForLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; ForOp &gt; mlir::scf::pipelineForLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1scf_1_1PipeliningOption.html">PipeliningOption</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a pipelined version of the scf.for loop based on the schedule given as option. </p>
<p>This applies the mechanical transformation of changing the loop and generating the prologue/epilogue for the pipelining and doesn't make any decision regarding the schedule. Based on the options the loop is split into several stages. The transformation assumes that the scheduling given by user is valid. For example if we break a loop into 3 stages named S0, S1, S2 we would generate the following code with the number in parenthesis as the iteration index: S0(0) // Prologue S0(1) S1(0) // Prologue scf.for I = C0 to N - 2 { S0(I+2) S1(I+1) S2(I) // Pipelined kernel } S1(N) S2(N-1) // Epilogue S2(N) // Epilogue </p>

<p class="definition">Definition at line <a class="el" href="LoopPipelining_8cpp_source.html#l00498">498</a> of file <a class="el" href="LoopPipelining_8cpp_source.html">LoopPipelining.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8cpp_source.html#l00285">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00266">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="Builders_8h_source.html#l00393">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Patterns_8h_source.html#l00048">mlir::scf::ForLoopPipeliningPattern::returningMatchAndRewrite()</a>.</p>

</div>
</div>
<a id="acbd982adcd3c785d3417107be92fee3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd982adcd3c785d3417107be92fee3a">&#9670;&nbsp;</a></span>populateSCFForLoopCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::populateSCFForLoopCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns for canonicalizing operations inside SCF loop bodies. </p>
<p>At the moment, only affine.min/max computations with iteration variables, loop bounds and loop steps are canonicalized. </p>

<p class="definition">Definition at line <a class="el" href="LoopCanonicalization_8cpp_source.html#l00178">178</a> of file <a class="el" href="LoopCanonicalization_8cpp_source.html">LoopCanonicalization.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a331c5d2ebecbdc149e0d0637ce2a65c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331c5d2ebecbdc149e0d0637ce2a65c7">&#9670;&nbsp;</a></span>populateSCFLoopPipeliningPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::populateSCFLoopPipeliningPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1scf_1_1PipeliningOption.html">PipeliningOption</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns for SCF software pipelining transformation. </p>
<p>See the <a class="el" href="classmlir_1_1scf_1_1ForLoopPipeliningPattern.html">ForLoopPipeliningPattern</a> for the transformation details. </p>

<p class="definition">Definition at line <a class="el" href="LoopPipelining_8cpp_source.html#l00541">541</a> of file <a class="el" href="LoopPipelining_8cpp_source.html">LoopPipelining.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="a8915020cb011e315b6832d111e789f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8915020cb011e315b6832d111e789f32">&#9670;&nbsp;</a></span>populateSCFStructuralOneToNTypeConversions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::populateSCFStructuralOneToNTypeConversions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the provided pattern set with patterns that do 1:N type conversions on (some) SCF ops. </p>
<p>This is intended to be used with applyPartialOneToNConversion. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2OneToNTypeConversion_8cpp_source.html#l00146">146</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2OneToNTypeConversion_8cpp_source.html">OneToNTypeConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a699a6b066e35f218deec9bf3b59f25c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699a6b066e35f218deec9bf3b59f25c2">&#9670;&nbsp;</a></span>populateSCFStructuralTypeConversionsAndLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::populateSCFStructuralTypeConversionsAndLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns for SCF structural type conversions and sets up the provided <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target.">ConversionTarget</a> with the appropriate legality configuration for the ops to get converted properly. </p>
<p>A "structural" type conversion is one where the underlying ops are completely agnostic to the actual types involved and simply need to update their types. An example of this is scf.if &ndash; the scf.if op and the corresponding scf.yield ops need to update their types accordingly to the <a class="el" href="classmlir_1_1TypeConverter.html" title="Type conversion class.">TypeConverter</a>, but otherwise don't care what type conversions are happening. </p>

<p class="definition">Definition at line <a class="el" href="StructuralTypeConversions_8cpp_source.html#l00251">251</a> of file <a class="el" href="StructuralTypeConversions_8cpp_source.html">StructuralTypeConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00832">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a5438942b90e34c26a8df526af7c55431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5438942b90e34c26a8df526af7c55431">&#9670;&nbsp;</a></span>promote()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::promote </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForallOp&#160;</td>
          <td class="paramname"><em>forallOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes the loop body of a scf::ForallOp to its containing block. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00556">556</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00520">mlir::OpBuilder::clone()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8h_source.html#l00301">mlir::Type::isa()</a>, <a class="el" href="IRMapping_8h_source.html#l00065">mlir::IRMapping::lookupOrDefault()</a>, <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00266">mlir::RewriterBase::replaceOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00541">promoteIfSingleIteration()</a>.</p>

</div>
</div>
<a id="a2a269a61256ef02f60885be4f2b3fff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a269a61256ef02f60885be4f2b3fff9">&#9670;&nbsp;</a></span>promoteIfSingleIteration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::scf::promoteIfSingleIteration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForallOp&#160;</td>
          <td class="paramname"><em>forallOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes the loop body of a scf::ForallOp to its containing block if the loop was known to have a single iteration. </p>
<p>Promotes the loop body of a forallOp to its containing block if it can be determined that the loop has a single iteration. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00541">541</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00234">mlir::constantTripCount()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00556">promote()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="af30aa77e8423a12af795fd7c5fcbc562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30aa77e8423a12af795fd7c5fcbc562">&#9670;&nbsp;</a></span>registerBufferizableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::registerBufferizableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCF_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l01168">1168</a> of file <a class="el" href="SCF_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html">BufferizableOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00087">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a131df27a14db6c8a12e643fa2a0a5603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131df27a14db6c8a12e643fa2a0a5603">&#9670;&nbsp;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00087">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="ad68ad1a4a71bfedc1d4ebd46101cd31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68ad1a4a71bfedc1d4ebd46101cd31e">&#9670;&nbsp;</a></span>registerValueBoundsOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::registerValueBoundsOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCF_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00121">121</a> of file <a class="el" href="SCF_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html">ValueBoundsOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00087">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a673d966447761363e8583d22bbf08169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673d966447761363e8583d22bbf08169">&#9670;&nbsp;</a></span>rewritePeeledMinMaxOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::scf::rewritePeeledMinMaxOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>insideLoop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to simplify the given affine.min/max operation <code>op</code> after loop peeling. </p>
<p>This function can simplify min/max operations such as (ub is the previous upper bound of the unpeeled loop): </p><div class="fragment"><div class="line"><span class="preprocessor">#map = affine_map&lt;(d0)[s0, s1] -&gt; (s0, -d0 + s1)&gt;</span></div>
<div class="line"><span class="preprocessor">%r = affine.min #map(%iv)[%step, %ub]</span></div>
</div><!-- fragment --><p> and rewrites them into (in the case the peeled loop): </p><div class="fragment"><div class="line">%r = %step</div>
</div><!-- fragment --><p> min/max operations inside the partial iteration are rewritten in a similar way.</p>
<p>This function can simplify min/max operations such as (ub is the previous upper bound of the unpeeled loop): </p><div class="fragment"><div class="line"><span class="preprocessor">#map = affine_map&lt;(d0)[s0, s1] -&gt; (s0, -d0 + s1)&gt;</span></div>
<div class="line"><span class="preprocessor">%r = affine.min #affine.min #map(%iv)[%step, %ub]</span></div>
</div><!-- fragment --><p> and rewrites them into (in the case the peeled loop): </p><div class="fragment"><div class="line">%r = %step</div>
</div><!-- fragment --><p> min/max operations inside the partial iteration are rewritten in a similar way.</p>
<p>This function builds up a set of constraints, capable of proving that:</p><ul>
<li>Inside the peeled loop: min(step, ub - iv) == step</li>
<li>Inside the partial iteration: min(step, ub - iv) == ub - iv</li>
</ul>
<p>Returns <code>success</code> if the given operation was replaced by a new operation; <code>failure</code> otherwise.</p>
<p>Note: <code>ub</code> is the previous upper bound of the loop (before peeling). <code>insideLoop</code> must be true for min/max ops inside the loop and false for affine.min ops inside the partial iteration. For an explanation of the other parameters, see comment of <code>canonicalizeMinMaxOpInLoop</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00199">199</a> of file <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html">AffineCanonicalizationUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopSpecialization_8cpp_source.html#l00158">rewriteAffineOpAfterPeeling()</a>.</p>

</div>
</div>
<a id="a95864a410e0459ac1d33da677423144a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95864a410e0459ac1d33da677423144a">&#9670;&nbsp;</a></span>tileAndFuseProducerOfSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structmlir_1_1scf_1_1SCFFuseProducerOfSliceResult.html">scf::SCFFuseProducerOfSliceResult</a> &gt; mlir::scf::tileAndFuseProducerOfSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::ExtractSliceOp&#160;</td>
          <td class="paramname"><em>candidateSliceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of fusing producer of a single slice by computing the slice of the producer in-place. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00514">514</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00495">getUntiledProducerFromSliceSource()</a>, <a class="el" href="PatternMatch_8h_source.html#l00558">mlir::RewriterBase::replaceAllUsesWith()</a>, <a class="el" href="SwapExtractSliceWithProducerPatterns_8cpp_source.html#l00023">mlir::tensor::replaceExtractSliceWithTiledProducer()</a>, <a class="el" href="Builders_8h_source.html#l00379">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00240">updateDestinationOperandsForTiledOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00645">tileConsumerAndFuseProducerGreedilyUsingSCFForOp()</a>.</p>

</div>
</div>
<a id="ae6d9e17330fb4a1d9cca3c928993d9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d9e17330fb4a1d9cca3c928993d9cb">&#9670;&nbsp;</a></span>tileConsumerAndFuseProducerGreedilyUsingSCFForOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1scf_1_1SCFTileAndFuseResult.html">scf::SCFTileAndFuseResult</a> &gt; mlir::scf::tileConsumerAndFuseProducerGreedilyUsingSCFForOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1scf_1_1SCFTileAndFuseOptions.html">SCFTileAndFuseOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to tile and fuse a sequence of operations, by tiling the consumer and fusing its producers. </p>
<p>Implementation of tile consumer and fuse producer greedily.</p>
<p>Note that this assumes that it is valid to tile+fuse the producer into the innermost tiled loop. Its up to the caller to ensure that the tile sizes provided make this fusion valid.</p>
<p>For example, for the following sequence</p>
<div class="fragment"><div class="line">%0 =</div>
<div class="line">%1 = linalg.fill ... outs(%0 : ... )</div>
<div class="line">%2 = linalg.matmul ... outs(%1 : ...) ...</div>
</div><!-- fragment --><p>it is legal to fuse the fill with the matmul only if the matmul is tiled along the parallel dimensions and not the reduction dimension, i.e. the tile size for the reduction dimension should be 0. The resulting fused transformation is</p>
<div class="fragment"><div class="line">%1 = scf.for ... iter_args(%arg0 = %0)</div>
<div class="line">  %2 = tensor.extract_slice %arg0</div>
<div class="line">  %3 = linalg.fill .. outs(%2 : ... )</div>
<div class="line">  %4 = linalg.matmul .. outs(%3 : ...)</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00645">645</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00373">mlir::Operation::getOperands()</a>, <a class="el" href="TileUsingInterface_8h_source.html#l00170">mlir::scf::SCFTileAndFuseResult::loops</a>, <a class="el" href="PatternMatch_8h_source.html#l00597">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="TileUsingInterface_8h_source.html#l00172">mlir::scf::SCFTileAndFuseResult::replacements</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00514">tileAndFuseProducerOfSlice()</a>, <a class="el" href="TileUsingInterface_8h_source.html#l00168">mlir::scf::SCFTileAndFuseResult::tiledAndFusedOps</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00277">tileUsingSCFForOp()</a>.</p>

</div>
</div>
<a id="aac87521511b3088f00423de46226c32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac87521511b3088f00423de46226c32c">&#9670;&nbsp;</a></span>tileParallelLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; ParallelOp, ParallelOp &gt; mlir::scf::tileParallelLoop </td>
          <td>(</td>
          <td class="paramtype">ParallelOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noMinMaxBounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile a parallel loop of the form scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4, arg5) </p>
<p>into scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4*tileSize[0], arg5*tileSize[1]) scf.parallel (j0, j1) = (0, 0) to (min(tileSize[0], arg2-j0) min(tileSize[1], arg3-j1)) step (arg4, arg5) The old loop is replaced with the new one.</p>
<p>The function returns the resulting ParallelOps, i.e. {outer_loop_op, inner_loop_op}.</p>
<p>into scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4*tileSize[0], arg5*tileSize[1]) scf.parallel (j0, j1) = (0, 0) to (min(arg4*tileSize[0], arg2-i0) min(arg5*tileSize[1], arg3-i1)) step (arg4, arg5)</p>
<p>or, when no-min-max-bounds is true, into scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4*tileSize[0], arg5*tileSize[1]) scf.parallel (j0, j1) = (0, 0) to (arg4*tileSize[0], arg5*tileSize[1]) step (arg4, arg5) inbound = (j0 * arg4 + i0 &lt; arg2) &amp;&amp; (j1 * arg5 + i1 &lt; arg3) scf.if (inbound) ....</p>
<p>where the uses of i0 and i1 in the loop body are replaced by i0 + j0 and i1 + j1.</p>
<p>The old loop is replaced with the new one. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopTiling_8cpp_source.html#l00058">58</a> of file <a class="el" href="ParallelLoopTiling_8cpp_source.html">ParallelLoopTiling.cpp</a>.</p>

</div>
</div>
<a id="a3234ceb84be81b01ee005ce901cea8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3234ceb84be81b01ee005ce901cea8bb">&#9670;&nbsp;</a></span>tileReductionUsingScf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1scf_1_1SCFReductionTilingResult.html">scf::SCFReductionTilingResult</a> &gt; mlir::scf::tileReductionUsingScf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PartialReductionOpInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to tile a reduction and generate a parallel op within a serial loop. </p>
<p>Each of the partial reductions are calculated in parallel. Then after the loop all the partial reduction are merged into a final reduction. For example for the following sequence</p>
<div class="fragment"><div class="line">%0 = linalg.generic %in [&quot;parallel&quot;, &quot;reduction&quot;]</div>
<div class="line">  : tensor&lt;7x9xf32&gt; -&gt; tensor&lt;7xf32&gt;</div>
</div><!-- fragment --><p>into:</p>
<div class="fragment"><div class="line">%0 = linalg.fill ... : tensor&lt;7x4xf32&gt;</div>
<div class="line">%1 = scf.for ... iter_args(%arg0 = %0)</div>
<div class="line">  %2 = tensor.extract_slice %arg0 : tensor&lt;7x4xf32&gt; -&gt; tensor&lt;7x?xf32&gt;</div>
<div class="line">  %3 = tensor.extract_slice %in : tensor&lt;7x9xf32&gt; -&gt; tensor&lt;7x?xf32&gt;</div>
<div class="line">  %4 = linalg.generic %2, %3 [&quot;parallel&quot;, &quot;parallel&quot;]</div>
<div class="line">    : tensor&lt;7x?xf32&gt; -&gt; tensor&lt;7x?xf32&gt;</div>
<div class="line">  %5 = tensor.insert_slice %3, %0[0, 0] : tensor&lt;7x4xf32&gt;</div>
<div class="line">}</div>
<div class="line">%6 = linalg.generic %1 [&quot;parallel&quot;, &quot;reduction&quot;]</div>
<div class="line">  : tensor&lt;7x4xf32&gt; -&gt; tensor&lt;7xf32&gt;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00403">403</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

</div>
</div>
<a id="addc0d8bddd6ca8cbfbde8bdef46228f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc0d8bddd6ca8cbfbde8bdef46228f0">&#9670;&nbsp;</a></span>tileUsingSCFForOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1scf_1_1SCFTilingResult.html">scf::SCFTilingResult</a> &gt; mlir::scf::tileUsingSCFForOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html">SCFTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to tile an op that implements the <code>TilingInterface</code> using <code>scf.for</code> for iterating over the tiles. </p>
<p>Implementation of tiling transformation of <code>op</code> that implements the <code>TilingInterface</code> using <code>scf.for</code> to iterate over the tiles. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00277">277</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00645">tileConsumerAndFuseProducerGreedilyUsingSCFForOp()</a>.</p>

</div>
</div>
<a id="acd54c3e5cc3446b284e2829b853ce8ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd54c3e5cc3446b284e2829b853ce8ac">&#9670;&nbsp;</a></span>yieldReplacementForFusedProducer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::yieldReplacementForFusedProducer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::ExtractSliceOp&#160;</td>
          <td class="paramname"><em>sliceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1scf_1_1SCFFuseProducerOfSliceResult.html">scf::SCFFuseProducerOfSliceResult</a>&#160;</td>
          <td class="paramname"><em>fusedProducerInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconstruct the fused producer from within the tiled-and-fused code. </p>
<p>Based on the slice of the producer computed in place it is possible that within the loop nest same slice of the producer is computed multiple times. It is in general not possible to recompute the value of the fused producer from the tiled loop code in such cases. For the cases where no slice of the producer is computed in a redundant fashion it is possible to reconstruct the value of the original producer from within the tiled loop. It is upto the caller to ensure that the producer is not computed redundantly within the tiled loop nest. For example, consider</p>
<div class="fragment"><div class="line">%0 = linalg.matmul ins(...) outs(...) -&gt; tensor&lt;?x?xf32&gt;</div>
<div class="line">%1 = linalg.matmul ins(%0, ..) outs(...) -&gt; tensor&lt;?x?x?f32&gt;</div>
</div><!-- fragment --><p>If <code>%1</code> is tiled in a 2D fashion and <code>%0</code> is fused with it, the resulting IR is,</p>
<div class="fragment"><div class="line">%t1_0 = scf.for .... iter_args(%arg0 = ...) {</div>
<div class="line">  %t1_1 = scf.for ... iter_args(%arg1 = %arg0) {</div>
<div class="line">    ...</div>
<div class="line">    %t1_2 = linalg.matmul ins(...) outs(...) -&gt; tensor&lt;?x?xf32&gt;</div>
<div class="line">    %t1_3 = linalg.matmul ins(%t1_2, ...)</div>
<div class="line">    %t1_4 = tensor.insert_slice %t1_3 into %arg1 ...</div>
<div class="line">    scf.yield %t1_4</div>
<div class="line">  }</div>
<div class="line">  scf.yield %t1_1</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here <code>t1_2</code> is the same for all iterations of the inner <code>scf.for</code>. Instead if <code>%1</code> were tiled only along the rows, the resultant code would be</p>
<div class="fragment"><div class="line">%t2_0 = scf.for .... iter_args(%arg0 = ...) {</div>
<div class="line">  ...</div>
<div class="line">  %t2_1 = linalg.matmul ins(...) outs(...) -&gt; tensor&lt;?x?xf32&gt;</div>
<div class="line">  %t2_2 = linalg.matmul ins(%t2_1, ...)</div>
<div class="line">  %t2_3 = tensor.insert_slice %t2_2 into %arg0 ...</div>
<div class="line">  scf.yield %t2_3</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here there is no intersection in the different slices of <code>t2_1</code> computed across iterations of the <code>scf.for</code>. In such cases, the value of the original <code>%0</code> can be reconstructed from within the loop body. This is useful in cases where <code>%0</code> had other uses as well. If not reconstructed from within the loop body, uses of <code>%0</code> could not be replaced, making it still live and the fusion immaterial. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00614">614</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="TensorOps_8cpp_source.html#l00064">mlir::tensor::getOrCreateDestination()</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00240">updateDestinationOperandsForTiledOp()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00180">yieldTiledValues()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 4 2023 20:34:14 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
