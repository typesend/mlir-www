<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::LLVMTypeConverter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">17.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmlir_1_1LLVMTypeConverter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::LLVMTypeConverter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Conversion from types to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect.  
 <a href="classmlir_1_1LLVMTypeConverter.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="TypeConverter_8h_source.html">mlir/Conversion/LLVMCommon/TypeConverter.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for mlir::LLVMTypeConverter:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classmlir_1_1LLVMTypeConverter__inherit__graph.png" border="0" usemap="#amlir_1_1LLVMTypeConverter_inherit__map" alt="Inheritance graph"/></div>
<map name="amlir_1_1LLVMTypeConverter_inherit__map" id="amlir_1_1LLVMTypeConverter_inherit__map">
<area shape="rect" title="Conversion from types to the LLVM IR dialect." alt="" coords="5,80,189,107"/>
<area shape="rect" href="classmlir_1_1TypeConverter.html" title="Type conversion class." alt="" coords="22,5,173,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abb9279107c83f744985d247e3c87cc09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#abb9279107c83f744985d247e3c87cc09">LLVMTypeConverter</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a> *analysis=nullptr)</td></tr>
<tr class="memdesc:abb9279107c83f744985d247e3c87cc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> using the default <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a>.  <a href="classmlir_1_1LLVMTypeConverter.html#abb9279107c83f744985d247e3c87cc09">More...</a><br /></td></tr>
<tr class="separator:abb9279107c83f744985d247e3c87cc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0838be3560f61a0c13e8d39ff13f828"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#aa0838be3560f61a0c13e8d39ff13f828">LLVMTypeConverter</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, const <a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a> &amp;options, const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a> *analysis=nullptr)</td></tr>
<tr class="memdesc:aa0838be3560f61a0c13e8d39ff13f828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> using custom <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a>.  <a href="classmlir_1_1LLVMTypeConverter.html#aa0838be3560f61a0c13e8d39ff13f828">More...</a><br /></td></tr>
<tr class="separator:aa0838be3560f61a0c13e8d39ff13f828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada21944aa42c235d88a1cb7f79a735bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#ada21944aa42c235d88a1cb7f79a735bd">convertFunctionSignature</a> (FunctionType funcTy, bool isVariadic, bool useBarePtrCallConv, <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &amp;result)</td></tr>
<tr class="memdesc:ada21944aa42c235d88a1cb7f79a735bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a function type.  <a href="classmlir_1_1LLVMTypeConverter.html#ada21944aa42c235d88a1cb7f79a735bd">More...</a><br /></td></tr>
<tr class="separator:ada21944aa42c235d88a1cb7f79a735bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d7f839bdd11d02bc96cc2778cdb852"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#ad4d7f839bdd11d02bc96cc2778cdb852">packFunctionResults</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types, bool useBarePointerCallConv=false)</td></tr>
<tr class="memdesc:ad4d7f839bdd11d02bc96cc2778cdb852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a non-empty list of types to be returned from a function into an LLVM-compatible type.  <a href="classmlir_1_1LLVMTypeConverter.html#ad4d7f839bdd11d02bc96cc2778cdb852">More...</a><br /></td></tr>
<tr class="separator:ad4d7f839bdd11d02bc96cc2778cdb852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f1b781321d4c4908a1914e3a4c04eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a92f1b781321d4c4908a1914e3a4c04eb">packOperationResults</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types)</td></tr>
<tr class="memdesc:a92f1b781321d4c4908a1914e3a4c04eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a non-empty list of types of values produced by an operation into an LLVM-compatible type.  <a href="classmlir_1_1LLVMTypeConverter.html#a92f1b781321d4c4908a1914e3a4c04eb">More...</a><br /></td></tr>
<tr class="separator:a92f1b781321d4c4908a1914e3a4c04eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441924b700c78828d6c5bf1855ff1cde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a441924b700c78828d6c5bf1855ff1cde">convertCallingConventionType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, bool useBarePointerCallConv=false)</td></tr>
<tr class="memdesc:a441924b700c78828d6c5bf1855ff1cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a type in the context of the default or bare pointer calling convention.  <a href="classmlir_1_1LLVMTypeConverter.html#a441924b700c78828d6c5bf1855ff1cde">More...</a><br /></td></tr>
<tr class="separator:a441924b700c78828d6c5bf1855ff1cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0d181a7762464d5591f1e6a4e8298f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a8b0d181a7762464d5591f1e6a4e8298f">promoteBarePtrsToDescriptors</a> (<a class="el" href="classmlir_1_1ConversionPatternRewriter.html">ConversionPatternRewriter</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; stdTypes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:a8b0d181a7762464d5591f1e6a4e8298f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote the bare pointers in 'values' that resulted from memrefs to descriptors.  <a href="classmlir_1_1LLVMTypeConverter.html#a8b0d181a7762464d5591f1e6a4e8298f">More...</a><br /></td></tr>
<tr class="separator:a8b0d181a7762464d5591f1e6a4e8298f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639369e362248ce7d1ffc1270030394e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a639369e362248ce7d1ffc1270030394e">getContext</a> ()</td></tr>
<tr class="memdesc:a639369e362248ce7d1ffc1270030394e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MLIR context.  <a href="classmlir_1_1LLVMTypeConverter.html#a639369e362248ce7d1ffc1270030394e">More...</a><br /></td></tr>
<tr class="separator:a639369e362248ce7d1ffc1270030394e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9b6a759e14ed157646219e078f508a"><td class="memItemLeft" align="right" valign="top">LLVM::LLVMDialect *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a2b9b6a759e14ed157646219e078f508a">getDialect</a> ()</td></tr>
<tr class="memdesc:a2b9b6a759e14ed157646219e078f508a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <a href="classmlir_1_1LLVMTypeConverter.html#a2b9b6a759e14ed157646219e078f508a">More...</a><br /></td></tr>
<tr class="separator:a2b9b6a759e14ed157646219e078f508a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f142ecd8d10e44d253307880715607"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a48f142ecd8d10e44d253307880715607">getOptions</a> () const</td></tr>
<tr class="separator:a48f142ecd8d10e44d253307880715607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa1bc939aee87e282d8944671cfa4f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a9fa1bc939aee87e282d8944671cfa4f6">dangerousSetOptions</a> (<a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a> newOptions)</td></tr>
<tr class="memdesc:a9fa1bc939aee87e282d8944671cfa4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the lowering options to <code>newOptions</code>.  <a href="classmlir_1_1LLVMTypeConverter.html#a9fa1bc939aee87e282d8944671cfa4f6">More...</a><br /></td></tr>
<tr class="separator:a9fa1bc939aee87e282d8944671cfa4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbeaa2b5b35879e7c2d0873a222f7db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#acdbeaa2b5b35879e7c2d0873a222f7db">promoteOperands</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> opOperands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, bool useBarePtrCallConv=false)</td></tr>
<tr class="memdesc:acdbeaa2b5b35879e7c2d0873a222f7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> representation of all operands including promoting MemRef descriptors to stack and use pointers to struct to avoid the complexity of the platform-specific C/C++ ABI lowering related to struct argument passing.  <a href="classmlir_1_1LLVMTypeConverter.html#acdbeaa2b5b35879e7c2d0873a222f7db">More...</a><br /></td></tr>
<tr class="separator:acdbeaa2b5b35879e7c2d0873a222f7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82800024c8e09ab46e31d3ba0c926ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#ae82800024c8e09ab46e31d3ba0c926ab">promoteOneMemRefDescriptor</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> operand, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:ae82800024c8e09ab46e31d3ba0c926ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> struct representation of one MemRef descriptor to stack and use pointer to struct to avoid the complexity of the platform-specific C/C++ ABI lowering related to struct argument passing.  <a href="classmlir_1_1LLVMTypeConverter.html#ae82800024c8e09ab46e31d3ba0c926ab">More...</a><br /></td></tr>
<tr class="separator:ae82800024c8e09ab46e31d3ba0c926ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4795414ea3fb67868831b414969309d9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; LLVM::LLVMFunctionType, <a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVM::LLVMStructType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a4795414ea3fb67868831b414969309d9">convertFunctionTypeCWrapper</a> (FunctionType type)</td></tr>
<tr class="memdesc:a4795414ea3fb67868831b414969309d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the function type to a C-compatible format, in particular using pointers to memref descriptors for arguments.  <a href="classmlir_1_1LLVMTypeConverter.html#a4795414ea3fb67868831b414969309d9">More...</a><br /></td></tr>
<tr class="separator:a4795414ea3fb67868831b414969309d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a88e7f4974a20cccef1bfe5e9477210"><td class="memItemLeft" align="right" valign="top">const llvm::DataLayout &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a4a88e7f4974a20cccef1bfe5e9477210">getDataLayout</a> ()</td></tr>
<tr class="memdesc:a4a88e7f4974a20cccef1bfe5e9477210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data layout to use during and after conversion.  <a href="classmlir_1_1LLVMTypeConverter.html#a4a88e7f4974a20cccef1bfe5e9477210">More...</a><br /></td></tr>
<tr class="separator:a4a88e7f4974a20cccef1bfe5e9477210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5617fe390dff357f3e9e39f9ed9e38"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a5e5617fe390dff357f3e9e39f9ed9e38">getDataLayoutAnalysis</a> () const</td></tr>
<tr class="memdesc:a5e5617fe390dff357f3e9e39f9ed9e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data layout analysis to query during conversion.  <a href="classmlir_1_1LLVMTypeConverter.html#a5e5617fe390dff357f3e9e39f9ed9e38">More...</a><br /></td></tr>
<tr class="separator:a5e5617fe390dff357f3e9e39f9ed9e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fadfd6858d9b4f3957470c164cf6b57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a7fadfd6858d9b4f3957470c164cf6b57">getIndexType</a> ()</td></tr>
<tr class="memdesc:a7fadfd6858d9b4f3957470c164cf6b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> representation of the index type.  <a href="classmlir_1_1LLVMTypeConverter.html#a7fadfd6858d9b4f3957470c164cf6b57">More...</a><br /></td></tr>
<tr class="separator:a7fadfd6858d9b4f3957470c164cf6b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01c64b195a60c0ec83ead602fbda4e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#af01c64b195a60c0ec83ead602fbda4e6">useOpaquePointers</a> () const</td></tr>
<tr class="memdesc:af01c64b195a60c0ec83ead602fbda4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if using opaque pointers was enabled in the lowering options.  <a href="classmlir_1_1LLVMTypeConverter.html#af01c64b195a60c0ec83ead602fbda4e6">More...</a><br /></td></tr>
<tr class="separator:af01c64b195a60c0ec83ead602fbda4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c426cb26260227ea555baf03fb9ddbb"><td class="memItemLeft" align="right" valign="top">LLVM::LLVMPointerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a8c426cb26260227ea555baf03fb9ddbb">getPointerType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> elementType, unsigned addressSpace=0)</td></tr>
<tr class="memdesc:a8c426cb26260227ea555baf03fb9ddbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> pointer type with the given element type and address space.  <a href="classmlir_1_1LLVMTypeConverter.html#a8c426cb26260227ea555baf03fb9ddbb">More...</a><br /></td></tr>
<tr class="separator:a8c426cb26260227ea555baf03fb9ddbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48a9d6dd176ca0546f7531e44f97ab1"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#ae48a9d6dd176ca0546f7531e44f97ab1">getIndexTypeBitwidth</a> ()</td></tr>
<tr class="memdesc:ae48a9d6dd176ca0546f7531e44f97ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bitwidth of the index type when converted to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="classmlir_1_1LLVMTypeConverter.html#ae48a9d6dd176ca0546f7531e44f97ab1">More...</a><br /></td></tr>
<tr class="separator:ae48a9d6dd176ca0546f7531e44f97ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075dac045e3c8d4830fb66fcf485c6f2"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a075dac045e3c8d4830fb66fcf485c6f2">getPointerBitwidth</a> (unsigned addressSpace=0)</td></tr>
<tr class="memdesc:a075dac045e3c8d4830fb66fcf485c6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer bitwidth.  <a href="classmlir_1_1LLVMTypeConverter.html#a075dac045e3c8d4830fb66fcf485c6f2">More...</a><br /></td></tr>
<tr class="separator:a075dac045e3c8d4830fb66fcf485c6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828b50e5112b76e4e7c11c4ca4ec7c2b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a828b50e5112b76e4e7c11c4ca4ec7c2b">getMemRefDescriptorSize</a> (MemRefType type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout)</td></tr>
<tr class="memdesc:a828b50e5112b76e4e7c11c4ca4ec7c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the memref descriptor object in bytes.  <a href="classmlir_1_1LLVMTypeConverter.html#a828b50e5112b76e4e7c11c4ca4ec7c2b">More...</a><br /></td></tr>
<tr class="separator:a828b50e5112b76e4e7c11c4ca4ec7c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3372283ec8117a49904af1d15363d27"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#af3372283ec8117a49904af1d15363d27">getUnrankedMemRefDescriptorSize</a> (<a class="el" href="structUnrankedMemRefType.html">UnrankedMemRefType</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout)</td></tr>
<tr class="memdesc:af3372283ec8117a49904af1d15363d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the unranked memref descriptor object in bytes.  <a href="classmlir_1_1LLVMTypeConverter.html#af3372283ec8117a49904af1d15363d27">More...</a><br /></td></tr>
<tr class="separator:af3372283ec8117a49904af1d15363d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f69b8adac8435c67d3edbc9c18f977"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#aa1f69b8adac8435c67d3edbc9c18f977">getMemRefAddressSpace</a> (<a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> type)</td></tr>
<tr class="memdesc:aa1f69b8adac8435c67d3edbc9c18f977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> address space corresponding to the memory space of the memref type <code>type</code> or failure if the memory space cannot be converted to an integer.  <a href="classmlir_1_1LLVMTypeConverter.html#aa1f69b8adac8435c67d3edbc9c18f977">More...</a><br /></td></tr>
<tr class="separator:aa1f69b8adac8435c67d3edbc9c18f977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c3e12662d60542476df0feddcd9fff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a98c3e12662d60542476df0feddcd9fff">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;results)</td></tr>
<tr class="memdesc:a98c3e12662d60542476df0feddcd9fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given type.  <a href="classmlir_1_1LLVMTypeConverter.html#a98c3e12662d60542476df0feddcd9fff">More...</a><br /></td></tr>
<tr class="separator:a98c3e12662d60542476df0feddcd9fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b17254bd638b2e408c7d5f972ced99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a82b17254bd638b2e408c7d5f972ced99">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t)</td></tr>
<tr class="memdesc:a82b17254bd638b2e408c7d5f972ced99"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook simplifies defining 1-1 type conversions.  <a href="classmlir_1_1LLVMTypeConverter.html#a82b17254bd638b2e408c7d5f972ced99">More...</a><br /></td></tr>
<tr class="separator:a82b17254bd638b2e408c7d5f972ced99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61425aa746e1219cb2c1f2a509f39ff9"><td class="memTemplParams" colspan="2">template&lt;typename TargetType &gt; </td></tr>
<tr class="memitem:a61425aa746e1219cb2c1f2a509f39ff9"><td class="memTemplItemLeft" align="right" valign="top">TargetType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a61425aa746e1219cb2c1f2a509f39ff9">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t)</td></tr>
<tr class="memdesc:a61425aa746e1219cb2c1f2a509f39ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts a 1-1 type conversion, expecting the result type to be <code>TargetType</code>.  <a href="classmlir_1_1LLVMTypeConverter.html#a61425aa746e1219cb2c1f2a509f39ff9">More...</a><br /></td></tr>
<tr class="separator:a61425aa746e1219cb2c1f2a509f39ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1TypeConverter"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1TypeConverter')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1TypeConverter.html">mlir::TypeConverter</a></td></tr>
<tr class="memitem:a272bc4144b1ac5a3f7f1ad25c0e39e03 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;0&gt;&gt; </td></tr>
<tr class="memitem:a272bc4144b1ac5a3f7f1ad25c0e39e03 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a272bc4144b1ac5a3f7f1ad25c0e39e03">addConversion</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:a272bc4144b1ac5a3f7f1ad25c0e39e03 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a conversion function.  <a href="classmlir_1_1TypeConverter.html#a272bc4144b1ac5a3f7f1ad25c0e39e03">More...</a><br /></td></tr>
<tr class="separator:a272bc4144b1ac5a3f7f1ad25c0e39e03 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db00a47b187ad5846fea3362969a913 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </td></tr>
<tr class="memitem:a3db00a47b187ad5846fea3362969a913 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a3db00a47b187ad5846fea3362969a913">addArgumentMaterialization</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:a3db00a47b187ad5846fea3362969a913 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a materialization function, which must be convertible to the following form: <code>std::optional&lt;<a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>&gt;(<a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations.">OpBuilder</a> &amp;, T, <a class="el" href="classmlir_1_1ValueRange.html" title="This class provides an abstraction over the different types of ranges over Values.">ValueRange</a>, <a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a>)</code>, where <code>T</code> is any subclass of <code><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a></code>.  <a href="classmlir_1_1TypeConverter.html#a3db00a47b187ad5846fea3362969a913">More...</a><br /></td></tr>
<tr class="separator:a3db00a47b187ad5846fea3362969a913 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf35c0b4faa6fa6d8eda987ad71393e9 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </td></tr>
<tr class="memitem:aaf35c0b4faa6fa6d8eda987ad71393e9 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#aaf35c0b4faa6fa6d8eda987ad71393e9">addSourceMaterialization</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:aaf35c0b4faa6fa6d8eda987ad71393e9 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method registers a materialization that will be called when converting a legal type to an illegal source type.  <a href="classmlir_1_1TypeConverter.html#aaf35c0b4faa6fa6d8eda987ad71393e9">More...</a><br /></td></tr>
<tr class="separator:aaf35c0b4faa6fa6d8eda987ad71393e9 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe54f9a4348e1d8aa30535f53ddaf37 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </td></tr>
<tr class="memitem:acfe54f9a4348e1d8aa30535f53ddaf37 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#acfe54f9a4348e1d8aa30535f53ddaf37">addTargetMaterialization</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:acfe54f9a4348e1d8aa30535f53ddaf37 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method registers a materialization that will be called when converting type from an illegal, or source, type to a legal type.  <a href="classmlir_1_1TypeConverter.html#acfe54f9a4348e1d8aa30535f53ddaf37">More...</a><br /></td></tr>
<tr class="separator:acfe54f9a4348e1d8aa30535f53ddaf37 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b36cbf0a62aab9acb39d9299336980 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;0&gt;, typename A  = typename llvm::function_traits&lt;std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </td></tr>
<tr class="memitem:ac5b36cbf0a62aab9acb39d9299336980 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ac5b36cbf0a62aab9acb39d9299336980">addTypeAttributeConversion</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:ac5b36cbf0a62aab9acb39d9299336980 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a conversion function for attributes within types.  <a href="classmlir_1_1TypeConverter.html#ac5b36cbf0a62aab9acb39d9299336980">More...</a><br /></td></tr>
<tr class="separator:ac5b36cbf0a62aab9acb39d9299336980 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c3e12662d60542476df0feddcd9fff inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a98c3e12662d60542476df0feddcd9fff">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;results)</td></tr>
<tr class="memdesc:a98c3e12662d60542476df0feddcd9fff inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given type.  <a href="classmlir_1_1TypeConverter.html#a98c3e12662d60542476df0feddcd9fff">More...</a><br /></td></tr>
<tr class="separator:a98c3e12662d60542476df0feddcd9fff inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b17254bd638b2e408c7d5f972ced99 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a82b17254bd638b2e408c7d5f972ced99">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t)</td></tr>
<tr class="memdesc:a82b17254bd638b2e408c7d5f972ced99 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook simplifies defining 1-1 type conversions.  <a href="classmlir_1_1TypeConverter.html#a82b17254bd638b2e408c7d5f972ced99">More...</a><br /></td></tr>
<tr class="separator:a82b17254bd638b2e408c7d5f972ced99 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61425aa746e1219cb2c1f2a509f39ff9 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplParams" colspan="2">template&lt;typename TargetType &gt; </td></tr>
<tr class="memitem:a61425aa746e1219cb2c1f2a509f39ff9 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplItemLeft" align="right" valign="top">TargetType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a61425aa746e1219cb2c1f2a509f39ff9">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t)</td></tr>
<tr class="memdesc:a61425aa746e1219cb2c1f2a509f39ff9 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts a 1-1 type conversion, expecting the result type to be <code>TargetType</code>.  <a href="classmlir_1_1TypeConverter.html#a61425aa746e1219cb2c1f2a509f39ff9">More...</a><br /></td></tr>
<tr class="separator:a61425aa746e1219cb2c1f2a509f39ff9 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4e8bb70bde7031736a7092c001c4ba inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a5c4e8bb70bde7031736a7092c001c4ba">convertTypes</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;results)</td></tr>
<tr class="memdesc:a5c4e8bb70bde7031736a7092c001c4ba inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given set of types, filling 'results' as necessary.  <a href="classmlir_1_1TypeConverter.html#a5c4e8bb70bde7031736a7092c001c4ba">More...</a><br /></td></tr>
<tr class="separator:a5c4e8bb70bde7031736a7092c001c4ba inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851e966212a7ca7d0f6ba4217cc94555 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a851e966212a7ca7d0f6ba4217cc94555">isLegal</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memdesc:a851e966212a7ca7d0f6ba4217cc94555 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given type is legal for this type converter, i.e.  <a href="classmlir_1_1TypeConverter.html#a851e966212a7ca7d0f6ba4217cc94555">More...</a><br /></td></tr>
<tr class="separator:a851e966212a7ca7d0f6ba4217cc94555 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0564be6da3bb990712f30fee9a71dedf inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplParams" colspan="2">template&lt;typename RangeT &gt; </td></tr>
<tr class="memitem:a0564be6da3bb990712f30fee9a71dedf inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_convertible&lt; RangeT, <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;::value &amp;&amp;!std::is_convertible&lt; RangeT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a0564be6da3bb990712f30fee9a71dedf">isLegal</a> (RangeT &amp;&amp;range)</td></tr>
<tr class="memdesc:a0564be6da3bb990712f30fee9a71dedf inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all of the given types are legal for this type converter.  <a href="classmlir_1_1TypeConverter.html#a0564be6da3bb990712f30fee9a71dedf">More...</a><br /></td></tr>
<tr class="separator:a0564be6da3bb990712f30fee9a71dedf inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad883e7fdaecf9928ec69b04af4f95c37 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ad883e7fdaecf9928ec69b04af4f95c37">isLegal</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ad883e7fdaecf9928ec69b04af4f95c37 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given operation has legal operand and result types.  <a href="classmlir_1_1TypeConverter.html#ad883e7fdaecf9928ec69b04af4f95c37">More...</a><br /></td></tr>
<tr class="separator:ad883e7fdaecf9928ec69b04af4f95c37 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4a4f962742b7455a70218227b7201d inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a4c4a4f962742b7455a70218227b7201d">isLegal</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memdesc:a4c4a4f962742b7455a70218227b7201d inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the types of block arguments within the region are legal.  <a href="classmlir_1_1TypeConverter.html#a4c4a4f962742b7455a70218227b7201d">More...</a><br /></td></tr>
<tr class="separator:a4c4a4f962742b7455a70218227b7201d inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3e6b3ab7ac3d67208f429fbf15fade inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a2c3e6b3ab7ac3d67208f429fbf15fade">isSignatureLegal</a> (FunctionType ty)</td></tr>
<tr class="memdesc:a2c3e6b3ab7ac3d67208f429fbf15fade inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the inputs and outputs of the given function type are legal.  <a href="classmlir_1_1TypeConverter.html#a2c3e6b3ab7ac3d67208f429fbf15fade">More...</a><br /></td></tr>
<tr class="separator:a2c3e6b3ab7ac3d67208f429fbf15fade inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8d8fb83971ae60f79e79bca268547a inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a3a8d8fb83971ae60f79e79bca268547a">convertSignatureArg</a> (unsigned inputNo, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &amp;result)</td></tr>
<tr class="memdesc:a3a8d8fb83971ae60f79e79bca268547a inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows for converting a specific argument of a signature.  <a href="classmlir_1_1TypeConverter.html#a3a8d8fb83971ae60f79e79bca268547a">More...</a><br /></td></tr>
<tr class="separator:a3a8d8fb83971ae60f79e79bca268547a inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642cd6e09a55f7d5ca4d99bb31d643cf inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a642cd6e09a55f7d5ca4d99bb31d643cf">convertSignatureArgs</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types, <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &amp;result, unsigned origInputOffset=0)</td></tr>
<tr class="separator:a642cd6e09a55f7d5ca4d99bb31d643cf inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0d70ed6d97cbb8da4ba4a6e46a475e inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a9a0d70ed6d97cbb8da4ba4a6e46a475e">convertBlockSignature</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block)</td></tr>
<tr class="memdesc:a9a0d70ed6d97cbb8da4ba4a6e46a475e inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts the type signature of the given block, by invoking 'convertSignatureArg' for each argument.  <a href="classmlir_1_1TypeConverter.html#a9a0d70ed6d97cbb8da4ba4a6e46a475e">More...</a><br /></td></tr>
<tr class="separator:a9a0d70ed6d97cbb8da4ba4a6e46a475e inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf86f32f772b0c88c285052599b1b5e6 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#aaf86f32f772b0c88c285052599b1b5e6">materializeArgumentConversion</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inputs)</td></tr>
<tr class="memdesc:aaf86f32f772b0c88c285052599b1b5e6 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize a conversion from a set of types into one result type by generating a cast sequence of some kind.  <a href="classmlir_1_1TypeConverter.html#aaf86f32f772b0c88c285052599b1b5e6">More...</a><br /></td></tr>
<tr class="separator:aaf86f32f772b0c88c285052599b1b5e6 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09f0ebddc61145342e5f9f8b19a12a1 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ad09f0ebddc61145342e5f9f8b19a12a1">materializeSourceConversion</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inputs)</td></tr>
<tr class="separator:ad09f0ebddc61145342e5f9f8b19a12a1 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e4c78aeadbd4d8e6bc2eb0548fad68 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ae9e4c78aeadbd4d8e6bc2eb0548fad68">materializeTargetConversion</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inputs)</td></tr>
<tr class="separator:ae9e4c78aeadbd4d8e6bc2eb0548fad68 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79321344199a43a3e0f8a38802b46861 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a79321344199a43a3e0f8a38802b46861">convertTypeAttribute</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:a79321344199a43a3e0f8a38802b46861 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an attribute present <code>attr</code> from within the type <code>type</code> using the registered conversion functions.  <a href="classmlir_1_1TypeConverter.html#a79321344199a43a3e0f8a38802b46861">More...</a><br /></td></tr>
<tr class="separator:a79321344199a43a3e0f8a38802b46861 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:add6a58ffa4a0f076c7e513d493c82fb3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#add6a58ffa4a0f076c7e513d493c82fb3">canConvertToBarePtr</a> (<a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> type)</td></tr>
<tr class="memdesc:add6a58ffa4a0f076c7e513d493c82fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a memref type can be converted to a bare pointer.  <a href="classmlir_1_1LLVMTypeConverter.html#add6a58ffa4a0f076c7e513d493c82fb3">More...</a><br /></td></tr>
<tr class="separator:add6a58ffa4a0f076c7e513d493c82fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0034100981a301427abe8367c89ef6a3"><td class="memItemLeft" align="right" valign="top">LLVM::LLVMDialect *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a0034100981a301427abe8367c89ef6a3">llvmDialect</a></td></tr>
<tr class="memdesc:a0034100981a301427abe8367c89ef6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <a href="classmlir_1_1LLVMTypeConverter.html#a0034100981a301427abe8367c89ef6a3">More...</a><br /></td></tr>
<tr class="separator:a0034100981a301427abe8367c89ef6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab10f3537cce1df5dfed478d3897a47ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#ab10f3537cce1df5dfed478d3897a47ce">structFuncArgTypeConverter</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:ab10f3537cce1df5dfed478d3897a47ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give structFuncArgTypeConverter access to memref-specific functions.  <a href="classmlir_1_1LLVMTypeConverter.html#ab10f3537cce1df5dfed478d3897a47ce">More...</a><br /></td></tr>
<tr class="separator:ab10f3537cce1df5dfed478d3897a47ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Conversion from types to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00033">33</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abb9279107c83f744985d247e3c87cc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9279107c83f744985d247e3c87cc09">&#9670;&nbsp;</a></span>LLVMTypeConverter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLVMTypeConverter::LLVMTypeConverter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a> *&#160;</td>
          <td class="paramname"><em>analysis</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> using the default <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a>. </p>
<p>Create an <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> using default <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a>.</p>
<p>Optionally takes a data layout analysis to use in conversions. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00019">19</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

</div>
</div>
<a id="aa0838be3560f61a0c13e8d39ff13f828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0838be3560f61a0c13e8d39ff13f828">&#9670;&nbsp;</a></span>LLVMTypeConverter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLVMTypeConverter::LLVMTypeConverter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a> *&#160;</td>
          <td class="paramname"><em>analysis</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> using custom <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a>. </p>
<p>Optionally takes a data layout analysis to use in conversions. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00024">24</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00166">mlir::TypeConverter::addArgumentMaterialization()</a>, <a class="el" href="DialectConversion_8h_source.html#l00146">mlir::TypeConverter::addConversion()</a>, <a class="el" href="DialectConversion_8h_source.html#l00175">mlir::TypeConverter::addSourceMaterialization()</a>, <a class="el" href="DialectConversion_8h_source.html#l00183">mlir::TypeConverter::addTargetMaterialization()</a>, <a class="el" href="DialectConversion_8h_source.html#l00211">mlir::TypeConverter::addTypeAttributeConversion()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02901">convertType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02949">mlir::TypeConverter::convertTypes()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00419">mlir::LLVM::LLVMStructType::getIdentified()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00447">mlir::LLVM::LLVMStructType::getLiteral()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00402">mlir::Operation::getResult()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00824">mlir::LLVM::isCompatibleType()</a>, <a class="el" href="TypeConverter_8h_source.html#l00169">llvmDialect</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00232">mlir::MemRefDescriptor::pack()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00342">mlir::UnrankedMemRefDescriptor::pack()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="add6a58ffa4a0f076c7e513d493c82fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6a58ffa4a0f076c7e513d493c82fb3">&#9670;&nbsp;</a></span>canConvertToBarePtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LLVMTypeConverter::canConvertToBarePtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a memref type can be converted to a bare pointer. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00414">414</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00321">mlir::Type::cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00785">mlir::getStridesAndOffset()</a>, and <a class="el" href="IR_2Types_8h_source.html#l00301">mlir::Type::isa()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00054">canBeCalledWithBarePointers()</a>.</p>

</div>
</div>
<a id="a441924b700c78828d6c5bf1855ff1cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441924b700c78828d6c5bf1855ff1cde">&#9670;&nbsp;</a></span>convertCallingConventionType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> LLVMTypeConverter::convertCallingConventionType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBarePtrCallConv</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a type in the context of the default or bare pointer calling convention. </p>
<p>Calling convention sensitive types, such as MemRefType and <a class="el" href="structUnrankedMemRefType.html">UnrankedMemRefType</a>, are converted following the specific rules for the calling convention. Calling convention independent types are converted following the default <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> type conversions. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00476">476</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02901">convertType()</a>, and <a class="el" href="IR_2Types_8h_source.html#l00311">mlir::Type::dyn_cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00629">mlir::barePtrFuncArgTypeConverter()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00524">packFunctionResults()</a>.</p>

</div>
</div>
<a id="ada21944aa42c235d88a1cb7f79a735bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada21944aa42c235d88a1cb7f79a735bd">&#9670;&nbsp;</a></span>convertFunctionSignature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> LLVMTypeConverter::convertFunctionSignature </td>
          <td>(</td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>funcTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isVariadic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBarePtrCallConv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">LLVMTypeConverter::SignatureConversion</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a function type. </p>
<p>The arguments and results are converted one by one and results are packed into a wrapped <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR structure type. <code>result</code> is populated with argument mapping. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00223">223</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02872">mlir::TypeConverter::SignatureConversion::addInputs()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00629">mlir::barePtrFuncArgTypeConverter()</a>, <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00169">getContext()</a>, <a class="el" href="DialectConversion_8h_source.html#l00055">mlir::TypeConverter::SignatureConversion::getConvertedTypes()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00524">packFunctionResults()</a>, <a class="el" href="classmlir_1_1LLVMTypeConverter.html#ab10f3537cce1df5dfed478d3897a47ce">structFuncArgTypeConverter</a>, and <a class="el" href="LoweringOptions_8h_source.html#l00035">mlir::LowerToLLVMOptions::useBarePtrCallConv</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUOpsLowering_8cpp_source.html#l00020">mlir::GPUFuncOpLowering::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a4795414ea3fb67868831b414969309d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4795414ea3fb67868831b414969309d9">&#9670;&nbsp;</a></span>convertFunctionTypeCWrapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; LLVM::LLVMFunctionType, <a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVM::LLVMStructType</a> &gt; LLVMTypeConverter::convertFunctionTypeCWrapper </td>
          <td>(</td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the function type to a C-compatible format, in particular using pointers to memref descriptors for arguments. </p>
<p>Also converts the return type to a pointer argument if it is a struct. Returns true if this was the case. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00254">254</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02901">convertType()</a>, <a class="el" href="IR_2Types_8h_source.html#l00311">mlir::Type::dyn_cast()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00169">getContext()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00178">getPointerType()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00824">mlir::LLVM::isCompatibleType()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00524">packFunctionResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FuncToLLVM_8cpp_source.html#l00183">wrapExternalFunction()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00119">wrapForExternalCallers()</a>.</p>

</div>
</div>
<a id="a82b17254bd638b2e408c7d5f972ced99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b17254bd638b2e408c7d5f972ced99">&#9670;&nbsp;</a></span>convertType() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> TypeConverter::convertType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This hook simplifies defining 1-1 type conversions. </p>
<p>This function returns the type to convert to on success, and a null type on failure. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l00224">224</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

</div>
</div>
<a id="a61425aa746e1219cb2c1f2a509f39ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61425aa746e1219cb2c1f2a509f39ff9">&#9670;&nbsp;</a></span>convertType() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TargetType mlir::TypeConverter::convertType </td>
          <td>(</td>
          <td class="paramtype">typename TargetType&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts a 1-1 type conversion, expecting the result type to be <code>TargetType</code>. </p>
<p>Returns the converted type cast to <code>TargetType</code> on success, and a null type on conversion or cast failure. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00230">230</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

</div>
</div>
<a id="a98c3e12662d60542476df0feddcd9fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c3e12662d60542476df0feddcd9fff">&#9670;&nbsp;</a></span>convertType() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> TypeConverter::convertType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given type. </p>
<p>This function should return failure if no valid conversion exists, success otherwise. If the new set of types is empty, the type is removed and any usages of the existing value are expected to be removed during conversion. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l00220">220</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00140">broadcast()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00202">mlir::MemRefDescriptor::bufferPtr()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00476">convertCallingConventionType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00254">convertFunctionTypeCWrapper()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00265">convertPointerType()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00228">mlir::ConvertToLLVMPattern::copyUnrankedDescriptors()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00063">mlir::AllocationOpLLVMLowering::createIndexConstant()</a>, <a class="el" href="VectorPattern_8cpp_source.html#l00019">mlir::LLVM::detail::extractNDVectorTypeInfo()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00069">extractOne()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00050">mlir::MemRefDescriptor::fromStaticShape()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00113">getIndexedPtrs()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00084">getMemRefAlignment()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00053">getPtrToElementType()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00052">insertOne()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00024">LLVMTypeConverter()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00020">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00280">modifyFuncOpToUseBarePtrCallingConv()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00232">mlir::MemRefDescriptor::pack()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00342">mlir::UnrankedMemRefDescriptor::pack()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00503">packOperationResults()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00600">mlir::structFuncArgTypeConverter()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00183">wrapExternalFunction()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00119">wrapForExternalCallers()</a>.</p>

</div>
</div>
<a id="a9fa1bc939aee87e282d8944671cfa4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa1bc939aee87e282d8944671cfa4f6">&#9670;&nbsp;</a></span>dangerousSetOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::LLVMTypeConverter::dangerousSetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a>&#160;</td>
          <td class="paramname"><em>newOptions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the lowering options to <code>newOptions</code>. </p>
<p>Note: using this after some some conversions have been performed can lead to inconsistencies in the IR. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00098">98</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

</div>
</div>
<a id="a639369e362248ce7d1ffc1270030394e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639369e362248ce7d1ffc1270030394e">&#9670;&nbsp;</a></span>getContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp; LLVMTypeConverter::getContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the MLIR context. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00169">169</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8h_source.html#l00091">getDialect()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00223">convertFunctionSignature()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00254">convertFunctionTypeCWrapper()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00173">getIndexType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00178">getPointerType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00524">packFunctionResults()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00503">packOperationResults()</a>, <a class="el" href="ArmSVE_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00070">mlir::populateArmSVELegalizeForLLVMExportPatterns()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00962">mlir::populateGpuToLLVMConversionPatterns()</a>, <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00314">mlir::populateGpuToNVVMConversionPatterns()</a>, and <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00212">mlir::populateGpuToROCDLConversionPatterns()</a>.</p>

</div>
</div>
<a id="a4a88e7f4974a20cccef1bfe5e9477210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a88e7f4974a20cccef1bfe5e9477210">&#9670;&nbsp;</a></span>getDataLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const llvm::DataLayout&amp; mlir::LLVMTypeConverter::getDataLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the data layout to use during and after conversion. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00124">124</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">References <a class="el" href="LoweringOptions_8h_source.html#l00057">mlir::LowerToLLVMOptions::dataLayout</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00084">getMemRefAlignment()</a>.</p>

</div>
</div>
<a id="a5e5617fe390dff357f3e9e39f9ed9e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5617fe390dff357f3e9e39f9ed9e38">&#9670;&nbsp;</a></span>getDataLayoutAnalysis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a>* mlir::LLVMTypeConverter::getDataLayoutAnalysis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the data layout analysis to query during conversion. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00127">127</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

</div>
</div>
<a id="a2b9b6a759e14ed157646219e078f508a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9b6a759e14ed157646219e078f508a">&#9670;&nbsp;</a></span>getDialect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM::LLVMDialect* mlir::LLVMTypeConverter::getDialect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00091">91</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8h_source.html#l00169">llvmDialect</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00169">getContext()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00033">mlir::ConvertToLLVMPattern::getDialect()</a>, and <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l01698">mlir::populateVectorToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a7fadfd6858d9b4f3957470c164cf6b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fadfd6858d9b4f3957470c164cf6b57">&#9670;&nbsp;</a></span>getIndexType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> LLVMTypeConverter::getIndexType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> representation of the index type. </p>
<p>The returned type is an integer type with the size configured for this type converter. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00173">173</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00169">getContext()</a>, and <a class="el" href="TypeConverter_8h_source.html#l00147">getIndexTypeBitwidth()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefBuilder_8cpp_source.html#l00202">mlir::MemRefDescriptor::bufferPtr()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00365">mlir::UnrankedMemRefDescriptor::computeSizes()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00228">mlir::ConvertToLLVMPattern::copyUnrankedDescriptors()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00037">mlir::ConvertToLLVMPattern::getIndexType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00351">getMemRefDescriptorSize()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00383">getUnrankedMemRefDescriptorSize()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00501">mlir::UnrankedMemRefDescriptor::offset()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00483">mlir::UnrankedMemRefDescriptor::offsetBasePtr()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00556">mlir::UnrankedMemRefDescriptor::setSize()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00590">mlir::UnrankedMemRefDescriptor::setStride()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00544">mlir::UnrankedMemRefDescriptor::size()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00521">mlir::UnrankedMemRefDescriptor::sizeBasePtr()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00578">mlir::UnrankedMemRefDescriptor::stride()</a>, and <a class="el" href="MemRefBuilder_8cpp_source.html#l00568">mlir::UnrankedMemRefDescriptor::strideBasePtr()</a>.</p>

</div>
</div>
<a id="ae48a9d6dd176ca0546f7531e44f97ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48a9d6dd176ca0546f7531e44f97ab1">&#9670;&nbsp;</a></span>getIndexTypeBitwidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::LLVMTypeConverter::getIndexTypeBitwidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the bitwidth of the index type when converted to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00147">147</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">References <a class="el" href="LoweringOptions_8h_source.html#l00067">mlir::LowerToLLVMOptions::getIndexBitwidth()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefBuilder_8cpp_source.html#l00365">mlir::UnrankedMemRefDescriptor::computeSizes()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00173">getIndexType()</a>.</p>

</div>
</div>
<a id="aa1f69b8adac8435c67d3edbc9c18f977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f69b8adac8435c67d3edbc9c18f977">&#9670;&nbsp;</a></span>getMemRefAddressSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; unsigned &gt; LLVMTypeConverter::getMemRefAddressSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> address space corresponding to the memory space of the memref type <code>type</code> or failure if the memory space cannot be converted to an integer. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00399">399</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03048">mlir::TypeConverter::convertTypeAttribute()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00373">mlir::BaseMemRefType::getMemorySpace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AllocLikeConversion_8cpp_source.html#l00057">castAllocFuncResult()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00128">castDataPtr()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00228">mlir::ConvertToLLVMPattern::copyUnrankedDescriptors()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00112">mlir::ConvertToLLVMPattern::getElementPtrType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00351">getMemRefDescriptorSize()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00383">getUnrankedMemRefDescriptorSize()</a>, and <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00099">isMemRefTypeSupported()</a>.</p>

</div>
</div>
<a id="a828b50e5112b76e4e7c11c4ca4ec7c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828b50e5112b76e4e7c11c4ca4ec7c2b">&#9670;&nbsp;</a></span>getMemRefDescriptorSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned LLVMTypeConverter::getMemRefDescriptorSize </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the memref descriptor object in bytes. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00351">351</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00173">getIndexType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00399">getMemRefAddressSpace()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00184">getPointerBitwidth()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00436">mlir::DataLayout::getTypeSize()</a>.</p>

</div>
</div>
<a id="a48f142ecd8d10e44d253307880715607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f142ecd8d10e44d253307880715607">&#9670;&nbsp;</a></span>getOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a>&amp; mlir::LLVMTypeConverter::getOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00093">93</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefToLLVM_8cpp_source.html#l01882">mlir::populateFinalizeMemRefToLLVMConversionPatterns()</a>, and <a class="el" href="TypeConverter_8h_source.html#l00136">useOpaquePointers()</a>.</p>

</div>
</div>
<a id="a075dac045e3c8d4830fb66fcf485c6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075dac045e3c8d4830fb66fcf485c6f2">&#9670;&nbsp;</a></span>getPointerBitwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned LLVMTypeConverter::getPointerBitwidth </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>addressSpace</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the pointer bitwidth. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00184">184</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoweringOptions_8h_source.html#l00057">mlir::LowerToLLVMOptions::dataLayout</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefBuilder_8cpp_source.html#l00365">mlir::UnrankedMemRefDescriptor::computeSizes()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00351">getMemRefDescriptorSize()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00383">getUnrankedMemRefDescriptorSize()</a>.</p>

</div>
</div>
<a id="a8c426cb26260227ea555baf03fb9ddbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c426cb26260227ea555baf03fb9ddbb">&#9670;&nbsp;</a></span>getPointerType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLVM::LLVMPointerType LLVMTypeConverter::getPointerType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>elementType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>addressSpace</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> pointer type with the given element type and address space. </p>
<p>This function is meant to be used in code supporting both typed and opaque pointers, as it will create an opaque pointer with the given address space if opaque pointers are enabled in the lowering options. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00178">178</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00169">getContext()</a>, and <a class="el" href="TypeConverter_8h_source.html#l00136">useOpaquePointers()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00860">bitAndAddrspaceCast()</a>, <a class="el" href="AllocLikeConversion_8cpp_source.html#l00057">castAllocFuncResult()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00254">convertFunctionTypeCWrapper()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00265">convertPointerType()</a>, <a class="el" href="ControlFlowToLLVM_8cpp_source.html#l00047">createPrintMsg()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00112">mlir::ConvertToLLVMPattern::getElementPtrType()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00121">mlir::ConvertToLLVMPattern::getMemRefDescriptorSizes()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00173">mlir::ConvertToLLVMPattern::getSizeInBytes()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00020">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00219">mlir::GPUPrintfOpToHIPLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00330">mlir::GPUPrintfOpToLLVMCallLowering::matchAndRewrite()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00962">mlir::populateGpuToLLVMConversionPatterns()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00544">promoteOneMemRefDescriptor()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00556">mlir::UnrankedMemRefDescriptor::setSize()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00590">mlir::UnrankedMemRefDescriptor::setStride()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00544">mlir::UnrankedMemRefDescriptor::size()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00578">mlir::UnrankedMemRefDescriptor::stride()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00568">mlir::UnrankedMemRefDescriptor::strideBasePtr()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00183">wrapExternalFunction()</a>.</p>

</div>
</div>
<a id="af3372283ec8117a49904af1d15363d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3372283ec8117a49904af1d15363d27">&#9670;&nbsp;</a></span>getUnrankedMemRefDescriptorSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned LLVMTypeConverter::getUnrankedMemRefDescriptorSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUnrankedMemRefType.html">UnrankedMemRefType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the unranked memref descriptor object in bytes. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00383">383</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00173">getIndexType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00399">getMemRefAddressSpace()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00184">getPointerBitwidth()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00436">mlir::DataLayout::getTypeSize()</a>.</p>

</div>
</div>
<a id="ad4d7f839bdd11d02bc96cc2778cdb852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d7f839bdd11d02bc96cc2778cdb852">&#9670;&nbsp;</a></span>packFunctionResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> LLVMTypeConverter::packFunctionResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBarePtrCallConv</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a non-empty list of types to be returned from a function into an LLVM-compatible type. </p>
<p>In particular, if more than one value is returned, create an <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect structure type with elements that correspond to each of the types converted with <code>convertCallingConventionType</code>. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00524">524</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00476">convertCallingConventionType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00169">getContext()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00447">mlir::LLVM::LLVMStructType::getLiteral()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00824">mlir::LLVM::isCompatibleType()</a>, and <a class="el" href="LoweringOptions_8h_source.html#l00035">mlir::LowerToLLVMOptions::useBarePtrCallConv</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00223">convertFunctionSignature()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00254">convertFunctionTypeCWrapper()</a>.</p>

</div>
</div>
<a id="a92f1b781321d4c4908a1914e3a4c04eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f1b781321d4c4908a1914e3a4c04eb">&#9670;&nbsp;</a></span>packOperationResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> LLVMTypeConverter::packOperationResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a non-empty list of types of values produced by an operation into an LLVM-compatible type. </p>
<p>In particular, if more than one value is produced, create a literal structure with elements that correspond to each of the LLVM-compatible types converted with <code>convertType</code>.</p>
<p>In particular, if more than one value is produced, create a literal structure with elements that correspond to each of the types converted with <code>convertType</code>. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00503">503</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02901">convertType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00169">getContext()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00447">mlir::LLVM::LLVMStructType::getLiteral()</a>, and <a class="el" href="LLVMTypes_8cpp_source.html#l00824">mlir::LLVM::isCompatibleType()</a>.</p>

</div>
</div>
<a id="a8b0d181a7762464d5591f1e6a4e8298f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0d181a7762464d5591f1e6a4e8298f">&#9670;&nbsp;</a></span>promoteBarePtrsToDescriptors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LLVMTypeConverter::promoteBarePtrsToDescriptors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionPatternRewriter.html">ConversionPatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>stdTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promote the bare pointers in 'values' that resulted from memrefs to descriptors. </p>
<p>'stdTypes' holds the types of 'values' before the conversion to the LLVM-IR dialect (i.e., MemRefType, or any other builtin type).</p>
<p>'stdTypes' holds they types of 'values' before the conversion to the LLVM-IR dialect (i.e., MemRefType, or any other builtin type). </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00488">488</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemRefBuilder_8cpp_source.html#l00044">mlir::MemRefDescriptor::fromStaticShape()</a>.</p>

</div>
</div>
<a id="ae82800024c8e09ab46e31d3ba0c926ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82800024c8e09ab46e31d3ba0c926ab">&#9670;&nbsp;</a></span>promoteOneMemRefDescriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> LLVMTypeConverter::promoteOneMemRefDescriptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promote the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> struct representation of one MemRef descriptor to stack and use pointer to struct to avoid the complexity of the platform-specific C/C++ ABI lowering related to struct argument passing. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00544">544</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8cpp_source.html#l00082">mlir::Builder::getI64Type()</a>, <a class="el" href="Builders_8cpp_source.html#l00121">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00178">getPointerType()</a>, and <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="acdbeaa2b5b35879e7c2d0873a222f7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbeaa2b5b35879e7c2d0873a222f7db">&#9670;&nbsp;</a></span>promoteOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt; LLVMTypeConverter::promoteOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>opOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBarePtrCallConv</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promote the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> representation of all operands including promoting MemRef descriptors to stack and use pointers to struct to avoid the complexity of the platform-specific C/C++ ABI lowering related to struct argument passing. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00559">559</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemRefBuilder_8cpp_source.html#l00090">mlir::MemRefDescriptor::alignedPtr()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00253">mlir::MemRefDescriptor::unpack()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00356">mlir::UnrankedMemRefDescriptor::unpack()</a>, and <a class="el" href="LoweringOptions_8h_source.html#l00035">mlir::LowerToLLVMOptions::useBarePtrCallConv</a>.</p>

</div>
</div>
<a id="af01c64b195a60c0ec83ead602fbda4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01c64b195a60c0ec83ead602fbda4e6">&#9670;&nbsp;</a></span>useOpaquePointers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::LLVMTypeConverter::useOpaquePointers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if using opaque pointers was enabled in the lowering options. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00136">136</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8h_source.html#l00093">getOptions()</a>, and <a class="el" href="LoweringOptions_8h_source.html#l00036">mlir::LowerToLLVMOptions::useOpaquePointers</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00860">bitAndAddrspaceCast()</a>, <a class="el" href="AllocLikeConversion_8cpp_source.html#l00057">castAllocFuncResult()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00128">castDataPtr()</a>, <a class="el" href="ControlFlowToLLVM_8cpp_source.html#l00047">createPrintMsg()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00178">getPointerType()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ab10f3537cce1df5dfed478d3897a47ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10f3537cce1df5dfed478d3897a47ce">&#9670;&nbsp;</a></span>structFuncArgTypeConverter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> structFuncArgTypeConverter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give structFuncArgTypeConverter access to memref-specific functions. </p>
<p>It converts a MemRef function argument to a list of non-aggregate types containing descriptor information, and an UnrankedmemRef function argument to a list containing the rank and a pointer to a descriptor struct. </p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00223">convertFunctionSignature()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0034100981a301427abe8367c89ef6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0034100981a301427abe8367c89ef6a3">&#9670;&nbsp;</a></span>llvmDialect</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM::LLVMDialect* mlir::LLVMTypeConverter::llvmDialect</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00169">169</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8h_source.html#l00091">getDialect()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00024">LLVMTypeConverter()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Conversion/LLVMCommon/<a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a></li>
<li>lib/Conversion/LLVMCommon/<a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 4 2023 20:34:10 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
