<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::linalg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">17.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1linalg.html">linalg</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::linalg Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1linalg_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1LinalgOpToLibraryCallRewrite.html">LinalgOpToLibraryCallRewrite</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTilingAndFusionOptions.html">LinalgTilingAndFusionOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">LinalgPaddingOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1SplitReductionOptions.html">SplitReductionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split Reduction options.  <a href="structmlir_1_1linalg_1_1SplitReductionOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ElementwiseOpFusionResult.html">ElementwiseOpFusionResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse two <code>linalg.generic</code> operations that have a producer-consumer relationship captured through <code>fusedOperand</code>.  <a href="structmlir_1_1linalg_1_1ElementwiseOpFusionResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform standalone tiling of a single LinalgOp by <code>tileSizes</code>.  <a href="structmlir_1_1linalg_1_1TiledLinalgOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">PromotionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer using the <code>allocationFn</code> provided.  <a href="structmlir_1_1linalg_1_1PromotionInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1MultiSizeSpecification.html">MultiSizeSpecification</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A description of a multi-size tiling comprising tile sizes and numbers of tiles, expressed as Values which may or may not be constant.  <a href="structmlir_1_1linalg_1_1MultiSizeSpecification.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1StaticMultiSizeSpecification.html">StaticMultiSizeSpecification</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ForallTilingResult.html">ForallTilingResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a TilingInterface <code>op</code> to a tiled <code>scf.forall</code>, applying tiling by <code>numThreads</code>.  <a href="structmlir_1_1linalg_1_1ForallTilingResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ForallReductionTilingResult.html">ForallReductionTilingResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation information returned after reduction tiling.  <a href="structmlir_1_1linalg_1_1ForallReductionTilingResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1SplitReductionResult.html">SplitReductionResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply transformation to split the single linalg op reduction into a parallel and reduction dimension.  <a href="structmlir_1_1linalg_1_1SplitReductionResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LowerPackResult.html">LowerPackResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LowerUnPackOpResult.html">LowerUnPackOpResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold the result of a <code>pack</code> call.  <a href="structmlir_1_1linalg_1_1PackResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PackTransposeResult.html">PackTransposeResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold the result of a <code>packTranspose</code> call.  <a href="structmlir_1_1linalg_1_1PackTransposeResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingPattern.html">LinalgPaddingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg padding pattern.  <a href="structmlir_1_1linalg_1_1LinalgPaddingPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DownscaleSizeOneWindowed2DConvolution.html">DownscaleSizeOneWindowed2DConvolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites 2-D convolution ops with size-1 window dimensions into 1-D convolution ops.  <a href="structmlir_1_1linalg_1_1DownscaleSizeOneWindowed2DConvolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DownscaleDepthwiseConv2DNhwcHwcOp.html">DownscaleDepthwiseConv2DNhwcHwcOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites 2-D depthwise convolution ops with size-1 (w, kw) or (h, kh) dimensions into 1-D depthwise convolution ops.  <a href="structmlir_1_1linalg_1_1DownscaleDepthwiseConv2DNhwcHwcOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DownscaleConv2DOp.html">DownscaleConv2DOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgGeneralizationPattern.html">LinalgGeneralizationPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg generalization pattern.  <a href="structmlir_1_1linalg_1_1LinalgGeneralizationPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1CopyVectorizationPattern.html">CopyVectorizationPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorization pattern for memref::CopyOp.  <a href="structmlir_1_1linalg_1_1CopyVectorizationPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PadOpTransformationPattern.html">PadOpTransformationPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tensor::PadOp is not canonicalized away yet, so we provide a transformation to <code>linalg.generic</code>.  <a href="structmlir_1_1linalg_1_1PadOpTransformationPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1GeneralizePadOpPattern.html">GeneralizePadOpPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a tensor::PadOp into a sequence of EmptyOp, FillOp and InsertSliceOp.  <a href="structmlir_1_1linalg_1_1GeneralizePadOpPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1GeneralizeOuterUnitDimsPackOpPattern.html">GeneralizeOuterUnitDimsPackOpPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites a tensor::PackOp into a sequence of tensor.pad + linalg.transpose + tensor.insert_slice ops, where the tensor::PackOp has outer dims being all 1s.  <a href="structmlir_1_1linalg_1_1GeneralizeOuterUnitDimsPackOpPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1GeneralizeOuterUnitDimsUnPackOpPattern.html">GeneralizeOuterUnitDimsUnPackOpPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites a tensor::UnPackOp into a sequence of rank-reduced extract_slice op.  <a href="structmlir_1_1linalg_1_1GeneralizeOuterUnitDimsUnPackOpPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgCopyVTRForwardingPattern.html">LinalgCopyVTRForwardingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match and rewrite for the pattern:  <a href="structmlir_1_1linalg_1_1LinalgCopyVTRForwardingPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgCopyVTWForwardingPattern.html">LinalgCopyVTWForwardingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match and rewrite for the pattern:  <a href="structmlir_1_1linalg_1_1LinalgCopyVTWForwardingPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ExtractSliceOfPadTensorSwapPattern.html">ExtractSliceOfPadTensorSwapPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite extract_slice(tensor.pad(x)) into tensor.pad(extract_slice(x)).  <a href="structmlir_1_1linalg_1_1ExtractSliceOfPadTensorSwapPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1EmbeddedMatmulDimsCandidates.html">EmbeddedMatmulDimsCandidates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible dimension candidates that define a matmul embedded in the indexing maps of a LinalgOp.  <a href="structmlir_1_1linalg_1_1EmbeddedMatmulDimsCandidates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html">SliceParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containg offsets-sizes-strides arguments of the tiled shape.  <a href="structmlir_1_1linalg_1_1SliceParameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing the Linalg producer before and after fusion.  <a href="structmlir_1_1linalg_1_1FusionInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">ProcInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to get processor ID, and number of processors used for distribution for all parallel loops generated.  <a href="structmlir_1_1linalg_1_1ProcInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgLoopDistributionOptions.html">LinalgLoopDistributionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options that allow distribution of loops generated in Linalg transforms to processors while generating the loops.  <a href="structmlir_1_1linalg_1_1LinalgLoopDistributionOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1TileLoopNest.html">TileLoopNest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct to manage the tile loop nest specific information.  <a href="classmlir_1_1linalg_1_1TileLoopNest.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1RegionMatcher.html">RegionMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing common matchers over linalg op's region.  <a href="structmlir_1_1linalg_1_1RegionMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1GenerateLoopNest.html">GenerateLoopNest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class used to generate nested loops with ranges described by <code>loopRanges</code> and loop type described by the <code>iteratorTypes</code>.  <a href="structmlir_1_1linalg_1_1GenerateLoopNest.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a730df0415b8172eb93f8f7b346e04440"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a730df0415b8172eb93f8f7b346e04440">TileSizeComputationFunction</a> = std::function&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td></tr>
<tr class="separator:a730df0415b8172eb93f8f7b346e04440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcbad447f843c9b98886ad6f49469a9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1bcbad447f843c9b98886ad6f49469a9">AllocBufferCallbackFn</a> = std::function&lt; std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, memref::SubViewOp subView, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; boundingSubViewSize, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout)&gt;</td></tr>
<tr class="memdesc:a1bcbad447f843c9b98886ad6f49469a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to perform the allocation for the promoted <code>subView</code>.  <a href="namespacemlir_1_1linalg.html#a1bcbad447f843c9b98886ad6f49469a9">More...</a><br /></td></tr>
<tr class="separator:a1bcbad447f843c9b98886ad6f49469a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7afb284c4be072a74a24eeb71cc985"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3d7afb284c4be072a74a24eeb71cc985">DeallocBufferCallbackFn</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> buffer)&gt;</td></tr>
<tr class="memdesc:a3d7afb284c4be072a74a24eeb71cc985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to deallocate the buffers used to hold the promoted subview.  <a href="namespacemlir_1_1linalg.html#a3d7afb284c4be072a74a24eeb71cc985">More...</a><br /></td></tr>
<tr class="separator:a3d7afb284c4be072a74a24eeb71cc985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49994e2aab61b35167972384684cf24"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa49994e2aab61b35167972384684cf24">CopyCallbackFn</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)&gt;</td></tr>
<tr class="memdesc:aa49994e2aab61b35167972384684cf24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to insert copy from original subview to subview of the promoted region for the read operands/subview of promoted region to original subview for the results.  <a href="namespacemlir_1_1linalg.html#aa49994e2aab61b35167972384684cf24">More...</a><br /></td></tr>
<tr class="separator:aa49994e2aab61b35167972384684cf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16099880d7579f488dd714c6273ea4c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">ControlSplitReductionFn</a> = std::function&lt; <a class="el" href="structmlir_1_1linalg_1_1SplitReductionOptions.html">SplitReductionOptions</a>(LinalgOp op)&gt;</td></tr>
<tr class="memdesc:ad16099880d7579f488dd714c6273ea4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function signature to control reduction splitting.  <a href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">More...</a><br /></td></tr>
<tr class="separator:ad16099880d7579f488dd714c6273ea4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9ca79033211e3e53e0eb25a8e9551b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, 4 &gt;</td></tr>
<tr class="separator:a4a9ca79033211e3e53e0eb25a8e9551b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2363d9b68019db04dbf0c710afe7f224"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a2363d9b68019db04dbf0c710afe7f224">LoopIndexToRangeIndexMap</a> = <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; int, int &gt;</td></tr>
<tr class="memdesc:a2363d9b68019db04dbf0c710afe7f224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a number of ranges equal to the number of non-zero in <code>tileSizes</code>.  <a href="namespacemlir_1_1linalg.html#a2363d9b68019db04dbf0c710afe7f224">More...</a><br /></td></tr>
<tr class="separator:a2363d9b68019db04dbf0c710afe7f224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7326883dfd3172d344f305860482e9ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7326883dfd3172d344f305860482e9ff">OptimizeCopyFn</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;, tensor::PadOp, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td></tr>
<tr class="separator:a7326883dfd3172d344f305860482e9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3115e251fd057529cff9b2d44a0ba1c0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> = std::function&lt; bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand)&gt;</td></tr>
<tr class="memdesc:a3115e251fd057529cff9b2d44a0ba1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type which is used to control when to stop fusion.  <a href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">More...</a><br /></td></tr>
<tr class="separator:a3115e251fd057529cff9b2d44a0ba1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3729e968453a5f63415044c66e5255c5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3729e968453a5f63415044c66e5255c5">ControlPropagationFn</a> = std::function&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)&gt;</td></tr>
<tr class="memdesc:a3729e968453a5f63415044c66e5255c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type which is used to control propagation of tensor.pack/unpack ops.  <a href="namespacemlir_1_1linalg.html#a3729e968453a5f63415044c66e5255c5">More...</a><br /></td></tr>
<tr class="separator:a3729e968453a5f63415044c66e5255c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfcecb6fc18af7e6d462f3a904c73733"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#adfcecb6fc18af7e6d462f3a904c73733">GetCollapsableDimensionsFn</a> = std::function&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt;(linalg::GenericOp)&gt;</td></tr>
<tr class="memdesc:adfcecb6fc18af7e6d462f3a904c73733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type to control generic op dimension collapsing.  <a href="namespacemlir_1_1linalg.html#adfcecb6fc18af7e6d462f3a904c73733">More...</a><br /></td></tr>
<tr class="separator:adfcecb6fc18af7e6d462f3a904c73733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651199aee7abd57b3b297b905d109183"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a651199aee7abd57b3b297b905d109183">ProcInfoCallBackFn</a> = std::function&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">ProcInfo</a> &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; parallelLoopRanges)&gt;</td></tr>
<tr class="separator:a651199aee7abd57b3b297b905d109183"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3cdd229e1459c7e6ed2f9c7ee7168325"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325">LinalgTilingLoopType</a> { <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325a4b2257cb98694284507e77f34e73c2d8">Loops</a> = 0
, <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325a6d8bf0bdeaca5ef4693524bf04c4c877">AffineLoops</a> = 1
, <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325ab92546344b4e3fa9b10c9472795297a7">ParallelLoops</a> = 2
 }</td></tr>
<tr class="memdesc:a3cdd229e1459c7e6ed2f9c7ee7168325"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of loops to be generated during tiling.  <a href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325">More...</a><br /></td></tr>
<tr class="separator:a3cdd229e1459c7e6ed2f9c7ee7168325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7382d59369873eb3a9a9ddd571056982"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982">DistributionMethod</a> { <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982ad71670d62b238eaf063979407361034e">Cyclic</a> = 0
, <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982abab54876ff518ecd2d59b46fd3be9c0e">CyclicNumProcsGeNumIters</a> = 1
, <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982ad93606014b9a6b479ba0e6faa948540b">CyclicNumProcsEqNumIters</a> = 2
, <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982a6adf97f83acf6453d4a6a4b1070f3754">None</a> = 3
 }</td></tr>
<tr class="memdesc:a7382d59369873eb3a9a9ddd571056982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheme used to distribute loops to processors.  <a href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982">More...</a><br /></td></tr>
<tr class="separator:a7382d59369873eb3a9a9ddd571056982"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a703d4f21c6f57b8c680dc20dd6928a61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a703d4f21c6f57b8c680dc20dd6928a61">populateLinalgToStandardConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a703d4f21c6f57b8c680dc20dd6928a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Linalg to Standard.  <a href="namespacemlir_1_1linalg.html#a703d4f21c6f57b8c680dc20dd6928a61">More...</a><br /></td></tr>
<tr class="separator:a703d4f21c6f57b8c680dc20dd6928a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754ec5c5960c640563ddcd9727b77d87"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a754ec5c5960c640563ddcd9727b77d87">generateLibraryCallName</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a754ec5c5960c640563ddcd9727b77d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name mangled library call name to disambiguate between different overloads at the C level.  <a href="namespacemlir_1_1linalg.html#a754ec5c5960c640563ddcd9727b77d87">More...</a><br /></td></tr>
<tr class="separator:a754ec5c5960c640563ddcd9727b77d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962a46fba2ac497e30bb6d23fef35d1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a962a46fba2ac497e30bb6d23fef35d1a">makeAffineDimExprs</a> (unsigned num, unsigned &amp;startIdx, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a962a46fba2ac497e30bb6d23fef35d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>num</code> <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> dimensions at positions [startIdx, startIdx + num) and increments <code>startIdx</code> to <code>startIdx + num</code>.  <a href="namespacemlir_1_1linalg.html#a962a46fba2ac497e30bb6d23fef35d1a">More...</a><br /></td></tr>
<tr class="separator:a962a46fba2ac497e30bb6d23fef35d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956959faad992424aaa215510e50e618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a956959faad992424aaa215510e50e618">extractOrIdentityMap</a> (std::optional&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maybeMap, unsigned rank, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a956959faad992424aaa215510e50e618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code><a class="el" href="namespacemlir.html#ab4871db68c59a176135e0e35a3625e73" title="Helper method that injects context only if needed, this helps unify some of the attribute constructio...">maybeMap.get()</a></code> if <code>maybeMap</code> is set, otherwise returns the symbol-less identity map of <code>rank</code>.  <a href="namespacemlir_1_1linalg.html#a956959faad992424aaa215510e50e618">More...</a><br /></td></tr>
<tr class="separator:a956959faad992424aaa215510e50e618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8ea0aae80d24eeffa3fef8f1f08c43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4f8ea0aae80d24eeffa3fef8f1f08c43">concat</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; a, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; b)</td></tr>
<tr class="memdesc:a4f8ea0aae80d24eeffa3fef8f1f08c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector that is the concatenation of <code>a</code> and <code>b</code>.  <a href="namespacemlir_1_1linalg.html#a4f8ea0aae80d24eeffa3fef8f1f08c43">More...</a><br /></td></tr>
<tr class="separator:a4f8ea0aae80d24eeffa3fef8f1f08c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5277093c168682f123f1e99d90461f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab5277093c168682f123f1e99d90461f0">isaContractionOpInterface</a> (LinalgOp linalgOp)</td></tr>
<tr class="memdesc:ab5277093c168682f123f1e99d90461f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>linalgOp</code> conforms to ContractionOpInterface.  <a href="namespacemlir_1_1linalg.html#ab5277093c168682f123f1e99d90461f0">More...</a><br /></td></tr>
<tr class="separator:ab5277093c168682f123f1e99d90461f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e756b2e152d167af6823f8fb6298933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5e756b2e152d167af6823f8fb6298933">registerValueBoundsOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a5e756b2e152d167af6823f8fb6298933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac2b4190e764bf1951b6e077e2e7ce6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0ac2b4190e764bf1951b6e077e2e7ce6">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a0ac2b4190e764bf1951b6e077e2e7ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab570ed1db81a641eb5b3d9948775e517"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab570ed1db81a641eb5b3d9948775e517">registerBufferizableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:ab570ed1db81a641eb5b3d9948775e517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869b2d2412244532c263f6ee009677a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a869b2d2412244532c263f6ee009677a5">hoistRedundantVectorTransfers</a> (func::FuncOp func)</td></tr>
<tr class="memdesc:a869b2d2412244532c263f6ee009677a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoist vector.transfer_read/vector.transfer_write on buffers pairs out of immediately enclosing scf::ForOp iteratively, if the following conditions are true:  <a href="namespacemlir_1_1linalg.html#a869b2d2412244532c263f6ee009677a5">More...</a><br /></td></tr>
<tr class="separator:a869b2d2412244532c263f6ee009677a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3881d7e28d54f38fef29eae672d322"><td class="memItemLeft" align="right" valign="top">scf::ForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7e3881d7e28d54f38fef29eae672d322">hoistRedundantSubsetExtractInsert</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, scf::ForOp forOp)</td></tr>
<tr class="memdesc:a7e3881d7e28d54f38fef29eae672d322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greedily hoist redundant subset extract/insert operations on tensors outside of <code>forOp</code>.  <a href="namespacemlir_1_1linalg.html#a7e3881d7e28d54f38fef29eae672d322">More...</a><br /></td></tr>
<tr class="separator:a7e3881d7e28d54f38fef29eae672d322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15d4eeea23d8e587288af4d3af05583"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae15d4eeea23d8e587288af4d3af05583">hoistRedundantVectorTransfersOnTensor</a> (func::FuncOp func)</td></tr>
<tr class="memdesc:ae15d4eeea23d8e587288af4d3af05583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call into <code>hoistRedundantSubsetInsertExtract</code> without a <a class="el" href="classmlir_1_1RewriterBase.html" title="This class coordinates the application of a rewrite on a set of IR, providing a way for clients to tr...">RewriterBase</a>.  <a href="namespacemlir_1_1linalg.html#ae15d4eeea23d8e587288af4d3af05583">More...</a><br /></td></tr>
<tr class="separator:ae15d4eeea23d8e587288af4d3af05583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae430d8314310084f3bfae3c0de4081dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae430d8314310084f3bfae3c0de4081dd">registerTilingInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:ae430d8314310084f3bfae3c0de4081dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27267a4634c46beba8c9f55c14cdfa1"><td class="memItemLeft" align="right" valign="top">std::optional&lt; vector::CombiningKind &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae27267a4634c46beba8c9f55c14cdfa1">getCombinerOpKind</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *combinerOp)</td></tr>
<tr class="memdesc:ae27267a4634c46beba8c9f55c14cdfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return vector::CombiningKind for the given op.  <a href="namespacemlir_1_1linalg.html#ae27267a4634c46beba8c9f55c14cdfa1">More...</a><br /></td></tr>
<tr class="separator:ae27267a4634c46beba8c9f55c14cdfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa220da60546acce7c4a8b3635d5b21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8fa220da60546acce7c4a8b3635d5b21">areElementwiseOpsFusable</a> (<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand)</td></tr>
<tr class="memdesc:a8fa220da60546acce7c4a8b3635d5b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if two <code>linalg.generic</code> operations with producer/consumer relationship through <code>fusedOperand</code> can be fused using elementwise op fusion.  <a href="namespacemlir_1_1linalg.html#a8fa220da60546acce7c4a8b3635d5b21">More...</a><br /></td></tr>
<tr class="separator:a8fa220da60546acce7c4a8b3635d5b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850b9fd11404efe17bca02011aff2e88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a850b9fd11404efe17bca02011aff2e88">promoteSubviewsPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a850b9fd11404efe17bca02011aff2e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote memref.subviews feeding linalg-on-buffers operations.  <a href="namespacemlir_1_1linalg.html#a850b9fd11404efe17bca02011aff2e88">More...</a><br /></td></tr>
<tr class="separator:a850b9fd11404efe17bca02011aff2e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76247db28f1352895996e7346a2084d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a76247db28f1352895996e7346a2084d2">vectorizeLinalgOpPrecondition</a> (LinalgOp linalgOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inputVectorSizes={}, bool vectorizeNDExtract=false)</td></tr>
<tr class="memdesc:a76247db28f1352895996e7346a2084d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return success if the operation can be vectorized.  <a href="namespacemlir_1_1linalg.html#a76247db28f1352895996e7346a2084d2">More...</a><br /></td></tr>
<tr class="separator:a76247db28f1352895996e7346a2084d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af200f0e047b9365a24c21b1cc6d1a8d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af200f0e047b9365a24c21b1cc6d1a8d2">bufferizeToAllocation</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::PadOp padOp, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={})</td></tr>
<tr class="memdesc:af200f0e047b9365a24c21b1cc6d1a8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize a buffer allocation for the given tensor.pad op and lower the op to linalg.fill/linalg.generic + memref.tensor_store.  <a href="namespacemlir_1_1linalg.html#af200f0e047b9365a24c21b1cc6d1a8d2">More...</a><br /></td></tr>
<tr class="separator:af200f0e047b9365a24c21b1cc6d1a8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c571913d792aae43a0a97cdb824d042"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8c571913d792aae43a0a97cdb824d042">bufferizeToAllocation</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={})</td></tr>
<tr class="memdesc:a8c571913d792aae43a0a97cdb824d042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize a buffer allocation for the given tensor value.  <a href="namespacemlir_1_1linalg.html#a8c571913d792aae43a0a97cdb824d042">More...</a><br /></td></tr>
<tr class="separator:a8c571913d792aae43a0a97cdb824d042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ceec493e0b40673125a0402c3cf78e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1ElementwiseOpFusionResult.html">ElementwiseOpFusionResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4ceec493e0b40673125a0402c3cf78e4">fuseElementwiseOps</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand)</td></tr>
<tr class="separator:a4ceec493e0b40673125a0402c3cf78e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae273bd1d7e48f4503eefba4f1487fa56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae273bd1d7e48f4503eefba4f1487fa56">peelLoop</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ae273bd1d7e48f4503eefba4f1487fa56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to peel and canonicalize loop <code>op</code> and return the new result.  <a href="namespacemlir_1_1linalg.html#ae273bd1d7e48f4503eefba4f1487fa56">More...</a><br /></td></tr>
<tr class="separator:ae273bd1d7e48f4503eefba4f1487fa56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5faa18744febf8ff36b38176ca04d8fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5faa18744febf8ff36b38176ca04d8fc">peelLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt; loops)</td></tr>
<tr class="memdesc:a5faa18744febf8ff36b38176ca04d8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peel 'loops' and applies affine_min/max bounds simplification on the fly where relevant.  <a href="namespacemlir_1_1linalg.html#a5faa18744febf8ff36b38176ca04d8fc">More...</a><br /></td></tr>
<tr class="separator:a5faa18744febf8ff36b38176ca04d8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724e74361e155d68bd8690902548e91a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a724e74361e155d68bd8690902548e91a">rewriteAsPaddedOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp opToPad, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; paddingDimensions, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; paddingValues, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt; packPaddings, LinalgOp &amp;paddedOp)</td></tr>
<tr class="memdesc:a724e74361e155d68bd8690902548e91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad the iterator dimensions <code>paddingDimensions</code> of all <code>opToPad</code> operands to a static bounding box.  <a href="namespacemlir_1_1linalg.html#a724e74361e155d68bd8690902548e91a">More...</a><br /></td></tr>
<tr class="separator:a724e74361e155d68bd8690902548e91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75511cb041f22d05a9abde75e8001677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a75511cb041f22d05a9abde75e8001677">hoistPaddingOnTensors</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::PadOp opToHoist, int64_t numLoops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; transposeVector, tensor::PadOp &amp;hoistedOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; GenericOp &gt; &amp;transposeOps)</td></tr>
<tr class="memdesc:a75511cb041f22d05a9abde75e8001677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mechanically hoist padding operations on tensors by <code>numLoops</code> into a new, generally larger tensor.  <a href="namespacemlir_1_1linalg.html#a75511cb041f22d05a9abde75e8001677">More...</a><br /></td></tr>
<tr class="separator:a75511cb041f22d05a9abde75e8001677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada17eefc3ffa4987b6b56afccb94022"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aada17eefc3ffa4987b6b56afccb94022">hoistPaddingOnTensors</a> (tensor::PadOp opToHoist, int64_t numLoops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; transposeVector, tensor::PadOp &amp;hoistedOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; GenericOp &gt; &amp;transposeOps)</td></tr>
<tr class="memdesc:aada17eefc3ffa4987b6b56afccb94022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls into <code>hoistPaddingOnTensors</code> with a local <a class="el" href="classmlir_1_1IRRewriter.html" title="This class coordinates rewriting a piece of IR outside of a pattern rewrite, providing a way to keep ...">IRRewriter</a>.  <a href="namespacemlir_1_1linalg.html#aada17eefc3ffa4987b6b56afccb94022">More...</a><br /></td></tr>
<tr class="separator:aada17eefc3ffa4987b6b56afccb94022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c1ec48c56c585df31bf47f8a19c341"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; LinalgOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac8c1ec48c56c585df31bf47f8a19c341">padAndHoistLinalgOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp, <a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">LinalgPaddingOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:ac8c1ec48c56c585df31bf47f8a19c341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply padding and hoisting to <code>linalgOp</code> according to the configuration specified in <code>options</code>.  <a href="namespacemlir_1_1linalg.html#ac8c1ec48c56c585df31bf47f8a19c341">More...</a><br /></td></tr>
<tr class="separator:ac8c1ec48c56c585df31bf47f8a19c341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af025e45095e64f984901c4f65fa3c72f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; TilingInterface, TilingInterface &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af025e45095e64f984901c4f65fa3c72f">splitOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface op, unsigned dimension, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> splitPoint)</td></tr>
<tr class="memdesc:af025e45095e64f984901c4f65fa3c72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given <code>op</code> into two parts along the given iteration space <code>dimension</code> at the specified <code>splitPoint</code>, and return the two parts.  <a href="namespacemlir_1_1linalg.html#af025e45095e64f984901c4f65fa3c72f">More...</a><br /></td></tr>
<tr class="separator:af025e45095e64f984901c4f65fa3c72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13050e75a64a26bf82a80b19006d0e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac13050e75a64a26bf82a80b19006d0e9">tileLinalgOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, LinalgOp op, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="separator:ac13050e75a64a26bf82a80b19006d0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcc62e199cdb1863a3d6f30e4dc317a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; GenericOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8dcc62e199cdb1863a3d6f30e4dc317a">interchangeGenericOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, GenericOp genericOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt; interchangeVector)</td></tr>
<tr class="memdesc:a8dcc62e199cdb1863a3d6f30e4dc317a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interchange the <code>iterator_types</code> and <code>iterator_maps</code> dimensions and adapts the index accesses of <code>op</code>.  <a href="namespacemlir_1_1linalg.html#a8dcc62e199cdb1863a3d6f30e4dc317a">More...</a><br /></td></tr>
<tr class="separator:a8dcc62e199cdb1863a3d6f30e4dc317a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f75a142d34f0b8ab6db239fc7de6cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; GenericOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a06f75a142d34f0b8ab6db239fc7de6cb">generalizeNamedOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp namedOp)</td></tr>
<tr class="memdesc:a06f75a142d34f0b8ab6db239fc7de6cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a GenericOp from the given named operation <code>namedOp</code> and replace namedOp.  <a href="namespacemlir_1_1linalg.html#a06f75a142d34f0b8ab6db239fc7de6cb">More...</a><br /></td></tr>
<tr class="separator:a06f75a142d34f0b8ab6db239fc7de6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52323b7c688e08d502b988597580fd37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">PromotionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a52323b7c688e08d502b988597580fd37">promoteSubviewAsNewBuffer</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, memref::SubViewOp subView, const <a class="el" href="namespacemlir_1_1linalg.html#a1bcbad447f843c9b98886ad6f49469a9">AllocBufferCallbackFn</a> &amp;allocationFn, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout)</td></tr>
<tr class="separator:a52323b7c688e08d502b988597580fd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd639dc165f0ab64ec7afbac992c4d65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; LinalgOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#acd639dc165f0ab64ec7afbac992c4d65">promoteSubViews</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp op, const <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:acd639dc165f0ab64ec7afbac992c4d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote the <code>subViews</code> into a new buffer allocated at the insertion point <code>b</code>.  <a href="namespacemlir_1_1linalg.html#acd639dc165f0ab64ec7afbac992c4d65">More...</a><br /></td></tr>
<tr class="separator:acd639dc165f0ab64ec7afbac992c4d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266200755192d09deb827c799e59277b"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a266200755192d09deb827c799e59277b">allocateWorkgroupMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, memref::SubViewOp subview, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizeBounds, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;)</td></tr>
<tr class="memdesc:a266200755192d09deb827c799e59277b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the subview in the GPU workgroup memory.  <a href="namespacemlir_1_1linalg.html#a266200755192d09deb827c799e59277b">More...</a><br /></td></tr>
<tr class="separator:a266200755192d09deb827c799e59277b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6babd80190e8df26f441fca7d2fbe31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad6babd80190e8df26f441fca7d2fbe31">deallocateWorkgroupMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Value.html">Value</a>)</td></tr>
<tr class="memdesc:ad6babd80190e8df26f441fca7d2fbe31"><td class="mdescLeft">&#160;</td><td class="mdescRight">In case of GPU group memory there is no need to deallocate.  <a href="namespacemlir_1_1linalg.html#ad6babd80190e8df26f441fca7d2fbe31">More...</a><br /></td></tr>
<tr class="separator:ad6babd80190e8df26f441fca7d2fbe31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fb3984f986840e0dc914c1ab90dc3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a72fb3984f986840e0dc914c1ab90dc3b">copyToWorkgroupMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)</td></tr>
<tr class="memdesc:a72fb3984f986840e0dc914c1ab90dc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Memref copy operations and add gpu barrier guards before and after the copy operation to ensure data integrity.  <a href="namespacemlir_1_1linalg.html#a72fb3984f986840e0dc914c1ab90dc3b">More...</a><br /></td></tr>
<tr class="separator:a72fb3984f986840e0dc914c1ab90dc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5606dfca8a9078fc6bc9b74972f15fdc"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5606dfca8a9078fc6bc9b74972f15fdc">allocateGPUPrivateMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, memref::SubViewOp subview, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizeBounds, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;)</td></tr>
<tr class="memdesc:a5606dfca8a9078fc6bc9b74972f15fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the subview in the GPU private memory.  <a href="namespacemlir_1_1linalg.html#a5606dfca8a9078fc6bc9b74972f15fdc">More...</a><br /></td></tr>
<tr class="separator:a5606dfca8a9078fc6bc9b74972f15fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88359f69353831d971485ff6b6b86dc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a88359f69353831d971485ff6b6b86dc1">copyToGPUPrivateMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)</td></tr>
<tr class="memdesc:a88359f69353831d971485ff6b6b86dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal copy to between src and dst.  <a href="namespacemlir_1_1linalg.html#a88359f69353831d971485ff6b6b86dc1">More...</a><br /></td></tr>
<tr class="separator:a88359f69353831d971485ff6b6b86dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487d4430e8217b1dabc50cb28bb93342"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a487d4430e8217b1dabc50cb28bb93342">deallocateGPUPrivateMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Value.html">Value</a>)</td></tr>
<tr class="memdesc:a487d4430e8217b1dabc50cb28bb93342"><td class="mdescLeft">&#160;</td><td class="mdescRight">In case of GPU private memory there is no need to deallocate since the memory is freed when going outside of the scope.  <a href="namespacemlir_1_1linalg.html#a487d4430e8217b1dabc50cb28bb93342">More...</a><br /></td></tr>
<tr class="separator:a487d4430e8217b1dabc50cb28bb93342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31275f732e5575c158fb570eba1208c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a31275f732e5575c158fb570eba1208c8">vectorize</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inputVectorSizes={}, bool vectorizeNDExtract=false)</td></tr>
<tr class="memdesc:a31275f732e5575c158fb570eba1208c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a suitable vector form for a Linalg op.  <a href="namespacemlir_1_1linalg.html#a31275f732e5575c158fb570eba1208c8">More...</a><br /></td></tr>
<tr class="separator:a31275f732e5575c158fb570eba1208c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c63bc9239511b70751c238a12f5b1da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8c63bc9239511b70751c238a12f5b1da">vectorizeCopy</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;builder, memref::CopyOp copyOp)</td></tr>
<tr class="memdesc:a8c63bc9239511b70751c238a12f5b1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a suitable vector form for a Copy op with fully static shape.  <a href="namespacemlir_1_1linalg.html#a8c63bc9239511b70751c238a12f5b1da">More...</a><br /></td></tr>
<tr class="separator:a8c63bc9239511b70751c238a12f5b1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb02fa2fc529a0f22670a3d3b7972cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; vector::TransferWriteOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1eb02fa2fc529a0f22670a3d3b7972cc">maskedVectorize</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::PadOp padOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inputVectorSizes)</td></tr>
<tr class="memdesc:a1eb02fa2fc529a0f22670a3d3b7972cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorize a <code>padOp</code> with (1) static result type, (2) constant padding value and (3) all-zero lowPad to <code>transfer_write_in_bounds(transfer_read_masked(pad_source, pad_value))</code>.  <a href="namespacemlir_1_1linalg.html#a1eb02fa2fc529a0f22670a3d3b7972cc">More...</a><br /></td></tr>
<tr class="separator:a1eb02fa2fc529a0f22670a3d3b7972cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edd4be30bfb8af9bc8e486f8368c1e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7edd4be30bfb8af9bc8e486f8368c1e2">linalgOpToLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a7edd4be30bfb8af9bc8e486f8368c1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a loop nest of <code>scf.for</code> with the proper body for <code>linalgOp</code>.  <a href="namespacemlir_1_1linalg.html#a7edd4be30bfb8af9bc8e486f8368c1e2">More...</a><br /></td></tr>
<tr class="separator:a7edd4be30bfb8af9bc8e486f8368c1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff809877c1d119dae06d06a8bad953e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aff809877c1d119dae06d06a8bad953e4">linalgOpToParallelLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:aff809877c1d119dae06d06a8bad953e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a loop nest of <code>scf.parallel</code> with the proper body for <code>linalgOp</code>.  <a href="namespacemlir_1_1linalg.html#aff809877c1d119dae06d06a8bad953e4">More...</a><br /></td></tr>
<tr class="separator:aff809877c1d119dae06d06a8bad953e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f289e066dcbb7844bd444c0880fc36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a95f289e066dcbb7844bd444c0880fc36">linalgOpToAffineLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a95f289e066dcbb7844bd444c0880fc36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a loop nest of <code>affine.for</code> with the proper body for <code>linalgOp</code>.  <a href="namespacemlir_1_1linalg.html#a95f289e066dcbb7844bd444c0880fc36">More...</a><br /></td></tr>
<tr class="separator:a95f289e066dcbb7844bd444c0880fc36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8144efefcad502e511c24aa5ce5b36e8"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a>, 4 &gt;, <a class="el" href="namespacemlir_1_1linalg.html#a2363d9b68019db04dbf0c710afe7f224">LoopIndexToRangeIndexMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8144efefcad502e511c24aa5ce5b36e8">makeTiledLoopRanges</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; allShapeSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; allTileSizes)</td></tr>
<tr class="separator:a8144efefcad502e511c24aa5ce5b36e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ef5fd09c3c79a47b8c4732ace79928"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1MultiSizeSpecification.html">MultiSizeSpecification</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af8ef5fd09c3c79a47b8c4732ace79928">computeMultiTileSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, LinalgOp op, unsigned dimension, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> targetSize, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> divisor, bool emitAssertions=true)</td></tr>
<tr class="memdesc:af8ef5fd09c3c79a47b8c4732ace79928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits the IR computing the multi-sized tiling specification with two tile sizes not exceeding <code>targetSize</code>, each divisible by <code>sizeDivisor</code>, such that there exist numbers of tiles with these sizes that fully cover the given iteration space <code>dimension</code> of the structured <code>op</code>.  <a href="namespacemlir_1_1linalg.html#af8ef5fd09c3c79a47b8c4732ace79928">More...</a><br /></td></tr>
<tr class="separator:af8ef5fd09c3c79a47b8c4732ace79928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c1fb37672289a396df9c95a9b1dd0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1StaticMultiSizeSpecification.html">StaticMultiSizeSpecification</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a91c1fb37672289a396df9c95a9b1dd0b">computeStaticMultiTileSizes</a> (LinalgOp op, unsigned dimension, int64_t targetSize, int64_t divisor)</td></tr>
<tr class="separator:a91c1fb37672289a396df9c95a9b1dd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681abb3bd7d080168a988832f5c35f11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1ForallTilingResult.html">ForallTilingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a681abb3bd7d080168a988832f5c35f11">tileToForallOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;builder, TilingInterface op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads, std::optional&lt; ArrayAttr &gt; mapping)</td></tr>
<tr class="separator:a681abb3bd7d080168a988832f5c35f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150f6416a97acbe486aaaf69cf12c104"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1ForallTilingResult.html">ForallTilingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a150f6416a97acbe486aaaf69cf12c104">tileToForallOpUsingTileSizes</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;builder, TilingInterface op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, std::optional&lt; ArrayAttr &gt; mapping)</td></tr>
<tr class="memdesc:a150f6416a97acbe486aaaf69cf12c104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>tileToForallOp</code>, but calculate the number of threads required using the given tileSizes.  <a href="namespacemlir_1_1linalg.html#a150f6416a97acbe486aaaf69cf12c104">More...</a><br /></td></tr>
<tr class="separator:a150f6416a97acbe486aaaf69cf12c104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3085a8dbbf3c572b3279bdcc53dbe72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1ForallReductionTilingResult.html">ForallReductionTilingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab3085a8dbbf3c572b3279bdcc53dbe72">tileReductionUsingForall</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, PartialReductionOpInterface op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes={}, std::optional&lt; ArrayAttr &gt; mapping=std::nullopt)</td></tr>
<tr class="memdesc:ab3085a8dbbf3c572b3279bdcc53dbe72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to tile a reduction to parallel iterations computing partial reductions.  <a href="namespacemlir_1_1linalg.html#ab3085a8dbbf3c572b3279bdcc53dbe72">More...</a><br /></td></tr>
<tr class="separator:ab3085a8dbbf3c572b3279bdcc53dbe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2368f6f815597fcf395106e8978e44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1b2368f6f815597fcf395106e8978e44">transformIndexOps</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, LinalgOp op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;ivs, const <a class="el" href="namespacemlir_1_1linalg.html#a2363d9b68019db04dbf0c710afe7f224">LoopIndexToRangeIndexMap</a> &amp;loopIndexToRangeIndex)</td></tr>
<tr class="memdesc:a1b2368f6f815597fcf395106e8978e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">All indices returned by IndexOp should be invariant with respect to tiling.  <a href="namespacemlir_1_1linalg.html#a1b2368f6f815597fcf395106e8978e44">More...</a><br /></td></tr>
<tr class="separator:a1b2368f6f815597fcf395106e8978e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4f58f6a18fb7c9af60fb15122e0994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1SplitReductionResult.html">SplitReductionResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aaa4f58f6a18fb7c9af60fb15122e0994">splitReduction</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, LinalgOp op, const <a class="el" href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">ControlSplitReductionFn</a> &amp;controlSplitReductionFn, bool useAlloc=false)</td></tr>
<tr class="separator:aaa4f58f6a18fb7c9af60fb15122e0994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87c3f5c965b8e271579136775d51ffc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1SplitReductionResult.html">SplitReductionResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af87c3f5c965b8e271579136775d51ffc">splitReductionByScaling</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, LinalgOp op, const <a class="el" href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">ControlSplitReductionFn</a> &amp;controlSplitReductionFn, bool useAlloc=false)</td></tr>
<tr class="memdesc:af87c3f5c965b8e271579136775d51ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling-based implementation of the split reduction transformation.  <a href="namespacemlir_1_1linalg.html#af87c3f5c965b8e271579136775d51ffc">More...</a><br /></td></tr>
<tr class="separator:af87c3f5c965b8e271579136775d51ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b48a1ef778b1a379cbc6191e5c6d96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a67b48a1ef778b1a379cbc6191e5c6d96">collapseGenericOpIterationDims</a> (GenericOp genericOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; foldedIterationDims, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter)</td></tr>
<tr class="memdesc:a67b48a1ef778b1a379cbc6191e5c6d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapses dimensions of linalg.generic operation.  <a href="namespacemlir_1_1linalg.html#a67b48a1ef778b1a379cbc6191e5c6d96">More...</a><br /></td></tr>
<tr class="separator:a67b48a1ef778b1a379cbc6191e5c6d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6161e899e8e77c1f29b4b7d7751dbac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1LowerPackResult.html">LowerPackResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac6161e899e8e77c1f29b4b7d7751dbac">lowerPack</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::PackOp packOp)</td></tr>
<tr class="memdesc:ac6161e899e8e77c1f29b4b7d7751dbac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite pack as pad + reshape + transpose.  <a href="namespacemlir_1_1linalg.html#ac6161e899e8e77c1f29b4b7d7751dbac">More...</a><br /></td></tr>
<tr class="separator:ac6161e899e8e77c1f29b4b7d7751dbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1646364e16a4592a25500238dec29ab5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1LowerUnPackOpResult.html">LowerUnPackOpResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1646364e16a4592a25500238dec29ab5">lowerUnPack</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::UnPackOp unPackOp)</td></tr>
<tr class="memdesc:a1646364e16a4592a25500238dec29ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite pack as empty + transpose + reshape + extract_slice.  <a href="namespacemlir_1_1linalg.html#a1646364e16a4592a25500238dec29ab5">More...</a><br /></td></tr>
<tr class="separator:a1646364e16a4592a25500238dec29ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd29d6299d2891ae1d092974bc1c4e30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30">pack</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::LinalgOp linalgOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; packedSizes)</td></tr>
<tr class="memdesc:abd29d6299d2891ae1d092974bc1c4e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement packing of a single LinalgOp by <code>packedSizes</code>.  <a href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30">More...</a><br /></td></tr>
<tr class="separator:abd29d6299d2891ae1d092974bc1c4e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb917cff90a2d440ccad06d225fa26a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1PackTransposeResult.html">PackTransposeResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aedb917cff90a2d440ccad06d225fa26a">packTranspose</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::PackOp packOp, linalg::LinalgOp linalgOp, tensor::UnPackOp maybeUnPackOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; outerPerm, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; innerPerm)</td></tr>
<tr class="memdesc:aedb917cff90a2d440ccad06d225fa26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose a single PackOp -&gt; LinalgOp -&gt; UnPackOp chain and return the transposed PackOp -&gt; LinalgOp -&gt; UnPackOp chain after replacements.  <a href="namespacemlir_1_1linalg.html#aedb917cff90a2d440ccad06d225fa26a">More...</a><br /></td></tr>
<tr class="separator:aedb917cff90a2d440ccad06d225fa26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a579fdd0e468c7aec96f84d016c829e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5a579fdd0e468c7aec96f84d016c829e">rewriteInDestinationPassingStyle</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::FromElementsOp fromElementsOp)</td></tr>
<tr class="memdesc:a5a579fdd0e468c7aec96f84d016c829e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite tensor.from_elements to linalg.generic.  <a href="namespacemlir_1_1linalg.html#a5a579fdd0e468c7aec96f84d016c829e">More...</a><br /></td></tr>
<tr class="separator:a5a579fdd0e468c7aec96f84d016c829e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e500c4bf906d65572af9b3d2982852"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab2e500c4bf906d65572af9b3d2982852">rewriteInDestinationPassingStyle</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::GenerateOp generateOp)</td></tr>
<tr class="memdesc:ab2e500c4bf906d65572af9b3d2982852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite tensor.generate to linalg.generic.  <a href="namespacemlir_1_1linalg.html#ab2e500c4bf906d65572af9b3d2982852">More...</a><br /></td></tr>
<tr class="separator:ab2e500c4bf906d65572af9b3d2982852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3e743297fd7a20a30c7c4e39608fbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#acf3e743297fd7a20a30c7c4e39608fbc">rewriteInDestinationPassingStyle</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::PadOp padOp)</td></tr>
<tr class="memdesc:acf3e743297fd7a20a30c7c4e39608fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite tensor.pad to linalg.generic + tensor.insert_slice.  <a href="namespacemlir_1_1linalg.html#acf3e743297fd7a20a30c7c4e39608fbc">More...</a><br /></td></tr>
<tr class="separator:acf3e743297fd7a20a30c7c4e39608fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2c1f265ce47a53398eab6e8f18b30c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0e2c1f265ce47a53398eab6e8f18b30c">rewriteInIm2Col</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNhwcHwcfOp convOp)</td></tr>
<tr class="memdesc:a0e2c1f265ce47a53398eab6e8f18b30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert linalg.conv_2d_nhwc_hwcf into linalg.generic (for img2col packing) and linalg.matmul.  <a href="namespacemlir_1_1linalg.html#a0e2c1f265ce47a53398eab6e8f18b30c">More...</a><br /></td></tr>
<tr class="separator:a0e2c1f265ce47a53398eab6e8f18b30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f61511bb9ed963c3eeb360bfdb1a6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a49f61511bb9ed963c3eeb360bfdb1a6a">rewriteInIm2Col</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::DepthwiseConv2DNhwcHwcOp convOp)</td></tr>
<tr class="memdesc:a49f61511bb9ed963c3eeb360bfdb1a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to rewriteInIm2Col with linalg::Conv2DNhwcHwcfOp except there is no reduction among the input channels so each convolution can be a matrix-vector product and by transposing both input filter so channels are outer most the computation is a batched matrix-vector product.  <a href="namespacemlir_1_1linalg.html#a49f61511bb9ed963c3eeb360bfdb1a6a">More...</a><br /></td></tr>
<tr class="separator:a49f61511bb9ed963c3eeb360bfdb1a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43dfb86d76bed86ecd1117849e5b6f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad43dfb86d76bed86ecd1117849e5b6f4">rewriteInIm2Col</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNchwFchwOp convOp)</td></tr>
<tr class="memdesc:ad43dfb86d76bed86ecd1117849e5b6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to rewriteInIm2Col with linalg::Conv2DNhwcHwcfOp except because the channels are to the left of the image shape dimensions, the position of the contraction dimension in the resulting matmul is reversed.  <a href="namespacemlir_1_1linalg.html#ad43dfb86d76bed86ecd1117849e5b6f4">More...</a><br /></td></tr>
<tr class="separator:ad43dfb86d76bed86ecd1117849e5b6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61503376ad6b88f0c35f8ce358dbc9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae61503376ad6b88f0c35f8ce358dbc9e">getLinalgTilingCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:ae61503376ad6b88f0c35f8ce358dbc9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalization patterns relevant to apply after tiling patterns.  <a href="namespacemlir_1_1linalg.html#ae61503376ad6b88f0c35f8ce358dbc9e">More...</a><br /></td></tr>
<tr class="separator:ae61503376ad6b88f0c35f8ce358dbc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4701ad0fa2e34da0089a80135935f02e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4701ad0fa2e34da0089a80135935f02e">populateLinalgTilingCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a4701ad0fa2e34da0089a80135935f02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9bb5c9c8ef1aadbbc563431443b5e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ada9bb5c9c8ef1aadbbc563431443b5e2">populateLinalgNamedOpsGeneralizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ada9bb5c9c8ef1aadbbc563431443b5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg generalization patterns.  <a href="namespacemlir_1_1linalg.html#ada9bb5c9c8ef1aadbbc563431443b5e2">More...</a><br /></td></tr>
<tr class="separator:ada9bb5c9c8ef1aadbbc563431443b5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887c3b461640ae2783747a1c89726203"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a887c3b461640ae2783747a1c89726203">populateDecomposeConvolutionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a887c3b461640ae2783747a1c89726203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg decompose convolutions patterns.  <a href="namespacemlir_1_1linalg.html#a887c3b461640ae2783747a1c89726203">More...</a><br /></td></tr>
<tr class="separator:a887c3b461640ae2783747a1c89726203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e349c4f7a13b98a31f89dec948c5533"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1e349c4f7a13b98a31f89dec948c5533">populateConvertConv2DToImg2ColPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a1e349c4f7a13b98a31f89dec948c5533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns to transform linalg.conv_2d_xxx operations into linalg.generic (for img2col packing) and linalg.matmul.  <a href="namespacemlir_1_1linalg.html#a1e349c4f7a13b98a31f89dec948c5533">More...</a><br /></td></tr>
<tr class="separator:a1e349c4f7a13b98a31f89dec948c5533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e855c782e575c2b31e13e7d36b22390"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a9e855c782e575c2b31e13e7d36b22390">populatePadTensorTilingPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="separator:a9e855c782e575c2b31e13e7d36b22390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c2ef8a778a33a17885475c11b50bdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a43c2ef8a778a33a17885475c11b50bdd">populatePadOpVectorizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> baseBenefit=1)</td></tr>
<tr class="memdesc:a43c2ef8a778a33a17885475c11b50bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns that vectorize tensor.pad.  <a href="namespacemlir_1_1linalg.html#a43c2ef8a778a33a17885475c11b50bdd">More...</a><br /></td></tr>
<tr class="separator:a43c2ef8a778a33a17885475c11b50bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91bb4884dcdcdd946fbc19b8a313482"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af91bb4884dcdcdd946fbc19b8a313482">populateExtractOpVectorizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> baseBenefit=1)</td></tr>
<tr class="separator:af91bb4884dcdcdd946fbc19b8a313482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6f59ca20a1e8ce21c3c29916aec917"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aad6f59ca20a1e8ce21c3c29916aec917">populateDecomposeLinalgOpsPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool removeDeadArgsAndResults=true)</td></tr>
<tr class="memdesc:aad6f59ca20a1e8ce21c3c29916aec917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns for splitting a <code>LinalgOp</code> with multiple statements within its payload into multiple <code>GenericOp</code> that have a single statement.  <a href="namespacemlir_1_1linalg.html#aad6f59ca20a1e8ce21c3c29916aec917">More...</a><br /></td></tr>
<tr class="separator:aad6f59ca20a1e8ce21c3c29916aec917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f8e903a075470f95fa853892083469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a68f8e903a075470f95fa853892083469">populateConvertToDestinationStylePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a68f8e903a075470f95fa853892083469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that convert non-destination-style ops to destination style ops.  <a href="namespacemlir_1_1linalg.html#a68f8e903a075470f95fa853892083469">More...</a><br /></td></tr>
<tr class="separator:a68f8e903a075470f95fa853892083469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891b8f2d145dcc3327ba55c7a49d44e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a891b8f2d145dcc3327ba55c7a49d44e4">populateConvolutionVectorizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a891b8f2d145dcc3327ba55c7a49d44e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns for vectorizing low-D convolution ops.  <a href="namespacemlir_1_1linalg.html#a891b8f2d145dcc3327ba55c7a49d44e4">More...</a><br /></td></tr>
<tr class="separator:a891b8f2d145dcc3327ba55c7a49d44e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a49133ef595966377878adc42196f47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7a49133ef595966377878adc42196f47">populateElementwiseToLinalgConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a7a49133ef595966377878adc42196f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that convert <code>ElementwiseMappable</code> ops to linalg parallel loops.  <a href="namespacemlir_1_1linalg.html#a7a49133ef595966377878adc42196f47">More...</a><br /></td></tr>
<tr class="separator:a7a49133ef595966377878adc42196f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49366865f5ce183ae19888eceb6667e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a49366865f5ce183ae19888eceb6667e5">populateSparseTensorRewriting</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a49366865f5ce183ae19888eceb6667e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that are only useful in the context of sparse tensors.  <a href="namespacemlir_1_1linalg.html#a49366865f5ce183ae19888eceb6667e5">More...</a><br /></td></tr>
<tr class="separator:a49366865f5ce183ae19888eceb6667e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af537f75332b531f2f627083684c201e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af537f75332b531f2f627083684c201e4">populateElementwiseOpsFusionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> &amp;controlElementwiseOpFusion)</td></tr>
<tr class="memdesc:af537f75332b531f2f627083684c201e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns for fusing linalg operation on tensors.  <a href="namespacemlir_1_1linalg.html#af537f75332b531f2f627083684c201e4">More...</a><br /></td></tr>
<tr class="separator:af537f75332b531f2f627083684c201e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0c4216814c93fb83b999f3f4923f7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3e0c4216814c93fb83b999f3f4923f7d">populateDataLayoutPropagationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="namespacemlir_1_1linalg.html#a3729e968453a5f63415044c66e5255c5">ControlPropagationFn</a> &amp;controlPackUnPackPropagation)</td></tr>
<tr class="memdesc:a3e0c4216814c93fb83b999f3f4923f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to bubble up or down data layout ops across other operations.  <a href="namespacemlir_1_1linalg.html#a3e0c4216814c93fb83b999f3f4923f7d">More...</a><br /></td></tr>
<tr class="separator:a3e0c4216814c93fb83b999f3f4923f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbdbb9ec2d0ed200d6a679ffd803c7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a9cbdbb9ec2d0ed200d6a679ffd803c7e">populateEraseUnusedOperandsAndResultsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a9cbdbb9ec2d0ed200d6a679ffd803c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to remove dead operands and results of <code>linalg.generic</code> operations.  <a href="namespacemlir_1_1linalg.html#a9cbdbb9ec2d0ed200d6a679ffd803c7e">More...</a><br /></td></tr>
<tr class="separator:a9cbdbb9ec2d0ed200d6a679ffd803c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6e2c64c65b1a22b1794d731be0c612"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#abe6e2c64c65b1a22b1794d731be0c612">populateEraseUnnecessaryInputsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:abe6e2c64c65b1a22b1794d731be0c612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to promote inputs to outputs and remove unused inputs of <code>linalg.generic</code> ops.  <a href="namespacemlir_1_1linalg.html#abe6e2c64c65b1a22b1794d731be0c612">More...</a><br /></td></tr>
<tr class="separator:abe6e2c64c65b1a22b1794d731be0c612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef1d681922add4fcf065a64d713c3b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8ef1d681922add4fcf065a64d713c3b5">populateCollapseDimensions</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="namespacemlir_1_1linalg.html#adfcecb6fc18af7e6d462f3a904c73733">GetCollapsableDimensionsFn</a> &amp;controlCollapseDimensions)</td></tr>
<tr class="memdesc:a8ef1d681922add4fcf065a64d713c3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to collapse dimensions in a linalg.generic op.  <a href="namespacemlir_1_1linalg.html#a8ef1d681922add4fcf065a64d713c3b5">More...</a><br /></td></tr>
<tr class="separator:a8ef1d681922add4fcf065a64d713c3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73f0e4d33b9691f06d722f2146c4a66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac73f0e4d33b9691f06d722f2146c4a66">populateFoldReshapeOpsByExpansionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> &amp;controlFoldingReshapes)</td></tr>
<tr class="memdesc:ac73f0e4d33b9691f06d722f2146c4a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold an expanding (collapsing) tensor_reshape operation with its producer (consumer) generic operation by expanding the dimensionality of the loop in the generic op.  <a href="namespacemlir_1_1linalg.html#ac73f0e4d33b9691f06d722f2146c4a66">More...</a><br /></td></tr>
<tr class="separator:ac73f0e4d33b9691f06d722f2146c4a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8bdabd42dfb2f3617cc87eccfa4199"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3c8bdabd42dfb2f3617cc87eccfa4199">populateFoldReshapeOpsByCollapsingPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> &amp;controlFoldingReshapes)</td></tr>
<tr class="memdesc:a3c8bdabd42dfb2f3617cc87eccfa4199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold an expanding tensor.expand_shape operation with its producer generic operation by collapsing the dimensions of the generic op.  <a href="namespacemlir_1_1linalg.html#a3c8bdabd42dfb2f3617cc87eccfa4199">More...</a><br /></td></tr>
<tr class="separator:a3c8bdabd42dfb2f3617cc87eccfa4199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b142daa69f3f2b8986960b726ba2eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad0b142daa69f3f2b8986960b726ba2eb">populateConstantFoldLinalgOperations</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> &amp;controlFn)</td></tr>
<tr class="memdesc:ad0b142daa69f3f2b8986960b726ba2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to constant fold Linalg operations.  <a href="namespacemlir_1_1linalg.html#ad0b142daa69f3f2b8986960b726ba2eb">More...</a><br /></td></tr>
<tr class="separator:ad0b142daa69f3f2b8986960b726ba2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0b4c454598e4be0bd0fcde89783a20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0e0b4c454598e4be0bd0fcde89783a20">populateFuseTensorPadWithProducerLinalgOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a0e0b4c454598e4be0bd0fcde89783a20"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to fuse a <code>tensor.pad</code> operation with the producer of its source, if the producer is a <code>linalg</code> operation with all parallel iterator types.  <a href="namespacemlir_1_1linalg.html#a0e0b4c454598e4be0bd0fcde89783a20">More...</a><br /></td></tr>
<tr class="separator:a0e0b4c454598e4be0bd0fcde89783a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0419b15db70f16465aec05d8f86f6e4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0419b15db70f16465aec05d8f86f6e4e">populateLinalgNamedOpConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a0419b15db70f16465aec05d8f86f6e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to convert from one named op to another.  <a href="namespacemlir_1_1linalg.html#a0419b15db70f16465aec05d8f86f6e4e">More...</a><br /></td></tr>
<tr class="separator:a0419b15db70f16465aec05d8f86f6e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240f21341db0a0eb9a0051683864a484"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a240f21341db0a0eb9a0051683864a484">populateFoldUnitExtentDimsViaReshapesPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a240f21341db0a0eb9a0051683864a484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold unit-extent dimensions in operands/results of linalg ops on tensors via reassociative reshape ops.  <a href="namespacemlir_1_1linalg.html#a240f21341db0a0eb9a0051683864a484">More...</a><br /></td></tr>
<tr class="separator:a240f21341db0a0eb9a0051683864a484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90aac103dc48569168f968d41cca91c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae90aac103dc48569168f968d41cca91c">populateFoldUnitExtentDimsViaSlicesPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ae90aac103dc48569168f968d41cca91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold unit-extent dimensions in operands/results of linalg ops on tensors via rank-reducing slices.  <a href="namespacemlir_1_1linalg.html#ae90aac103dc48569168f968d41cca91c">More...</a><br /></td></tr>
<tr class="separator:ae90aac103dc48569168f968d41cca91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042bb54cd9155ed1ca8818a16ab5110a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a042bb54cd9155ed1ca8818a16ab5110a">populateMoveInitOperandsToInputPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a042bb54cd9155ed1ca8818a16ab5110a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern that converts init operands to input operands.  <a href="namespacemlir_1_1linalg.html#a042bb54cd9155ed1ca8818a16ab5110a">More...</a><br /></td></tr>
<tr class="separator:a042bb54cd9155ed1ca8818a16ab5110a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc64a8c8a9ecf3de84383893d8e4ddc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#acc64a8c8a9ecf3de84383893d8e4ddc2">populateInlineConstantOperandsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:acc64a8c8a9ecf3de84383893d8e4ddc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns that are used to inline constant operands into linalg generic ops.  <a href="namespacemlir_1_1linalg.html#acc64a8c8a9ecf3de84383893d8e4ddc2">More...</a><br /></td></tr>
<tr class="separator:acc64a8c8a9ecf3de84383893d8e4ddc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fce962e3d12d2dfc3b467076c71f39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a18fce962e3d12d2dfc3b467076c71f39">populateBubbleUpExtractSliceOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a18fce962e3d12d2dfc3b467076c71f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns that are used to bubble up extract slice op above linalg op.  <a href="namespacemlir_1_1linalg.html#a18fce962e3d12d2dfc3b467076c71f39">More...</a><br /></td></tr>
<tr class="separator:a18fce962e3d12d2dfc3b467076c71f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8003a713f74f7a32cc681c245ae9708"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac8003a713f74f7a32cc681c245ae9708">populateSwapExtractSliceWithFillPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ac8003a713f74f7a32cc681c245ae9708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds patterns that waps tensor.extract_slice(linalg.fill(cst, init)) into linalg.fill(cst, tensor.extract_slice(init)).  <a href="namespacemlir_1_1linalg.html#ac8003a713f74f7a32cc681c245ae9708">More...</a><br /></td></tr>
<tr class="separator:ac8003a713f74f7a32cc681c245ae9708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c26bb1f203c97b9d5bcf9b8ae6ea102"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0c26bb1f203c97b9d5bcf9b8ae6ea102">populateSplitReductionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">ControlSplitReductionFn</a> &amp;controlSplitReductionFn, bool useAlloc=false)</td></tr>
<tr class="memdesc:a0c26bb1f203c97b9d5bcf9b8ae6ea102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to apply <code>splitReduction</code> below.  <a href="namespacemlir_1_1linalg.html#a0c26bb1f203c97b9d5bcf9b8ae6ea102">More...</a><br /></td></tr>
<tr class="separator:a0c26bb1f203c97b9d5bcf9b8ae6ea102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf73bb051fb347d6519cdcb174ba230e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aaf73bb051fb347d6519cdcb174ba230e">createOrFoldDimOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> val, int64_t dim)</td></tr>
<tr class="memdesc:aaf73bb051fb347d6519cdcb174ba230e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create one memref::DimOp or tensor::DimOp depending on the type of <code>val</code>.  <a href="namespacemlir_1_1linalg.html#aaf73bb051fb347d6519cdcb174ba230e">More...</a><br /></td></tr>
<tr class="separator:aaf73bb051fb347d6519cdcb174ba230e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dac633b692c130881f315320220fcce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6dac633b692c130881f315320220fcce">createFoldedDimOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> val, int64_t dim)</td></tr>
<tr class="memdesc:a6dac633b692c130881f315320220fcce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create one memref::DimOp or tensor::DimOp depending on the type of <code>val</code>.  <a href="namespacemlir_1_1linalg.html#a6dac633b692c130881f315320220fcce">More...</a><br /></td></tr>
<tr class="separator:a6dac633b692c130881f315320220fcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8344cb25585969440c5081fd3bd45e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a9d8344cb25585969440c5081fd3bd45e">createDynamicDimensions</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a9d8344cb25585969440c5081fd3bd45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the list of DimOp for the dynamic dimensions of <code>val</code>.  <a href="namespacemlir_1_1linalg.html#a9d8344cb25585969440c5081fd3bd45e">More...</a><br /></td></tr>
<tr class="separator:a9d8344cb25585969440c5081fd3bd45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae200262953f416dfaa0120d221e883c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae200262953f416dfaa0120d221e883c1">getMixedDimensions</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:ae200262953f416dfaa0120d221e883c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the list of all dimensions for <code>val</code>, mixing static attributes and dynamic values where appropriate.  <a href="namespacemlir_1_1linalg.html#ae200262953f416dfaa0120d221e883c1">More...</a><br /></td></tr>
<tr class="separator:ae200262953f416dfaa0120d221e883c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f68253e362486827ce3c1115e52b666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a2f68253e362486827ce3c1115e52b666">findPermutationsIndexingOperand</a> (LinalgOp linalgOp, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *opOperand, utils::IteratorType iter)</td></tr>
<tr class="memdesc:a2f68253e362486827ce3c1115e52b666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <code>linalgOp</code> and one of its <code>opOperand</code>, returns the positions of the iterators of type <code>iter</code> that index the <code>opOperand</code> as a permutation.  <a href="namespacemlir_1_1linalg.html#a2f68253e362486827ce3c1115e52b666">More...</a><br /></td></tr>
<tr class="separator:a2f68253e362486827ce3c1115e52b666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4914ba0c77c1dfff911b144cb1781d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa4914ba0c77c1dfff911b144cb1781d7">containsMostMinorMatmul</a> (linalg::LinalgOp linalgOp)</td></tr>
<tr class="memdesc:aa4914ba0c77c1dfff911b144cb1781d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <code>linalgOp</code> contains an embedded matmul subcomputation in its most minor dimensions.  <a href="namespacemlir_1_1linalg.html#aa4914ba0c77c1dfff911b144cb1781d7">More...</a><br /></td></tr>
<tr class="separator:aa4914ba0c77c1dfff911b144cb1781d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4747869121c2bff8855e830ffb05c585"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1EmbeddedMatmulDimsCandidates.html">EmbeddedMatmulDimsCandidates</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4747869121c2bff8855e830ffb05c585">inferMatmulDims</a> (linalg::LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a4747869121c2bff8855e830ffb05c585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find 2 parallel (m and n) and 1 reduction (k) dimension candidates that form a matmul subcomputation within <code>linalgOp</code>.  <a href="namespacemlir_1_1linalg.html#a4747869121c2bff8855e830ffb05c585">More...</a><br /></td></tr>
<tr class="separator:a4747869121c2bff8855e830ffb05c585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eda2843cbf0dc5507bc64ec67f46f22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1eda2843cbf0dc5507bc64ec67f46f22">allIndexingsAreProjectedPermutation</a> (LinalgOp op)</td></tr>
<tr class="memdesc:a1eda2843cbf0dc5507bc64ec67f46f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all indexing maps are projected permutations.  <a href="namespacemlir_1_1linalg.html#a1eda2843cbf0dc5507bc64ec67f46f22">More...</a><br /></td></tr>
<tr class="separator:a1eda2843cbf0dc5507bc64ec67f46f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5473845890c7e81fc544f7bfce900d81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5473845890c7e81fc544f7bfce900d81">hasOnlyScalarElementwiseOp</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;r)</td></tr>
<tr class="memdesc:a5473845890c7e81fc544f7bfce900d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect whether <code>r</code> has only ConstantOp, ElementwiseMappable and YieldOp.  <a href="namespacemlir_1_1linalg.html#a5473845890c7e81fc544f7bfce900d81">More...</a><br /></td></tr>
<tr class="separator:a5473845890c7e81fc544f7bfce900d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1c347bc995910212c197f9f8728b12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8b1c347bc995910212c197f9f8728b12">isElementwise</a> (LinalgOp op)</td></tr>
<tr class="memdesc:a8b1c347bc995910212c197f9f8728b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a LinalgOp is an element-wise operation.  <a href="namespacemlir_1_1linalg.html#a8b1c347bc995910212c197f9f8728b12">More...</a><br /></td></tr>
<tr class="separator:a8b1c347bc995910212c197f9f8728b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24909cfdf87977961b71f1ca78a25919"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a24909cfdf87977961b71f1ca78a25919">isParallelIterator</a> (utils::IteratorType iteratorType)</td></tr>
<tr class="memdesc:a24909cfdf87977961b71f1ca78a25919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if iterator type has "parallel" semantics.  <a href="namespacemlir_1_1linalg.html#a24909cfdf87977961b71f1ca78a25919">More...</a><br /></td></tr>
<tr class="separator:a24909cfdf87977961b71f1ca78a25919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5377722f56e02541897c157260bd1eee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5377722f56e02541897c157260bd1eee">isReductionIterator</a> (utils::IteratorType iteratorType)</td></tr>
<tr class="memdesc:a5377722f56e02541897c157260bd1eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if iterator type has "reduction" semantics.  <a href="namespacemlir_1_1linalg.html#a5377722f56e02541897c157260bd1eee">More...</a><br /></td></tr>
<tr class="separator:a5377722f56e02541897c157260bd1eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9edcaadd998bad20bfb048ad9570c93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa9edcaadd998bad20bfb048ad9570c93">makeComposedPadHighOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, RankedTensorType type, <a class="el" href="classmlir_1_1Value.html">Value</a> source, <a class="el" href="classmlir_1_1Value.html">Value</a> pad, bool nofold)</td></tr>
<tr class="memdesc:aa9edcaadd998bad20bfb048ad9570c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a tensor::PadOp that pads <code>source</code> to the size of the statically sized <code>type</code> whose static sizes are assumed to be greater than the dynamic <code>source</code> size.  <a href="namespacemlir_1_1linalg.html#aa9edcaadd998bad20bfb048ad9570c93">More...</a><br /></td></tr>
<tr class="separator:aa9edcaadd998bad20bfb048ad9570c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cad527515e5ab07ddc46d539c915916"><td class="memItemLeft" align="right" valign="top">GenericOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5cad527515e5ab07ddc46d539c915916">makeTransposeOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> inputTensor, <a class="el" href="classmlir_1_1Value.html">Value</a> outputTensor, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; transposeVector)</td></tr>
<tr class="memdesc:a5cad527515e5ab07ddc46d539c915916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a GenericOp that transposes <code>inputTensor</code> into <code>outputTensor</code> using <code>transposeVector</code> to permute the <code>inputTensor</code> dimensions.  <a href="namespacemlir_1_1linalg.html#a5cad527515e5ab07ddc46d539c915916">More...</a><br /></td></tr>
<tr class="separator:a5cad527515e5ab07ddc46d539c915916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30703b58e97c9678d9ee3d95c1b31f5d"><td class="memItemLeft" align="right" valign="top">GenericOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a30703b58e97c9678d9ee3d95c1b31f5d">makeMemRefCopyOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> from, <a class="el" href="classmlir_1_1Value.html">Value</a> to)</td></tr>
<tr class="memdesc:a30703b58e97c9678d9ee3d95c1b31f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns GenericOp that copies an n-D memref.  <a href="namespacemlir_1_1linalg.html#a30703b58e97c9678d9ee3d95c1b31f5d">More...</a><br /></td></tr>
<tr class="separator:a30703b58e97c9678d9ee3d95c1b31f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c303f22e35937f101dc36b676ef8861"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6c303f22e35937f101dc36b676ef8861">getReassociationMapForFoldingUnitDims</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedSizes)</td></tr>
<tr class="memdesc:a6c303f22e35937f101dc36b676ef8861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reassociation maps to fold the result of a extract_slice (or source of a insert_slice) operation with given offsets, and sizes to its rank-reduced version.  <a href="namespacemlir_1_1linalg.html#a6c303f22e35937f101dc36b676ef8861">More...</a><br /></td></tr>
<tr class="separator:a6c303f22e35937f101dc36b676ef8861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbd3df245d2309a7c68311dc91fbe34"><td class="memItemLeft" align="right" valign="top">std::optional&lt; TypedAttr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aecbd3df245d2309a7c68311dc91fbe34">getNeutralElement</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:aecbd3df245d2309a7c68311dc91fbe34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the identity numeric value associated to the give op.  <a href="namespacemlir_1_1linalg.html#aecbd3df245d2309a7c68311dc91fbe34">More...</a><br /></td></tr>
<tr class="separator:aecbd3df245d2309a7c68311dc91fbe34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358e4f52f7be98a79c9189eb82a42eef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a358e4f52f7be98a79c9189eb82a42eef">computeTileOffsets</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ivs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes)</td></tr>
<tr class="memdesc:a358e4f52f7be98a79c9189eb82a42eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes tile offsets, given a list of loop <code>ivs</code> and <code>tileSizes</code>.  <a href="namespacemlir_1_1linalg.html#a358e4f52f7be98a79c9189eb82a42eef">More...</a><br /></td></tr>
<tr class="separator:a358e4f52f7be98a79c9189eb82a42eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29aed62cd711098f063d5a628905c074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a29aed62cd711098f063d5a628905c074">computeTileSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizeBounds)</td></tr>
<tr class="memdesc:a29aed62cd711098f063d5a628905c074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes tile sizes, given a list of <code>tileSizes</code> and dimension sizes (<code>sizeBounds</code>).  <a href="namespacemlir_1_1linalg.html#a29aed62cd711098f063d5a628905c074">More...</a><br /></td></tr>
<tr class="separator:a29aed62cd711098f063d5a628905c074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2da35587b12f700693b151c166fee34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af2da35587b12f700693b151c166fee34">getTensorOutputTypes</a> (LinalgOp op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands)</td></tr>
<tr class="memdesc:af2da35587b12f700693b151c166fee34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of tensor output types produced when the given structured operation <code>op</code> is applied to the given <code>operands</code>.  <a href="namespacemlir_1_1linalg.html#af2da35587b12f700693b151c166fee34">More...</a><br /></td></tr>
<tr class="separator:af2da35587b12f700693b151c166fee34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f9038823afe23e270d5bdc0734bc3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a78f9038823afe23e270d5bdc0734bc3e">insertSlicesBack</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, LinalgOp op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> results)</td></tr>
<tr class="memdesc:a78f9038823afe23e270d5bdc0734bc3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <code>insert_slice</code> ops that insert <code>results</code> back into larger tensors they were originally extracted from with <code>extract_slice</code> before being passed as <code>operands</code> to the given structured operation <code>op</code> or its clone.  <a href="namespacemlir_1_1linalg.html#a78f9038823afe23e270d5bdc0734bc3e">More...</a><br /></td></tr>
<tr class="separator:a78f9038823afe23e270d5bdc0734bc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc396179b7b2aee5cfef868a42592c60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html">SliceParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#afc396179b7b2aee5cfef868a42592c60">computeSliceParameters</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> valueToTile, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; lbs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ubs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; subShapeSizes, bool omitPartialTileCheck)</td></tr>
<tr class="memdesc:afc396179b7b2aee5cfef868a42592c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html" title="A struct containg offsets-sizes-strides arguments of the tiled shape.">SliceParameters</a> for a single <code>valueToTile</code> assuming that its user is being tiled with the given loop bounds <code>lbs</code> and <code>ubs</code> and the tile sizes <code>tileSizes</code>.  <a href="namespacemlir_1_1linalg.html#afc396179b7b2aee5cfef868a42592c60">More...</a><br /></td></tr>
<tr class="separator:afc396179b7b2aee5cfef868a42592c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06c54273304b8d82c1b239db2b7db90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; std::optional&lt; <a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html">SliceParameters</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa06c54273304b8d82c1b239db2b7db90">computeAllSliceParameters</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, LinalgOp linalgOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> valuesToTile, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ivs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizeBounds, bool omitPartialTileCheck)</td></tr>
<tr class="memdesc:aa06c54273304b8d82c1b239db2b7db90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes SliceParamaters for all <code>valuesToTile</code> of the given <code>linalgOp</code>, assuming <code>linalgOp</code> is being fused into a loop nest.  <a href="namespacemlir_1_1linalg.html#aa06c54273304b8d82c1b239db2b7db90">More...</a><br /></td></tr>
<tr class="separator:aa06c54273304b8d82c1b239db2b7db90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5778b3a8ef5ed7c94b0463a10519cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#afb5778b3a8ef5ed7c94b0463a10519cf">makeTiledShape</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> valueToTile, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; lbs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ubs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; subShapeSizes, bool omitPartialTileCheck)</td></tr>
<tr class="memdesc:afb5778b3a8ef5ed7c94b0463a10519cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an extract_slice/subview op for a single <code>valueToTile</code> with <code>builder</code>.  <a href="namespacemlir_1_1linalg.html#afb5778b3a8ef5ed7c94b0463a10519cf">More...</a><br /></td></tr>
<tr class="separator:afb5778b3a8ef5ed7c94b0463a10519cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5fecbf19090f24723800d371f08271"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1a5fecbf19090f24723800d371f08271">makeTiledShapes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, LinalgOp linalgOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> valuesToTile, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ivs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizeBounds, bool omitPartialTileCheck)</td></tr>
<tr class="memdesc:a1a5fecbf19090f24723800d371f08271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates extract_slice/subview ops for all <code>valuesToTile</code> of the given <code>linalgOp</code> with <code>builder</code>, assuming <code>linalgOp</code> is being fused into a loop nest for tiling with the given induction variables <code>ivs</code> and tile sizes <code>tileSizes</code>.  <a href="namespacemlir_1_1linalg.html#a1a5fecbf19090f24723800d371f08271">More...</a><br /></td></tr>
<tr class="separator:a1a5fecbf19090f24723800d371f08271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917a655a236200d3202b07fb842561b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a917a655a236200d3202b07fb842561b8">offsetIndices</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp linalgOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; offests)</td></tr>
<tr class="memdesc:a917a655a236200d3202b07fb842561b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the specified offsets to any <code>linalg.index</code> ops contained in the given <code>linalgOp</code>.  <a href="namespacemlir_1_1linalg.html#a917a655a236200d3202b07fb842561b8">More...</a><br /></td></tr>
<tr class="separator:a917a655a236200d3202b07fb842561b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bed319cb33ba0b063edefa38e27309"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a34bed319cb33ba0b063edefa38e27309">offsetIndices</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, LinalgOp linalgOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; offests)</td></tr>
<tr class="separator:a34bed319cb33ba0b063edefa38e27309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c5cf1a47f0bf5b6405224845ff8d83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a13c5cf1a47f0bf5b6405224845ff8d83">fuseProducerOfTensor</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;consumerOpOperand)</td></tr>
<tr class="memdesc:a13c5cf1a47f0bf5b6405224845ff8d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor counterpart of <code>fuseProducerOfBuffer</code>.  <a href="namespacemlir_1_1linalg.html#a13c5cf1a47f0bf5b6405224845ff8d83">More...</a><br /></td></tr>
<tr class="separator:a13c5cf1a47f0bf5b6405224845ff8d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7195637d33a1cf8133bc32a219adf6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa7195637d33a1cf8133bc32a219adf6b">fuseProducerOfTensor</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> producerOpResult, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;consumerOpOperand)</td></tr>
<tr class="memdesc:aa7195637d33a1cf8133bc32a219adf6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor counterpart of <code>fuseProducerOfBuffer</code>.  <a href="namespacemlir_1_1linalg.html#aa7195637d33a1cf8133bc32a219adf6b">More...</a><br /></td></tr>
<tr class="separator:aa7195637d33a1cf8133bc32a219adf6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb173d5edf56a08ed3610924312dd364"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aeb173d5edf56a08ed3610924312dd364">updateBoundsForCyclicDistribution</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> procId, <a class="el" href="classmlir_1_1Value.html">Value</a> nprocs, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;lb, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;ub, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;step)</td></tr>
<tr class="memdesc:aeb173d5edf56a08ed3610924312dd364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the <code>lb</code>, <code>ub</code> and <code>step</code> to get per processor <code>lb</code>, <code>ub</code> and <code>step</code>.  <a href="namespacemlir_1_1linalg.html#aeb173d5edf56a08ed3610924312dd364">More...</a><br /></td></tr>
<tr class="separator:aeb173d5edf56a08ed3610924312dd364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3c6ebbcb16507e55a2f5c07542b312"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:a6a3c6ebbcb16507e55a2f5c07542b312"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6a3c6ebbcb16507e55a2f5c07542b312">getPrunedAttributeList</a> (OpTy op)</td></tr>
<tr class="memdesc:a6a3c6ebbcb16507e55a2f5c07542b312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an attribute list that excludes pre-defined attributes.  <a href="namespacemlir_1_1linalg.html#a6a3c6ebbcb16507e55a2f5c07542b312">More...</a><br /></td></tr>
<tr class="separator:a6a3c6ebbcb16507e55a2f5c07542b312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab874160ec1bdc15b5c867c4799391a03"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab874160ec1bdc15b5c867c4799391a03">hasAllOneValues</a> (<a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a> attr)</td></tr>
<tr class="separator:ab874160ec1bdc15b5c867c4799391a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f801aa72135899ae36567a9c78c5b3b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3f801aa72135899ae36567a9c78c5b3b">createAdd</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> x, <a class="el" href="classmlir_1_1Value.html">Value</a> y, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="separator:a3f801aa72135899ae36567a9c78c5b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e6451d40cef8244025d03bc83cfdad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a80e6451d40cef8244025d03bc83cfdad">createMul</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> x, <a class="el" href="classmlir_1_1Value.html">Value</a> y, <a class="el" href="classmlir_1_1Type.html">Type</a> accType, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="separator:a80e6451d40cef8244025d03bc83cfdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0775243640f0e58d6cce7f49809b13"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0a0775243640f0e58d6cce7f49809b13">unrollIndex</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> index, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; factors)</td></tr>
<tr class="separator:a0a0775243640f0e58d6cce7f49809b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90b3b862ac8de64b21095282e64305c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab90b3b862ac8de64b21095282e64305c">getConvolvedIndex</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> oIndex, <a class="el" href="classmlir_1_1Value.html">Value</a> fIndex, int64_t stride)</td></tr>
<tr class="separator:ab90b3b862ac8de64b21095282e64305c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330275ee0b8daf6e838a8bce3d70a331"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a330275ee0b8daf6e838a8bce3d70a331">generateParallelLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> steps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt; iteratorTypes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">linalg::ProcInfo</a> &gt; procInfo, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilderFn, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;ivStorage)</td></tr>
<tr class="memdesc:a330275ee0b8daf6e838a8bce3d70a331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a loop nest consisting of scf.parallel and scf.for, depending on the <code>iteratorTypes. </code> <a href="namespacemlir_1_1linalg.html#a330275ee0b8daf6e838a8bce3d70a331">More...</a><br /></td></tr>
<tr class="separator:a330275ee0b8daf6e838a8bce3d70a331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1706425d4f7a288d7296e0ba978b5c5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac1706425d4f7a288d7296e0ba978b5c5">materializeTiledShape</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> valueToTile, const <a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html">SliceParameters</a> &amp;sliceParams)</td></tr>
<tr class="separator:ac1706425d4f7a288d7296e0ba978b5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a1bcbad447f843c9b98886ad6f49469a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bcbad447f843c9b98886ad6f49469a9">&#9670;&nbsp;</a></span>AllocBufferCallbackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a1bcbad447f843c9b98886ad6f49469a9">mlir::linalg::AllocBufferCallbackFn</a> = typedef std::function&lt;std::optional&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;( <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, memref::SubViewOp subView, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; boundingSubViewSize, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function type used to perform the allocation for the promoted <code>subView</code>. </p>
<p>In <code>boundingSubViewsize</code> a best attempt is made to find the smallest constant value for the size of the buffer needed for each dimension. If that is not possible, contains the dynamic size of the subview. The call back should return the buffer to use. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00179">179</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a3115e251fd057529cff9b2d44a0ba1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3115e251fd057529cff9b2d44a0ba1c0">&#9670;&nbsp;</a></span>ControlFusionFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">mlir::linalg::ControlFusionFn</a> = typedef std::function&lt;bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type which is used to control when to stop fusion. </p>
<p>It is expected that <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> is not modified in the callback. The <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> is not marked as const to allow callers to use non-const methods. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01347">1347</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a3729e968453a5f63415044c66e5255c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3729e968453a5f63415044c66e5255c5">&#9670;&nbsp;</a></span>ControlPropagationFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a3729e968453a5f63415044c66e5255c5">mlir::linalg::ControlPropagationFn</a> = typedef std::function&lt;bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type which is used to control propagation of tensor.pack/unpack ops. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01359">1359</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="ad16099880d7579f488dd714c6273ea4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16099880d7579f488dd714c6273ea4c">&#9670;&nbsp;</a></span>ControlSplitReductionFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">mlir::linalg::ControlSplitReductionFn</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1linalg_1_1SplitReductionOptions.html">SplitReductionOptions</a>(LinalgOp op)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function signature to control reduction splitting. </p>
<p>This returns <code><a class="el" href="structmlir_1_1linalg_1_1SplitReductionOptions.html" title="Split Reduction options.">SplitReductionOptions</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00276">276</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="aa49994e2aab61b35167972384684cf24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49994e2aab61b35167972384684cf24">&#9670;&nbsp;</a></span>CopyCallbackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#aa49994e2aab61b35167972384684cf24">mlir::linalg::CopyCallbackFn</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function type used to insert copy from original subview to subview of the promoted region for the read operands/subview of promoted region to original subview for the results. </p>
<p>The copy has to happen from <code>src</code> to <code>dst</code>. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00192">192</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a3d7afb284c4be072a74a24eeb71cc985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7afb284c4be072a74a24eeb71cc985">&#9670;&nbsp;</a></span>DeallocBufferCallbackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a3d7afb284c4be072a74a24eeb71cc985">mlir::linalg::DeallocBufferCallbackFn</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> buffer)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function type used to deallocate the buffers used to hold the promoted subview. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00185">185</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="adfcecb6fc18af7e6d462f3a904c73733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfcecb6fc18af7e6d462f3a904c73733">&#9670;&nbsp;</a></span>GetCollapsableDimensionsFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#adfcecb6fc18af7e6d462f3a904c73733">mlir::linalg::GetCollapsableDimensionsFn</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a>&gt;(linalg::GenericOp)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type to control generic op dimension collapsing. </p>
<p>It is expected to return an array of <code>ReassociationIndices</code> representing dimensions that should be merged. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01377">1377</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a4a9ca79033211e3e53e0eb25a8e9551b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9ca79033211e3e53e0eb25a8e9551b">&#9670;&nbsp;</a></span>LinalgLoops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">mlir::linalg::LinalgLoops</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00303">303</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a2363d9b68019db04dbf0c710afe7f224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2363d9b68019db04dbf0c710afe7f224">&#9670;&nbsp;</a></span>LoopIndexToRangeIndexMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a2363d9b68019db04dbf0c710afe7f224">mlir::linalg::LoopIndexToRangeIndexMap</a> = typedef <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt;int, int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a number of ranges equal to the number of non-zero in <code>tileSizes</code>. </p>
<p>One for each loop of the LinalgOp that is tiled. The <code>tileSizes</code> argument has one entry per surrounding loop. It uses zero as the convention that a particular loop is not tiled. This convention simplifies implementations by avoiding affine map manipulations. The returned ranges correspond to the loop ranges, in the proper order, that are tiled and for which new loops will be created. Also the function returns a map from loop indices of the LinalgOp to the corresponding non-empty range indices of newly created loops. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00620">620</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a7326883dfd3172d344f305860482e9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7326883dfd3172d344f305860482e9ff">&#9670;&nbsp;</a></span>OptimizeCopyFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a7326883dfd3172d344f305860482e9ff">mlir::linalg::OptimizeCopyFn</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;, tensor::PadOp, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01147">1147</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a651199aee7abd57b3b297b905d109183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651199aee7abd57b3b297b905d109183">&#9670;&nbsp;</a></span>ProcInfoCallBackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a651199aee7abd57b3b297b905d109183">mlir::linalg::ProcInfoCallBackFn</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">ProcInfo</a>&gt;( <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="structmlir_1_1Range.html">Range</a>&gt; parallelLoopRanges)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00339">339</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a730df0415b8172eb93f8f7b346e04440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730df0415b8172eb93f8f7b346e04440">&#9670;&nbsp;</a></span>TileSizeComputationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a730df0415b8172eb93f8f7b346e04440">mlir::linalg::TileSizeComputationFunction</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, 4&gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00045">45</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a7382d59369873eb3a9a9ddd571056982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7382d59369873eb3a9a9ddd571056982">&#9670;&nbsp;</a></span>DistributionMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982">mlir::linalg::DistributionMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scheme used to distribute loops to processors. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7382d59369873eb3a9a9ddd571056982ad71670d62b238eaf063979407361034e"></a>Cyclic&#160;</td><td class="fielddoc"><p>Cyclic distribution where no assumption is made about the dynamic relationship between number of processors and number of iterations of the distributed loop. </p>
<p>Distributes the following loop</p>
<p>scf.parallel (iv) = (lb) to (ub) step (step)</p>
<p>to</p>
<p>scf.parallel(iv)= (lb + procId * step) to (ub) step (step * nprocs) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7382d59369873eb3a9a9ddd571056982abab54876ff518ecd2d59b46fd3be9c0e"></a>CyclicNumProcsGeNumIters&#160;</td><td class="fielddoc"><p>Cyclic distribution where the number of processors can be assumed to be more than or equal to the number of iterations of the distributed loop. </p>
<p>In such cases, a simple in-bounds check is enough (instead of materializing a loop). Distributes the following loop</p>
<p>scf.parallel (iv) = (lb) to (ub) step (step)</p>
<p>to</p>
<p>iv = lb + procId * step cond = arith.cmpi "slt", iv, ub scf.if cond { ... } </p>
</td></tr>
<tr><td class="fieldname"><a id="a7382d59369873eb3a9a9ddd571056982ad93606014b9a6b479ba0e6faa948540b"></a>CyclicNumProcsEqNumIters&#160;</td><td class="fielddoc"><p>Cyclic distribution where the number of processors can be assumed to be equal to the number of iterations of the distributed loop. </p>
<p>In such cases, no bounds check is needed. Distributes the following loop</p>
<p>scf.parallel (iv) = (lb) to (ub) step (step)</p>
<p>to</p>
<p>iv = lb + procId * step </p>
</td></tr>
<tr><td class="fieldname"><a id="a7382d59369873eb3a9a9ddd571056982a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>No Distribution. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00284">284</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a3cdd229e1459c7e6ed2f9c7ee7168325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cdd229e1459c7e6ed2f9c7ee7168325">&#9670;&nbsp;</a></span>LinalgTilingLoopType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325">mlir::linalg::LinalgTilingLoopType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of loops to be generated during tiling. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325a4b2257cb98694284507e77f34e73c2d8"></a>Loops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325a6d8bf0bdeaca5ef4693524bf04c4c877"></a>AffineLoops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325ab92546344b4e3fa9b10c9472795297a7"></a>ParallelLoops&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00142">142</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1eda2843cbf0dc5507bc64ec67f46f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eda2843cbf0dc5507bc64ec67f46f22">&#9670;&nbsp;</a></span>allIndexingsAreProjectedPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::allIndexingsAreProjectedPermutation </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if all indexing maps are projected permutations. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00228">228</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01315">vectorizeLinalgOpPrecondition()</a>.</p>

</div>
</div>
<a id="a5606dfca8a9078fc6bc9b74972f15fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5606dfca8a9078fc6bc9b74972f15fdc">&#9670;&nbsp;</a></span>allocateGPUPrivateMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::allocateGPUPrivateMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::SubViewOp&#160;</td>
          <td class="paramname"><em>subview</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizeBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate the subview in the GPU private memory. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00469">469</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Promotion_8cpp_source.html#l00409">allocateSubviewGPUMemoryInAddressSpace()</a>.</p>

</div>
</div>
<a id="a266200755192d09deb827c799e59277b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266200755192d09deb827c799e59277b">&#9670;&nbsp;</a></span>allocateWorkgroupMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::allocateWorkgroupMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::SubViewOp&#160;</td>
          <td class="paramname"><em>subview</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizeBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate the subview in the GPU workgroup memory. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00444">444</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Promotion_8cpp_source.html#l00409">allocateSubviewGPUMemoryInAddressSpace()</a>.</p>

</div>
</div>
<a id="a8fa220da60546acce7c4a8b3635d5b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa220da60546acce7c4a8b3635d5b21">&#9670;&nbsp;</a></span>areElementwiseOpsFusable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::areElementwiseOpsFusable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&#160;</td>
          <td class="paramname"><em>fusedOperand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if two <code>linalg.generic</code> operations with producer/consumer relationship through <code>fusedOperand</code> can be fused using elementwise op fusion. </p>
<p>Conditions for elementwise fusion of generic operations. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00075">75</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00137">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00045">getIndexingMapOfProducerOperandsInCoordinatesOfFusedOp()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00332">mlir::AffineMap::getNumResults()</a>, <a class="el" href="UseDefLists_8h_source.html#l00040">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8h_source.html#l00301">mlir::Type::isa()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00551">mlir::AffineMap::isPermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00277">fuseElementwiseOps()</a>.</p>

</div>
</div>
<a id="af200f0e047b9365a24c21b1cc6d1a8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af200f0e047b9365a24c21b1cc6d1a8d2">&#9670;&nbsp;</a></span>bufferizeToAllocation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::bufferizeToAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp&#160;</td>
          <td class="paramname"><em>padOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Materialize a buffer allocation for the given tensor.pad op and lower the op to linalg.fill/linalg.generic + memref.tensor_store. </p>
<p>E.g.:</p>
<p>%0 = tensor.pad low[l] high[h] t ...</p>
<p>is lowered to:</p>
<p>alloc = memref.alloc linalg.fill ... outs(alloc) subview = memref.subview alloc [l] [...] [1] memref.tensor_store t, subview %0 = bufferization.to_tensor alloc restrict writable</p>
<p>In addition to rewriting the IR as shown above, the result of the bufferization.to_tensor op is returned. </p>

<p class="reference">Referenced by <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00331">bufferizeToAllocation()</a>.</p>

</div>
</div>
<a id="a8c571913d792aae43a0a97cdb824d042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c571913d792aae43a0a97cdb824d042">&#9670;&nbsp;</a></span>bufferizeToAllocation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::bufferizeToAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Materialize a buffer allocation for the given tensor value. </p>
<p>E.g.:</p>
<p>alloc = memref.alloc memref.tensor_store value, alloc %0 = bufferization.to_tensor alloc restrict writable</p>
<p>In case <code>value</code> is a tensor.pad result, the corresponding overload is used internally to produce a better bufferization. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00331">331</a> of file <a class="el" href="ConvertToDestinationStyle_8cpp_source.html">ConvertToDestinationStyle.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1linalg.html#af200f0e047b9365a24c21b1cc6d1a8d2">bufferizeToAllocation()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00152">createAllocationForTensor()</a>, <a class="el" href="Value_8h_source.html#l00103">mlir::Value::dyn_cast()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8cpp_source.html#l00026">mlir::Value::getLoc()</a>, <a class="el" href="UseDefLists_8h_source.html#l00040">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Value_8h_source.html#l00201">mlir::Value::getUses()</a>, <a class="el" href="UseDefLists_8h_source.html#l00140">mlir::IROperand&lt; DerivedT, IRValueT &gt;::set()</a>, <a class="el" href="Builders_8h_source.html#l00393">mlir::OpBuilder::setInsertionPointAfter()</a>, <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00549">mlir::RewriterBase::updateRootInPlace()</a>.</p>

</div>
</div>
<a id="a67b48a1ef778b1a379cbc6191e5c6d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b48a1ef778b1a379cbc6191e5c6d96">&#9670;&nbsp;</a></span>collapseGenericOpIterationDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt; mlir::linalg::collapseGenericOpIterationDims </td>
          <td>(</td>
          <td class="paramtype">GenericOp&#160;</td>
          <td class="paramname"><em>genericOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>foldedIterationDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collapses dimensions of linalg.generic operation. </p>
<p>Implementation of fusion with reshape operation by collapsing dimensions.</p>
<p>It also collapses inputs before the op and expands outputs after the op. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01418">1418</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00321">mlir::Type::cast()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Block_8h_source.html#l00142">mlir::Block::front()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01379">generateCollapsedIndexingRegion()</a>, <a class="el" href="Block_8h_source.html#l00076">mlir::Block::getArguments()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01287">getCollapsedOpIteratorTypes()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01357">getCollapsedOpOperand()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01330">getOperandReassociation()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00057">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="Matchers_8h_source.html#l00401">mlir::m_ConstantInt()</a>, <a class="el" href="Matchers_8h_source.html#l00378">mlir::matchPattern()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00356">mlir::RewriterBase::mergeBlocks()</a>, <a class="el" href="PatternMatch_8h_source.html#l00597">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00031">mlir::Range::offset</a>, <a class="el" href="Builders_8h_source.html#l00379">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00032">mlir::Range::size</a>, and <a class="el" href="StaticValueUtils_8h_source.html#l00033">mlir::Range::stride</a>.</p>

</div>
</div>
<a id="aa06c54273304b8d82c1b239db2b7db90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06c54273304b8d82c1b239db2b7db90">&#9670;&nbsp;</a></span>computeAllSliceParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; std::optional&lt; <a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html">SliceParameters</a> &gt; &gt; mlir::linalg::computeAllSliceParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>valuesToTile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sizeBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>omitPartialTileCheck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes SliceParamaters for all <code>valuesToTile</code> of the given <code>linalgOp</code>, assuming <code>linalgOp</code> is being fused into a loop nest. </p>
<p>Calls <code>computeSliceParameters</code> for every individual value.</p>
<p>Note that a constant zero in <code>tileSizes</code> means no tiling at that implicit loop. The number of non-zero values in <code>tileSizes</code> should be equal to the number of values in <code>ivs</code>.</p>
<p>Some of the <code>valuesToTile</code> won't be affected by tiling. For these values, std::nullopt will be returned. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00858">858</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00683">computeSliceParameters()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00790">computeTileOffsets()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00804">computeTileSizes()</a>, <a class="el" href="IR_2Types_8h_source.html#l00301">mlir::Type::isa()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00078">isTiled()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00909">makeTiledShapes()</a>.</p>

</div>
</div>
<a id="af8ef5fd09c3c79a47b8c4732ace79928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ef5fd09c3c79a47b8c4732ace79928">&#9670;&nbsp;</a></span>computeMultiTileSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1MultiSizeSpecification.html">MultiSizeSpecification</a> &gt; mlir::linalg::computeMultiTileSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>targetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>divisor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>emitAssertions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits the IR computing the multi-sized tiling specification with two tile sizes not exceeding <code>targetSize</code>, each divisible by <code>sizeDivisor</code>, such that there exist numbers of tiles with these sizes that fully cover the given iteration space <code>dimension</code> of the structured <code>op</code>. </p>
<p>The computation is as follows:</p>
<p>b = originalTripCount floordiv sizeDivisor t = (targetSize + sizeDivisor - 1) floordiv sizeDivisor d = (b + t - 1) floordiv t s = (b floordiv d) * sizeDivisor v = b % d u = d - v</p>
<p>where the tile sizes are <code>s</code> and <code>s</code> + <code>sizeDivisor</code>, and the numbers of the corresponding tiles are <code>u</code> and <code>v</code>, respectively. Alternatively,</p>
<p>s * u + (s + sizeDivisor) * v == original size, where s mod sizeDivisor = 0.</p>
<p>Expects all values to be positive. In some cases with the target tile size sufficiently close to the dimension shape and non-unit divisor, it is impossible to compute such sizes. If <code>emitAssertion</code> is set, also emit the assertion that size computation succeeded.</p>
<p>Returns the specification consisting of both tile values and the number of tiles of each size. </p>

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00148">148</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

</div>
</div>
<a id="afc396179b7b2aee5cfef868a42592c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc396179b7b2aee5cfef868a42592c60">&#9670;&nbsp;</a></span>computeSliceParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html">SliceParameters</a> mlir::linalg::computeSliceParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>valueToTile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>subShapeSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>omitPartialTileCheck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes <a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html" title="A struct containg offsets-sizes-strides arguments of the tiled shape.">SliceParameters</a> for a single <code>valueToTile</code> assuming that its user is being tiled with the given loop bounds <code>lbs</code> and <code>ubs</code> and the tile sizes <code>tileSizes</code>. </p>
<p><code>omitPartialTileCheck</code> controls whether to omit the partial/boundary tile condition check in cases where we statically know that it is unnecessary. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00683">683</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00329">mlir::bindDims()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00515">createFoldedDimOp()</a>, <a class="el" href="IR_2Types_8h_source.html#l00311">mlir::Type::dyn_cast()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00512">mlir::getAffineSymbolExpr()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00117">mlir::getConstantIntValue()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00121">mlir::Builder::getIndexAttr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00557">mlir::AffineMap::getSubMap()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00242">mlir::AffineMap::inferFromExprList()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00078">isTiled()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01333">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01397">mlir::affine::makeComposedFoldedAffineMin()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00180">mlir::linalg::SliceParameters::offsets</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00181">mlir::linalg::SliceParameters::sizes</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00182">mlir::linalg::SliceParameters::strides</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00858">computeAllSliceParameters()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00671">makeTiledShape()</a>.</p>

</div>
</div>
<a id="a91c1fb37672289a396df9c95a9b1dd0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c1fb37672289a396df9c95a9b1dd0b">&#9670;&nbsp;</a></span>computeStaticMultiTileSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1StaticMultiSizeSpecification.html">StaticMultiSizeSpecification</a> &gt; mlir::linalg::computeStaticMultiTileSizes </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>targetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00122">122</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

</div>
</div>
<a id="a358e4f52f7be98a79c9189eb82a42eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358e4f52f7be98a79c9189eb82a42eef">&#9670;&nbsp;</a></span>computeTileOffsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::linalg::computeTileOffsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes tile offsets, given a list of loop <code>ivs</code> and <code>tileSizes</code>. </p>
<p>In case a tile size is zero (i.e., no tiling), the corresponding offset is also zero. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00790">790</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00121">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00078">isTiled()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00018">mlir::isZeroIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00858">computeAllSliceParameters()</a>.</p>

</div>
</div>
<a id="a29aed62cd711098f063d5a628905c074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29aed62cd711098f063d5a628905c074">&#9670;&nbsp;</a></span>computeTileSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::linalg::computeTileSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sizeBounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes tile sizes, given a list of <code>tileSizes</code> and dimension sizes (<code>sizeBounds</code>). </p>
<p>In case a tile size is zero (i.e., no tiling), the corresponding result size is the corresponding value from <code>sizeBounds</code>. Note: The returned tile sizes are closed intervals. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00804">804</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00502">mlir::getAffineDimExpr()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00078">isTiled()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00018">mlir::isZeroIndex()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01333">mlir::affine::makeComposedFoldedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00858">computeAllSliceParameters()</a>.</p>

</div>
</div>
<a id="a4f8ea0aae80d24eeffa3fef8f1f08c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8ea0aae80d24eeffa3fef8f1f08c43">&#9670;&nbsp;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt; mlir::linalg::concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the vector that is the concatenation of <code>a</code> and <code>b</code>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l01789">1789</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simplex_8cpp_source.html#l01478">mlir::presburger::Simplex::makeProduct()</a>.</p>

</div>
</div>
<a id="aa4914ba0c77c1dfff911b144cb1781d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4914ba0c77c1dfff911b144cb1781d7">&#9670;&nbsp;</a></span>containsMostMinorMatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::containsMostMinorMatmul </td>
          <td>(</td>
          <td class="paramtype">linalg::LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if <code>linalgOp</code> contains an embedded matmul subcomputation in its most minor dimensions. </p>

</div>
</div>
<a id="a88359f69353831d971485ff6b6b86dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88359f69353831d971485ff6b6b86dc1">&#9670;&nbsp;</a></span>copyToGPUPrivateMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::copyToGPUPrivateMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normal copy to between src and dst. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00477">477</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Value_8cpp_source.html#l00026">mlir::Value::getLoc()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a72fb3984f986840e0dc914c1ab90dc3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72fb3984f986840e0dc914c1ab90dc3b">&#9670;&nbsp;</a></span>copyToWorkgroupMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::copyToWorkgroupMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create Memref copy operations and add gpu barrier guards before and after the copy operation to ensure data integrity. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00460">460</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Value_8cpp_source.html#l00026">mlir::Value::getLoc()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a3f801aa72135899ae36567a9c78c5b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f801aa72135899ae36567a9c78c5b3b">&#9670;&nbsp;</a></span>createAdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::createAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00031">31</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, and <a class="el" href="IR_2Types_8h_source.html#l00301">mlir::Type::isa()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00076">rewriteInIm2Col()</a>.</p>

</div>
</div>
<a id="a9d8344cb25585969440c5081fd3bd45e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8344cb25585969440c5081fd3bd45e">&#9670;&nbsp;</a></span>createDynamicDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::createDynamicDimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the list of DimOp for the dynamic dimensions of <code>val</code>. </p>
<p>Asserts that <code>val</code> is a ranked shaped type. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Utils_2IndexingUtils_8cpp_source.html#l00061">61</a> of file <a class="el" href="Linalg_2Utils_2IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00321">mlir::Type::cast()</a>, <a class="el" href="Linalg_2Utils_2IndexingUtils_8cpp_source.html#l00045">createOrFoldDimOp()</a>, <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>, and <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Utils_2IndexingUtils_8cpp_source.html#l00074">getMixedDimensions()</a>.</p>

</div>
</div>
<a id="a6dac633b692c130881f315320220fcce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dac633b692c130881f315320220fcce">&#9670;&nbsp;</a></span>createFoldedDimOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::linalg::createFoldedDimOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create one memref::DimOp or tensor::DimOp depending on the type of <code>val</code>. </p>
<p>This is a polymorphic convenience function to abstract away the rank and concrete type of <code>val</code>. Asserts that <code>val</code> is a memref or tensor type. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Utils_2IndexingUtils_8cpp_source.html#l00053">53</a> of file <a class="el" href="Linalg_2Utils_2IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00321">mlir::Type::cast()</a>, <a class="el" href="Linalg_2Utils_2IndexingUtils_8cpp_source.html#l00045">createOrFoldDimOp()</a>, <a class="el" href="Builders_8cpp_source.html#l00121">mlir::Builder::getIndexAttr()</a>, and <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00113">fuse()</a>.</p>

</div>
</div>
<a id="a80e6451d40cef8244025d03bc83cfdad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e6451d40cef8244025d03bc83cfdad">&#9670;&nbsp;</a></span>createMul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::createMul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>accType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00038">38</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00087">mlir::convertScalarToDtype()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, and <a class="el" href="IR_2Types_8h_source.html#l00301">mlir::Type::isa()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00076">rewriteInIm2Col()</a>.</p>

</div>
</div>
<a id="aaf73bb051fb347d6519cdcb174ba230e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf73bb051fb347d6519cdcb174ba230e">&#9670;&nbsp;</a></span>createOrFoldDimOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::createOrFoldDimOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create one memref::DimOp or tensor::DimOp depending on the type of <code>val</code>. </p>
<p>This is a polymorphic convenience function to abstract away the rank and concrete type of <code>val</code>. Asserts that <code>val</code> is a memref or tensor type. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Utils_2IndexingUtils_8cpp_source.html#l00045">45</a> of file <a class="el" href="Linalg_2Utils_2IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00501">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, and <a class="el" href="IR_2Types_8h_source.html#l00301">mlir::Type::isa()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00184">concatSizesFromInputs()</a>, <a class="el" href="Linalg_2Utils_2IndexingUtils_8cpp_source.html#l00061">createDynamicDimensions()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00515">createFoldedDimOp()</a>, <a class="el" href="Linalg_2Utils_2IndexingUtils_8cpp_source.html#l00053">createFoldedDimOp()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00467">mlir::sparse_tensor::genDenseTensorOrSparseConstantIterLoop()</a>, <a class="el" href="LoopEmitter_8cpp_source.html#l00343">mlir::sparse_tensor::LoopEmitter::initializeLoopEmit()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00512">mlir::sparse_tensor::sizesFromSrc()</a>.</p>

</div>
</div>
<a id="a487d4430e8217b1dabc50cb28bb93342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487d4430e8217b1dabc50cb28bb93342">&#9670;&nbsp;</a></span>deallocateGPUPrivateMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::deallocateGPUPrivateMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In case of GPU private memory there is no need to deallocate since the memory is freed when going outside of the scope. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00485">485</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="ad6babd80190e8df26f441fca7d2fbe31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6babd80190e8df26f441fca7d2fbe31">&#9670;&nbsp;</a></span>deallocateWorkgroupMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::deallocateWorkgroupMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In case of GPU group memory there is no need to deallocate. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00453">453</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a956959faad992424aaa215510e50e618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956959faad992424aaa215510e50e618">&#9670;&nbsp;</a></span>extractOrIdentityMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::linalg::extractOrIdentityMap </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maybeMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code><a class="el" href="namespacemlir.html#ab4871db68c59a176135e0e35a3625e73" title="Helper method that injects context only if needed, this helps unify some of the attribute constructio...">maybeMap.get()</a></code> if <code>maybeMap</code> is set, otherwise returns the symbol-less identity map of <code>rank</code>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l01769">1769</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01135">mlir::AffineMap::get()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00262">mlir::AffineMap::getMultiDimIdentityMap()</a>.</p>

</div>
</div>
<a id="a2f68253e362486827ce3c1115e52b666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f68253e362486827ce3c1115e52b666">&#9670;&nbsp;</a></span>findPermutationsIndexingOperand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; int64_t &gt; mlir::linalg::findPermutationsIndexingOperand </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&#160;</td>
          <td class="paramname"><em>opOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utils::IteratorType&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <code>linalgOp</code> and one of its <code>opOperand</code>, returns the positions of the iterators of type <code>iter</code> that index the <code>opOperand</code> as a permutation. </p>
<p>This is useful to infer various subcomputations on a given <code>linalgOp</code>. This is performed by looking up each result in the matching indexing map and determining whether:</p><ul>
<li>It is a single <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a>.</li>
<li>It is the only result involving this <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00147">147</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00040">mlir::detail::IROperandBase::getOwner()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00337">mlir::AffineMap::getResults()</a>.</p>

</div>
</div>
<a id="a4ceec493e0b40673125a0402c3cf78e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ceec493e0b40673125a0402c3cf78e4">&#9670;&nbsp;</a></span>fuseElementwiseOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1ElementwiseOpFusionResult.html">mlir::linalg::ElementwiseOpFusionResult</a> &gt; mlir::linalg::fuseElementwiseOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&#160;</td>
          <td class="paramname"><em>fusedOperand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the results of the producer that have uses outside of the consumer.</p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00277">277</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00075">areElementwiseOpsFusable()</a>, <a class="el" href="Value_8h_source.html#l00113">mlir::Value::cast()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00482">mlir::AffineMap::compose()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00285">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00338">mlir::linalg::ElementwiseOpFusionResult::fusedOp</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00153">generateFusedElementwiseOpRegion()</a>, <a class="el" href="UseDefLists_8h_source.html#l00137">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00312">mlir::Builder::getAffineMapArrayAttr()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00045">getIndexingMapOfProducerOperandsInCoordinatesOfFusedOp()</a>, <a class="el" href="UseDefLists_8h_source.html#l00040">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00667">mlir::inversePermutation()</a>, <a class="el" href="IR_2Types_8h_source.html#l00301">mlir::Type::isa()</a>, <a class="el" href="PatternMatch_8h_source.html#l00597">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00339">mlir::linalg::ElementwiseOpFusionResult::replacements</a>.</p>

</div>
</div>
<a id="a13c5cf1a47f0bf5b6405224845ff8d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c5cf1a47f0bf5b6405224845ff8d83">&#9670;&nbsp;</a></span>fuseProducerOfTensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt; mlir::linalg::fuseProducerOfTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>consumerOpOperand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tensor counterpart of <code>fuseProducerOfBuffer</code>. </p>
<p>This implements the fusion part of the "tileAndFuse on tensors" transformation and thus requires the <code>consumerOpOperand</code> to be a <code>extract_slice</code> op (generally obtained by applying the tiling transformation). </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00237">237</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="UseDefLists_8h_source.html#l00137">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00212">getProducerOfTensor()</a>.</p>

</div>
</div>
<a id="aa7195637d33a1cf8133bc32a219adf6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7195637d33a1cf8133bc32a219adf6b">&#9670;&nbsp;</a></span>fuseProducerOfTensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt; mlir::linalg::fuseProducerOfTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a>&#160;</td>
          <td class="paramname"><em>producerOpResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>consumerOpOperand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tensor counterpart of <code>fuseProducerOfBuffer</code>. </p>
<p>This implements the fusion part of the "tileAndFuse on tensors" transformation and thus requires the <code>consumerOpOperand</code> to be a <code>extract_slice</code> op (generally obtained by applying the tiling transformation). Assumes <code>producerOfTensor</code> is a Linalg op that produces <code>consumerOpOperand</code>. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00249">249</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Fusion_8cpp_source.html#l00113">fuse()</a>, <a class="el" href="UseDefLists_8h_source.html#l00137">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="UseDefLists_8h_source.html#l00040">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Value_8h_source.html#l00451">mlir::OpResult::getOwner()</a>, <a class="el" href="Value_8cpp_source.html#l00048">mlir::Value::getParentBlock()</a>, <a class="el" href="Value_8h_source.html#l00454">mlir::OpResult::getResultNumber()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, <a class="el" href="UseDefLists_8h_source.html#l00140">mlir::IROperand&lt; DerivedT, IRValueT &gt;::set()</a>, and <a class="el" href="Builders_8h_source.html#l00379">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="a06f75a142d34f0b8ab6db239fc7de6cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f75a142d34f0b8ab6db239fc7de6cb">&#9670;&nbsp;</a></span>generalizeNamedOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; GenericOp &gt; mlir::linalg::generalizeNamedOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>namedOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a GenericOp from the given named operation <code>namedOp</code> and replace namedOp. </p>
<p>Return failure if <code>namedOp</code> is a GenericOp or misses a region builder. </p>

<p class="definition">Definition at line <a class="el" href="Generalization_8cpp_source.html#l00051">51</a> of file <a class="el" href="Generalization_8cpp_source.html">Generalization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="Generalization_8cpp_source.html#l00038">generalizeNamedOpPrecondition()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00382">mlir::RewriterBase::inlineRegionBefore()</a>, <a class="el" href="PatternMatch_8h_source.html#l00597">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00266">mlir::RewriterBase::replaceOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgTransformOps_8cpp_source.html#l01087">packMatmulGreedily()</a>.</p>

</div>
</div>
<a id="a754ec5c5960c640563ddcd9727b77d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754ec5c5960c640563ddcd9727b77d87">&#9670;&nbsp;</a></span>generateLibraryCallName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlir::linalg::generateLibraryCallName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name mangled library call name to disambiguate between different overloads at the C level. </p>
<p>The name mangling scheme is basic and uses MLIR type names:</p><ol type="1">
<li>form a string which is the concatenation of the linalg op name with all the operand type names, separate by underscores;</li>
<li>drop the <code>linalg.</code> prefix, and the <code>&lt;</code>, <code>&gt;</code>, <code>?</code> symbols from the type. Assumes <code>op</code> is a LinalgOp.</li>
</ol>
<p>Examples:</p>
<ol type="1">
<li>linalg.fill(f, A) : f32, memref&lt;f32&gt; name mangles into <code>linalg_fill_f32_viewf32</code></li>
<li>linalg.dot A, B, C : (memref&lt;?xf32, stride_specification&gt;, memref&lt;?xf32, stride_specification&gt;, memref&lt;f32&gt;) name mangles into <code>linalg_dot_viewxf32_viewxf32_viewf32</code></li>
<li>linalg.matmul(...) : memref&lt;?x?xf32, stride_specification&gt;, memref&lt;?x?xf32, stride_specification&gt;, memref&lt;?x?xf32, stride_specification&gt; name mangles into <code>linalg_matmul_viewxxf32_viewxxf32_viewxxf32</code> </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l01829">1829</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

</div>
</div>
<a id="a330275ee0b8daf6e838a8bce3d70a331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330275ee0b8daf6e838a8bce3d70a331">&#9670;&nbsp;</a></span>generateParallelLoopNest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mlir::linalg::generateParallelLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt;&#160;</td>
          <td class="paramname"><em>iteratorTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">linalg::ProcInfo</a> &gt;&#160;</td>
          <td class="paramname"><em>procInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilderFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ivStorage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a loop nest consisting of scf.parallel and scf.for, depending on the <code>iteratorTypes. </code></p>
<p>Consecutive parallel loops create a single scf.parallel operation; each sequential loop creates a new scf.for operation. The body of the innermost loop is populated by <code>bodyBuilderFn</code> that accepts a range of induction variables for all loops. <code>ivStorage</code> is used to store the partial list of induction variables. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00489">489</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00140">mlir::ArithBuilder::_and()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00594">mlir::scf::buildLoopNest()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00337">mlir::linalg::ProcInfo::distributionMethod</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00263">isParallelIterator()</a>, <a class="el" href="MlirTblgenMain_8cpp_source.html#l00028">None</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00163">mlir::ArithBuilder::slt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00604">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>.</p>

</div>
</div>
<a id="ae27267a4634c46beba8c9f55c14cdfa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27267a4634c46beba8c9f55c14cdfa1">&#9670;&nbsp;</a></span>getCombinerOpKind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; vector::CombiningKind &gt; mlir::linalg::getCombinerOpKind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>combinerOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return vector::CombiningKind for the given op. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00462">462</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00526">buildMultiDimReduce()</a>.</p>

</div>
</div>
<a id="ab90b3b862ac8de64b21095282e64305c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90b3b862ac8de64b21095282e64305c">&#9670;&nbsp;</a></span>getConvolvedIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::getConvolvedIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>oIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>fIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00066">66</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00343">mlir::bindSymbols()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01135">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01284">mlir::affine::makeComposedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00076">rewriteInIm2Col()</a>.</p>

</div>
</div>
<a id="ae61503376ad6b88f0c35f8ce358dbc9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61503376ad6b88f0c35f8ce358dbc9e">&#9670;&nbsp;</a></span>getLinalgTilingCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> mlir::linalg::getLinalgTilingCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalization patterns relevant to apply after tiling patterns. </p>
<p>These are applied automatically by the tiling pass but need to be applied manually when tiling is called programmatically. </p>

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00963">963</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="Tiling_8cpp_source.html#l00969">populateLinalgTilingCanonicalizationPatterns()</a>.</p>

</div>
</div>
<a id="ae200262953f416dfaa0120d221e883c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae200262953f416dfaa0120d221e883c1">&#9670;&nbsp;</a></span>getMixedDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::linalg::getMixedDimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the list of all dimensions for <code>val</code>, mixing static attributes and dynamic values where appropriate. </p>
<p>Asserts that <code>val</code> is a ranked shaped type. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Utils_2IndexingUtils_8cpp_source.html#l00074">74</a> of file <a class="el" href="Linalg_2Utils_2IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00321">mlir::Type::cast()</a>, <a class="el" href="Linalg_2Utils_2IndexingUtils_8cpp_source.html#l00061">createDynamicDimensions()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00163">mlir::getMixedValues()</a>, and <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transforms_8cpp_source.html#l00480">lowerPack()</a>, <a class="el" href="Transforms_8cpp_source.html#l00610">lowerUnPack()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01411">maskedVectorize()</a>.</p>

</div>
</div>
<a id="aecbd3df245d2309a7c68311dc91fbe34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecbd3df245d2309a7c68311dc91fbe34">&#9670;&nbsp;</a></span>getNeutralElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; TypedAttr &gt; mlir::linalg::getNeutralElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the identity numeric value associated to the give op. </p>
<p>Return std::nullopt if there is no known neutral element. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00988">988</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a id="a6a3c6ebbcb16507e55a2f5c07542b312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3c6ebbcb16507e55a2f5c07542b312">&#9670;&nbsp;</a></span>getPrunedAttributeList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a>&gt; mlir::linalg::getPrunedAttributeList </td>
          <td>(</td>
          <td class="paramtype">OpTy&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an attribute list that excludes pre-defined attributes. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00469">469</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a6c303f22e35937f101dc36b676ef8861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c303f22e35937f101dc36b676ef8861">&#9670;&nbsp;</a></span>getReassociationMapForFoldingUnitDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; &gt; mlir::linalg::getReassociationMapForFoldingUnitDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>mixedSizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the reassociation maps to fold the result of a extract_slice (or source of a insert_slice) operation with given offsets, and sizes to its rank-reduced version. </p>
<p>This is only done for the cases where the size is 1 and offset is 0. Strictly speaking the offset 0 is not required in general, but non-zero offsets are not handled by SPIR-V backend at this point (and potentially cannot be handled). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00966">966</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>.</p>

</div>
</div>
<a id="af2da35587b12f700693b151c166fee34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2da35587b12f700693b151c166fee34">&#9670;&nbsp;</a></span>getTensorOutputTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; mlir::linalg::getTensorOutputTypes </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the list of tensor output types produced when the given structured operation <code>op</code> is applied to the given <code>operands</code>. </p>
<p>Note that <code>operands</code> are not necessarily the actual operands of <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00820">820</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a id="ab874160ec1bdc15b5c867c4799391a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab874160ec1bdc15b5c867c4799391a03">&#9670;&nbsp;</a></span>hasAllOneValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::linalg::hasAllOneValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00026">26</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00076">rewriteInIm2Col()</a>.</p>

</div>
</div>
<a id="a5473845890c7e81fc544f7bfce900d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5473845890c7e81fc544f7bfce900d81">&#9670;&nbsp;</a></span>hasOnlyScalarElementwiseOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::hasOnlyScalarElementwiseOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect whether <code>r</code> has only ConstantOp, ElementwiseMappable and YieldOp. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00234">234</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a id="a75511cb041f22d05a9abde75e8001677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75511cb041f22d05a9abde75e8001677">&#9670;&nbsp;</a></span>hoistPaddingOnTensors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::hoistPaddingOnTensors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp&#160;</td>
          <td class="paramname"><em>opToHoist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>numLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>transposeVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp &amp;&#160;</td>
          <td class="paramname"><em>hoistedOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; GenericOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>transposeOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mechanically hoist padding operations on tensors by <code>numLoops</code> into a new, generally larger tensor. </p>
<p>This achieves packing of multiple padding ops into a larger tensor. On success, <code>opToHoist</code> is replaced by the cloned version in the packing loop so the caller can continue reasoning about the padding operation. If <code>transposeVector</code> is non-empty, hoist padding introduces a GenericOp to transpose the padded tensor before inserting it into the packed tensor. A <code>transposeVector</code> can change the storage order of the padded tensor but does not change the order of the pack or compute loops.</p>
<p>TODO: In the future, we should consider rewriting as a tensor.pack after hoisting since this abstraction is now available.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
Example in pseudo-mlir:</h1>
<p>If hoistPaddingOnTensors is called with <code>nLoops</code> = 2 on the following IR. </p><div class="fragment"><div class="line">scf.for (%i, %<a class="code" href="unionj.html">j</a>, %k)</div>
<div class="line">  %st0 = tensor.extract_slice f(%i, %k) : ... to tensor&lt;?x?xf32&gt;</div>
<div class="line">  %0 = tensor.pad %st0 low[0, 0] high[...] {</div>
<div class="line">  ^bb0( ... ):</div>
<div class="line">    linalg.yield %pad</div>
<div class="line">  } : tensor&lt;?x?xf32&gt; to tensor&lt;4x8xf32&gt;</div>
<div class="line">  compute(%0)</div>
<div class="ttc" id="aunionj_html"><div class="ttname"><a href="unionj.html">j</a></div><div class="ttdoc">Eliminates variable at the specified position using Fourier-Motzkin variable elimination.</div></div>
</div><!-- fragment --><p>IR resembling the following is produced:</p>
<div class="fragment"><div class="line">scf.for (%i) {</div>
<div class="line">  %packed_init = tensor.empty range(%<a class="code" href="unionj.html">j</a>) : tensor&lt;?x4x8xf32&gt;</div>
<div class="line">  %packed = scf.for (%k) iter_args(%p : %packed_init) {</div>
<div class="line">    %st0 = tensor.extract_slice f(%i, %k) : ... to tensor&lt;?x?xf32&gt;</div>
<div class="line">    %0 = tensor.pad %st0 low[0, 0] high[...] {</div>
<div class="line">    ^bb0( ... ):</div>
<div class="line">      linalg.yield %pad</div>
<div class="line">    } : tensor&lt;?x?xf32&gt; to tensor&lt;4x8xf32&gt;</div>
<div class="line">    %1 = tensor.insert_slice %0 ...</div>
<div class="line">        : tensor&lt;4x8xf32&gt; to tensor&lt;?x4x8xf32&gt;</div>
<div class="line">    scf.yield %1: tensor&lt;?x4x8xf32&gt;</div>
<div class="line">  } -&gt; tensor&lt;?x4x8xf32&gt;</div>
<div class="line">  scf.for (%<a class="code" href="unionj.html">j</a>, %k) {</div>
<div class="line">    %st0 = tensor.extract_slice %packed [%k, 0, 0][1, 4, 8][1, 1, 1] :</div>
<div class="line">             tensor&lt;?x4x8xf32&gt; to tensor&lt;4x8xf32&gt;</div>
<div class="line">    compute(%st0)</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> <p>Construct the packing loop nest.</p>

<p class="definition">Definition at line <a class="el" href="HoistPadding_8cpp_source.html#l00937">937</a> of file <a class="el" href="HoistPadding_8cpp_source.html">HoistPadding.cpp</a>.</p>

<p class="reference">References <a class="el" href="HoistPadding_8cpp_source.html#l00538">buildPackingLoopNestImpl()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00087">mlir::tensor::computeTransposedType()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00035">DBGS</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00238">mlir::Operation::getParentOfType()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00331">makeTransposeOp()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00874">replaceByPackingResult()</a>, <a class="el" href="Builders_8h_source.html#l00393">mlir::OpBuilder::setInsertionPointAfter()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>.</p>

<p class="reference">Referenced by <a class="el" href="HoistPadding_8cpp_source.html#l01002">hoistPaddingOnTensors()</a>, and <a class="el" href="Transforms_8cpp_source.html#l00285">padAndHoistLinalgOp()</a>.</p>

</div>
</div>
<a id="aada17eefc3ffa4987b6b56afccb94022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada17eefc3ffa4987b6b56afccb94022">&#9670;&nbsp;</a></span>hoistPaddingOnTensors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::hoistPaddingOnTensors </td>
          <td>(</td>
          <td class="paramtype">tensor::PadOp&#160;</td>
          <td class="paramname"><em>opToHoist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>numLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>transposeVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp &amp;&#160;</td>
          <td class="paramname"><em>hoistedOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; GenericOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>transposeOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls into <code>hoistPaddingOnTensors</code> with a local <a class="el" href="classmlir_1_1IRRewriter.html" title="This class coordinates rewriting a piece of IR outside of a pattern rewrite, providing a way to keep ...">IRRewriter</a>. </p>

<p class="definition">Definition at line <a class="el" href="HoistPadding_8cpp_source.html#l01002">1002</a> of file <a class="el" href="HoistPadding_8cpp_source.html">HoistPadding.cpp</a>.</p>

<p class="reference">References <a class="el" href="HoistPadding_8cpp_source.html#l00937">hoistPaddingOnTensors()</a>.</p>

</div>
</div>
<a id="a7e3881d7e28d54f38fef29eae672d322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3881d7e28d54f38fef29eae672d322">&#9670;&nbsp;</a></span>hoistRedundantSubsetExtractInsert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scf::ForOp mlir::linalg::hoistRedundantSubsetExtractInsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>forOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greedily hoist redundant subset extract/insert operations on tensors outside of <code>forOp</code>. </p>
<p>Greedily hoist redundant subset extract/insert operations on tensors outside <code>forOp</code>.</p>
<p>The logic follows:</p><ol type="1">
<li>Look for a write walking back from the <code>forOp</code> yield.</li>
<li>Check the uses of the matching block argument and look for a matching read (i.e. extract_slice of transfer_read) with matching indices.</li>
<li>In the case of a transfer_write, we can bypass other non-conflicting operations and find more hoisting opportunities.</li>
<li>Hoist the read/write pair and update the tensor SSA links.</li>
</ol>
<p>Return the unmodified <code>forOp</code> if no hoisting occured. Return a new scf::ForOp if hoisting on tensors occured.</p>
<p>After this transformation the returned scf::ForOp may have unused arguments that can be removed by application of canonicalization patterns.</p>
<h1><a class="anchor" id="autotoc_md11"></a>
Example:</h1>
<p>IR Resembling:</p>
<div class="fragment"><div class="line">%0 = scf.for %i = %l to %u step %s iter_args(%a0 = %t0)-&gt;(tensor&lt;10xf32&gt;) {</div>
<div class="line"> %1 = scf.for %<a class="code" href="unionj.html">j</a> = %l to %u step %s iter_args(%a6 = %a0)-&gt;(tensor&lt;10xf32&gt;) {</div>
<div class="line">  %e = tensor.extract_slice %a6[%i][%sz][1]: tensor&lt;10xf32&gt; to tensor&lt;?xf32&gt;</div>
<div class="line">  %r = vector.transfer_read %e[%c0], %cst: tensor&lt;?xf32&gt;, vector&lt;4xf32&gt;</div>
<div class="line">  %u = <span class="stringliteral">&quot;some_use&quot;</span>(%r) : (vector&lt;4xf32&gt;) -&gt; vector&lt;4xf32&gt;</div>
<div class="line">  %w = vector.transfer_write %u, %e[%c0] : vector&lt;4xf32&gt;, tensor&lt;?xf32&gt;</div>
<div class="line">  %st = tensor.insert_slice %w into %a6[%i][%sz][1]</div>
<div class="line">    : tensor&lt;?xf32&gt; into tensor&lt;10xf32&gt;</div>
<div class="line">  scf.yield %st: tensor&lt;10xf32&gt;</div>
<div class="line"> }</div>
<div class="line"> scf.yield %1: tensor&lt;10xf32&gt;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Progressively hoists to:</p>
<div class="fragment"><div class="line">%0 = scf.for %i = %l to %u step %s iter_args(%a0 = %t0) -&gt; (tensor&lt;10xf32&gt;){</div>
<div class="line"> %e = tensor.extract_slice %a0[%i][%sz][1]: tensor&lt;10xf32&gt; to tensor&lt;?xf32&gt;</div>
<div class="line"> %1:2 = scf.for %<a class="code" href="unionj.html">j</a> = %l to %u step %s iter_args(%a6 = a0, %a7 = %e)</div>
<div class="line">    -&gt; (tensor&lt;10xf32&gt;, tensor&lt;?xf32&gt;) {</div>
<div class="line">  %r = vector.transfer_read %a7[%c0], %cst: tensor&lt;?xf32&gt;, vector&lt;4xf32&gt;</div>
<div class="line">  %u = <span class="stringliteral">&quot;some_use&quot;</span>(%r) : (vector&lt;4xf32&gt;) -&gt; vector&lt;4xf32&gt;</div>
<div class="line">  %w = vector.transfer_write %u, %a7[%c0] : vector&lt;4xf32&gt;, tensor&lt;?xf32&gt;</div>
<div class="line">  scf.yield %a6, %w: tensor&lt;10xf32&gt;, tensor&lt;?xf32&gt;</div>
<div class="line"> }</div>
<div class="line"> %st = tensor.insert_slice %1#1 into %1#0[%i][%sz][1]</div>
<div class="line">   : tensor&lt;?xf32&gt; into tensor&lt;10xf32&gt;</div>
<div class="line"> scf.yield %1: tensor&lt;10xf32&gt;</div>
<div class="line">}</div>
</div><!-- fragment --><p>and</p>
<div class="fragment"><div class="line">%0 = scf.for %i = %l to %u step %s iter_args(%a0 = %t0) -&gt; (tensor&lt;10xf32&gt;){</div>
<div class="line"> %e = tensor.extract_slice %a0[%i][%sz][1]: tensor&lt;10xf32&gt; to tensor&lt;?xf32&gt;</div>
<div class="line"> %r = vector.transfer_read %a7[%c0], %cst: tensor&lt;?xf32&gt;, vector&lt;4xf32&gt;</div>
<div class="line"> %1:3 = scf.for %<a class="code" href="unionj.html">j</a> = %l to %u step %s iter_args(%a6 = a0, %a7 = %e, %a7 = r)</div>
<div class="line">    -&gt; (tensor&lt;10xf32&gt;, tensor&lt;?xf32&gt;, vector&lt;4xf32&gt;) {</div>
<div class="line">  %u = <span class="stringliteral">&quot;some_use&quot;</span>(%r) : (vector&lt;4xf32&gt;) -&gt; vector&lt;4xf32&gt;</div>
<div class="line">  scf.yield %a6, %a7, %u: tensor&lt;10xf32&gt;, tensor&lt;?xf32&gt;, vector&lt;4xf32&gt;</div>
<div class="line"> }</div>
<div class="line"> %w = vector.transfer_write %1#2, %1#1[%c0] : vector&lt;4xf32&gt;, tensor&lt;?xf32&gt;</div>
<div class="line"> %st = tensor.insert_slice %w into %1#0[%i][%sz][1]</div>
<div class="line">   : tensor&lt;?xf32&gt; into tensor&lt;10xf32&gt;</div>
<div class="line"> scf.yield %1: tensor&lt;10xf32&gt;</div>
<div class="line">}</div>
</div><!-- fragment --><p>It can then canonicalize to:</p>
<div class="fragment"><div class="line">%0 = scf.for %i = %l to %u step %s iter_args(%a0 = %t0) -&gt; (tensor&lt;10xf32&gt;){</div>
<div class="line"> %e = tensor.extract_slice %a0[%i][%sz][1]: tensor&lt;10xf32&gt; to tensor&lt;?xf32&gt;</div>
<div class="line"> %r = vector.transfer_read %a7[%c0], %cst: tensor&lt;?xf32&gt;, vector&lt;4xf32&gt;</div>
<div class="line"> %1 = scf.for %<a class="code" href="unionj.html">j</a> = %l to %u step %s iter_args(%a7 = r)</div>
<div class="line">    -&gt; (tensor&lt;10xf32&gt;, tensor&lt;?xf32&gt;, vector&lt;4xf32&gt;) {</div>
<div class="line">  %u = <span class="stringliteral">&quot;some_use&quot;</span>(%r) : (vector&lt;4xf32&gt;) -&gt; vector&lt;4xf32&gt;</div>
<div class="line">  scf.yield %u: vector&lt;4xf32&gt;</div>
<div class="line"> }</div>
<div class="line"> %w = vector.transfer_write %1, %e[%c0] : vector&lt;4xf32&gt;, tensor&lt;?xf32&gt;</div>
<div class="line"> %st = tensor.insert_slice %w into %a0[%i][%sz][1]</div>
<div class="line">   : tensor&lt;?xf32&gt; into tensor&lt;10xf32&gt;</div>
<div class="line"> scf.yield %1: tensor&lt;10xf32&gt;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Return the unmodified <code>forOp</code> if no hoisting occurred. Return a new scf::ForOp if hoisting on tensors occurred. </p>

<p class="definition">Definition at line <a class="el" href="SubsetHoisting_8cpp_source.html#l00462">462</a> of file <a class="el" href="SubsetHoisting_8cpp_source.html">SubsetHoisting.cpp</a>.</p>

<p class="reference">References <a class="el" href="SubsetHoisting_8cpp_source.html#l00030">DBGS</a>, <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="SubsetHoisting_8cpp_source.html#l00065">findHoistableMatchingExtractSlice()</a>, <a class="el" href="SubsetHoisting_8cpp_source.html#l00119">findHoistableMatchingTransferRead()</a>, <a class="el" href="SubsetHoisting_8cpp_source.html#l00242">getLoopInvariantInsertSliceDefining()</a>, <a class="el" href="SubsetHoisting_8cpp_source.html#l00198">getLoopInvariantTransferWriteDefining()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00383">mlir::Operation::getOpOperand()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00790">mlir::Operation::hasOneUse()</a>, <a class="el" href="SubsetHoisting_8cpp_source.html#l00399">hoistExtractInsertSlice()</a>, <a class="el" href="SubsetHoisting_8cpp_source.html#l00340">hoistTransferReadWrite()</a>, <a class="el" href="SubsetHoisting_8cpp_source.html#l00274">isTensorChunkAccessedByUnknownOp()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Hoisting_8cpp_source.html#l00046">hoistRedundantVectorTransfersOnTensor()</a>.</p>

</div>
</div>
<a id="a869b2d2412244532c263f6ee009677a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869b2d2412244532c263f6ee009677a5">&#9670;&nbsp;</a></span>hoistRedundantVectorTransfers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::hoistRedundantVectorTransfers </td>
          <td>(</td>
          <td class="paramtype">func::FuncOp&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoist vector.transfer_read/vector.transfer_write on buffers pairs out of immediately enclosing scf::ForOp iteratively, if the following conditions are true: </p>
<ol type="1">
<li>The two ops access the same memref with the same indices.</li>
<li>All operands are invariant under the enclosing scf::ForOp.</li>
<li>No uses of the memref either dominate the transfer_read or are dominated by the transfer_write (i.e. no aliasing between the write and the read across the loop) To improve hoisting opportunities, call the <code>moveLoopInvariantCode</code> helper function on the candidate loop above which to hoist. Hoisting the transfers results in scf::ForOp yielding the value that originally transited through memory.</li>
</ol>
<p>WARNING: This hoisting does not model parallelism and is generally incorrect when used on distributed loops with memref semantics! </p>

<p class="definition">Definition at line <a class="el" href="Hoisting_8cpp_source.html#l00079">79</a> of file <a class="el" href="Hoisting_8cpp_source.html">Hoisting.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00052">mlir::WalkResult::advance()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00041">DBGS</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00053">mlir::getForwardSlice()</a>, <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::interrupt()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00209">mlir::vector::isDisjointTransferSet()</a>, <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00050">mlir::moveLoopInvariantCode()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00055">noAliasingUseInLoop()</a>, <a class="el" href="Dominance_8h_source.html#l00134">mlir::DominanceInfo::properlyDominates()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02781">mlir::affine::replaceForOpWithNewYields()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00042">mlir::replaceLoopWithNewYields()</a>.</p>

</div>
</div>
<a id="ae15d4eeea23d8e587288af4d3af05583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15d4eeea23d8e587288af4d3af05583">&#9670;&nbsp;</a></span>hoistRedundantVectorTransfersOnTensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::hoistRedundantVectorTransfersOnTensor </td>
          <td>(</td>
          <td class="paramtype">func::FuncOp&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call into <code>hoistRedundantSubsetInsertExtract</code> without a <a class="el" href="classmlir_1_1RewriterBase.html" title="This class coordinates the application of a rewrite on a set of IR, providing a way for clients to tr...">RewriterBase</a>. </p>

<p class="definition">Definition at line <a class="el" href="Hoisting_8cpp_source.html#l00046">46</a> of file <a class="el" href="Hoisting_8cpp_source.html">Hoisting.cpp</a>.</p>

<p class="reference">References <a class="el" href="SubsetHoisting_8cpp_source.html#l00462">hoistRedundantSubsetExtractInsert()</a>.</p>

</div>
</div>
<a id="a4747869121c2bff8855e830ffb05c585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4747869121c2bff8855e830ffb05c585">&#9670;&nbsp;</a></span>inferMatmulDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt;<a class="el" href="structmlir_1_1linalg_1_1EmbeddedMatmulDimsCandidates.html">EmbeddedMatmulDimsCandidates</a>&gt; mlir::linalg::inferMatmulDims </td>
          <td>(</td>
          <td class="paramtype">linalg::LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find 2 parallel (m and n) and 1 reduction (k) dimension candidates that form a matmul subcomputation within <code>linalgOp</code>. </p>
<p>These dimensions are such that:</p><ol type="1">
<li>The m dimension is involved in an outer-product along LHS (i.e. it is a permutation on RES and LHS and does not appear in RHS).</li>
<li>The n dimension is involved in an outer-product along RHS (i.e. it is a permutation on RES and RHS and does not appear in LHS).</li>
<li>The k dimension appears as a permutation on LHS and RHS.</li>
<li>m, n and k appear only once in any given indexing. This allows detecting that some matmul is embedded within <code>linalgOp</code> with some orthogonal heuristic. </li>
</ol>

<p class="reference">Referenced by <a class="el" href="LinalgTransformOps_8cpp_source.html#l01087">packMatmulGreedily()</a>.</p>

</div>
</div>
<a id="a78f9038823afe23e270d5bdc0734bc3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f9038823afe23e270d5bdc0734bc3e">&#9670;&nbsp;</a></span>insertSlicesBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::insertSlicesBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates <code>insert_slice</code> ops that insert <code>results</code> back into larger tensors they were originally extracted from with <code>extract_slice</code> before being passed as <code>operands</code> to the given structured operation <code>op</code> or its clone. </p>
<p>Note that <code>operands</code> are not necessarily the actual operands of <code>op</code>, the operation serves only as metadata container for operand types and positions. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00829">829</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a id="a8dcc62e199cdb1863a3d6f30e4dc317a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dcc62e199cdb1863a3d6f30e4dc317a">&#9670;&nbsp;</a></span>interchangeGenericOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; GenericOp &gt; mlir::linalg::interchangeGenericOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GenericOp&#160;</td>
          <td class="paramname"><em>genericOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>interchangeVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interchange the <code>iterator_types</code> and <code>iterator_maps</code> dimensions and adapts the index accesses of <code>op</code>. </p>
<p>This is an in-place transformation controlled by <code>interchangeVector</code>. An empty vector is interpreted as the identity permutation and the transformation returns early.</p>
<p>E.g. the permutation <code>(i,j,k) -&gt; (j,k,i)</code> is expressed with <code>interchangeVector = [1,2,0]</code>. All values in <code>interchangeVector</code> must be integers, in the range 0..<code>op.rank</code> without duplications (i.e. <code>[1,1,2]</code> is an invalid permutation).</p>
<p>Return failure if the permutation is not valid. </p>

<p class="definition">Definition at line <a class="el" href="Interchange_8cpp_source.html#l00050">50</a> of file <a class="el" href="Interchange_8cpp_source.html">Interchange.cpp</a>.</p>

<p class="reference">References <a class="el" href="Utils_2IndexingUtils_8h_source.html#l00187">mlir::applyPermutationToVector()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00482">mlir::AffineMap::compose()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00300">mlir::RewriterBase::finalizeRootUpdate()</a>, <a class="el" href="Builders_8cpp_source.html#l00312">mlir::Builder::getAffineMapArrayAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00259">mlir::Builder::getArrayAttr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00212">mlir::AffineMap::getPermutationMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00557">mlir::AffineMap::getSubMap()</a>, <a class="el" href="Interchange_8cpp_source.html#l00036">interchangeGenericOpPrecondition()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00667">mlir::inversePermutation()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00297">mlir::AffineMap::isEmpty()</a>, <a class="el" href="PatternMatch_8h_source.html#l00597">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PatternMatch_8h_source.html#l00482">mlir::RewriterBase::replaceOpWithNewOp()</a>, <a class="el" href="Builders_8h_source.html#l00379">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00534">mlir::RewriterBase::startRootUpdate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgTransformOps_8cpp_source.html#l01087">packMatmulGreedily()</a>.</p>

</div>
</div>
<a id="ab5277093c168682f123f1e99d90461f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5277093c168682f123f1e99d90461f0">&#9670;&nbsp;</a></span>isaContractionOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isaContractionOpInterface </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <code>linalgOp</code> conforms to ContractionOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00145">145</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

</div>
</div>
<a id="a8b1c347bc995910212c197f9f8728b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1c347bc995910212c197f9f8728b12">&#9670;&nbsp;</a></span>isElementwise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isElementwise </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a LinalgOp is an element-wise operation. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00248">248</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01315">vectorizeLinalgOpPrecondition()</a>.</p>

</div>
</div>
<a id="a24909cfdf87977961b71f1ca78a25919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24909cfdf87977961b71f1ca78a25919">&#9670;&nbsp;</a></span>isParallelIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isParallelIterator </td>
          <td>(</td>
          <td class="paramtype">utils::IteratorType&#160;</td>
          <td class="paramname"><em>iteratorType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if iterator type has "parallel" semantics. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00263">263</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00489">generateParallelLoopNest()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01095">getCollapsableIterationSpaceDims()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00505">isFusableWithReshapeByDimExpansion()</a>.</p>

</div>
</div>
<a id="a5377722f56e02541897c157260bd1eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5377722f56e02541897c157260bd1eee">&#9670;&nbsp;</a></span>isReductionIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isReductionIterator </td>
          <td>(</td>
          <td class="paramtype">utils::IteratorType&#160;</td>
          <td class="paramname"><em>iteratorType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if iterator type has "reduction" semantics. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00267">267</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01095">getCollapsableIterationSpaceDims()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00535">getDimsToReduce()</a>, <a class="el" href="CodegenEnv_8cpp_source.html#l00186">mlir::sparse_tensor::CodegenEnv::isAdmissibleTopoOrder()</a>, and <a class="el" href="Sparsification_8cpp_source.html#l00460">topSortOptimal()</a>.</p>

</div>
</div>
<a id="a95f289e066dcbb7844bd444c0880fc36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f289e066dcbb7844bd444c0880fc36">&#9670;&nbsp;</a></span>linalgOpToAffineLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt; mlir::linalg::linalgOpToAffineLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a loop nest of <code>affine.for</code> with the proper body for <code>linalgOp</code>. </p>
<p>Emits a loop nest of <code>affine.for</code> with the proper body for <code>linalgOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00372">372</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

</div>
</div>
<a id="a7edd4be30bfb8af9bc8e486f8368c1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7edd4be30bfb8af9bc8e486f8368c1e2">&#9670;&nbsp;</a></span>linalgOpToLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt; mlir::linalg::linalgOpToLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a loop nest of <code>scf.for</code> with the proper body for <code>linalgOp</code>. </p>
<p>Emits a loop nest of <code>scf.for</code> with the proper body for <code>linalgOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00377">377</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

</div>
</div>
<a id="aff809877c1d119dae06d06a8bad953e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff809877c1d119dae06d06a8bad953e4">&#9670;&nbsp;</a></span>linalgOpToParallelLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt; mlir::linalg::linalgOpToParallelLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a loop nest of <code>scf.parallel</code> with the proper body for <code>linalgOp</code>. </p>
<p>Emits a loop nest of <code>scf.parallel</code> with the proper body for <code>linalgOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00384">384</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

</div>
</div>
<a id="ac6161e899e8e77c1f29b4b7d7751dbac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6161e899e8e77c1f29b4b7d7751dbac">&#9670;&nbsp;</a></span>lowerPack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1LowerPackResult.html">LowerPackResult</a> &gt; mlir::linalg::lowerPack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PackOp&#160;</td>
          <td class="paramname"><em>packOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite pack as pad + reshape + transpose. </p>

<p class="definition">Definition at line <a class="el" href="Transforms_8cpp_source.html#l00480">480</a> of file <a class="el" href="Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="Utils_2IndexingUtils_8h_source.html#l00187">mlir::applyPermutationToVector()</a>, <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00217">mlir::computePermutationVector()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00023">mlir::tensor::createPadHighOp()</a>, <a class="el" href="Transforms_8cpp_source.html#l00046">DBGS</a>, <a class="el" href="Transforms_8cpp_source.html#l00047">DBGSNL</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00024">mlir::getElementTypeOrSelf()</a>, <a class="el" href="Builders_8cpp_source.html#l00121">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Linalg_2Utils_2IndexingUtils_8cpp_source.html#l00074">getMixedDimensions()</a>, <a class="el" href="Builders_8cpp_source.html#l00318">mlir::Builder::getZeroAttr()</a>, <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00194">mlir::invertPermutationVector()</a>, <a class="el" href="PatternMatch_8h_source.html#l00597">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00266">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="Builders_8h_source.html#l00379">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00227">mlir::RankedTensorType::Builder::setShape()</a>.</p>

</div>
</div>
<a id="a1646364e16a4592a25500238dec29ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1646364e16a4592a25500238dec29ab5">&#9670;&nbsp;</a></span>lowerUnPack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1LowerUnPackOpResult.html">LowerUnPackOpResult</a> &gt; mlir::linalg::lowerUnPack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::UnPackOp&#160;</td>
          <td class="paramname"><em>unPackOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite pack as empty + transpose + reshape + extract_slice. </p>

<p class="definition">Definition at line <a class="el" href="Transforms_8cpp_source.html#l00610">610</a> of file <a class="el" href="Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="Utils_2IndexingUtils_8h_source.html#l00187">mlir::applyPermutationToVector()</a>, <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00217">mlir::computePermutationVector()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Transforms_8cpp_source.html#l00046">DBGS</a>, <a class="el" href="Transforms_8cpp_source.html#l00047">DBGSNL</a>, <a class="el" href="Builders_8cpp_source.html#l00121">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Linalg_2Utils_2IndexingUtils_8cpp_source.html#l00074">getMixedDimensions()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00049">mlir::tensor::getMixedSizes()</a>, <a class="el" href="PatternMatch_8h_source.html#l00597">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00266">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="Builders_8h_source.html#l00379">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00227">mlir::RankedTensorType::Builder::setShape()</a>.</p>

</div>
</div>
<a id="a962a46fba2ac497e30bb6d23fef35d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962a46fba2ac497e30bb6d23fef35d1a">&#9670;&nbsp;</a></span>makeAffineDimExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt; mlir::linalg::makeAffineDimExprs </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>num</code> <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> dimensions at positions [startIdx, startIdx + num) and increments <code>startIdx</code> to <code>startIdx + num</code>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l01780">1780</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00502">mlir::getAffineDimExpr()</a>.</p>

</div>
</div>
<a id="aa9edcaadd998bad20bfb048ad9570c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9edcaadd998bad20bfb048ad9570c93">&#9670;&nbsp;</a></span>makeComposedPadHighOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::makeComposedPadHighOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RankedTensorType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>pad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nofold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a tensor::PadOp that pads <code>source</code> to the size of the statically sized <code>type</code> whose static sizes are assumed to be greater than the dynamic <code>source</code> size. </p>
<p>The padding introduces trailing <code>pad</code> values until the target size is met. If <code>source</code> is defined by one or more LinalgOps that have been padded with the same value and sizes, return their padded result instead of creating a tensor::PadOp.</p>
<p>Example: </p><div class="fragment"><div class="line">%0 = tensor.extract_slice %arg0 [%iv0, %iv1] [%sz0, %sz1]</div>
<div class="line">%1 = tensor.pad %0 low[0, 0] high[...] { tensor.yield %cst }</div>
<div class="line">%2 = linalg.matmul ins(...) outs(%1)</div>
<div class="line">%3 = tensor.extract_slice %2 [0, 0] [%sz0, %sz1]</div>
</div><!-- fragment --><p> makeComposedPadHighOp(source=%3, pad=cst) returns %2 makeComposedPadHighOp(source=%3, pad=other_cst) returns %4 </p><div class="fragment"><div class="line">%4 = tensor.pad %3 low[0, 0] high[...] { tensor.yield %other_cst }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00271">271</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00113">mlir::Value::cast()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00023">mlir::tensor::createPadHighOp()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00454">mlir::OpResult::getResultNumber()</a>, <a class="el" href="Matchers_8h_source.html#l00287">mlir::m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00378">mlir::matchPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transforms_8cpp_source.html#l00056">padOperandToSmallestStaticBoundingBox()</a>.</p>

</div>
</div>
<a id="a30703b58e97c9678d9ee3d95c1b31f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30703b58e97c9678d9ee3d95c1b31f5d">&#9670;&nbsp;</a></span>makeMemRefCopyOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GenericOp mlir::linalg::makeMemRefCopyOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns GenericOp that copies an n-D memref. </p>
<p>Unlike the current implementation of memref::CopyOp, this op can further tile, lower to loops or vectorize. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00368">368</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00321">mlir::Type::cast()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00262">mlir::AffineMap::getMultiDimIdentityMap()</a>, and <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a8144efefcad502e511c24aa5ce5b36e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8144efefcad502e511c24aa5ce5b36e8">&#9670;&nbsp;</a></span>makeTiledLoopRanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a>, 4 &gt;, <a class="el" href="namespacemlir_1_1linalg.html#a2363d9b68019db04dbf0c710afe7f224">LoopIndexToRangeIndexMap</a> &gt; mlir::linalg::makeTiledLoopRanges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>allShapeSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>allTileSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00061">61</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00121">mlir::Builder::getIndexAttr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00332">mlir::AffineMap::getNumResults()</a>, <a class="el" href="Tiling_8cpp_source.html#l00048">isZero()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01361">mlir::affine::makeComposedFoldedMultiResultAffineApply()</a>.</p>

</div>
</div>
<a id="afb5778b3a8ef5ed7c94b0463a10519cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5778b3a8ef5ed7c94b0463a10519cf">&#9670;&nbsp;</a></span>makeTiledShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::makeTiledShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>valueToTile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>subShapeSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>omitPartialTileCheck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an extract_slice/subview op for a single <code>valueToTile</code> with <code>builder</code>. </p>
<p>This new operation extracts a tile of <code>valueToTile</code>, starting at offsets <code>lbs</code> and with sizes <code>subShapeSizes</code>. <code>omitPartialTileCheck</code> controls whether to omit the partial/boundary tile condition check in cases where we statically know that it is unnecessary. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00671">671</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00683">computeSliceParameters()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00650">materializeTiledShape()</a>.</p>

</div>
</div>
<a id="a1a5fecbf19090f24723800d371f08271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5fecbf19090f24723800d371f08271">&#9670;&nbsp;</a></span>makeTiledShapes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::makeTiledShapes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>valuesToTile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sizeBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>omitPartialTileCheck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates extract_slice/subview ops for all <code>valuesToTile</code> of the given <code>linalgOp</code> with <code>builder</code>, assuming <code>linalgOp</code> is being fused into a loop nest for tiling with the given induction variables <code>ivs</code> and tile sizes <code>tileSizes</code>. </p>
<p><code>sizeBounds</code> are the iteration space bounds for <em>all</em> the implicit loops in <code>linalgOp</code>. <code>omitPartialTileCheck</code> controls whether to omit the partial/boundary tile condition check in cases where we statically know that it is unnecessary.</p>
<p>Note that a constant zero in <code>tileSizes</code> means no tiling at that implicit loop. The number of non-zero values in <code>tileSizes</code> should be equal to the number of values in <code>ivs</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00909">909</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00858">computeAllSliceParameters()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00650">materializeTiledShape()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00113">fuse()</a>, and <a class="el" href="FusionOnTensors_8cpp_source.html#l00129">getTiledProducer()</a>.</p>

</div>
</div>
<a id="a5cad527515e5ab07ddc46d539c915916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cad527515e5ab07ddc46d539c915916">&#9670;&nbsp;</a></span>makeTransposeOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GenericOp mlir::linalg::makeTransposeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>inputTensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>outputTensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>transposeVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a GenericOp that transposes <code>inputTensor</code> into <code>outputTensor</code> using <code>transposeVector</code> to permute the <code>inputTensor</code> dimensions. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00331">331</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00321">mlir::Type::cast()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00262">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00212">mlir::AffineMap::getPermutationMap()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00667">mlir::inversePermutation()</a>, <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00204">mlir::isPermutationVector()</a>, <a class="el" href="IR_2Region_8h_source.html#l00061">mlir::Region::push_back()</a>, and <a class="el" href="Builders_8h_source.html#l00417">mlir::OpBuilder::setInsertionPointToEnd()</a>.</p>

<p class="reference">Referenced by <a class="el" href="HoistPadding_8cpp_source.html#l00937">hoistPaddingOnTensors()</a>.</p>

</div>
</div>
<a id="a1eb02fa2fc529a0f22670a3d3b7972cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb02fa2fc529a0f22670a3d3b7972cc">&#9670;&nbsp;</a></span>maskedVectorize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; vector::TransferWriteOp &gt; mlir::linalg::maskedVectorize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp&#160;</td>
          <td class="paramname"><em>padOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>inputVectorSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vectorize a <code>padOp</code> with (1) static result type, (2) constant padding value and (3) all-zero lowPad to <code>transfer_write_in_bounds(transfer_read_masked(pad_source, pad_value))</code>. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01411">1411</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00070">mlir::Builder::getI1Type()</a>, <a class="el" href="Linalg_2Utils_2IndexingUtils_8cpp_source.html#l00074">getMixedDimensions()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00044">LDBG</a>, <a class="el" href="namespacemlir_1_1vector.html#a4f68d86708480673ecc59b2714973a65">mlir::vector::maskOperation()</a>, <a class="el" href="PatternMatch_8h_source.html#l00597">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00266">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="Builders_8h_source.html#l00379">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="ac1706425d4f7a288d7296e0ba978b5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1706425d4f7a288d7296e0ba978b5c5">&#9670;&nbsp;</a></span>materializeTiledShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::materializeTiledShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>valueToTile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html">SliceParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>sliceParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00650">650</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Types_8h_source.html#l00311">mlir::Type::dyn_cast()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00180">mlir::linalg::SliceParameters::offsets</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00181">mlir::linalg::SliceParameters::sizes</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00182">mlir::linalg::SliceParameters::strides</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00671">makeTiledShape()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00909">makeTiledShapes()</a>.</p>

</div>
</div>
<a id="a917a655a236200d3202b07fb842561b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917a655a236200d3202b07fb842561b8">&#9670;&nbsp;</a></span>offsetIndices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::offsetIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>offests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the specified offsets to any <code>linalg.index</code> ops contained in the given <code>linalgOp</code>. </p>
<p>The offsets are provided in the same order as iteration space dimensions. Null offests are assumed to be zero. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00930">930</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00113">fuse()</a>, and <a class="el" href="FusionOnTensors_8cpp_source.html#l00129">getTiledProducer()</a>.</p>

</div>
</div>
<a id="a34bed319cb33ba0b063edefa38e27309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34bed319cb33ba0b063edefa38e27309">&#9670;&nbsp;</a></span>offsetIndices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::offsetIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>offests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00936">936</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00329">mlir::bindDims()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="UseDefLists_8h_source.html#l00040">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00057">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01333">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00232">mlir::RewriterBase::replaceOpWithIf()</a>, and <a class="el" href="Builders_8h_source.html#l00393">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

</div>
</div>
<a id="abd29d6299d2891ae1d092974bc1c4e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd29d6299d2891ae1d092974bc1c4e30">&#9670;&nbsp;</a></span>pack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a> &gt; mlir::linalg::pack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>packedSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implement packing of a single LinalgOp by <code>packedSizes</code>. </p>
<p>Implement packing of a single LinalgOp by performing packing by <code>packedSizes</code>.</p>
<p>There must be one packedSizes entry per <code>linalgOp</code> iterator. Return the packed Linalg op on success, failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="Transforms_8cpp_source.html#l00736">736</a> of file <a class="el" href="Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Transforms_8cpp_source.html#l00046">DBGS</a>, <a class="el" href="Transforms_8cpp_source.html#l00047">DBGSNL</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00117">mlir::getConstantIntValue()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00024">mlir::getElementTypeOrSelf()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00648">mlir::Operation::getRegion()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, <a class="el" href="classmlir_1_1ValueRange.html#ab8f3a1aeea4da0acfaad1bc71b072017">mlir::ValueRange::getTypes()</a>, <a class="el" href="Builders_8cpp_source.html#l00318">mlir::Builder::getZeroAttr()</a>, <a class="el" href="PatternMatch_8h_source.html#l00597">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="Transforms_8cpp_source.html#l00409">packLinalgMetadataOnce()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00266">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00241">mlir::Region::takeBody()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgTransformOps_8cpp_source.html#l01087">packMatmulGreedily()</a>.</p>

</div>
</div>
<a id="aedb917cff90a2d440ccad06d225fa26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb917cff90a2d440ccad06d225fa26a">&#9670;&nbsp;</a></span>packTranspose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1PackTransposeResult.html">PackTransposeResult</a> &gt; mlir::linalg::packTranspose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PackOp&#160;</td>
          <td class="paramname"><em>packOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::UnPackOp&#160;</td>
          <td class="paramname"><em>maybeUnPackOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>outerPerm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>innerPerm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transpose a single PackOp -&gt; LinalgOp -&gt; UnPackOp chain and return the transposed PackOp -&gt; LinalgOp -&gt; UnPackOp chain after replacements. </p>
<p>Return failure if either:</p><ol type="1">
<li>the <code>packOp</code> does not have the <code>linalgOp</code> as its unique use.</li>
<li>the <code>maybeUnPackOp</code>, if specified must be a consumer of the result tied to the unique <code>packOp</code> use.</li>
<li><code>outerPerm</code> (resp. <code>innerPerm</code>) must be valid permutations of <code>packOp.getOuterDimsPerm</code> (resp. <code>packOp.getInnerDimsPerm</code>) or empty. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Transforms_8cpp_source.html#l00917">917</a> of file <a class="el" href="Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00212">mlir::OpOperand::getOperandNumber()</a>, <a class="el" href="UseDefLists_8h_source.html#l00040">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00204">mlir::isPermutationVector()</a>, <a class="el" href="PatternMatch_8h_source.html#l00597">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00266">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="Builders_8h_source.html#l00379">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="Transforms_8cpp_source.html#l00872">transposeOneLinalgOperandAndReplace()</a>.</p>

</div>
</div>
<a id="ac8c1ec48c56c585df31bf47f8a19c341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c1ec48c56c585df31bf47f8a19c341">&#9670;&nbsp;</a></span>padAndHoistLinalgOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; LinalgOp &gt; mlir::linalg::padAndHoistLinalgOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">LinalgPaddingOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply padding and hoisting to <code>linalgOp</code> according to the configuration specified in <code>options</code>. </p>

<p class="definition">Definition at line <a class="el" href="Transforms_8cpp_source.html#l00285">285</a> of file <a class="el" href="Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="UseDefLists_8h_source.html#l00137">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00937">hoistPaddingOnTensors()</a>, <a class="el" href="PatternMatch_8h_source.html#l00597">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00266">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="Transforms_8cpp_source.html#l00184">rewriteAsPaddedOp()</a>.</p>

</div>
</div>
<a id="ae273bd1d7e48f4503eefba4f1487fa56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae273bd1d7e48f4503eefba4f1487fa56">&#9670;&nbsp;</a></span>peelLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::peelLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to peel and canonicalize loop <code>op</code> and return the new result. </p>
<p>Also applies affine_min/max bounds simplification on the fly where relevant. </p>

<p class="definition">Definition at line <a class="el" href="Transforms_8cpp_source.html#l00258">258</a> of file <a class="el" href="Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transforms_8cpp_source.html#l00274">peelLoops()</a>.</p>

</div>
</div>
<a id="a5faa18744febf8ff36b38176ca04d8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5faa18744febf8ff36b38176ca04d8fc">&#9670;&nbsp;</a></span>peelLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::peelLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peel 'loops' and applies affine_min/max bounds simplification on the fly where relevant. </p>

<p class="definition">Definition at line <a class="el" href="Transforms_8cpp_source.html#l00274">274</a> of file <a class="el" href="Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="Transforms_8cpp_source.html#l00258">peelLoop()</a>.</p>

</div>
</div>
<a id="a18fce962e3d12d2dfc3b467076c71f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18fce962e3d12d2dfc3b467076c71f39">&#9670;&nbsp;</a></span>populateBubbleUpExtractSliceOpPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateBubbleUpExtractSliceOpPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns that are used to bubble up extract slice op above linalg op. </p>

<p class="definition">Definition at line <a class="el" href="BubbleUpExtractSlice_8cpp_source.html#l00134">134</a> of file <a class="el" href="BubbleUpExtractSlice_8cpp_source.html">BubbleUpExtractSlice.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a8ef1d681922add4fcf065a64d713c3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef1d681922add4fcf065a64d713c3b5">&#9670;&nbsp;</a></span>populateCollapseDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateCollapseDimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#adfcecb6fc18af7e6d462f3a904c73733">GetCollapsableDimensionsFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlCollapseDimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to collapse dimensions in a linalg.generic op. </p>
<p>This will collapse tensor operands when needed and expand back the result tensors. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01836">1836</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ad0b142daa69f3f2b8986960b726ba2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b142daa69f3f2b8986960b726ba2eb">&#9670;&nbsp;</a></span>populateConstantFoldLinalgOperations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateConstantFoldLinalgOperations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to constant fold Linalg operations. </p>

<p class="definition">Definition at line <a class="el" href="ConstantFold_8cpp_source.html#l00304">304</a> of file <a class="el" href="ConstantFold_8cpp_source.html">ConstantFold.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01734">mlir::RewritePatternSet::insert()</a>.</p>

</div>
</div>
<a id="a1e349c4f7a13b98a31f89dec948c5533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e349c4f7a13b98a31f89dec948c5533">&#9670;&nbsp;</a></span>populateConvertConv2DToImg2ColPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateConvertConv2DToImg2ColPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns to transform linalg.conv_2d_xxx operations into linalg.generic (for img2col packing) and linalg.matmul. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacemlir_1_1linalg.html#a0e2c1f265ce47a53398eab6e8f18b30c" title="Convert linalg.conv_2d_nhwc_hwcf into linalg.generic (for img2col packing) and linalg....">rewriteInIm2Col</a> for more details. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00536">536</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01734">mlir::RewritePatternSet::insert()</a>.</p>

</div>
</div>
<a id="a68f8e903a075470f95fa853892083469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f8e903a075470f95fa853892083469">&#9670;&nbsp;</a></span>populateConvertToDestinationStylePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateConvertToDestinationStylePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns that convert non-destination-style ops to destination style ops. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00378">378</a> of file <a class="el" href="ConvertToDestinationStyle_8cpp_source.html">ConvertToDestinationStyle.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="a891b8f2d145dcc3327ba55c7a49d44e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891b8f2d145dcc3327ba55c7a49d44e4">&#9670;&nbsp;</a></span>populateConvolutionVectorizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateConvolutionVectorizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns for vectorizing low-D convolution ops. </p>
<p>This is a step in progressive lowering for convolution ops, it assume high-D convolution ops were decomposed previously. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l02955">2955</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a3e0c4216814c93fb83b999f3f4923f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e0c4216814c93fb83b999f3f4923f7d">&#9670;&nbsp;</a></span>populateDataLayoutPropagationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateDataLayoutPropagationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#a3729e968453a5f63415044c66e5255c5">ControlPropagationFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlPackUnPackPropagation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to bubble up or down data layout ops across other operations. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutPropagation_8cpp_source.html#l00688">688</a> of file <a class="el" href="DataLayoutPropagation_8cpp_source.html">DataLayoutPropagation.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01734">mlir::RewritePatternSet::insert()</a>.</p>

</div>
</div>
<a id="a887c3b461640ae2783747a1c89726203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887c3b461640ae2783747a1c89726203">&#9670;&nbsp;</a></span>populateDecomposeConvolutionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateDecomposeConvolutionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linalg decompose convolutions patterns. </p>
<p>Populates patterns to decompose high-D convolution ops into low-D ones. This is a step in progressive lowering for convolution ops, afterwards we can vectorize the low-D convolution ops. </p>

<p class="definition">Definition at line <a class="el" href="Transforms_8cpp_source.html#l01744">1744</a> of file <a class="el" href="Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="aad6f59ca20a1e8ce21c3c29916aec917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6f59ca20a1e8ce21c3c29916aec917">&#9670;&nbsp;</a></span>populateDecomposeLinalgOpsPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateDecomposeLinalgOpsPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeDeadArgsAndResults</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns for splitting a <code>LinalgOp</code> with multiple statements within its payload into multiple <code>GenericOp</code> that have a single statement. </p>
<p>The option <code>removeDeadArgsAndResults</code> adds patterns to remove dead arguments and results from the generated decomposed ops. This is default <code>true</code> since the core decomposition patterns relies on these clean up patterns. It is set to false only for testing purposes. </p>

<p class="definition">Definition at line <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00379">379</a> of file <a class="el" href="DecomposeLinalgOps_8cpp_source.html">DecomposeLinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>, <a class="el" href="PatternMatch_8h_source.html#l01734">mlir::RewritePatternSet::insert()</a>, and <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00414">populateEraseUnusedOperandsAndResultsPatterns()</a>.</p>

</div>
</div>
<a id="af537f75332b531f2f627083684c201e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af537f75332b531f2f627083684c201e4">&#9670;&nbsp;</a></span>populateElementwiseOpsFusionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateElementwiseOpsFusionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlElementwiseOpFusion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns for fusing linalg operation on tensors. </p>
<p><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to fuse <code>linalg.generic</code> -&gt; <code>linalg.generic</code> operations when both operations are fusable elementwise operations. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01825">1825</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00414">populateEraseUnusedOperandsAndResultsPatterns()</a>.</p>

</div>
</div>
<a id="a7a49133ef595966377878adc42196f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a49133ef595966377878adc42196f47">&#9670;&nbsp;</a></span>populateElementwiseToLinalgConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateElementwiseToLinalgConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns that convert <code>ElementwiseMappable</code> ops to linalg parallel loops. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00120">120</a> of file <a class="el" href="ElementwiseToLinalg_8cpp_source.html">ElementwiseToLinalg.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="abe6e2c64c65b1a22b1794d731be0c612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6e2c64c65b1a22b1794d731be0c612">&#9670;&nbsp;</a></span>populateEraseUnnecessaryInputsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateEraseUnnecessaryInputsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to promote inputs to outputs and remove unused inputs of <code>linalg.generic</code> ops. </p>

<p class="definition">Definition at line <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00421">421</a> of file <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html">EraseUnusedOperandsAndResults.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01734">mlir::RewritePatternSet::insert()</a>.</p>

</div>
</div>
<a id="a9cbdbb9ec2d0ed200d6a679ffd803c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbdbb9ec2d0ed200d6a679ffd803c7e">&#9670;&nbsp;</a></span>populateEraseUnusedOperandsAndResultsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateEraseUnusedOperandsAndResultsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to remove dead operands and results of <code>linalg.generic</code> operations. </p>
<p>This is effectively DCE for a linalg op. </p>

<p class="definition">Definition at line <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00414">414</a> of file <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html">EraseUnusedOperandsAndResults.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01734">mlir::RewritePatternSet::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00379">populateDecomposeLinalgOpsPattern()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01825">populateElementwiseOpsFusionPatterns()</a>.</p>

</div>
</div>
<a id="af91bb4884dcdcdd946fbc19b8a313482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af91bb4884dcdcdd946fbc19b8a313482">&#9670;&nbsp;</a></span>populateExtractOpVectorizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateExtractOpVectorizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>baseBenefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c8bdabd42dfb2f3617cc87eccfa4199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8bdabd42dfb2f3617cc87eccfa4199">&#9670;&nbsp;</a></span>populateFoldReshapeOpsByCollapsingPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateFoldReshapeOpsByCollapsingPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlFoldingReshapes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold an expanding tensor.expand_shape operation with its producer generic operation by collapsing the dimensions of the generic op. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01818">1818</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ac73f0e4d33b9691f06d722f2146c4a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73f0e4d33b9691f06d722f2146c4a66">&#9670;&nbsp;</a></span>populateFoldReshapeOpsByExpansionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateFoldReshapeOpsByExpansionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlFoldingReshapes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold an expanding (collapsing) tensor_reshape operation with its producer (consumer) generic operation by expanding the dimensionality of the loop in the generic op. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01809">1809</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a240f21341db0a0eb9a0051683864a484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240f21341db0a0eb9a0051683864a484">&#9670;&nbsp;</a></span>populateFoldUnitExtentDimsViaReshapesPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateFoldUnitExtentDimsViaReshapesPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold unit-extent dimensions in operands/results of linalg ops on tensors via reassociative reshape ops. </p>
<p>Patterns that are used to canonicalize the use of unit-extent dims for broadcasting. </p>

<p class="definition">Definition at line <a class="el" href="DropUnitDims_8cpp_source.html#l00664">664</a> of file <a class="el" href="DropUnitDims_8cpp_source.html">DropUnitDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>, <a class="el" href="EmptyOpPatterns_8cpp_source.html#l00069">mlir::tensor::populateFoldTensorEmptyPatterns()</a>, <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00124">mlir::memref::populateResolveRankedShapeTypeResultDimsPatterns()</a>, and <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00131">mlir::memref::populateResolveShapedTypeResultDimsPatterns()</a>.</p>

</div>
</div>
<a id="ae90aac103dc48569168f968d41cca91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90aac103dc48569168f968d41cca91c">&#9670;&nbsp;</a></span>populateFoldUnitExtentDimsViaSlicesPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateFoldUnitExtentDimsViaSlicesPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold unit-extent dimensions in operands/results of linalg ops on tensors via rank-reducing slices. </p>

<p class="definition">Definition at line <a class="el" href="DropUnitDims_8cpp_source.html#l00683">683</a> of file <a class="el" href="DropUnitDims_8cpp_source.html">DropUnitDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>, <a class="el" href="EmptyOpPatterns_8cpp_source.html#l00069">mlir::tensor::populateFoldTensorEmptyPatterns()</a>, <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00124">mlir::memref::populateResolveRankedShapeTypeResultDimsPatterns()</a>, and <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00131">mlir::memref::populateResolveShapedTypeResultDimsPatterns()</a>.</p>

</div>
</div>
<a id="a0e0b4c454598e4be0bd0fcde89783a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0b4c454598e4be0bd0fcde89783a20">&#9670;&nbsp;</a></span>populateFuseTensorPadWithProducerLinalgOpPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateFuseTensorPadWithProducerLinalgOpPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to fuse a <code>tensor.pad</code> operation with the producer of its source, if the producer is a <code>linalg</code> operation with all parallel iterator types. </p>

<p class="definition">Definition at line <a class="el" href="FusePadOpWithLinalgProducer_8cpp_source.html#l00121">121</a> of file <a class="el" href="FusePadOpWithLinalgProducer_8cpp_source.html">FusePadOpWithLinalgProducer.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="acc64a8c8a9ecf3de84383893d8e4ddc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc64a8c8a9ecf3de84383893d8e4ddc2">&#9670;&nbsp;</a></span>populateInlineConstantOperandsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateInlineConstantOperandsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns that are used to inline constant operands into linalg generic ops. </p>

<p class="definition">Definition at line <a class="el" href="InlineScalarOperands_8cpp_source.html#l00094">94</a> of file <a class="el" href="InlineScalarOperands_8cpp_source.html">InlineScalarOperands.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a0419b15db70f16465aec05d8f86f6e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0419b15db70f16465aec05d8f86f6e4e">&#9670;&nbsp;</a></span>populateLinalgNamedOpConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateLinalgNamedOpConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to convert from one named op to another. </p>
<p>These can be seen as canonicalizations of named ops into another named op. </p>

<p class="definition">Definition at line <a class="el" href="NamedOpConversions_8cpp_source.html#l00160">160</a> of file <a class="el" href="NamedOpConversions_8cpp_source.html">NamedOpConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ada9bb5c9c8ef1aadbbc563431443b5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9bb5c9c8ef1aadbbc563431443b5e2">&#9670;&nbsp;</a></span>populateLinalgNamedOpsGeneralizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateLinalgNamedOpsGeneralizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linalg generalization patterns. </p>
<p>Populates <code>patterns</code> with patterns to convert spec-generated named ops to linalg.generic ops. </p>

<p class="definition">Definition at line <a class="el" href="Generalization_8cpp_source.html#l00091">91</a> of file <a class="el" href="Generalization_8cpp_source.html">Generalization.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a4701ad0fa2e34da0089a80135935f02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4701ad0fa2e34da0089a80135935f02e">&#9670;&nbsp;</a></span>populateLinalgTilingCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateLinalgTilingCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00969">969</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00963">getLinalgTilingCanonicalizationPatterns()</a>.</p>

</div>
</div>
<a id="a703d4f21c6f57b8c680dc20dd6928a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703d4f21c6f57b8c680dc20dd6928a61">&#9670;&nbsp;</a></span>populateLinalgToStandardConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateLinalgToStandardConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Linalg to Standard. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToStandard_8cpp_source.html#l00127">127</a> of file <a class="el" href="LinalgToStandard_8cpp_source.html">LinalgToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a042bb54cd9155ed1ca8818a16ab5110a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042bb54cd9155ed1ca8818a16ab5110a">&#9670;&nbsp;</a></span>populateMoveInitOperandsToInputPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateMoveInitOperandsToInputPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pattern that converts init operands to input operands. </p>

<p class="definition">Definition at line <a class="el" href="DropUnitDims_8cpp_source.html#l00697">697</a> of file <a class="el" href="DropUnitDims_8cpp_source.html">DropUnitDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a43c2ef8a778a33a17885475c11b50bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c2ef8a778a33a17885475c11b50bdd">&#9670;&nbsp;</a></span>populatePadOpVectorizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populatePadOpVectorizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>baseBenefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>patterns</code> with patterns that vectorize tensor.pad. </p>
<p>These patterns are meant to apply in a complementary fashion. Benefits are used to encode a certain ordering of pattern application. To avoid scattering magic constants throughout the code base, the patterns must be added with this function. <code>baseBenefit</code> can be used to offset the benefit of all tensor::PadOp vectorization patterns by a certain value. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01995">1995</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00023">mlir::PatternBenefit::getBenefit()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a9e855c782e575c2b31e13e7d36b22390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e855c782e575c2b31e13e7d36b22390">&#9670;&nbsp;</a></span>populatePadTensorTilingPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populatePadTensorTilingPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00997">997</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="a49366865f5ce183ae19888eceb6667e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49366865f5ce183ae19888eceb6667e5">&#9670;&nbsp;</a></span>populateSparseTensorRewriting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateSparseTensorRewriting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns that are only useful in the context of sparse tensors. </p>

</div>
</div>
<a id="a0c26bb1f203c97b9d5bcf9b8ae6ea102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c26bb1f203c97b9d5bcf9b8ae6ea102">&#9670;&nbsp;</a></span>populateSplitReductionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateSplitReductionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">ControlSplitReductionFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlSplitReductionFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAlloc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to apply <code>splitReduction</code> below. </p>

<p class="definition">Definition at line <a class="el" href="SplitReduction_8cpp_source.html#l00447">447</a> of file <a class="el" href="SplitReduction_8cpp_source.html">SplitReduction.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ac8003a713f74f7a32cc681c245ae9708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8003a713f74f7a32cc681c245ae9708">&#9670;&nbsp;</a></span>populateSwapExtractSliceWithFillPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateSwapExtractSliceWithFillPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds patterns that waps tensor.extract_slice(linalg.fill(cst, init)) into linalg.fill(cst, tensor.extract_slice(init)). </p>

<p class="definition">Definition at line <a class="el" href="SwapExtractSliceWithFillPatterns_8cpp_source.html#l00038">38</a> of file <a class="el" href="SwapExtractSliceWithFillPatterns_8cpp_source.html">SwapExtractSliceWithFillPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a52323b7c688e08d502b988597580fd37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52323b7c688e08d502b988597580fd37">&#9670;&nbsp;</a></span>promoteSubviewAsNewBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">PromotionInfo</a> &gt; mlir::linalg::promoteSubviewAsNewBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::SubViewOp&#160;</td>
          <td class="paramname"><em>subView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#a1bcbad447f843c9b98886ad6f49469a9">AllocBufferCallbackFn</a> &amp;&#160;</td>
          <td class="paramname"><em>allocationFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00213">213</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8h_source.html#l00501">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Builders_8cpp_source.html#l00121">mlir::Builder::getIndexAttr()</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00057">mlir::getValueOrCreateConstantIndexOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Promotion_8cpp_source.html#l00265">promoteSubViews()</a>.</p>

</div>
</div>
<a id="acd639dc165f0ab64ec7afbac992c4d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd639dc165f0ab64ec7afbac992c4d65">&#9670;&nbsp;</a></span>promoteSubViews()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; LinalgOp &gt; mlir::linalg::promoteSubViews </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promote the <code>subViews</code> into a new buffer allocated at the insertion point <code>b</code>. </p>
<p>Promotion occurs in 3 steps:</p><ol type="1">
<li>Create a new buffer for a full tile (i.e. not clipped at the boundary).</li>
<li>Take a full view on the buffer.</li>
<li>Take a partial slice of the full view in step 2. and copy into it.</li>
</ol>
<p>Return the modified linalg op (the modification happens in place) as well as all the copy ops created. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00395">395</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, and <a class="el" href="Promotion_8cpp_source.html#l00265">promoteSubViews()</a>.</p>

</div>
</div>
<a id="a850b9fd11404efe17bca02011aff2e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850b9fd11404efe17bca02011aff2e88">&#9670;&nbsp;</a></span>promoteSubviewsPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::promoteSubviewsPrecondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promote memref.subviews feeding linalg-on-buffers operations. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00373">373</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

</div>
</div>
<a id="ab570ed1db81a641eb5b3d9948775e517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab570ed1db81a641eb5b3d9948775e517">&#9670;&nbsp;</a></span>registerBufferizableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::registerBufferizableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00126">126</a> of file <a class="el" href="Linalg_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html">BufferizableOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00087">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="ae430d8314310084f3bfae3c0de4081dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae430d8314310084f3bfae3c0de4081dd">&#9670;&nbsp;</a></span>registerTilingInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::registerTilingInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TilingInterfaceImpl_8cpp_source.html#l00420">420</a> of file <a class="el" href="TilingInterfaceImpl_8cpp_source.html">TilingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="TilingInterfaceImpl_8cpp_source.html#l00414">registerAll()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00087">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a0ac2b4190e764bf1951b6e077e2e7ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac2b4190e764bf1951b6e077e2e7ce6">&#9670;&nbsp;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectExtension_8cpp_source.html#l00056">56</a> of file <a class="el" href="DialectExtension_8cpp_source.html">DialectExtension.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00185">mlir::DialectRegistry::addExtensions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00087">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a5e756b2e152d167af6823f8fb6298933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e756b2e152d167af6823f8fb6298933">&#9670;&nbsp;</a></span>registerValueBoundsOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::registerValueBoundsOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00064">64</a> of file <a class="el" href="Linalg_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html">ValueBoundsOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00087">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a724e74361e155d68bd8690902548e91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724e74361e155d68bd8690902548e91a">&#9670;&nbsp;</a></span>rewriteAsPaddedOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt; mlir::linalg::rewriteAsPaddedOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>opToPad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>paddingDimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>paddingValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>packPaddings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp &amp;&#160;</td>
          <td class="paramname"><em>paddedOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pad the iterator dimensions <code>paddingDimensions</code> of all <code>opToPad</code> operands to a static bounding box. </p>
<p>Use <code>paddingValues</code> and <code>packPaddings</code> to set padding value and nofold attribute of the created tensor::PadOps, respectively. Update <code>paddedOp</code> to the cloned operation with statically shaped <code>paddingDimensions</code> and return the extracted dynamically shaped results. If padding fails, return failure. </p>

<p class="definition">Definition at line <a class="el" href="Transforms_8cpp_source.html#l00184">184</a> of file <a class="el" href="Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00321">mlir::Type::cast()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00099">mlir::clone()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Transforms_8cpp_source.html#l00046">DBGS</a>, <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="Builders_8cpp_source.html#l00121">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, <a class="el" href="classmlir_1_1ValueRange.html#ab8f3a1aeea4da0acfaad1bc71b072017">mlir::ValueRange::getTypes()</a>, <a class="el" href="PatternMatch_8h_source.html#l00597">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="Transforms_8cpp_source.html#l00056">padOperandToSmallestStaticBoundingBox()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00026">mlir::reifyResultShapes()</a>, and <a class="el" href="Builders_8h_source.html#l00393">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transforms_8cpp_source.html#l00285">padAndHoistLinalgOp()</a>.</p>

</div>
</div>
<a id="a5a579fdd0e468c7aec96f84d016c829e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a579fdd0e468c7aec96f84d016c829e">&#9670;&nbsp;</a></span>rewriteInDestinationPassingStyle() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::rewriteInDestinationPassingStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::FromElementsOp&#160;</td>
          <td class="paramname"><em>fromElementsOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite tensor.from_elements to linalg.generic. </p>
<p>Lower tensor.from_elements to a sequence of chained tensor.insert. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00205">205</a> of file <a class="el" href="ConvertToDestinationStyle_8cpp_source.html">ConvertToDestinationStyle.cpp</a>.</p>

<p class="reference">References <a class="el" href="Location_8h_source.html#l00089">mlir::Location::cast()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00034">createInserts()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00266">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00482">mlir::RewriterBase::replaceOpWithNewOp()</a>.</p>

</div>
</div>
<a id="ab2e500c4bf906d65572af9b3d2982852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e500c4bf906d65572af9b3d2982852">&#9670;&nbsp;</a></span>rewriteInDestinationPassingStyle() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::rewriteInDestinationPassingStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::GenerateOp&#160;</td>
          <td class="paramname"><em>generateOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite tensor.generate to linalg.generic. </p>
<p>Lower tensor.generate to linalg.generic. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00243">243</a> of file <a class="el" href="ConvertToDestinationStyle_8cpp_source.html">ConvertToDestinationStyle.cpp</a>.</p>

<p class="reference">References <a class="el" href="Location_8h_source.html#l00089">mlir::Location::cast()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8cpp_source.html#l00405">mlir::OpBuilder::createBlock()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Builders_8cpp_source.html#l00362">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00356">mlir::RewriterBase::mergeBlocks()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00266">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00482">mlir::RewriterBase::replaceOpWithNewOp()</a>, and <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="acf3e743297fd7a20a30c7c4e39608fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3e743297fd7a20a30c7c4e39608fbc">&#9670;&nbsp;</a></span>rewriteInDestinationPassingStyle() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::rewriteInDestinationPassingStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp&#160;</td>
          <td class="paramname"><em>padOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite tensor.pad to linalg.generic + tensor.insert_slice. </p>
<p>Lower tensor.pad to linalg.generic + tensor.insert_slice. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00284">284</a> of file <a class="el" href="ConvertToDestinationStyle_8cpp_source.html">ConvertToDestinationStyle.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Builders_8cpp_source.html#l00121">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00049">mlir::tensor::getMixedSizes()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00018">mlir::isZeroIndex()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00056">movePaddingToFillOrGenericOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00597">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00026">mlir::reifyResultShapes()</a>, <a class="el" href="PatternMatch_8h_source.html#l00482">mlir::RewriterBase::replaceOpWithNewOp()</a>, and <a class="el" href="Builders_8h_source.html#l00393">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

</div>
</div>
<a id="ad43dfb86d76bed86ecd1117849e5b6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43dfb86d76bed86ecd1117849e5b6f4">&#9670;&nbsp;</a></span>rewriteInIm2Col() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt; mlir::linalg::rewriteInIm2Col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::Conv2DNchwFchwOp&#160;</td>
          <td class="paramname"><em>convOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to rewriteInIm2Col with linalg::Conv2DNhwcHwcfOp except because the channels are to the left of the image shape dimensions, the position of the contraction dimension in the resulting matmul is reversed. </p>
<p>This swaps the LHS and RHS of the matmul when compared with nhwc (i.e. (D, C x Kh x Kw) * (C x Kh x Kw, Ho x Wo)) </p>

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00362">362</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00329">mlir::bindDims()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00031">createAdd()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00038">createMul()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01135">mlir::AffineMap::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00066">getConvolvedIndex()</a>, <a class="el" href="Value_8cpp_source.html#l00026">mlir::Value::getLoc()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00262">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00026">hasAllOneValues()</a>, <a class="el" href="PatternMatch_8h_source.html#l00597">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00266">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00051">unrollIndex()</a>.</p>

</div>
</div>
<a id="a0e2c1f265ce47a53398eab6e8f18b30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2c1f265ce47a53398eab6e8f18b30c">&#9670;&nbsp;</a></span>rewriteInIm2Col() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt; mlir::linalg::rewriteInIm2Col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::Conv2DNhwcHwcfOp&#160;</td>
          <td class="paramname"><em>convOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert linalg.conv_2d_nhwc_hwcf into linalg.generic (for img2col packing) and linalg.matmul. </p>
<p>A convolution operation can be written as a matrix-matrix multiplication by unfolding the cross-correlation between input and filter and explicitly copy overlapped sliding window inputs.</p>
<p>Consider 2D input X with single channel input and output and 2x2 filter W: [x(0, 0) , x(0, 1) , ..., x(0, n) ] [x(1, 0) , x(1, 1) , ..., x(1, n) ] [. , . ,. , . ] [w(0, 0), w(0, 1)] [. , . , . , . ] (conv) [w(1, 0), w(1, 1)] [. , . , ., . ] [x(n-1, 0), x(n-1, 1), ..., x(n-1, n-1)]</p>
<p>The packed input data (img2col) is a matrix with |rows| = output spatial size, |columns| = filter spatial size. To compute the output Y(i, j) we need to calculate the dot product between filter window at input X(x, y)) and the filter which will look like the following where r.h.s is the img2col matrix and l.h.s is the flattened filter:</p>
<p>[x(0,0), x(0,1), x(1,0), x(1,1)] [x(0,1), x(1,1), x(0,2), x(1,2)] (matmul) [w(0,0), w(0,1), w(1,0), w(1,1)] [x(0,1), x(1,1), x(0,2), x(1,2)] [ . , . , . , . ]</p>
<p>In general for 2D case with (N, H, W, C) input and (Kh, Kw, C, D) filter and output (N, Ho, Wo, D) the convolution is the following matrix-matrix multiplication (Ho x Wo, Kh x Kw x C) * (Kh x Kw x C, D) for each input in the N input. For the case where N &gt; 1 its a batched matrix-matrix multiplication.</p>
<p>On success, return both the operation that produces the img2col tensor and the final operation of the sequence that replaces the original convolution. </p>

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00076">76</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00329">mlir::bindDims()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00031">createAdd()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00038">createMul()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01135">mlir::AffineMap::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00066">getConvolvedIndex()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00262">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00026">hasAllOneValues()</a>, <a class="el" href="PatternMatch_8h_source.html#l00597">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00266">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00051">unrollIndex()</a>.</p>

</div>
</div>
<a id="a49f61511bb9ed963c3eeb360bfdb1a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f61511bb9ed963c3eeb360bfdb1a6a">&#9670;&nbsp;</a></span>rewriteInIm2Col() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt; mlir::linalg::rewriteInIm2Col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::DepthwiseConv2DNhwcHwcOp&#160;</td>
          <td class="paramname"><em>convOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to rewriteInIm2Col with linalg::Conv2DNhwcHwcfOp except there is no reduction among the input channels so each convolution can be a matrix-vector product and by transposing both input filter so channels are outer most the computation is a batched matrix-vector product. </p>

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00211">211</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00329">mlir::bindDims()</a>, <a class="el" href="IR_2Types_8h_source.html#l00321">mlir::Type::cast()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01135">mlir::AffineMap::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00347">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00339">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00262">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00402">mlir::Operation::getResult()</a>, <a class="el" href="Traits_8cpp_source.html#l00118">getShape()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00026">hasAllOneValues()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00667">mlir::inversePermutation()</a>, <a class="el" href="PatternMatch_8h_source.html#l00597">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00266">mlir::RewriterBase::replaceOp()</a>.</p>

</div>
</div>
<a id="af025e45095e64f984901c4f65fa3c72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af025e45095e64f984901c4f65fa3c72f">&#9670;&nbsp;</a></span>splitOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; TilingInterface, TilingInterface &gt; mlir::linalg::splitOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>splitPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given <code>op</code> into two parts along the given iteration space <code>dimension</code> at the specified <code>splitPoint</code>, and return the two parts. </p>
<p>If the second part is statically known to be empty, do not create it and return nullptr instead. Error state is signalled by returning a pair of nullptrs.</p>
<p>For example, the following op:</p>
<p>linalg.matmul ins(%0, %1 : tensor&lt;128x32xf32&gt;, tensor&lt;32x64xf32&gt;) outs(%2 : tensor&lt;128x64xf32&gt;)</p>
<p>split along the first dimension at position 42 will result in:</p>
<p>%3 = tensor.extract_slice %0[0, 0][42, 32][1, 1] %4 = tensor.extract_slice %2[0, 0][42, 64][1, 1] %5 = linalg.matmul ins(%3, %1 : tensor&lt;42x32xf32&gt;, tensor&lt;32x64xf32&gt;) outs(%5 : tensor&lt;42x64xf32&gt;) %6 = tensor.insert_slice %5 into %2[0, 0][42, 64][1, 1]</p>
<p>%7 = tensor.extract_slice %0[42, 0][86, 32][1, 1] %8 = tensor.extract_slice %6[42, 0][86, 64][1, 1] %9 = linalg.matmul ins(%7, %1 : tensor&lt;86x32xf32&gt;, tensor&lt;32x64xf32&gt;) outs(%8 : tensor&lt;86x64xf32&gt;) tensor.insert_slice %5 into %6[42, 0][86, 64][1, 1]</p>
<p>Note that there is no simplification other than constant propagation applied to slice extraction and insertion. </p>

<p class="definition">Definition at line <a class="el" href="Split_8cpp_source.html#l00067">67</a> of file <a class="el" href="Split_8cpp_source.html">Split.cpp</a>.</p>

</div>
</div>
<a id="aaa4f58f6a18fb7c9af60fb15122e0994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4f58f6a18fb7c9af60fb15122e0994">&#9670;&nbsp;</a></span>splitReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1SplitReductionResult.html">SplitReductionResult</a> &gt; mlir::linalg::splitReduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">ControlSplitReductionFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlSplitReductionFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAlloc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SplitReduction_8cpp_source.html#l00030">30</a> of file <a class="el" href="SplitReduction_8cpp_source.html">SplitReduction.cpp</a>.</p>

</div>
</div>
<a id="af87c3f5c965b8e271579136775d51ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87c3f5c965b8e271579136775d51ffc">&#9670;&nbsp;</a></span>splitReductionByScaling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1SplitReductionResult.html">SplitReductionResult</a> &gt; mlir::linalg::splitReductionByScaling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">ControlSplitReductionFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlSplitReductionFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAlloc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scaling-based implementation of the split reduction transformation. </p>
<p>Core rewrite implementation.</p>
<p>Instead of introducing an ExpandShapeOp, this rewrites a reduction dimension <code>k</code> into <code>k * scale + kk</code>.</p>
<p>Example: ``` %0 = linalg.matmul ins(A, B: tensor&lt;16x256xf32&gt;, tensor&lt;256x32xf32&gt;) outs(C: tensor&lt;16x32xf32&gt;) -&gt; tensor&lt;16x32xf32&gt; ```</p>
<p>Is transformed to:</p>
<p>``` #map0 = affine_map&lt;(d0, d1, d2, d3) -&gt; (d0, d2 * 4 + d3)&gt; #map1 = affine_map&lt;(d0, d1, d2, d3) -&gt; (d2 * 4 + d3, d1)&gt; #map2 = affine_map&lt;(d0, d1, d2, d3) -&gt; (d2, d3)&gt; #map3 = affine_map&lt;(d0, d1, d2, d3) -&gt; (d0, d1, d2)&gt; #map4 = affine_map&lt;(d0, d1, d2) -&gt; (d0, d1, d2)&gt; #map5 = affine_map&lt;(d0, d1, d2) -&gt; (d0, d1)&gt; %0 = tensor.empty [16, 32, 64] : tensor&lt;16x32x64xf32&gt; cst = arith.constant 0.000000e+00 : f32 %1 = linalg.fill ins(cst : f32) outs(%0 : tensor&lt;16x32x64xf32&gt;) -&gt; tensor&lt;16x32x64xf32&gt; %2 = tensor.empty [64, 4] : tensor&lt;64x4xi1&gt;</p>
<p>%3 = linalg.generic {indexing_maps = [#map0, #map1, #map2, #map3], iterator_types = ["parallel", "parallel", "parallel", "reduction"]} ins(A, B, %2 : tensor&lt;16x256xf32&gt;, tensor&lt;256x32xf32&gt;, tensor&lt;64x4xi1&gt;) outs(%1 : tensor&lt;16x32x64xf32&gt;) { ^bb0(arg3: f32, arg4: f32, arg5: i1, arg6: f32): %5 = arith.mulf arg3, arg4 : f32 %6 = arith.addf arg6, %5 : f32 linalg.yield %6 : f32 } -&gt; tensor&lt;16x32x64xf32&gt;</p>
<p>%4 = linalg.generic {indexing_maps = [#map4, #map5], iterator_types = ["parallel", "parallel", "reduction"]} */ // ins(%3 : tensor&lt;16x32x64xf32&gt;) /** outs(C : tensor&lt;16x32xf32&gt;) { ^bb0(arg3: f32, arg4: f32): %5 = arith.addf arg3, arg4 : f32 linalg.yield %5 : f32 } -&gt; tensor&lt;16x32xf32&gt;</p>
<p>return %4 : tensor&lt;16x32xf32&gt; ``` </p>

<p class="definition">Definition at line <a class="el" href="SplitReduction_8cpp_source.html#l00241">241</a> of file <a class="el" href="SplitReduction_8cpp_source.html">SplitReduction.cpp</a>.</p>

</div>
</div>
<a id="ac13050e75a64a26bf82a80b19006d0e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac13050e75a64a26bf82a80b19006d0e9">&#9670;&nbsp;</a></span>tileLinalgOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a> &gt; mlir::linalg::tileLinalgOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00842">842</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="FusionOnTensors_8cpp_source.html#l00275">mlir::linalg::TileLoopNest::tileRootOp()</a>.</p>

</div>
</div>
<a id="ab3085a8dbbf3c572b3279bdcc53dbe72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3085a8dbbf3c572b3279bdcc53dbe72">&#9670;&nbsp;</a></span>tileReductionUsingForall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1ForallReductionTilingResult.html">linalg::ForallReductionTilingResult</a> &gt; mlir::linalg::tileReductionUsingForall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PartialReductionOpInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; ArrayAttr &gt;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to tile a reduction to parallel iterations computing partial reductions. </p>
<p>After the loop all the partial reduction are merged into a final reduction. For example for the following sequence</p>
<div class="fragment"><div class="line">%0 = linalg.generic %in [&quot;parallel&quot;, &quot;reduction&quot;]</div>
<div class="line">  : tensor&lt;7x9xf32&gt; -&gt; tensor&lt;7xf32&gt;</div>
</div><!-- fragment --><p>into:</p>
<div class="fragment"><div class="line">%0 = linalg.fill ... : tensor&lt;7x4xf32&gt;</div>
<div class="line">%1 = scf.forall (%iv) in (%c4) shared_outs(%arg0 = %0)</div>
<div class="line">  -&gt; (tensor&lt;7x4xf32&gt;) {</div>
<div class="line">  %2 = tensor.extract_slice %arg3 : tensor&lt;7x4xf32&gt; to tensor&lt;7xf32&gt;</div>
<div class="line">  %3 = tensor.extract_slice %in : tensor&lt;7x9xf32&gt; -&gt; tensor&lt;7x?xf32&gt;</div>
<div class="line">  %4 = linalg.generic %2, %3 [&quot;parallel&quot;, &quot;reduction&quot;]</div>
<div class="line">    : tensor&lt;7x?xf32&gt; -&gt; tensor&lt;7xf32&gt;</div>
<div class="line">  %5 = tensor.insert_slice %3, %arg0[0, %iv] : tensor&lt;7x4xf32&gt;</div>
<div class="line">}</div>
<div class="line">%6 = linalg.generic %1 [&quot;parallel&quot;, &quot;reduction&quot;]</div>
<div class="line">  : tensor&lt;7x4xf32&gt; -&gt; tensor&lt;7xf32&gt;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00611">611</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

</div>
</div>
<a id="a681abb3bd7d080168a988832f5c35f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681abb3bd7d080168a988832f5c35f11">&#9670;&nbsp;</a></span>tileToForallOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1ForallTilingResult.html">ForallTilingResult</a> &gt; mlir::linalg::tileToForallOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; ArrayAttr &gt;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00427">427</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgTransformOps_8cpp_source.html#l02507">mlir::transform::tileToForallOpImpl()</a>.</p>

</div>
</div>
<a id="a150f6416a97acbe486aaaf69cf12c104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150f6416a97acbe486aaaf69cf12c104">&#9670;&nbsp;</a></span>tileToForallOpUsingTileSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1ForallTilingResult.html">ForallTilingResult</a> &gt; mlir::linalg::tileToForallOpUsingTileSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; ArrayAttr &gt;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <code>tileToForallOp</code>, but calculate the number of threads required using the given tileSizes. </p>

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00436">436</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgTransformOps_8cpp_source.html#l02507">mlir::transform::tileToForallOpImpl()</a>.</p>

</div>
</div>
<a id="a1b2368f6f815597fcf395106e8978e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2368f6f815597fcf395106e8978e44">&#9670;&nbsp;</a></span>transformIndexOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::transformIndexOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#a2363d9b68019db04dbf0c710afe7f224">LoopIndexToRangeIndexMap</a> &amp;&#160;</td>
          <td class="paramname"><em>loopIndexToRangeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All indices returned by IndexOp should be invariant with respect to tiling. </p>
<p>Therefore, if an operation is tiled, we have to transform the indices accordingly, i.e. offset them by the values of the corresponding induction variables that are captured implicitly in the body of the op.</p>
<p>Example. <code>linalg.generic</code> before tiling:</p>
<p>#id_2d = (i, j) -&gt; (i, j) #pointwise_2d_trait = { indexing_maps = [#id_2d, #id_2d], iterator_types = ["parallel", "parallel"] } linalg.generic #pointwise_2d_trait operand, result { ^bb0(operand_in: f32, result_in: f32): i = linalg.index 0 : index j = linalg.index 1 : index &lt;some operations that use i, j&gt; }: memref&lt;50x100xf32&gt;, memref&lt;50x100xf32&gt;</p>
<p>After tiling pass with tiles sizes 10 and 25:</p>
<p>#strided = (i, j)[s0, s1, s2] -&gt; (i * s1 + s0 + j * s2)</p>
<p>c1 = arith.constant 1 : index c0 = arith.constant 0 : index c25 = arith.constant 25 : index c10 = arith.constant 10 : index operand_dim_0 = dim operand, 0 : memref&lt;50x100xf32&gt; operand_dim_1 = dim operand, 1 : memref&lt;50x100xf32&gt; scf.for k = c0 to operand_dim_0 step c10 { scf.for l = c0 to operand_dim_1 step c25 { %4 = memref.subview operand[k, l][c10, c25][c1, c1] : memref&lt;50x100xf32&gt; to memref&lt;?x?xf32, #strided&gt; %5 = memref.subview result[k, l][c10, c25][c1, c1] : memref&lt;50x100xf32&gt; to memref&lt;?x?xf32, #strided&gt; linalg.generic pointwise_2d_trait %4, %5 { ^bb0(operand_in: f32, result_in: f32): i = linalg.index 0 : index j = linalg.index 1 : index // Indices <code>k</code> and <code>l</code> are implicitly captured in the body. transformed_i = arith.addi i, k : index // index <code>i</code> is offset by k transformed_j = arith.addi j, l : index // index <code>j</code> is offset by l // Every use of i, j is replaced with transformed_i, transformed_j &lt;some operations that use transformed_i, transformed_j&gt; }: memref&lt;?x?xf32, #strided&gt;, memref&lt;?x?xf32, #strided&gt; } }</p>
<p>TODO: Investigate whether mixing implicit and explicit indices does not lead to losing information. </p>

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00089">89</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

</div>
</div>
<a id="a0a0775243640f0e58d6cce7f49809b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0775243640f0e58d6cce7f49809b13">&#9670;&nbsp;</a></span>unrollIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; mlir::linalg::unrollIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00051">51</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01879">mlir::affine::delinearizeIndex()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, and <a class="el" href="Builders_8cpp_source.html#l00121">mlir::Builder::getIndexAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00076">rewriteInIm2Col()</a>.</p>

</div>
</div>
<a id="aeb173d5edf56a08ed3610924312dd364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb173d5edf56a08ed3610924312dd364">&#9670;&nbsp;</a></span>updateBoundsForCyclicDistribution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::updateBoundsForCyclicDistribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>procId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>nprocs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the <code>lb</code>, <code>ub</code> and <code>step</code> to get per processor <code>lb</code>, <code>ub</code> and <code>step</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00468">468</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00329">mlir::bindDims()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00512">mlir::getAffineSymbolExpr()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01284">mlir::affine::makeComposedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00604">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>.</p>

</div>
</div>
<a id="a31275f732e5575c158fb570eba1208c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31275f732e5575c158fb570eba1208c8">&#9670;&nbsp;</a></span>vectorize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::vectorize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>inputVectorSizes</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>vectorizeNDExtract</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a suitable vector form for a Linalg op. </p>
<p>If provided, <code>inputVectorSizes</code> are used to vectorize this operation. <code>inputVectorSizes</code> must match the rank of the iteration space of the operation and the sizes must be smaller or equal than their counterpart interation space sizes, if static. <code>inputVectorShapes</code> also allows the vectorization of operations with dynamic shapes.</p>
<p>If provided, <code>inputVectorSizes</code> are used to vectorize this operation. <code>inputVectorSizes</code> must match the rank of the iteration space of the operation and the input vector sizes must be greater than or equal to their counterpart iteration space sizes, if static. <code>inputVectorShapes</code> also allows the vectorization of operations with dynamic shapes. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01475">1475</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Vectorization_8cpp_source.html#l01396">convertAffineApply()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00285">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00270">VectorizationState::initState()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00044">LDBG</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00266">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01159">vectorizeAsLinalgGeneric()</a>, <a class="el" href="Vectorization_8cpp_source.html#l02907">vectorizeConvolution()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01315">vectorizeLinalgOpPrecondition()</a>.</p>

</div>
</div>
<a id="a8c63bc9239511b70751c238a12f5b1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c63bc9239511b70751c238a12f5b1da">&#9670;&nbsp;</a></span>vectorizeCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::vectorizeCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::CopyOp&#160;</td>
          <td class="paramname"><em>copyOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a suitable vector form for a Copy op with fully static shape. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01528">1528</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00024">mlir::getElementTypeOrSelf()</a>, <a class="el" href="Builders_8cpp_source.html#l00362">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00410">mlir::Operation::getResults()</a>, <a class="el" href="File_8h_source.html#l00049">mlir::sparse_tensor::detail::readValue()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00266">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transforms_8cpp_source.html#l01028">mlir::linalg::CopyVectorizationPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a76247db28f1352895996e7346a2084d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76247db28f1352895996e7346a2084d2">&#9670;&nbsp;</a></span>vectorizeLinalgOpPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::vectorizeLinalgOpPrecondition </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>inputVectorSizes</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>vectorizeNDExtract</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return success if the operation can be vectorized. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01315">1315</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00228">allIndexingsAreProjectedPermutation()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00648">mlir::Operation::getRegion()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00248">isElementwise()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00044">LDBG</a>, <a class="el" href="Vectorization_8cpp_source.html#l01285">reductionPreconditions()</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00670">tensorExtractVectorizationPrecondition()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01304">vectorizeDynamicLinalgOpPrecondition()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01475">vectorize()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 4 2023 20:34:13 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
