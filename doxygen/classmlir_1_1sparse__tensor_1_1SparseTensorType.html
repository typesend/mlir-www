<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::sparse_tensor::SparseTensorType Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">17.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1sparse__tensor.html">sparse_tensor</a></li><li class="navelem"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html">SparseTensorType</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmlir_1_1sparse__tensor_1_1SparseTensorType-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::sparse_tensor::SparseTensorType Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A wrapper around <code>RankedTensorType</code>, which has three goals:  
 <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="SparseTensorType_8h_source.html">mlir/Dialect/SparseTensor/IR/SparseTensorType.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a93121d975f00b0b379c15f6f98de4c83"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a93121d975f00b0b379c15f6f98de4c83">SparseTensorType</a> (RankedTensorType rtp)</td></tr>
<tr class="separator:a93121d975f00b0b379c15f6f98de4c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23343ec0bd74c0053ac63a606bb9c5d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a23343ec0bd74c0053ac63a606bb9c5d5">SparseTensorType</a> (ShapedType stp, SparseTensorEncodingAttr enc)</td></tr>
<tr class="separator:a23343ec0bd74c0053ac63a606bb9c5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d830b06b63a2f61566aaf98e9a868b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html">SparseTensorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#af4d830b06b63a2f61566aaf98e9a868b">operator=</a> (const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html">SparseTensorType</a> &amp;)=delete</td></tr>
<tr class="separator:af4d830b06b63a2f61566aaf98e9a868b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5f50ad4b2427cc6270e8d8cfc18c44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a5b5f50ad4b2427cc6270e8d8cfc18c44">SparseTensorType</a> (const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html">SparseTensorType</a> &amp;)=default</td></tr>
<tr class="separator:a5b5f50ad4b2427cc6270e8d8cfc18c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f4e7b6bfb6fb188b9aef8d26bacfdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html">SparseTensorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a53f4e7b6bfb6fb188b9aef8d26bacfdd">withEncoding</a> (SparseTensorEncodingAttr newEnc) const</td></tr>
<tr class="memdesc:a53f4e7b6bfb6fb188b9aef8d26bacfdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <code><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html" title="A wrapper around RankedTensorType, which has three goals:">SparseTensorType</a></code> with the same dimension-shape and element type, but with the encoding replaced by the given encoding.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a53f4e7b6bfb6fb188b9aef8d26bacfdd">More...</a><br /></td></tr>
<tr class="separator:a53f4e7b6bfb6fb188b9aef8d26bacfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26bfd8ce2eaa18acc30fb81ce49894cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html">SparseTensorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a26bfd8ce2eaa18acc30fb81ce49894cc">withoutOrdering</a> () const</td></tr>
<tr class="memdesc:a26bfd8ce2eaa18acc30fb81ce49894cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <code><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html" title="A wrapper around RankedTensorType, which has three goals:">SparseTensorType</a></code> with the same dimension-shape and element type, but with the encoding replaced by <code><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#ad5f5b4b2f2357638129b5621a50e3503" title="Returns the encoding (or the null-attribute for dense-tensors).">getEncoding()</a>.<a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a26bfd8ce2eaa18acc30fb81ce49894cc" title="Constructs a new SparseTensorType with the same dimension-shape and element type, but with the encodi...">withoutOrdering()</a></code>.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a26bfd8ce2eaa18acc30fb81ce49894cc">More...</a><br /></td></tr>
<tr class="separator:a26bfd8ce2eaa18acc30fb81ce49894cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6480eec7bd6676b1fe40f6bba14e459f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = std::enable_if_t&lt;                            std::is_convertible_v&lt;RankedTensorType, T&gt;&gt;&gt; </td></tr>
<tr class="memitem:a6480eec7bd6676b1fe40f6bba14e459f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a6480eec7bd6676b1fe40f6bba14e459f">operator T</a> () const</td></tr>
<tr class="memdesc:a6480eec7bd6676b1fe40f6bba14e459f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow implicit conversion to <code>RankedTensorType</code>, <code>ShapedType</code>, and <code><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a></code>.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a6480eec7bd6676b1fe40f6bba14e459f">More...</a><br /></td></tr>
<tr class="separator:a6480eec7bd6676b1fe40f6bba14e459f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95575d193fe675edda63c79f876780b1"><td class="memItemLeft" align="right" valign="top">RankedTensorType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a95575d193fe675edda63c79f876780b1">getRankedTensorType</a> () const</td></tr>
<tr class="memdesc:a95575d193fe675edda63c79f876780b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly convert to <code>RankedTensorType</code>.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a95575d193fe675edda63c79f876780b1">More...</a><br /></td></tr>
<tr class="separator:a95575d193fe675edda63c79f876780b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c04fd598aea23545eb45c17dd402c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a51c04fd598aea23545eb45c17dd402c7">operator==</a> (const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html">SparseTensorType</a> &amp;other) const</td></tr>
<tr class="separator:a51c04fd598aea23545eb45c17dd402c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f37b4e8c855ffbb1fa8bd9649221059"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a2f37b4e8c855ffbb1fa8bd9649221059">operator!=</a> (const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html">SparseTensorType</a> &amp;other) const</td></tr>
<tr class="separator:a2f37b4e8c855ffbb1fa8bd9649221059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ce3c3cccfeb3f6f77416fa517c58b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a05ce3c3cccfeb3f6f77416fa517c58b1">getContext</a> () const</td></tr>
<tr class="separator:a05ce3c3cccfeb3f6f77416fa517c58b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1978fe33f8c6d90427aec0bb593f76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a1b1978fe33f8c6d90427aec0bb593f76">getElementType</a> () const</td></tr>
<tr class="separator:a1b1978fe33f8c6d90427aec0bb593f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f5b4b2f2357638129b5621a50e3503"><td class="memItemLeft" align="right" valign="top">SparseTensorEncodingAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#ad5f5b4b2f2357638129b5621a50e3503">getEncoding</a> () const</td></tr>
<tr class="memdesc:ad5f5b4b2f2357638129b5621a50e3503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the encoding (or the null-attribute for dense-tensors).  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#ad5f5b4b2f2357638129b5621a50e3503">More...</a><br /></td></tr>
<tr class="separator:ad5f5b4b2f2357638129b5621a50e3503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dbbef399c0d42d883dd466f343bc43f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a3dbbef399c0d42d883dd466f343bc43f">hasEncoding</a> () const</td></tr>
<tr class="memdesc:a3dbbef399c0d42d883dd466f343bc43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true for tensors which have an encoding, and false for those which do not.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a3dbbef399c0d42d883dd466f343bc43f">More...</a><br /></td></tr>
<tr class="separator:a3dbbef399c0d42d883dd466f343bc43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d188327d9f1d4a42a32585ce2876ce5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a5d188327d9f1d4a42a32585ce2876ce5">isAllDense</a> () const</td></tr>
<tr class="memdesc:a5d188327d9f1d4a42a32585ce2876ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true for tensors where every level is dense.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a5d188327d9f1d4a42a32585ce2876ce5">More...</a><br /></td></tr>
<tr class="separator:a5d188327d9f1d4a42a32585ce2876ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44afa2cd918e7357236a62f4449f7899"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a44afa2cd918e7357236a62f4449f7899">isAllOrdered</a> () const</td></tr>
<tr class="memdesc:a44afa2cd918e7357236a62f4449f7899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true for tensors where every level is ordered.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a44afa2cd918e7357236a62f4449f7899">More...</a><br /></td></tr>
<tr class="separator:a44afa2cd918e7357236a62f4449f7899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839df43feb35ab6abf0136be0a7ee45e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a839df43feb35ab6abf0136be0a7ee45e">isIdentity</a> () const</td></tr>
<tr class="memdesc:a839df43feb35ab6abf0136be0a7ee45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the dimToLvl mapping is the identity.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a839df43feb35ab6abf0136be0a7ee45e">More...</a><br /></td></tr>
<tr class="separator:a839df43feb35ab6abf0136be0a7ee45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b332ec5dfa36e6358d8d0a1a084ece"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a86b332ec5dfa36e6358d8d0a1a084ece">getDimToLvlMap</a> () const</td></tr>
<tr class="memdesc:a86b332ec5dfa36e6358d8d0a1a084ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimToLvl mapping (or the null-map for the identity).  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a86b332ec5dfa36e6358d8d0a1a084ece">More...</a><br /></td></tr>
<tr class="separator:a86b332ec5dfa36e6358d8d0a1a084ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb679e9765bf80b185a4d8da7ef4e3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#aecb679e9765bf80b185a4d8da7ef4e3a">getExpandedDimToLvlMap</a> () const</td></tr>
<tr class="memdesc:aecb679e9765bf80b185a4d8da7ef4e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimToLvl mapping, where the identity map is expanded out into a full <code><a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a></code>.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#aecb679e9765bf80b185a4d8da7ef4e3a">More...</a><br /></td></tr>
<tr class="separator:aecb679e9765bf80b185a4d8da7ef4e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d644dc98bff26d6a94d50ef76e302dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a2d644dc98bff26d6a94d50ef76e302dd">hasSameDimToLvlMap</a> (const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html">SparseTensorType</a> &amp;other) const</td></tr>
<tr class="memdesc:a2d644dc98bff26d6a94d50ef76e302dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the two types have the same mapping.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a2d644dc98bff26d6a94d50ef76e302dd">More...</a><br /></td></tr>
<tr class="separator:a2d644dc98bff26d6a94d50ef76e302dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f91f9843d18c1a714ccb66d462718d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a39f7b45046f9cc6ee2490f64fdb564b0">Dimension</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a54f91f9843d18c1a714ccb66d462718d">getDimRank</a> () const</td></tr>
<tr class="memdesc:a54f91f9843d18c1a714ccb66d462718d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension-rank.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a54f91f9843d18c1a714ccb66d462718d">More...</a><br /></td></tr>
<tr class="separator:a54f91f9843d18c1a714ccb66d462718d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08f577afef29840b7caf3d0be2c793f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a4eeeb1242c0500476bf0e6b6da6a30e2">Level</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#ab08f577afef29840b7caf3d0be2c793f">getLvlRank</a> () const</td></tr>
<tr class="memdesc:ab08f577afef29840b7caf3d0be2c793f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the level-rank.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#ab08f577afef29840b7caf3d0be2c793f">More...</a><br /></td></tr>
<tr class="separator:ab08f577afef29840b7caf3d0be2c793f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbf738974b30d7842dd0f70010651eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1sparse__tensor.html#a72af2f55731ef9bb6340ac83785ab58d">DynSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a9fbf738974b30d7842dd0f70010651eb">getDimShape</a> () const</td></tr>
<tr class="memdesc:a9fbf738974b30d7842dd0f70010651eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension-shape.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a9fbf738974b30d7842dd0f70010651eb">More...</a><br /></td></tr>
<tr class="separator:a9fbf738974b30d7842dd0f70010651eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac28ffb358acbcebb563fcf4cc30ba13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a72af2f55731ef9bb6340ac83785ab58d">DynSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#aac28ffb358acbcebb563fcf4cc30ba13">getDynamicDimSize</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#a39f7b45046f9cc6ee2490f64fdb564b0">Dimension</a> d) const</td></tr>
<tr class="memdesc:aac28ffb358acbcebb563fcf4cc30ba13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely looks up the requested dimension-DynSize.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#aac28ffb358acbcebb563fcf4cc30ba13">More...</a><br /></td></tr>
<tr class="separator:aac28ffb358acbcebb563fcf4cc30ba13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791fd189fb370c4ea23e35f269f73ce9"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="namespacemlir_1_1sparse__tensor.html#ac7f940a96cde1dc0d86c5c83bd72a4b4">StaticSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a791fd189fb370c4ea23e35f269f73ce9">getStaticDimSize</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#a39f7b45046f9cc6ee2490f64fdb564b0">Dimension</a> d) const</td></tr>
<tr class="memdesc:a791fd189fb370c4ea23e35f269f73ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely looks up the requested dimension-size, mapping dynamic sizes to <code>std::nullopt</code>.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a791fd189fb370c4ea23e35f269f73ce9">More...</a><br /></td></tr>
<tr class="separator:a791fd189fb370c4ea23e35f269f73ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa266e34e646e484bb842fc94e3f11084"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#aa266e34e646e484bb842fc94e3f11084">hasStaticDimShape</a> () const</td></tr>
<tr class="memdesc:aa266e34e646e484bb842fc94e3f11084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if no dimension has dynamic size.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#aa266e34e646e484bb842fc94e3f11084">More...</a><br /></td></tr>
<tr class="separator:aa266e34e646e484bb842fc94e3f11084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9f94e79a621d5b827e0ea4d535bdb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a8e9f94e79a621d5b827e0ea4d535bdb6">hasDynamicDimShape</a> () const</td></tr>
<tr class="memdesc:a8e9f94e79a621d5b827e0ea4d535bdb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any dimension has dynamic size.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a8e9f94e79a621d5b827e0ea4d535bdb6">More...</a><br /></td></tr>
<tr class="separator:a8e9f94e79a621d5b827e0ea4d535bdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7626e19625af5dd5d73aacfb06061ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#ad7626e19625af5dd5d73aacfb06061ba">isDynamicDim</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#a39f7b45046f9cc6ee2490f64fdb564b0">Dimension</a> d) const</td></tr>
<tr class="memdesc:ad7626e19625af5dd5d73aacfb06061ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given dimension has dynamic size.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#ad7626e19625af5dd5d73aacfb06061ba">More...</a><br /></td></tr>
<tr class="separator:ad7626e19625af5dd5d73aacfb06061ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748d3e463f079b23679e617b7120cf78"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a748d3e463f079b23679e617b7120cf78">getNumDynamicDims</a> () const</td></tr>
<tr class="memdesc:a748d3e463f079b23679e617b7120cf78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of dimensions which have dynamic sizes.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a748d3e463f079b23679e617b7120cf78">More...</a><br /></td></tr>
<tr class="separator:a748d3e463f079b23679e617b7120cf78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1740494762525f9d3582ab6aa6e1ff36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a1740494762525f9d3582ab6aa6e1ff36">getLvlType</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#a4eeeb1242c0500476bf0e6b6da6a30e2">Level</a> l) const</td></tr>
<tr class="separator:a1740494762525f9d3582ab6aa6e1ff36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb76fe88dff789854c105b3f5c710a9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#adb76fe88dff789854c105b3f5c710a9f">isDenseLvl</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#a4eeeb1242c0500476bf0e6b6da6a30e2">Level</a> l) const</td></tr>
<tr class="separator:adb76fe88dff789854c105b3f5c710a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa152af64c6577dcb3abd948006a6b1f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#aa152af64c6577dcb3abd948006a6b1f3">isCompressedLvl</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#a4eeeb1242c0500476bf0e6b6da6a30e2">Level</a> l) const</td></tr>
<tr class="separator:aa152af64c6577dcb3abd948006a6b1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052dd43add6a4d59d42b5ba51b686c05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a052dd43add6a4d59d42b5ba51b686c05">isSingletonLvl</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#a4eeeb1242c0500476bf0e6b6da6a30e2">Level</a> l) const</td></tr>
<tr class="separator:a052dd43add6a4d59d42b5ba51b686c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f5a0c66c902927d30fa1d37df6573e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#af5f5a0c66c902927d30fa1d37df6573e">isOrderedLvl</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#a4eeeb1242c0500476bf0e6b6da6a30e2">Level</a> l) const</td></tr>
<tr class="separator:af5f5a0c66c902927d30fa1d37df6573e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6bd40237f4d3af041f2db05f7c8504"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#afc6bd40237f4d3af041f2db05f7c8504">isUniqueLvl</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#a4eeeb1242c0500476bf0e6b6da6a30e2">Level</a> l) const</td></tr>
<tr class="separator:afc6bd40237f4d3af041f2db05f7c8504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d71cb7ebe3b1e304f3e8a5bd8dd61b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a29d71cb7ebe3b1e304f3e8a5bd8dd61b">getCrdWidth</a> () const</td></tr>
<tr class="memdesc:a29d71cb7ebe3b1e304f3e8a5bd8dd61b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the coordinate-overhead bitwidth, defaulting to zero.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a29d71cb7ebe3b1e304f3e8a5bd8dd61b">More...</a><br /></td></tr>
<tr class="separator:a29d71cb7ebe3b1e304f3e8a5bd8dd61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55459c4e7398889a8bd3f9ce6e89c5d"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#ab55459c4e7398889a8bd3f9ce6e89c5d">getPosWidth</a> () const</td></tr>
<tr class="memdesc:ab55459c4e7398889a8bd3f9ce6e89c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position-overhead bitwidth, defaulting to zero.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#ab55459c4e7398889a8bd3f9ce6e89c5d">More...</a><br /></td></tr>
<tr class="separator:ab55459c4e7398889a8bd3f9ce6e89c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b65a254882cd7c349675af7087845e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a7b65a254882cd7c349675af7087845e9">getCrdType</a> () const</td></tr>
<tr class="memdesc:a7b65a254882cd7c349675af7087845e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the coordinate-overhead MLIR type, defaulting to <code>IndexType</code>.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a7b65a254882cd7c349675af7087845e9">More...</a><br /></td></tr>
<tr class="separator:a7b65a254882cd7c349675af7087845e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02457704b9e62b7d60579219105b87f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#af02457704b9e62b7d60579219105b87f">getPosType</a> () const</td></tr>
<tr class="memdesc:af02457704b9e62b7d60579219105b87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position-overhead MLIR type, defaulting to <code>IndexType</code>.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#af02457704b9e62b7d60579219105b87f">More...</a><br /></td></tr>
<tr class="separator:af02457704b9e62b7d60579219105b87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A wrapper around <code>RankedTensorType</code>, which has three goals: </p>
<p>(1) To provide a uniform API for querying aspects of sparse-tensor types; in particular, to make the "dimension" vs "level" distinction overt (i.e., explicit everywhere). Thus, throughout the sparse-compiler this class should be preferred over using <code>RankedTensorType</code> or <code>ShapedType</code> directly, since the methods of the latter do not make the "dimension" vs "level" distinction overt.</p>
<p>(2) To provide a uniform abstraction over both sparse-tensor types (i.e., <code>RankedTensorType</code> with <code>SparseTensorEncodingAttr</code>) and dense-tensor types (i.e., <code>RankedTensorType</code> without an encoding). That is, we want to manipulate dense-tensor types using the same API that we use for manipulating sparse-tensor types; both to keep the "dimension" vs "level" distinction overt, and to avoid needing to handle certain cases specially in the sparse-compiler.</p>
<p>(3) To provide uniform handling of "defaults". In particular this means that dense-tensors should always return the same answers as sparse-tensors with a default encoding. But it additionally means that the answers should be normalized, so that there's no way to distinguish between non-provided data (which is filled in by default) vs explicitly-provided data which equals the defaults. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00046">46</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a93121d975f00b0b379c15f6f98de4c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93121d975f00b0b379c15f6f98de4c83">&#9670;&nbsp;</a></span>SparseTensorType() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::sparse_tensor::SparseTensorType::SparseTensorType </td>
          <td>(</td>
          <td class="paramtype">RankedTensorType&#160;</td>
          <td class="paramname"><em>rtp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00050">50</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorType_8h_source.html#l00176">getDimRank()</a>, and <a class="el" href="SparseTensorType_8h_source.html#l00147">isIdentity()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorType_8h_source.html#l00070">withEncoding()</a>.</p>

</div>
</div>
<a id="a23343ec0bd74c0053ac63a606bb9c5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23343ec0bd74c0053ac63a606bb9c5d5">&#9670;&nbsp;</a></span>SparseTensorType() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::sparse_tensor::SparseTensorType::SparseTensorType </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>stp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseTensorEncodingAttr&#160;</td>
          <td class="paramname"><em>enc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00058">58</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

</div>
</div>
<a id="a5b5f50ad4b2427cc6270e8d8cfc18c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5f50ad4b2427cc6270e8d8cfc18c44">&#9670;&nbsp;</a></span>SparseTensorType() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::sparse_tensor::SparseTensorType::SparseTensorType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html">SparseTensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a05ce3c3cccfeb3f6f77416fa517c58b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ce3c3cccfeb3f6f77416fa517c58b1">&#9670;&nbsp;</a></span>getContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a>* mlir::sparse_tensor::SparseTensorType::getContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00125">125</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorDialect_8cpp_source.html#l00483">mlir::sparse_tensor::getCOOFromTypeWithOrdering()</a>, <a class="el" href="SparseTensorType_8h_source.html#l00243">getCrdType()</a>, <a class="el" href="SparseTensorType_8h_source.html#l00158">getExpandedDimToLvlMap()</a>, and <a class="el" href="SparseTensorType_8h_source.html#l00248">getPosType()</a>.</p>

</div>
</div>
<a id="a7b65a254882cd7c349675af7087845e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b65a254882cd7c349675af7087845e9">&#9670;&nbsp;</a></span>getCrdType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::sparse_tensor::SparseTensorType::getCrdType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the coordinate-overhead MLIR type, defaulting to <code>IndexType</code>. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00243">243</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorType_8h_source.html#l00125">getContext()</a>, <a class="el" href="SparseTensorType_8h_source.html#l00237">getCrdWidth()</a>, and <a class="el" href="SparseTensorDialect_8cpp_source.html#l00117">mlir::sparse_tensor::detail::getIntegerOrIndexType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorStorageLayout_8cpp_source.html#l00168">mlir::sparse_tensor::foreachFieldAndTypeInSparseTensor()</a>.</p>

</div>
</div>
<a id="a29d71cb7ebe3b1e304f3e8a5bd8dd61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d71cb7ebe3b1e304f3e8a5bd8dd61b">&#9670;&nbsp;</a></span>getCrdWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::sparse_tensor::SparseTensorType::getCrdWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the coordinate-overhead bitwidth, defaulting to zero. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00237">237</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorDialect_8cpp_source.html#l00483">mlir::sparse_tensor::getCOOFromTypeWithOrdering()</a>, and <a class="el" href="SparseTensorType_8h_source.html#l00243">getCrdType()</a>.</p>

</div>
</div>
<a id="a54f91f9843d18c1a714ccb66d462718d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f91f9843d18c1a714ccb66d462718d">&#9670;&nbsp;</a></span>getDimRank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a39f7b45046f9cc6ee2490f64fdb564b0">Dimension</a> mlir::sparse_tensor::SparseTensorType::getDimRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dimension-rank. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00176">176</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8cpp_source.html#l00530">mlir::sparse_tensor::foreachInSparseConstant()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00483">mlir::sparse_tensor::getCOOFromTypeWithOrdering()</a>, <a class="el" href="SparseTensorType_8h_source.html#l00187">getDynamicDimSize()</a>, <a class="el" href="SparseTensorType_8h_source.html#l00158">getExpandedDimToLvlMap()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00341">getNumNonTrivialIdxExpOnSparseLvls()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00512">mlir::sparse_tensor::sizesFromSrc()</a>, and <a class="el" href="SparseTensorType_8h_source.html#l00050">SparseTensorType()</a>.</p>

</div>
</div>
<a id="a9fbf738974b30d7842dd0f70010651eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fbf738974b30d7842dd0f70010651eb">&#9670;&nbsp;</a></span>getDimShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a72af2f55731ef9bb6340ac83785ab58d">DynSize</a>&gt; mlir::sparse_tensor::SparseTensorType::getDimShape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dimension-shape. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00182">182</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorDialect_8cpp_source.html#l00483">mlir::sparse_tensor::getCOOFromTypeWithOrdering()</a>, and <a class="el" href="SparseTensorType_8h_source.html#l00187">getDynamicDimSize()</a>.</p>

</div>
</div>
<a id="a86b332ec5dfa36e6358d8d0a1a084ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b332ec5dfa36e6358d8d0a1a084ece">&#9670;&nbsp;</a></span>getDimToLvlMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::sparse_tensor::SparseTensorType::getDimToLvlMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dimToLvl mapping (or the null-map for the identity). </p>
<p>If you intend to compare the results of this method for equality, see <code>hasSameDimToLvlMap</code> instead. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00152">152</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

</div>
</div>
<a id="aac28ffb358acbcebb563fcf4cc30ba13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac28ffb358acbcebb563fcf4cc30ba13">&#9670;&nbsp;</a></span>getDynamicDimSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a72af2f55731ef9bb6340ac83785ab58d">DynSize</a> mlir::sparse_tensor::SparseTensorType::getDynamicDimSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a39f7b45046f9cc6ee2490f64fdb564b0">Dimension</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safely looks up the requested dimension-DynSize. </p>
<p>If you intend to check the result with <code>ShapedType::isDynamic</code>, then see the <code>getStaticDimSize</code> method instead. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00187">187</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorType_8h_source.html#l00176">getDimRank()</a>, and <a class="el" href="SparseTensorType_8h_source.html#l00182">getDimShape()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorType_8h_source.html#l00194">getStaticDimSize()</a>, and <a class="el" href="SparseTensorType_8h_source.html#l00209">isDynamicDim()</a>.</p>

</div>
</div>
<a id="a1b1978fe33f8c6d90427aec0bb593f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1978fe33f8c6d90427aec0bb593f76">&#9670;&nbsp;</a></span>getElementType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::sparse_tensor::SparseTensorType::getElementType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00127">127</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorStorageLayout_8cpp_source.html#l00168">mlir::sparse_tensor::foreachFieldAndTypeInSparseTensor()</a>, and <a class="el" href="SparseTensorDialect_8cpp_source.html#l00483">mlir::sparse_tensor::getCOOFromTypeWithOrdering()</a>.</p>

</div>
</div>
<a id="ad5f5b4b2f2357638129b5621a50e3503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f5b4b2f2357638129b5621a50e3503">&#9670;&nbsp;</a></span>getEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SparseTensorEncodingAttr mlir::sparse_tensor::SparseTensorType::getEncoding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the encoding (or the null-attribute for dense-tensors). </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00130">130</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorStorageLayout_8cpp_source.html#l00168">mlir::sparse_tensor::foreachFieldAndTypeInSparseTensor()</a>, <a class="el" href="SparseTensorStorageLayout_8h_source.html#l00343">mlir::sparse_tensor::SparseTensorDescriptorImpl&lt; ValueArrayRef &gt;::getAOSMemRef()</a>, <a class="el" href="SparseTensorStorageLayout_8h_source.html#l00338">mlir::sparse_tensor::SparseTensorDescriptorImpl&lt; ValueArrayRef &gt;::getCrdMemRefIndexAndStride()</a>, <a class="el" href="SparseTensorStorageLayout_8cpp_source.html#l00077">mlir::sparse_tensor::SparseTensorSpecifier::getInitValue()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00341">getNumNonTrivialIdxExpOnSparseLvls()</a>, <a class="el" href="LoopEmitter_8cpp_source.html#l00227">mlir::sparse_tensor::LoopEmitter::initialize()</a>, and <a class="el" href="SparseTensorStorageLayout_8h_source.html#l00252">mlir::sparse_tensor::SparseTensorDescriptorImpl&lt; ValueArrayRef &gt;::SparseTensorDescriptorImpl()</a>.</p>

</div>
</div>
<a id="aecb679e9765bf80b185a4d8da7ef4e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb679e9765bf80b185a4d8da7ef4e3a">&#9670;&nbsp;</a></span>getExpandedDimToLvlMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::sparse_tensor::SparseTensorType::getExpandedDimToLvlMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dimToLvl mapping, where the identity map is expanded out into a full <code><a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a></code>. </p>
<p>This method is provided as a convenience, but for most purposes other methods (<code>isIdentity</code>, <code>getDimToLvlMap</code>, etc) will be more helpful. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00158">158</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorType_8h_source.html#l00125">getContext()</a>, <a class="el" href="SparseTensorType_8h_source.html#l00176">getDimRank()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00262">mlir::AffineMap::getMultiDimIdentityMap()</a>.</p>

</div>
</div>
<a id="ab08f577afef29840b7caf3d0be2c793f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08f577afef29840b7caf3d0be2c793f">&#9670;&nbsp;</a></span>getLvlRank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a4eeeb1242c0500476bf0e6b6da6a30e2">Level</a> mlir::sparse_tensor::SparseTensorType::getLvlRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the level-rank. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00179">179</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorStorageLayout_8h_source.html#l00343">mlir::sparse_tensor::SparseTensorDescriptorImpl&lt; ValueArrayRef &gt;::getAOSMemRef()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00341">getNumNonTrivialIdxExpOnSparseLvls()</a>, <a class="el" href="LoopEmitter_8cpp_source.html#l00227">mlir::sparse_tensor::LoopEmitter::initialize()</a>, and <a class="el" href="LoopEmitter_8cpp_source.html#l00343">mlir::sparse_tensor::LoopEmitter::initializeLoopEmit()</a>.</p>

</div>
</div>
<a id="a1740494762525f9d3582ab6aa6e1ff36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1740494762525f9d3582ab6aa6e1ff36">&#9670;&nbsp;</a></span>getLvlType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> mlir::sparse_tensor::SparseTensorType::getLvlType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a4eeeb1242c0500476bf0e6b6da6a30e2">Level</a>&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00220">220</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorType_8h_source.html#l00231">isCompressedLvl()</a>, <a class="el" href="SparseTensorType_8h_source.html#l00230">isDenseLvl()</a>, <a class="el" href="SparseTensorType_8h_source.html#l00233">isOrderedLvl()</a>, <a class="el" href="SparseTensorType_8h_source.html#l00232">isSingletonLvl()</a>, and <a class="el" href="SparseTensorType_8h_source.html#l00234">isUniqueLvl()</a>.</p>

</div>
</div>
<a id="a748d3e463f079b23679e617b7120cf78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748d3e463f079b23679e617b7120cf78">&#9670;&nbsp;</a></span>getNumDynamicDims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::sparse_tensor::SparseTensorType::getNumDynamicDims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of dimensions which have dynamic sizes. </p>
<p>The return type is <code>int64_t</code> to maintain consistency with <code>ShapedType::Trait&lt;T&gt;::getNumDynamicDims</code>. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00218">218</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

</div>
</div>
<a id="af02457704b9e62b7d60579219105b87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02457704b9e62b7d60579219105b87f">&#9670;&nbsp;</a></span>getPosType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::sparse_tensor::SparseTensorType::getPosType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position-overhead MLIR type, defaulting to <code>IndexType</code>. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00248">248</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorType_8h_source.html#l00125">getContext()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00117">mlir::sparse_tensor::detail::getIntegerOrIndexType()</a>, and <a class="el" href="SparseTensorType_8h_source.html#l00240">getPosWidth()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorStorageLayout_8cpp_source.html#l00168">mlir::sparse_tensor::foreachFieldAndTypeInSparseTensor()</a>.</p>

</div>
</div>
<a id="ab55459c4e7398889a8bd3f9ce6e89c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55459c4e7398889a8bd3f9ce6e89c5d">&#9670;&nbsp;</a></span>getPosWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::sparse_tensor::SparseTensorType::getPosWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position-overhead bitwidth, defaulting to zero. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00240">240</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorDialect_8cpp_source.html#l00483">mlir::sparse_tensor::getCOOFromTypeWithOrdering()</a>, and <a class="el" href="SparseTensorType_8h_source.html#l00248">getPosType()</a>.</p>

</div>
</div>
<a id="a95575d193fe675edda63c79f876780b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95575d193fe675edda63c79f876780b1">&#9670;&nbsp;</a></span>getRankedTensorType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RankedTensorType mlir::sparse_tensor::SparseTensorType::getRankedTensorType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly convert to <code>RankedTensorType</code>. </p>
<p>This method is a convenience for resolving overload-ambiguity issues with implicit conversion. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00113">113</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

</div>
</div>
<a id="a791fd189fb370c4ea23e35f269f73ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791fd189fb370c4ea23e35f269f73ce9">&#9670;&nbsp;</a></span>getStaticDimSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="namespacemlir_1_1sparse__tensor.html#ac7f940a96cde1dc0d86c5c83bd72a4b4">StaticSize</a>&gt; mlir::sparse_tensor::SparseTensorType::getStaticDimSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a39f7b45046f9cc6ee2490f64fdb564b0">Dimension</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safely looks up the requested dimension-size, mapping dynamic sizes to <code>std::nullopt</code>. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00194">194</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorType_8h_source.html#l00187">getDynamicDimSize()</a>.</p>

</div>
</div>
<a id="a8e9f94e79a621d5b827e0ea4d535bdb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9f94e79a621d5b827e0ea4d535bdb6">&#9670;&nbsp;</a></span>hasDynamicDimShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorType::hasDynamicDimShape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if any dimension has dynamic size. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00204">204</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorType_8h_source.html#l00201">hasStaticDimShape()</a>.</p>

</div>
</div>
<a id="a3dbbef399c0d42d883dd466f343bc43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dbbef399c0d42d883dd466f343bc43f">&#9670;&nbsp;</a></span>hasEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorType::hasEncoding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true for tensors which have an encoding, and false for those which do not. </p>
<p>Therefore tensors with an all-dense encoding return true. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00135">135</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorStorageLayout_8cpp_source.html#l00036">convertSparseTensorType()</a>, <a class="el" href="SparseTensorStorageLayout_8cpp_source.html#l00168">mlir::sparse_tensor::foreachFieldAndTypeInSparseTensor()</a>, <a class="el" href="LoopEmitter_8cpp_source.html#l00227">mlir::sparse_tensor::LoopEmitter::initialize()</a>, and <a class="el" href="SparseTensorStorageLayout_8h_source.html#l00252">mlir::sparse_tensor::SparseTensorDescriptorImpl&lt; ValueArrayRef &gt;::SparseTensorDescriptorImpl()</a>.</p>

</div>
</div>
<a id="a2d644dc98bff26d6a94d50ef76e302dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d644dc98bff26d6a94d50ef76e302dd">&#9670;&nbsp;</a></span>hasSameDimToLvlMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorType::hasSameDimToLvlMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html">SparseTensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true iff the two types have the same mapping. </p>
<p>This method takes care to handle identity maps properly, so it should be preferred over using <code>getDimToLvlMap</code> followed by <code><a class="el" href="classmlir_1_1AffineMap.html#a7381857cac60752009640964e99172c2">AffineMap::operator==</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00167">167</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorType_8h_source.html#l00147">isIdentity()</a>.</p>

</div>
</div>
<a id="aa266e34e646e484bb842fc94e3f11084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa266e34e646e484bb842fc94e3f11084">&#9670;&nbsp;</a></span>hasStaticDimShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorType::hasStaticDimShape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if no dimension has dynamic size. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00201">201</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorType_8h_source.html#l00204">hasDynamicDimShape()</a>.</p>

</div>
</div>
<a id="a5d188327d9f1d4a42a32585ce2876ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d188327d9f1d4a42a32585ce2876ce5">&#9670;&nbsp;</a></span>isAllDense()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorType::isAllDense </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true for tensors where every level is dense. </p>
<p>(This is always true for dense-tensors.) </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00139">139</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenEnv_8cpp_source.html#l00154">mlir::sparse_tensor::CodegenEnv::isAdmissibleTensorExp()</a>.</p>

</div>
</div>
<a id="a44afa2cd918e7357236a62f4449f7899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44afa2cd918e7357236a62f4449f7899">&#9670;&nbsp;</a></span>isAllOrdered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorType::isAllOrdered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true for tensors where every level is ordered. </p>
<p>(This is always true for dense-tensors.) </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00143">143</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

</div>
</div>
<a id="aa152af64c6577dcb3abd948006a6b1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa152af64c6577dcb3abd948006a6b1f3">&#9670;&nbsp;</a></span>isCompressedLvl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorType::isCompressedLvl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a4eeeb1242c0500476bf0e6b6da6a30e2">Level</a>&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00231">231</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorType_8h_source.html#l00220">getLvlType()</a>, and <a class="el" href="Enums_8h_source.html#l00262">mlir::sparse_tensor::isCompressedDLT()</a>.</p>

</div>
</div>
<a id="adb76fe88dff789854c105b3f5c710a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb76fe88dff789854c105b3f5c710a9f">&#9670;&nbsp;</a></span>isDenseLvl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorType::isDenseLvl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a4eeeb1242c0500476bf0e6b6da6a30e2">Level</a>&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00230">230</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorType_8h_source.html#l00220">getLvlType()</a>, and <a class="el" href="Enums_8h_source.html#l00253">mlir::sparse_tensor::isDenseDLT()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sparsification_8cpp_source.html#l00341">getNumNonTrivialIdxExpOnSparseLvls()</a>.</p>

</div>
</div>
<a id="ad7626e19625af5dd5d73aacfb06061ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7626e19625af5dd5d73aacfb06061ba">&#9670;&nbsp;</a></span>isDynamicDim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorType::isDynamicDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a39f7b45046f9cc6ee2490f64fdb564b0">Dimension</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the given dimension has dynamic size. </p>
<p>If you intend to call <code>getDynamicDimSize</code> based on the result, then see the <code>getStaticDimSize</code> method instead. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00209">209</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorType_8h_source.html#l00187">getDynamicDimSize()</a>.</p>

</div>
</div>
<a id="a839df43feb35ab6abf0136be0a7ee45e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839df43feb35ab6abf0136be0a7ee45e">&#9670;&nbsp;</a></span>isIdentity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorType::isIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the dimToLvl mapping is the identity. </p>
<p>(This is always true for dense-tensors.) </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00147">147</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorType_8h_source.html#l00167">hasSameDimToLvlMap()</a>, and <a class="el" href="SparseTensorType_8h_source.html#l00050">SparseTensorType()</a>.</p>

</div>
</div>
<a id="af5f5a0c66c902927d30fa1d37df6573e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f5a0c66c902927d30fa1d37df6573e">&#9670;&nbsp;</a></span>isOrderedLvl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorType::isOrderedLvl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a4eeeb1242c0500476bf0e6b6da6a30e2">Level</a>&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00233">233</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorType_8h_source.html#l00220">getLvlType()</a>, and <a class="el" href="Enums_8h_source.html#l00280">mlir::sparse_tensor::isOrderedDLT()</a>.</p>

</div>
</div>
<a id="a052dd43add6a4d59d42b5ba51b686c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052dd43add6a4d59d42b5ba51b686c05">&#9670;&nbsp;</a></span>isSingletonLvl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorType::isSingletonLvl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a4eeeb1242c0500476bf0e6b6da6a30e2">Level</a>&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00232">232</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorType_8h_source.html#l00220">getLvlType()</a>, and <a class="el" href="Enums_8h_source.html#l00274">mlir::sparse_tensor::isSingletonDLT()</a>.</p>

</div>
</div>
<a id="afc6bd40237f4d3af041f2db05f7c8504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6bd40237f4d3af041f2db05f7c8504">&#9670;&nbsp;</a></span>isUniqueLvl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorType::isUniqueLvl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a4eeeb1242c0500476bf0e6b6da6a30e2">Level</a>&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00234">234</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorType_8h_source.html#l00220">getLvlType()</a>, and <a class="el" href="Enums_8h_source.html#l00285">mlir::sparse_tensor::isUniqueDLT()</a>.</p>

</div>
</div>
<a id="a6480eec7bd6676b1fe40f6bba14e459f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6480eec7bd6676b1fe40f6bba14e459f">&#9670;&nbsp;</a></span>operator T()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = std::enable_if_t&lt;                            std::is_convertible_v&lt;RankedTensorType, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::sparse_tensor::SparseTensorType::operator T </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow implicit conversion to <code>RankedTensorType</code>, <code>ShapedType</code>, and <code><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a></code>. </p>
<p>These are implicit to help alleviate the impedance mismatch for code that has not been converted to use <code><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html" title="A wrapper around RankedTensorType, which has three goals:">SparseTensorType</a></code> directly. Once more of the sparse compiler has been converted to using <code><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html" title="A wrapper around RankedTensorType, which has three goals:">SparseTensorType</a></code>, we may want to make these explicit instead.</p>
<p>WARNING: This user-defined-conversion method causes overload ambiguity whenever passing a <code><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html" title="A wrapper around RankedTensorType, which has three goals:">SparseTensorType</a></code> directly to a function which is overloaded to accept either <code><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a></code> or <code><a class="el" href="classmlir_1_1TypeRange.html" title="This class provides an abstraction over the various different ranges of value types.">TypeRange</a></code>. In particular, this includes <code><a class="el" href="classmlir_1_1RewriterBase.html#afb1c910a57707f518d2b9c903c2bb5bc" title="Replaces the result op with a new op that is created without verification.">RewriterBase::replaceOpWithNewOp</a>&lt;OpTy&gt;</code> and <code><a class="el" href="classmlir_1_1OpBuilder.html#ac6a6edadd39800db410864ef06a004b2" title="Creates an operation given the fields represented as an OperationState.">OpBuilder::create</a>&lt;OpTy&gt;</code> whenever the <code>OpTy::build</code> is overloaded thus. This happens because the <code><a class="el" href="classmlir_1_1TypeRange.html" title="This class provides an abstraction over the various different ranges of value types.">TypeRange</a>&lt;T&gt;(T&amp;&amp;)</code> ctor is implicit as well, and there's no SFINAE we can add to this method that would block subsequent application of that ctor. The only way to fix the overload ambiguity is to avoid <em>implicit</em> conversion at the callsite: e.g., by using <code>static_cast</code> to make the conversion explicit, by assigning the <code><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html" title="A wrapper around RankedTensorType, which has three goals:">SparseTensorType</a></code> to a temporary variable of the desired type, etc. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00106">106</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

</div>
</div>
<a id="a2f37b4e8c855ffbb1fa8bd9649221059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f37b4e8c855ffbb1fa8bd9649221059">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorType::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html">SparseTensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00121">121</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

</div>
</div>
<a id="af4d830b06b63a2f61566aaf98e9a868b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d830b06b63a2f61566aaf98e9a868b">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html">SparseTensorType</a>&amp; mlir::sparse_tensor::SparseTensorType::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html">SparseTensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51c04fd598aea23545eb45c17dd402c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c04fd598aea23545eb45c17dd402c7">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorType::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html">SparseTensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00115">115</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

</div>
</div>
<a id="a53f4e7b6bfb6fb188b9aef8d26bacfdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f4e7b6bfb6fb188b9aef8d26bacfdd">&#9670;&nbsp;</a></span>withEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html">SparseTensorType</a> mlir::sparse_tensor::SparseTensorType::withEncoding </td>
          <td>(</td>
          <td class="paramtype">SparseTensorEncodingAttr&#160;</td>
          <td class="paramname"><em>newEnc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new <code><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html" title="A wrapper around RankedTensorType, which has three goals:">SparseTensorType</a></code> with the same dimension-shape and element type, but with the encoding replaced by the given encoding. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00070">70</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorType_8h_source.html#l00050">SparseTensorType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorType_8h_source.html#l00077">withoutOrdering()</a>.</p>

</div>
</div>
<a id="a26bfd8ce2eaa18acc30fb81ce49894cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26bfd8ce2eaa18acc30fb81ce49894cc">&#9670;&nbsp;</a></span>withoutOrdering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html">SparseTensorType</a> mlir::sparse_tensor::SparseTensorType::withoutOrdering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new <code><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html" title="A wrapper around RankedTensorType, which has three goals:">SparseTensorType</a></code> with the same dimension-shape and element type, but with the encoding replaced by <code><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#ad5f5b4b2f2357638129b5621a50e3503" title="Returns the encoding (or the null-attribute for dense-tensors).">getEncoding()</a>.<a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html#a26bfd8ce2eaa18acc30fb81ce49894cc" title="Constructs a new SparseTensorType with the same dimension-shape and element type, but with the encodi...">withoutOrdering()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorType_8h_source.html#l00077">77</a> of file <a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorType_8h_source.html#l00070">withEncoding()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/mlir/Dialect/SparseTensor/IR/<a class="el" href="SparseTensorType_8h_source.html">SparseTensorType.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 4 2023 20:34:14 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
