<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Affine/Utils/Utils.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">17.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_30022079959872f4a1874dfcab7bb1fc.html">Affine</a></li><li class="navelem"><a class="el" href="dir_36ccfdf0d236a67fd57e73c4a5bad479.html">Utils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utils.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Dialect_2Affine_2Utils_8h_source.html">mlir/Dialect/Affine/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">mlir/Dialect/Affine/Analysis/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineValueMap_8h_source.html">mlir/Dialect/Affine/IR/AffineValueMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LoopUtils_8h_source.html">mlir/Dialect/Affine/LoopUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Arith_2Utils_2Utils_8h_source.html">mlir/Dialect/Arith/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="FuncOps_8h_source.html">mlir/Dialect/Func/IR/FuncOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineExprVisitor_8h_source.html">mlir/IR/AffineExprVisitor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dominance_8h_source.html">mlir/IR/Dominance.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IRMapping_8h_source.html">mlir/IR/IRMapping.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2IntegerSet_8h_source.html">mlir/IR/IntegerSet.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="GreedyPatternRewriteDriver_8h_source.html">mlir/Transforms/GreedyPatternRewriteDriver.h</a>&quot;</code><br />
<code>#include &lt;optional&gt;</code><br />
</div>
<p><a href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;affine-utils&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8361db875ebdd069691084e31cb1f90a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90a">TileExprPattern</a> { <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90aa0a2909cee5222be1729a359f34c482f6">TileFloorDiv</a>
, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90aafab640cbd0e0ef2d840e36d087e561ec">TileMod</a>
, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90aabb4b0501a7b81d89719cae036aa1937e">TileNone</a>
 }</td></tr>
<tr class="memdesc:a8361db875ebdd069691084e31cb1f90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to set patterns of affine expr in tiled-layout map.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90a">More...</a><br /></td></tr>
<tr class="separator:a8361db875ebdd069691084e31cb1f90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a91ed5c48cf2d60834e274223a2fe3391"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a91ed5c48cf2d60834e274223a2fe3391">promoteIfBlock</a> (AffineIfOp ifOp, bool elseBlock)</td></tr>
<tr class="memdesc:a91ed5c48cf2d60834e274223a2fe3391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes the <code>then</code> or the <code>else</code> block of <code>ifOp</code> (depending on whether <code>elseBlock</code> is false or true) into <code>ifOp</code>'s containing block, and discards the rest of the op.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a91ed5c48cf2d60834e274223a2fe3391">More...</a><br /></td></tr>
<tr class="separator:a91ed5c48cf2d60834e274223a2fe3391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c58877969ba751da8da214b1866e2e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#ac0c58877969ba751da8da214b1866e2e">getOutermostInvariantForOp</a> (AffineIfOp ifOp)</td></tr>
<tr class="memdesc:ac0c58877969ba751da8da214b1866e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outermost affine.for/parallel op that the <code>ifOp</code> is invariant on.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#ac0c58877969ba751da8da214b1866e2e">More...</a><br /></td></tr>
<tr class="separator:ac0c58877969ba751da8da214b1866e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3327936fe7d848e7ec99d8efaebf3794"><td class="memItemLeft" align="right" valign="top">static AffineIfOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a3327936fe7d848e7ec99d8efaebf3794">hoistAffineIfOp</a> (AffineIfOp ifOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *hoistOverOp)</td></tr>
<tr class="memdesc:a3327936fe7d848e7ec99d8efaebf3794"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper for the mechanics of mlir::hoistAffineIfOp.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a3327936fe7d848e7ec99d8efaebf3794">More...</a><br /></td></tr>
<tr class="separator:a3327936fe7d848e7ec99d8efaebf3794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e21f26b1679f4db66be5d34b3f162b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#ae5e21f26b1679f4db66be5d34b3f162b">mustReachAtInnermost</a> (const <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a> &amp;srcAccess, const <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a> &amp;destAccess)</td></tr>
<tr class="memdesc:ae5e21f26b1679f4db66be5d34b3f162b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the memory operation of <code>destAccess</code> depends on <code>srcAccess</code> inside of the innermost common surrounding affine loop between the two accesses.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#ae5e21f26b1679f4db66be5d34b3f162b">More...</a><br /></td></tr>
<tr class="separator:ae5e21f26b1679f4db66be5d34b3f162b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3e2b0216da6f19e2c46070b8d87a34"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a1b3e2b0216da6f19e2c46070b8d87a34">mayHaveEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *srcMemOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *destMemOp, unsigned minSurroundingLoops)</td></tr>
<tr class="memdesc:a1b3e2b0216da6f19e2c46070b8d87a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>srcMemOp</code> may have an effect on <code>destMemOp</code> within the scope of the outermost <code>minSurroundingLoops</code> loops that surround them.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a1b3e2b0216da6f19e2c46070b8d87a34">More...</a><br /></td></tr>
<tr class="separator:a1b3e2b0216da6f19e2c46070b8d87a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b5e959a281013c569a8ca6720021e3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a68b5e959a281013c569a8ca6720021e3">forwardStoreToLoad</a> (AffineReadOpInterface loadOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;loadOpsToErase, <a class="el" href="classllvm_1_1SmallPtrSetImpl.html">SmallPtrSetImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;memrefsToErase, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo)</td></tr>
<tr class="memdesc:a68b5e959a281013c569a8ca6720021e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to eliminate loadOp by replacing it with a value stored into memory which the load is guaranteed to retrieve.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a68b5e959a281013c569a8ca6720021e3">More...</a><br /></td></tr>
<tr class="separator:a68b5e959a281013c569a8ca6720021e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b1fb80bc03c7abe950758794cad9e4"><td class="memItemLeft" align="right" valign="top">template bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#aa3b1fb80bc03c7abe950758794cad9e4">mlir::affine::hasNoInterveningEffect&lt; mlir::MemoryEffects::Read, affine::AffineReadOpInterface &gt;</a> (<a class="el" href="classmlir_1_1Operation.html">mlir::Operation</a> *, affine::AffineReadOpInterface)</td></tr>
<tr class="separator:aa3b1fb80bc03c7abe950758794cad9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ea120a9473888db3f617dac2404687"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a73ea120a9473888db3f617dac2404687">findUnusedStore</a> (AffineWriteOpInterface writeA, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;opsToErase, <a class="el" href="classmlir_1_1PostDominanceInfo.html">PostDominanceInfo</a> &amp;postDominanceInfo)</td></tr>
<tr class="separator:a73ea120a9473888db3f617dac2404687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c958409217e6311092b570801a9842"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a35c958409217e6311092b570801a9842">loadCSE</a> (AffineReadOpInterface loadA, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;loadOpsToErase, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo)</td></tr>
<tr class="separator:a35c958409217e6311092b570801a9842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533cf0842c1c6bce487e9c42d7593543"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a533cf0842c1c6bce487e9c42d7593543">getTileSizePos</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; std::tuple&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, unsigned, unsigned &gt;&gt; &amp;tileSizePos)</td></tr>
<tr class="memdesc:a533cf0842c1c6bce487e9c42d7593543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>map</code> is a tiled layout.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a533cf0842c1c6bce487e9c42d7593543">More...</a><br /></td></tr>
<tr class="separator:a533cf0842c1c6bce487e9c42d7593543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb08d5234d99d6f4af63a5d0466028d8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#adb08d5234d99d6f4af63a5d0466028d8">isNormalizedMemRefDynamicDim</a> (unsigned dim, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> layoutMap, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; unsigned &gt; &amp;inMemrefTypeDynDims, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:adb08d5234d99d6f4af63a5d0466028d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>dim</code> dimension of memrefType with <code>layoutMap</code> becomes dynamic after normalization.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#adb08d5234d99d6f4af63a5d0466028d8">More...</a><br /></td></tr>
<tr class="separator:adb08d5234d99d6f4af63a5d0466028d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d1fa11b6b2534b14e10e5214f5a108"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#ab1d1fa11b6b2534b14e10e5214f5a108">createDimSizeExprForTiledLayout</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> oldMapOutput, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90a">TileExprPattern</a> pat)</td></tr>
<tr class="memdesc:ab1d1fa11b6b2534b14e10e5214f5a108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create affine expr to calculate dimension size for a tiled-layout map.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#ab1d1fa11b6b2534b14e10e5214f5a108">More...</a><br /></td></tr>
<tr class="separator:ab1d1fa11b6b2534b14e10e5214f5a108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01de90caeccd203207a3806b7dae0ba3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a01de90caeccd203207a3806b7dae0ba3">createNewDynamicSizes</a> (MemRefType oldMemRefType, MemRefType newMemRefType, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, memref::AllocOp *allocOp, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> b, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;newDynamicSizes)</td></tr>
<tr class="memdesc:a01de90caeccd203207a3806b7dae0ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new maps to calculate each dimension size of <code>newMemRefType</code>, and create <code>newDynamicSizes</code> from them by using AffineApplyOp.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a01de90caeccd203207a3806b7dae0ba3">More...</a><br /></td></tr>
<tr class="separator:a01de90caeccd203207a3806b7dae0ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5496b69e9e151385e3cc306aa3b8a6eb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a5496b69e9e151385e3cc306aa3b8a6eb">getIndexProduct</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; set)</td></tr>
<tr class="memdesc:a5496b69e9e151385e3cc306aa3b8a6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create IR that computes the product of all elements in the set.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a5496b69e9e151385e3cc306aa3b8a6eb">More...</a><br /></td></tr>
<tr class="separator:a5496b69e9e151385e3cc306aa3b8a6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;affine-utils&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00030">30</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a8361db875ebdd069691084e31cb1f90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8361db875ebdd069691084e31cb1f90a">&#9670;&nbsp;</a></span>TileExprPattern</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90a">TileExprPattern</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum to set patterns of affine expr in tiled-layout map. </p>
<p>TileFloorDiv: &lt;dim expr&gt; div &lt;tile size&gt; TileMod: &lt;dim expr&gt; mod &lt;tile size&gt; TileNone: None of the above Example: #tiled_2d_128x256 = affine_map&lt;(d0, d1) -&gt; (d0 div 128, d1 div 256, d0 mod 128, d1 mod 256)&gt; "d0 div 128" and "d1 div 256" ==&gt; TileFloorDiv "d0 mod 128" and "d1 mod 256" ==&gt; TileMod </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8361db875ebdd069691084e31cb1f90aa0a2909cee5222be1729a359f34c482f6"></a>TileFloorDiv&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8361db875ebdd069691084e31cb1f90aafab640cbd0e0ef2d840e36d087e561ec"></a>TileMod&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8361db875ebdd069691084e31cb1f90aabb4b0501a7b81d89719cae036aa1937e"></a>TileNone&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01483">1483</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab1d1fa11b6b2534b14e10e5214f5a108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d1fa11b6b2534b14e10e5214f5a108">&#9670;&nbsp;</a></span>createDimSizeExprForTiledLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> createDimSizeExprForTiledLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>oldMapOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90a">TileExprPattern</a>&#160;</td>
          <td class="paramname"><em>pat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create affine expr to calculate dimension size for a tiled-layout map. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01610">1610</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00291">mlir::AffineExpr::cast()</a>, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a30c212eb3184a5ed41f01a25c8124e8a">mlir::CeilDiv</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00047">mlir::getAffineBinaryOpExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00317">mlir::AffineBinaryOpExpr::getLHS()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00320">mlir::AffineBinaryOpExpr::getRHS()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01483">TileFloorDiv</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01483">TileMod</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01665">createNewDynamicSizes()</a>.</p>

</div>
</div>
<a id="a01de90caeccd203207a3806b7dae0ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01de90caeccd203207a3806b7dae0ba3">&#9670;&nbsp;</a></span>createNewDynamicSizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void createNewDynamicSizes </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>oldMemRefType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>newMemRefType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::AllocOp *&#160;</td>
          <td class="paramname"><em>allocOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newDynamicSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new maps to calculate each dimension size of <code>newMemRefType</code>, and create <code>newDynamicSizes</code> from them by using AffineApplyOp. </p>
<p>Steps for normalizing dynamic memrefs for a tiled layout map Example: #map0 = affine_map&lt;(d0, d1) -&gt; (d0, d1 floordiv 32, d1 mod 32)&gt; %0 = dim arg0, c1 :memref&lt;4x?xf32&gt; %1 = alloc(%0) : memref&lt;4x?xf32, #map0&gt;</p>
<p>(Before this function)</p><ol type="1">
<li>Check if <code>map</code>(#map0) is a tiled layout using <code><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a533cf0842c1c6bce487e9c42d7593543" title="Check if map is a tiled layout.">getTileSizePos()</a></code>. Only single layout map is supported.</li>
<li>Create normalized memrefType using <code><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#adb08d5234d99d6f4af63a5d0466028d8" title="Check if dim dimension of memrefType with layoutMap becomes dynamic after normalization.">isNormalizedMemRefDynamicDim()</a></code>. It is memref&lt;4x?x?xf32&gt; in the above example.</li>
</ol>
<p>(In this function)</p><ol type="1">
<li>Create new maps to calculate each dimension of the normalized memrefType using <code><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#ab1d1fa11b6b2534b14e10e5214f5a108" title="Create affine expr to calculate dimension size for a tiled-layout map.">createDimSizeExprForTiledLayout()</a></code>. In the tiled layout, the dimension size can be calculated by replacing "floordiv &lt;tile size&gt;" with "ceildiv &lt;tile size&gt;" and "mod &lt;tile size&gt;" with "&lt;tile size&gt;".</li>
</ol>
<ul>
<li>New map in the above example #map0 = affine_map&lt;(d0, d1) -&gt; (d0)&gt; #map1 = affine_map&lt;(d0, d1) -&gt; (d1 ceildiv 32)&gt; #map2 = affine_map&lt;(d0, d1) -&gt; (32)&gt;</li>
</ul>
<ol type="1">
<li>Create AffineApplyOp to apply the new maps. The output of AffineApplyOp is used in dynamicSizes of new AllocOp. %0 = dim arg0, c1 : memref&lt;4x?xf32&gt; c4 = arith.constant 4 : index %1 = affine.apply #map1(c4, %0) %2 = affine.apply #map2(c4, %0) </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01665">1665</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01610">createDimSizeExprForTiledLayout()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01135">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00068">mlir::Builder::getIndexType()</a>, <a class="el" href="Builders_8cpp_source.html#l00224">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00333">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00328">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00337">mlir::AffineMap::getResults()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01491">getTileSizePos()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01483">TileFloorDiv</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01483">TileMod</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01483">TileNone</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01714">mlir::affine::normalizeMemRef()</a>.</p>

</div>
</div>
<a id="a73ea120a9473888db3f617dac2404687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ea120a9473888db3f617dac2404687">&#9670;&nbsp;</a></span>findUnusedStore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void findUnusedStore </td>
          <td>(</td>
          <td class="paramtype">AffineWriteOpInterface&#160;</td>
          <td class="paramname"><em>writeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>opsToErase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PostDominanceInfo.html">PostDominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>postDominanceInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00938">938</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00814">mlir::Operation::getUsers()</a>, and <a class="el" href="Dominance_8h_source.html#l00188">mlir::PostDominanceInfo::postDominates()</a>.</p>

</div>
</div>
<a id="a68b5e959a281013c569a8ca6720021e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b5e959a281013c569a8ca6720021e3">&#9670;&nbsp;</a></span>forwardStoreToLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> forwardStoreToLoad </td>
          <td>(</td>
          <td class="paramtype">AffineReadOpInterface&#160;</td>
          <td class="paramname"><em>loadOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>loadOpsToErase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallPtrSetImpl.html">SmallPtrSetImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>memrefsToErase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>domInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to eliminate loadOp by replacing it with a value stored into memory which the load is guaranteed to retrieve. </p>
<p>This check involves three components: 1) The store and load must be on the same location 2) The store must dominate (and therefore must always occur prior to) the load 3) No other operations will overwrite the memory loaded between the given load and store. If such a value exists, the replaced <code>loadOp</code> will be added to <code>loadOpsToErase</code> and its memref will be added to <code>memrefsToErase</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00862">862</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dominance_8h_source.html#l00141">mlir::DominanceInfo::dominates()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00658">mustReachAtInnermost()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01063">mlir::affine::affineScalarReplace()</a>.</p>

</div>
</div>
<a id="a5496b69e9e151385e3cc306aa3b8a6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5496b69e9e151385e3cc306aa3b8a6eb">&#9670;&nbsp;</a></span>getIndexProduct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; getIndexProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create IR that computes the product of all elements in the set. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01866">1866</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00343">mlir::bindSymbols()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01333">mlir::affine::makeComposedFoldedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01879">mlir::affine::delinearizeIndex()</a>.</p>

</div>
</div>
<a id="ac0c58877969ba751da8da214b1866e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c58877969ba751da8da214b1866e2e">&#9670;&nbsp;</a></span>getOutermostInvariantForOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Operation.html">Operation</a>* getOutermostInvariantForOp </td>
          <td>(</td>
          <td class="paramtype">AffineIfOp&#160;</td>
          <td class="paramname"><em>ifOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outermost affine.for/parallel op that the <code>ifOp</code> is invariant on. </p>
<p>The <code>ifOp</code> could be hoisted and placed right before such an operation. This method assumes that the ifOp has been canonicalized (to be correct and effective). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00257">257</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00373">mlir::Operation::getOperands()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00405">mlir::affine::hoistAffineIfOp()</a>.</p>

</div>
</div>
<a id="a533cf0842c1c6bce487e9c42d7593543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533cf0842c1c6bce487e9c42d7593543">&#9670;&nbsp;</a></span>getTileSizePos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> getTileSizePos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; std::tuple&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, unsigned, unsigned &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tileSizePos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <code>map</code> is a tiled layout. </p>
<p>In the tiled layout, specific k dimensions being floordiv'ed by respective tile sizes appeare in a mod with the same tile sizes, and no other expression involves those k dimensions. This function stores a vector of tuples (<code>tileSizePos</code>) including AffineExpr for tile size, positions of corresponding <code>floordiv</code> and <code>mod</code>. If it is not a tiled layout, an empty vector is returned. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01491">1491</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00291">mlir::AffineExpr::cast()</a>, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133abaa422535e7ce48b442cc07089e64e7a">mlir::FloorDiv</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00317">mlir::AffineBinaryOpExpr::getLHS()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00337">mlir::AffineMap::getResults()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00320">mlir::AffineBinaryOpExpr::getRHS()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00270">mlir::AffineExpr::isa()</a>, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a7aeb0277500c86e4aa6bd23f9a737942">mlir::Mod</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01665">createNewDynamicSizes()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01714">mlir::affine::normalizeMemRef()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01772">mlir::affine::normalizeMemRefType()</a>.</p>

</div>
</div>
<a id="a3327936fe7d848e7ec99d8efaebf3794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3327936fe7d848e7ec99d8efaebf3794">&#9670;&nbsp;</a></span>hoistAffineIfOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static AffineIfOp hoistAffineIfOp </td>
          <td>(</td>
          <td class="paramtype">AffineIfOp&#160;</td>
          <td class="paramname"><em>ifOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>hoistOverOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper for the mechanics of mlir::hoistAffineIfOp. </p>
<p>Hoists <code>ifOp</code> just over <code>hoistOverOp</code>. Returns the new hoisted op if any hoisting happened, otherwise the same <code>ifOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00283">283</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00052">mlir::WalkResult::advance()</a>, <a class="el" href="IRMapping_8h_source.html#l00079">mlir::IRMapping::clear()</a>, <a class="el" href="Builders_8cpp_source.html#l00520">mlir::OpBuilder::clone()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="Builders_8cpp_source.html#l00113">mlir::Builder::getBoolAttr()</a>, <a class="el" href="Block_8h_source.html#l00126">mlir::Block::getOperations()</a>, <a class="el" href="Builders_8cpp_source.html#l00255">mlir::Builder::getStringAttr()</a>, <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::interrupt()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00241">promoteIfBlock()</a>, and <a class="el" href="Builders_8h_source.html#l00393">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

</div>
</div>
<a id="adb08d5234d99d6f4af63a5d0466028d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb08d5234d99d6f4af63a5d0466028d8">&#9670;&nbsp;</a></span>isNormalizedMemRefDynamicDim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isNormalizedMemRefDynamicDim </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>layoutMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>inMemrefTypeDynDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <code>dim</code> dimension of memrefType with <code>layoutMap</code> becomes dynamic after normalization. </p>
<p>Dimensions that include dynamic dimensions in the map output will become dynamic dimensions. Return true if <code>dim</code> is dynamic dimension.</p>
<p>Example: #map0 = affine_map&lt;(d0, d1) -&gt; (d0, d1 floordiv 32, d1 mod 32)&gt;</p>
<p>If d1 is dynamic dimension, 2nd and 3rd dimension of map output are dynamic. memref&lt;4x?xf32, #map0&gt; ==&gt; memref&lt;4x?x?xf32&gt; </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01590">1590</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00337">mlir::AffineMap::getResults()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00270">mlir::AffineExpr::isa()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00030">mlir::AffineExpr::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01772">mlir::affine::normalizeMemRefType()</a>.</p>

</div>
</div>
<a id="a35c958409217e6311092b570801a9842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c958409217e6311092b570801a9842">&#9670;&nbsp;</a></span>loadCSE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void loadCSE </td>
          <td>(</td>
          <td class="paramtype">AffineReadOpInterface&#160;</td>
          <td class="paramname"><em>loadA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>loadOpsToErase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>domInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00983">983</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dominance_8h_source.html#l00141">mlir::DominanceInfo::dominates()</a>, and <a class="el" href="Value_8h_source.html#l00166">mlir::Value::replaceAllUsesWith()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01063">mlir::affine::affineScalarReplace()</a>.</p>

</div>
</div>
<a id="a1b3e2b0216da6f19e2c46070b8d87a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3e2b0216da6f19e2c46070b8d87a34">&#9670;&nbsp;</a></span>mayHaveEffect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mayHaveEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>srcMemOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>destMemOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>minSurroundingLoops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>srcMemOp</code> may have an effect on <code>destMemOp</code> within the scope of the outermost <code>minSurroundingLoops</code> loops that surround them. </p>
<p><code>srcMemOp</code> and <code>destMemOp</code> are expected to be affine read/write ops. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00675">675</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00598">mlir::affine::checkMemrefAccessDependence()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00251">mlir::affine::getAffineScope()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01765">mlir::affine::getNumCommonSurroundingLoops()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00082">mlir::affine::MemRefAccess::memref</a>, and <a class="el" href="AffineAnalysis_8h_source.html#l00184">mlir::affine::noDependence()</a>.</p>

</div>
</div>
<a id="aa3b1fb80bc03c7abe950758794cad9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b1fb80bc03c7abe950758794cad9e4">&#9670;&nbsp;</a></span>mlir::affine::hasNoInterveningEffect&lt; mlir::MemoryEffects::Read, affine::AffineReadOpInterface &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="namespacemlir_1_1affine.html#aac2822c435c4d6938d6c2d963f3fa0c6">mlir::affine::hasNoInterveningEffect</a>&lt; <a class="el" href="structmlir_1_1MemoryEffects_1_1Read.html">mlir::MemoryEffects::Read</a>, affine::AffineReadOpInterface &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">mlir::Operation</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">affine::AffineReadOpInterface&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5e21f26b1679f4db66be5d34b3f162b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e21f26b1679f4db66be5d34b3f162b">&#9670;&nbsp;</a></span>mustReachAtInnermost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mustReachAtInnermost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a> &amp;&#160;</td>
          <td class="paramname"><em>srcAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a> &amp;&#160;</td>
          <td class="paramname"><em>destAccess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the memory operation of <code>destAccess</code> depends on <code>srcAccess</code> inside of the innermost common surrounding affine loop between the two accesses. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00658">658</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00598">mlir::affine::checkMemrefAccessDependence()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00251">mlir::affine::getAffineScope()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01765">mlir::affine::getNumCommonSurroundingLoops()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00178">mlir::affine::hasDependence()</a>, and <a class="el" href="AffineAnalysis_8h_source.html#l00083">mlir::affine::MemRefAccess::opInst</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00862">forwardStoreToLoad()</a>.</p>

</div>
</div>
<a id="a91ed5c48cf2d60834e274223a2fe3391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ed5c48cf2d60834e274223a2fe3391">&#9670;&nbsp;</a></span>promoteIfBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void promoteIfBlock </td>
          <td>(</td>
          <td class="paramtype">AffineIfOp&#160;</td>
          <td class="paramname"><em>ifOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>elseBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Promotes the <code>then</code> or the <code>else</code> block of <code>ifOp</code> (depending on whether <code>elseBlock</code> is false or true) into <code>ifOp</code>'s containing block, and discards the rest of the op. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00241">241</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00132">mlir::Block::begin()</a>, <a class="el" href="Block_8h_source.html#l00133">mlir::Block::end()</a>, and <a class="el" href="Block_8h_source.html#l00126">mlir::Block::getOperations()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00283">hoistAffineIfOp()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 4 2023 20:34:08 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
