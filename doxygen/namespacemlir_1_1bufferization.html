<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::bufferization Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">17.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1bufferization.html">bufferization</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::bufferization Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1bufferization_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1bufferization_1_1func__ext"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization_1_1func__ext.html">func_ext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1AliasingOpOperand.html">AliasingOpOperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A maybe aliasing <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a>.  <a href="structmlir_1_1bufferization_1_1AliasingOpOperand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1AliasingOpResult.html">AliasingOpResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A maybe aliasing <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a>.  <a href="structmlir_1_1bufferization_1_1AliasingOpResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1AliasList.html">AliasList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1OpFilter.html">OpFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for BufferizableOpInterface-based bufferization.  <a href="structmlir_1_1bufferization_1_1BufferizationOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">AnalysisState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html" title="AnalysisState provides a variety of helper functions for dealing with tensor values.">AnalysisState</a> provides a variety of helper functions for dealing with tensor values.  <a href="classmlir_1_1bufferization_1_1AnalysisState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1DstBufferizableOpInterfaceExternalModel.html">DstBufferizableOpInterfaceExternalModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferizable ops that implement the DestinationStyleOpInterface can use this external model base class.  <a href="structmlir_1_1bufferization_1_1DstBufferizableOpInterfaceExternalModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferization statistics for debugging.  <a href="structmlir_1_1bufferization_1_1BufferizationStatistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper type converter class that automatically populates the relevant materializations and type conversions for bufferization.  <a href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferPlacementAllocs.html">BufferPlacementAllocs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple analysis that detects allocation operations.  <a href="classmlir_1_1bufferization_1_1BufferPlacementAllocs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferPlacementTransformationBase.html">BufferPlacementTransformationBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for all BufferPlacement transformations.  <a href="classmlir_1_1bufferization_1_1BufferPlacementTransformationBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for analysis-enabled bufferization.  <a href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State for analysis-enabled bufferization.  <a href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1BufferResultsToOutParamsOptions.html">BufferResultsToOutParamsOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a976af01e3a00f974529232f7e611233c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a976af01e3a00f974529232f7e611233c">AliasingOpOperandList</a> = <a class="el" href="classmlir_1_1bufferization_1_1AliasList.html">AliasList</a>&lt; <a class="el" href="structmlir_1_1bufferization_1_1AliasingOpOperand.html">AliasingOpOperand</a> &gt;</td></tr>
<tr class="memdesc:a976af01e3a00f974529232f7e611233c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of possible aliasing OpOperands.  <a href="namespacemlir_1_1bufferization.html#a976af01e3a00f974529232f7e611233c">More...</a><br /></td></tr>
<tr class="separator:a976af01e3a00f974529232f7e611233c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac062f1cc941a2a4f5f3ff71daca213c6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ac062f1cc941a2a4f5f3ff71daca213c6">AliasingOpResultList</a> = <a class="el" href="classmlir_1_1bufferization_1_1AliasList.html">AliasList</a>&lt; <a class="el" href="structmlir_1_1bufferization_1_1AliasingOpResult.html">AliasingOpResult</a> &gt;</td></tr>
<tr class="memdesc:ac062f1cc941a2a4f5f3ff71daca213c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of possible aliasing OpResults.  <a href="namespacemlir_1_1bufferization.html#ac062f1cc941a2a4f5f3ff71daca213c6">More...</a><br /></td></tr>
<tr class="separator:ac062f1cc941a2a4f5f3ff71daca213c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f555e6310adbe13cf6fd0163a345f65"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a9f555e6310adbe13cf6fd0163a345f65">AnchorMatchFn</a> = std::function&lt; bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;)&gt;</td></tr>
<tr class="memdesc:a9f555e6310adbe13cf6fd0163a345f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that matches anchor OpOperands for tensor::EmptyOp elimination.  <a href="namespacemlir_1_1bufferization.html#a9f555e6310adbe13cf6fd0163a345f65">More...</a><br /></td></tr>
<tr class="separator:a9f555e6310adbe13cf6fd0163a345f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad8a6459f58b1a5a6772110aac8d93d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#afad8a6459f58b1a5a6772110aac8d93d">RewriteFn</a> = std::function&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;)&gt;</td></tr>
<tr class="memdesc:afad8a6459f58b1a5a6772110aac8d93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that rewrites matched anchors.  <a href="namespacemlir_1_1bufferization.html#afad8a6459f58b1a5a6772110aac8d93d">More...</a><br /></td></tr>
<tr class="separator:afad8a6459f58b1a5a6772110aac8d93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afbf6d54f9e3c10b9003b66b6224b28bf"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bf">BufferRelation</a> { <a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bfa88183b946cc5f0e8c96b2e66e1c74a7e">Unknown</a>
, <a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bfaafd102579f64c98e96d92a7424130605">Equivalent</a>
 }</td></tr>
<tr class="memdesc:afbf6d54f9e3c10b9003b66b6224b28bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a fine-grain relationship between buffers to enable more analysis.  <a href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bf">More...</a><br /></td></tr>
<tr class="separator:afbf6d54f9e3c10b9003b66b6224b28bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa24e592182e0b88ede8e85dbc3dcac5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aa24e592182e0b88ede8e85dbc3dcac5e">isFunctionArgument</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:aa24e592182e0b88ede8e85dbc3dcac5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the given value is a <a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a> of a func::FuncOp.  <a href="namespacemlir_1_1bufferization.html#aa24e592182e0b88ede8e85dbc3dcac5e">More...</a><br /></td></tr>
<tr class="separator:aa24e592182e0b88ede8e85dbc3dcac5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b8affbc45eb90f938f0d94b21eac45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a84b8affbc45eb90f938f0d94b21eac45">allocateTensorForShapedValue</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> shapedValue, bool escape, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, bool <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp.html#a6ca5ef47ce8bbced1c354e95e188f2e2">copy</a>=true)</td></tr>
<tr class="memdesc:a84b8affbc45eb90f938f0d94b21eac45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an AllocTensorOp for the given shaped value (memref or tensor).  <a href="namespacemlir_1_1bufferization.html#a84b8affbc45eb90f938f0d94b21eac45">More...</a><br /></td></tr>
<tr class="separator:a84b8affbc45eb90f938f0d94b21eac45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328e7c6d8ce499626dbf57ca19e482dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a328e7c6d8ce499626dbf57ca19e482dd">allocationDoesNotEscape</a> (<a class="el" href="classmlir_1_1OpResult.html">OpResult</a> opResult)</td></tr>
<tr class="memdesc:a328e7c6d8ce499626dbf57ca19e482dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the allocation of the given op is guaranteed to not escape the containing block.  <a href="namespacemlir_1_1bufferization.html#a328e7c6d8ce499626dbf57ca19e482dd">More...</a><br /></td></tr>
<tr class="separator:a328e7c6d8ce499626dbf57ca19e482dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf241364e9dfd1def82141c75035f4b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#abf241364e9dfd1def82141c75035f4b0">getBuffer</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Value.html">Value</a> value, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:abf241364e9dfd1def82141c75035f4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup the buffer for the given value.  <a href="namespacemlir_1_1bufferization.html#abf241364e9dfd1def82141c75035f4b0">More...</a><br /></td></tr>
<tr class="separator:abf241364e9dfd1def82141c75035f4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc2d902756788c32c33244776d141c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aadc2d902756788c32c33244776d141c7">getBufferType</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:aadc2d902756788c32c33244776d141c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization without bufferizing any IR.  <a href="namespacemlir_1_1bufferization.html#aadc2d902756788c32c33244776d141c7">More...</a><br /></td></tr>
<tr class="separator:aadc2d902756788c32c33244776d141c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de4a7671524f168224c818658f03bfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a2de4a7671524f168224c818658f03bfb">getBufferType</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, const <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> &gt; &amp;fixedTypes)</td></tr>
<tr class="memdesc:a2de4a7671524f168224c818658f03bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization without bufferizing any IR.  <a href="namespacemlir_1_1bufferization.html#a2de4a7671524f168224c818658f03bfb">More...</a><br /></td></tr>
<tr class="separator:a2de4a7671524f168224c818658f03bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05561ae5b9cceea1c45832340484ad6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a05561ae5b9cceea1c45832340484ad6b">replaceOpWithBufferizedValues</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values)</td></tr>
<tr class="memdesc:a05561ae5b9cceea1c45832340484ad6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace an op with replacement values.  <a href="namespacemlir_1_1bufferization.html#a05561ae5b9cceea1c45832340484ad6b">More...</a><br /></td></tr>
<tr class="separator:a05561ae5b9cceea1c45832340484ad6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91366abfb8d491ea5701260487518959"><td class="memTemplParams" colspan="2">template&lt;typename OpTy , typename... Args&gt; </td></tr>
<tr class="memitem:a91366abfb8d491ea5701260487518959"><td class="memTemplItemLeft" align="right" valign="top">OpTy&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a91366abfb8d491ea5701260487518959">replaceOpWithNewBufferizedOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a91366abfb8d491ea5701260487518959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace an op with a new op.  <a href="namespacemlir_1_1bufferization.html#a91366abfb8d491ea5701260487518959">More...</a><br /></td></tr>
<tr class="separator:a91366abfb8d491ea5701260487518959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db18d8594be09f305df7fc8cc2afedb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a6db18d8594be09f305df7fc8cc2afedb">shouldDeallocateOpResult</a> (<a class="el" href="classmlir_1_1OpResult.html">OpResult</a> opResult, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a6db18d8594be09f305df7fc8cc2afedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the buffer of given <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> should be deallocated.  <a href="namespacemlir_1_1bufferization.html#a6db18d8594be09f305df7fc8cc2afedb">More...</a><br /></td></tr>
<tr class="separator:a6db18d8594be09f305df7fc8cc2afedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660fa21f93f165f53aa703efc73fa210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a660fa21f93f165f53aa703efc73fa210">getMemRefType</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, MemRefLayoutAttrInterface layout={}, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace=nullptr)</td></tr>
<tr class="memdesc:a660fa21f93f165f53aa703efc73fa210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a MemRefType to which the type of the given value can be bufferized.  <a href="namespacemlir_1_1bufferization.html#a660fa21f93f165f53aa703efc73fa210">More...</a><br /></td></tr>
<tr class="separator:a660fa21f93f165f53aa703efc73fa210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4daaf086abd1c64e90dc9529f76e1d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#af4daaf086abd1c64e90dc9529f76e1d4">getMemRefTypeWithFullyDynamicLayout</a> (<a class="el" href="classmlir_1_1TensorType.html">TensorType</a> tensorType, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace=nullptr)</td></tr>
<tr class="memdesc:af4daaf086abd1c64e90dc9529f76e1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a MemRef type with fully dynamic layout.  <a href="namespacemlir_1_1bufferization.html#af4daaf086abd1c64e90dc9529f76e1d4">More...</a><br /></td></tr>
<tr class="separator:af4daaf086abd1c64e90dc9529f76e1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d01c9f4f43c19b51520658e24853d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a05d01c9f4f43c19b51520658e24853d6">getMemRefTypeWithStaticIdentityLayout</a> (<a class="el" href="classmlir_1_1TensorType.html">TensorType</a> tensorType, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace=nullptr)</td></tr>
<tr class="memdesc:a05d01c9f4f43c19b51520658e24853d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a MemRef type with a static identity layout (i.e., no layout map).  <a href="namespacemlir_1_1bufferization.html#a05d01c9f4f43c19b51520658e24853d6">More...</a><br /></td></tr>
<tr class="separator:a05d01c9f4f43c19b51520658e24853d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ed0ccb4e307d98675ecab129feddf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a25ed0ccb4e307d98675ecab129feddf5">getOwnerOfValue</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a25ed0ccb4e307d98675ecab129feddf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the owner of the given value.  <a href="namespacemlir_1_1bufferization.html#a25ed0ccb4e307d98675ecab129feddf5">More...</a><br /></td></tr>
<tr class="separator:a25ed0ccb4e307d98675ecab129feddf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4161c8ecc07cf507a67acf1b5bfdc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a7b4161c8ecc07cf507a67acf1b5bfdc0">getEnclosingRepetitiveRegion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a7b4161c8ecc07cf507a67acf1b5bfdc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the closest enclosing repetitive region around the given op.  <a href="namespacemlir_1_1bufferization.html#a7b4161c8ecc07cf507a67acf1b5bfdc0">More...</a><br /></td></tr>
<tr class="separator:a7b4161c8ecc07cf507a67acf1b5bfdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b13384af1c06bd70e869d0031b411f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ae3b13384af1c06bd70e869d0031b411f">getEnclosingRepetitiveRegion</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:ae3b13384af1c06bd70e869d0031b411f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the closest enclosing repetitive region around the place where the given value is defined.  <a href="namespacemlir_1_1bufferization.html#ae3b13384af1c06bd70e869d0031b411f">More...</a><br /></td></tr>
<tr class="separator:ae3b13384af1c06bd70e869d0031b411f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d6257f0fd8cb5e33cb24d6bcaf8470"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ad5d6257f0fd8cb5e33cb24d6bcaf8470">getEnclosingRepetitiveRegion</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:ad5d6257f0fd8cb5e33cb24d6bcaf8470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the closest enclosing repetitive region around the given block.  <a href="namespacemlir_1_1bufferization.html#ad5d6257f0fd8cb5e33cb24d6bcaf8470">More...</a><br /></td></tr>
<tr class="separator:ad5d6257f0fd8cb5e33cb24d6bcaf8470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab812aaab64b7b9fb0416797db2e146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a8ab812aaab64b7b9fb0416797db2e146">getNextEnclosingRepetitiveRegion</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> *region, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a8ab812aaab64b7b9fb0416797db2e146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that the given region is repetitive, find the next enclosing repetitive region.  <a href="namespacemlir_1_1bufferization.html#a8ab812aaab64b7b9fb0416797db2e146">More...</a><br /></td></tr>
<tr class="separator:a8ab812aaab64b7b9fb0416797db2e146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7726e480700dfb860214b275d6a396d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#af7726e480700dfb860214b275d6a396d">populateDynamicDimSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> shapedValue, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dynamicDims)</td></tr>
<tr class="memdesc:af7726e480700dfb860214b275d6a396d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate <code>dynamicDims</code> with tensor::DimOp / memref::DimOp results for all dynamic dimensions of the given shaped value.  <a href="namespacemlir_1_1bufferization.html#af7726e480700dfb860214b275d6a396d">More...</a><br /></td></tr>
<tr class="separator:af7726e480700dfb860214b275d6a396d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf648dc804a1dcc39379e036051dbf82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#acf648dc804a1dcc39379e036051dbf82">castOrReallocMemRefValue</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> value, MemRefType type)</td></tr>
<tr class="memdesc:acf648dc804a1dcc39379e036051dbf82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to cast the given ranked MemRef-typed value to the given ranked MemRef type.  <a href="namespacemlir_1_1bufferization.html#acf648dc804a1dcc39379e036051dbf82">More...</a><br /></td></tr>
<tr class="separator:acf648dc804a1dcc39379e036051dbf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f68223b1811698fd85780df73c4fde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a64f68223b1811698fd85780df73c4fde">foldToMemrefToTensorPair</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, ToMemrefOp toMemref)</td></tr>
<tr class="memdesc:a64f68223b1811698fd85780df73c4fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to fold to_memref(to_tensor(x)).  <a href="namespacemlir_1_1bufferization.html#a64f68223b1811698fd85780df73c4fde">More...</a><br /></td></tr>
<tr class="separator:a64f68223b1811698fd85780df73c4fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2d5a6d2e5ab89ec76a879d71e32a36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a2b2d5a6d2e5ab89ec76a879d71e32a36">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a2b2d5a6d2e5ab89ec76a879d71e32a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6223871e93de2dbc611e8e54c5e4fb3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a6223871e93de2dbc611e8e54c5e4fb3b">populateBufferizeMaterializationLegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a6223871e93de2dbc611e8e54c5e4fb3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks ops used by bufferization for type conversion materializations as "legal" in the given <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target.">ConversionTarget</a>.  <a href="namespacemlir_1_1bufferization.html#a6223871e93de2dbc611e8e54c5e4fb3b">More...</a><br /></td></tr>
<tr class="separator:a6223871e93de2dbc611e8e54c5e4fb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22345dcd836dbc3216a89bbd4ce26821"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a22345dcd836dbc3216a89bbd4ce26821">populateEliminateBufferizeMaterializationsPatterns</a> (<a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a22345dcd836dbc3216a89bbd4ce26821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns to eliminate bufferize materializations.  <a href="namespacemlir_1_1bufferization.html#a22345dcd836dbc3216a89bbd4ce26821">More...</a><br /></td></tr>
<tr class="separator:a22345dcd836dbc3216a89bbd4ce26821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e83004db3df49f8b47869e41af7ed7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a65e83004db3df49f8b47869e41af7ed7">bufferizeOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, bool copyBeforeWrite=true, const <a class="el" href="classmlir_1_1bufferization_1_1OpFilter.html">OpFilter</a> *opFilter=nullptr, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *statistics=nullptr)</td></tr>
<tr class="memdesc:a65e83004db3df49f8b47869e41af7ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>.  <a href="namespacemlir_1_1bufferization.html#a65e83004db3df49f8b47869e41af7ed7">More...</a><br /></td></tr>
<tr class="separator:a65e83004db3df49f8b47869e41af7ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36c97b27b691ad7fcee01d70ca143a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ac36c97b27b691ad7fcee01d70ca143a9">getPartialBufferizationOptions</a> ()</td></tr>
<tr class="separator:ac36c97b27b691ad7fcee01d70ca143a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac429167681d191256dad3476d862bda2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; memref::GlobalOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ac429167681d191256dad3476d862bda2">getGlobalFor</a> (arith::ConstantOp constantOp, uint64_t alignment, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={})</td></tr>
<tr class="separator:ac429167681d191256dad3476d862bda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec3ce210ab7a2c1c1e82a266bfb9e3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a1ec3ce210ab7a2c1c1e82a266bfb9e3f">analyzeOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;state, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *statistics=nullptr)</td></tr>
<tr class="memdesc:a1ec3ce210ab7a2c1c1e82a266bfb9e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze <code>op</code> and its nested ops.  <a href="namespacemlir_1_1bufferization.html#a1ec3ce210ab7a2c1c1e82a266bfb9e3f">More...</a><br /></td></tr>
<tr class="separator:a1ec3ce210ab7a2c1c1e82a266bfb9e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02260c2ee96b5ef6845cf31eefabb24b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a02260c2ee96b5ef6845cf31eefabb24b">runOneShotBufferize</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *statistics=nullptr)</td></tr>
<tr class="memdesc:a02260c2ee96b5ef6845cf31eefabb24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run One-Shot Bufferize on the given op: Analysis + Bufferization.  <a href="namespacemlir_1_1bufferization.html#a02260c2ee96b5ef6845cf31eefabb24b">More...</a><br /></td></tr>
<tr class="separator:a02260c2ee96b5ef6845cf31eefabb24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a75fc3cff64d1470cbf4a50eb0261e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a79a75fc3cff64d1470cbf4a50eb0261e">analyzeModuleOp</a> (ModuleOp moduleOp, <a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;state, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *statistics=nullptr)</td></tr>
<tr class="memdesc:a79a75fc3cff64d1470cbf4a50eb0261e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze <code>moduleOp</code> and its nested ops.  <a href="namespacemlir_1_1bufferization.html#a79a75fc3cff64d1470cbf4a50eb0261e">More...</a><br /></td></tr>
<tr class="separator:a79a75fc3cff64d1470cbf4a50eb0261e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb127f406f6c5e58ffe5ee4939037891"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#afb127f406f6c5e58ffe5ee4939037891">bufferizeModuleOp</a> (ModuleOp moduleOp, const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *statistics=nullptr)</td></tr>
<tr class="memdesc:afb127f406f6c5e58ffe5ee4939037891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>.  <a href="namespacemlir_1_1bufferization.html#afb127f406f6c5e58ffe5ee4939037891">More...</a><br /></td></tr>
<tr class="separator:afb127f406f6c5e58ffe5ee4939037891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cfedafe4d56324592c31cbe6c7ddb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ac2cfedafe4d56324592c31cbe6c7ddb1">removeBufferizationAttributesInModule</a> (ModuleOp moduleOp)</td></tr>
<tr class="memdesc:ac2cfedafe4d56324592c31cbe6c7ddb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove bufferization attributes on every FuncOp arguments in the ModuleOp.  <a href="namespacemlir_1_1bufferization.html#ac2cfedafe4d56324592c31cbe6c7ddb1">More...</a><br /></td></tr>
<tr class="separator:ac2cfedafe4d56324592c31cbe6c7ddb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b77f5324f17a99ff8b568521bfaeadd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a3b77f5324f17a99ff8b568521bfaeadd">runOneShotModuleBufferize</a> (ModuleOp moduleOp, const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">bufferization::OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *statistics=nullptr)</td></tr>
<tr class="memdesc:a3b77f5324f17a99ff8b568521bfaeadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run One-Shot Module Bufferization on the given module.  <a href="namespacemlir_1_1bufferization.html#a3b77f5324f17a99ff8b568521bfaeadd">More...</a><br /></td></tr>
<tr class="separator:a3b77f5324f17a99ff8b568521bfaeadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbadbbffeae2eddfac65c53b2f1cadba"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#adbadbbffeae2eddfac65c53b2f1cadba">createBufferDeallocationPass</a> ()</td></tr>
<tr class="memdesc:adbadbbffeae2eddfac65c53b2f1cadba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the BufferDeallocation pass to free all allocated buffers.  <a href="namespacemlir_1_1bufferization.html#adbadbbffeae2eddfac65c53b2f1cadba">More...</a><br /></td></tr>
<tr class="separator:adbadbbffeae2eddfac65c53b2f1cadba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9fe9c9234e2d22a86553a393f074d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a8e9fe9c9234e2d22a86553a393f074d8">deallocateBuffers</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a8e9fe9c9234e2d22a86553a393f074d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run buffer deallocation.  <a href="namespacemlir_1_1bufferization.html#a8e9fe9c9234e2d22a86553a393f074d8">More...</a><br /></td></tr>
<tr class="separator:a8e9fe9c9234e2d22a86553a393f074d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b99b019001e22f13cbb9adaf483febe"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a4b99b019001e22f13cbb9adaf483febe">createBufferHoistingPass</a> ()</td></tr>
<tr class="memdesc:a4b99b019001e22f13cbb9adaf483febe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that moves allocations upwards to reduce the number of required copies that are inserted during the BufferDeallocation pass.  <a href="namespacemlir_1_1bufferization.html#a4b99b019001e22f13cbb9adaf483febe">More...</a><br /></td></tr>
<tr class="separator:a4b99b019001e22f13cbb9adaf483febe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f24bfd4dabfbaa35cb099c0cc78480"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a94f24bfd4dabfbaa35cb099c0cc78480">createBufferLoopHoistingPass</a> ()</td></tr>
<tr class="memdesc:a94f24bfd4dabfbaa35cb099c0cc78480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that moves allocations upwards out of loops.  <a href="namespacemlir_1_1bufferization.html#a94f24bfd4dabfbaa35cb099c0cc78480">More...</a><br /></td></tr>
<tr class="separator:a94f24bfd4dabfbaa35cb099c0cc78480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dcdd4f694419492c0a0b6adfc3c811"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a98dcdd4f694419492c0a0b6adfc3c811">createBufferResultsToOutParamsPass</a> (const <a class="el" href="structmlir_1_1bufferization_1_1BufferResultsToOutParamsOptions.html">BufferResultsToOutParamsOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>={})</td></tr>
<tr class="memdesc:a98dcdd4f694419492c0a0b6adfc3c811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that converts memref function results to out-params.  <a href="namespacemlir_1_1bufferization.html#a98dcdd4f694419492c0a0b6adfc3c811">More...</a><br /></td></tr>
<tr class="separator:a98dcdd4f694419492c0a0b6adfc3c811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81eaa45c7ad5180067f4cffcf43e4b41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a81eaa45c7ad5180067f4cffcf43e4b41">promoteBufferResultsToOutParams</a> (ModuleOp module, const <a class="el" href="structmlir_1_1bufferization_1_1BufferResultsToOutParamsOptions.html">BufferResultsToOutParamsOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a81eaa45c7ad5180067f4cffcf43e4b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace buffers that are returned from a function with an out parameter.  <a href="namespacemlir_1_1bufferization.html#a81eaa45c7ad5180067f4cffcf43e4b41">More...</a><br /></td></tr>
<tr class="separator:a81eaa45c7ad5180067f4cffcf43e4b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef2e0a39b0ed448dd072072ac76c68e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a1ef2e0a39b0ed448dd072072ac76c68e">createDropEquivalentBufferResultsPass</a> ()</td></tr>
<tr class="memdesc:a1ef2e0a39b0ed448dd072072ac76c68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that drops memref function results that are equivalent to a function argument.  <a href="namespacemlir_1_1bufferization.html#a1ef2e0a39b0ed448dd072072ac76c68e">More...</a><br /></td></tr>
<tr class="separator:a1ef2e0a39b0ed448dd072072ac76c68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1a94d4d5cc33f606dc0309a1d0b8db"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aea1a94d4d5cc33f606dc0309a1d0b8db">createEmptyTensorToAllocTensorPass</a> ()</td></tr>
<tr class="memdesc:aea1a94d4d5cc33f606dc0309a1d0b8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that rewrites tensor.empty to bufferization.alloc_tensor.  <a href="namespacemlir_1_1bufferization.html#aea1a94d4d5cc33f606dc0309a1d0b8db">More...</a><br /></td></tr>
<tr class="separator:aea1a94d4d5cc33f606dc0309a1d0b8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae342871cac8184abb98eb585dc44bf7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ae342871cac8184abb98eb585dc44bf7e">dropEquivalentBufferResults</a> (ModuleOp module)</td></tr>
<tr class="memdesc:ae342871cac8184abb98eb585dc44bf7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop all memref function results that are equivalent to a function argument.  <a href="namespacemlir_1_1bufferization.html#ae342871cac8184abb98eb585dc44bf7e">More...</a><br /></td></tr>
<tr class="separator:ae342871cac8184abb98eb585dc44bf7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851c8abcfd5da0332cb96347484e750e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a851c8abcfd5da0332cb96347484e750e">createFinalizingBufferizePass</a> ()</td></tr>
<tr class="memdesc:a851c8abcfd5da0332cb96347484e750e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that finalizes a partial bufferization by removing remaining bufferization.to_tensor and bufferization.to_memref operations.  <a href="namespacemlir_1_1bufferization.html#a851c8abcfd5da0332cb96347484e750e">More...</a><br /></td></tr>
<tr class="separator:a851c8abcfd5da0332cb96347484e750e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a438c09e875e0ca7b69ac35bd415812"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a8a438c09e875e0ca7b69ac35bd415812">createOneShotBufferizePass</a> ()</td></tr>
<tr class="memdesc:a8a438c09e875e0ca7b69ac35bd415812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that bufferizes all ops that implement BufferizableOpInterface with One-Shot Bufferize.  <a href="namespacemlir_1_1bufferization.html#a8a438c09e875e0ca7b69ac35bd415812">More...</a><br /></td></tr>
<tr class="separator:a8a438c09e875e0ca7b69ac35bd415812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6db8eb7bfe512d8fdd2a3bcc14767b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a0e6db8eb7bfe512d8fdd2a3bcc14767b">createOneShotBufferizePass</a> (const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a0e6db8eb7bfe512d8fdd2a3bcc14767b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that bufferizes all ops that implement BufferizableOpInterface with One-Shot Bufferize and the specified bufferization options.  <a href="namespacemlir_1_1bufferization.html#a0e6db8eb7bfe512d8fdd2a3bcc14767b">More...</a><br /></td></tr>
<tr class="separator:a0e6db8eb7bfe512d8fdd2a3bcc14767b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd135f127fc250fb96fd3817f98ab9d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aadd135f127fc250fb96fd3817f98ab9d">createPromoteBuffersToStackPass</a> (unsigned maxAllocSizeInBytes=1024, unsigned maxRankOfAllocatedMemRef=1)</td></tr>
<tr class="memdesc:aadd135f127fc250fb96fd3817f98ab9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that promotes heap-based allocations to stack-based ones.  <a href="namespacemlir_1_1bufferization.html#aadd135f127fc250fb96fd3817f98ab9d">More...</a><br /></td></tr>
<tr class="separator:aadd135f127fc250fb96fd3817f98ab9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a9fdbeb428d3911ee0fbfbc3854283"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a62a9fdbeb428d3911ee0fbfbc3854283">createPromoteBuffersToStackPass</a> (std::function&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; isSmallAlloc)</td></tr>
<tr class="memdesc:a62a9fdbeb428d3911ee0fbfbc3854283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that promotes heap-based allocations to stack-based ones.  <a href="namespacemlir_1_1bufferization.html#a62a9fdbeb428d3911ee0fbfbc3854283">More...</a><br /></td></tr>
<tr class="separator:a62a9fdbeb428d3911ee0fbfbc3854283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d40b6466dba71592273b41aa9abd340"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a9d40b6466dba71592273b41aa9abd340">createEmptyTensorEliminationPass</a> ()</td></tr>
<tr class="memdesc:a9d40b6466dba71592273b41aa9abd340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that tries to eliminate tensor.empty ops that are anchored on insert_slice ops.  <a href="namespacemlir_1_1bufferization.html#a9d40b6466dba71592273b41aa9abd340">More...</a><br /></td></tr>
<tr class="separator:a9d40b6466dba71592273b41aa9abd340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2bfa7b904999fa85ab33b9c7ad28e0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aeb2bfa7b904999fa85ab33b9c7ad28e0">createBufferizationBufferizePass</a> ()</td></tr>
<tr class="memdesc:aeb2bfa7b904999fa85ab33b9c7ad28e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that bufferizes ops from the bufferization dialect.  <a href="namespacemlir_1_1bufferization.html#aeb2bfa7b904999fa85ab33b9c7ad28e0">More...</a><br /></td></tr>
<tr class="separator:aeb2bfa7b904999fa85ab33b9c7ad28e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aabacf83eaecd5d832fcb2337eab274"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a6aabacf83eaecd5d832fcb2337eab274">registerAllocationOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a6aabacf83eaecd5d832fcb2337eab274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register external models for AllocationOpInterface.  <a href="namespacemlir_1_1bufferization.html#a6aabacf83eaecd5d832fcb2337eab274">More...</a><br /></td></tr>
<tr class="separator:a6aabacf83eaecd5d832fcb2337eab274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9473807b294c626dc1fa8b7e14d3063e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a9473807b294c626dc1fa8b7e14d3063e">eliminateEmptyTensors</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;state, <a class="el" href="namespacemlir_1_1bufferization.html#a9f555e6310adbe13cf6fd0163a345f65">AnchorMatchFn</a> anchorMatchFunc, <a class="el" href="namespacemlir_1_1bufferization.html#afad8a6459f58b1a5a6772110aac8d93d">RewriteFn</a> rewriteFunc)</td></tr>
<tr class="memdesc:a9473807b294c626dc1fa8b7e14d3063e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to eliminate tensor::EmptyOps inside <code>op</code>.  <a href="namespacemlir_1_1bufferization.html#a9473807b294c626dc1fa8b7e14d3063e">More...</a><br /></td></tr>
<tr class="separator:a9473807b294c626dc1fa8b7e14d3063e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab004a404d72d988763971e34cad784d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ab004a404d72d988763971e34cad784d0">insertSliceAnchoredEmptyTensorEliminationStep</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;state)</td></tr>
<tr class="memdesc:ab004a404d72d988763971e34cad784d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to eliminate tensor::EmptyOps inside <code>op</code> that are anchored on an InsertSliceOp, i.e., if it is eventually inserted into another tensor (and some other conditions are met).  <a href="namespacemlir_1_1bufferization.html#ab004a404d72d988763971e34cad784d0">More...</a><br /></td></tr>
<tr class="separator:ab004a404d72d988763971e34cad784d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da8751907537f3ff866a413457155a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a6da8751907537f3ff866a413457155a3">insertTensorCopies</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *statistics=nullptr)</td></tr>
<tr class="memdesc:a6da8751907537f3ff866a413457155a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve RaW and other conflicts by inserting bufferization.alloc_tensor ops.  <a href="namespacemlir_1_1bufferization.html#a6da8751907537f3ff866a413457155a3">More...</a><br /></td></tr>
<tr class="separator:a6da8751907537f3ff866a413457155a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa163b2955215e8f16e7105f5caa3cb27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aa163b2955215e8f16e7105f5caa3cb27">insertTensorCopies</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">AnalysisState</a> &amp;state)</td></tr>
<tr class="memdesc:aa163b2955215e8f16e7105f5caa3cb27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve RaW and other conflicts by inserting bufferization.alloc_tensor ops.  <a href="namespacemlir_1_1bufferization.html#aa163b2955215e8f16e7105f5caa3cb27">More...</a><br /></td></tr>
<tr class="separator:aa163b2955215e8f16e7105f5caa3cb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41285ff4926c59c44f84d013df399b83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a41285ff4926c59c44f84d013df399b83">populateEmptyTensorToAllocTensorPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a41285ff4926c59c44f84d013df399b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns to lower tensor.empty ops to bufferization.alloc_tensor ops.  <a href="namespacemlir_1_1bufferization.html#a41285ff4926c59c44f84d013df399b83">More...</a><br /></td></tr>
<tr class="separator:a41285ff4926c59c44f84d013df399b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a976af01e3a00f974529232f7e611233c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976af01e3a00f974529232f7e611233c">&#9670;&nbsp;</a></span>AliasingOpOperandList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1bufferization.html#a976af01e3a00f974529232f7e611233c">mlir::bufferization::AliasingOpOperandList</a> = typedef <a class="el" href="classmlir_1_1bufferization_1_1AliasList.html">AliasList</a>&lt;<a class="el" href="structmlir_1_1bufferization_1_1AliasingOpOperand.html">AliasingOpOperand</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of possible aliasing OpOperands. </p>
<p>This list models the runtime aliasing relationship for an <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a>. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8h_source.html#l00093">93</a> of file <a class="el" href="BufferizableOpInterface_8h_source.html">BufferizableOpInterface.h</a>.</p>

</div>
</div>
<a id="ac062f1cc941a2a4f5f3ff71daca213c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac062f1cc941a2a4f5f3ff71daca213c6">&#9670;&nbsp;</a></span>AliasingOpResultList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1bufferization.html#ac062f1cc941a2a4f5f3ff71daca213c6">mlir::bufferization::AliasingOpResultList</a> = typedef <a class="el" href="classmlir_1_1bufferization_1_1AliasList.html">AliasList</a>&lt;<a class="el" href="structmlir_1_1bufferization_1_1AliasingOpResult.html">AliasingOpResult</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of possible aliasing OpResults. </p>
<p>This list models the runtime aliasing relationship for an <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a>. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8h_source.html#l00097">97</a> of file <a class="el" href="BufferizableOpInterface_8h_source.html">BufferizableOpInterface.h</a>.</p>

</div>
</div>
<a id="a9f555e6310adbe13cf6fd0163a345f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f555e6310adbe13cf6fd0163a345f65">&#9670;&nbsp;</a></span>AnchorMatchFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1bufferization.html#a9f555e6310adbe13cf6fd0163a345f65">mlir::bufferization::AnchorMatchFn</a> = typedef std::function&lt;bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that matches anchor OpOperands for tensor::EmptyOp elimination. </p>
<p>If an <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> is matched, the function should populate the SmallVector with all values that are needed during <code>RewriteFn</code> to produce the replacement value. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Bufferization_2Transforms_2Transforms_8h_source.html#l00026">26</a> of file <a class="el" href="mlir_2Dialect_2Bufferization_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="afad8a6459f58b1a5a6772110aac8d93d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad8a6459f58b1a5a6772110aac8d93d">&#9670;&nbsp;</a></span>RewriteFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1bufferization.html#afad8a6459f58b1a5a6772110aac8d93d">mlir::bufferization::RewriteFn</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that rewrites matched anchors. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Bufferization_2Transforms_2Transforms_8h_source.html#l00029">29</a> of file <a class="el" href="mlir_2Dialect_2Bufferization_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afbf6d54f9e3c10b9003b66b6224b28bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf6d54f9e3c10b9003b66b6224b28bf">&#9670;&nbsp;</a></span>BufferRelation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bf">mlir::bufferization::BufferRelation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies a fine-grain relationship between buffers to enable more analysis. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afbf6d54f9e3c10b9003b66b6224b28bfa88183b946cc5f0e8c96b2e66e1c74a7e"></a>Unknown&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afbf6d54f9e3c10b9003b66b6224b28bfaafd102579f64c98e96d92a7424130605"></a>Equivalent&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8h_source.html#l00032">32</a> of file <a class="el" href="BufferizableOpInterface_8h_source.html">BufferizableOpInterface.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a84b8affbc45eb90f938f0d94b21eac45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b8affbc45eb90f938f0d94b21eac45">&#9670;&nbsp;</a></span>allocateTensorForShapedValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::bufferization::allocateTensorForShapedValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>shapedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>escape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an AllocTensorOp for the given shaped value (memref or tensor). </p>
<p>Create an AllocTensorOp for the given shaped value.</p>
<p>If <code>copy</code> is set, the shaped value is copied. Otherwise, a tensor with undefined contents is allocated. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00118">118</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00321">mlir::Type::cast()</a>, <a class="el" href="Value_8h_source.html#l00113">mlir::Value::cast()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00071">copy()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00265">mlir::Operation::emitError()</a>, <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Builders_8cpp_source.html#l00263">mlir::Builder::getBoolArrayAttr()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00693">getBufferType()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Builders_8cpp_source.html#l00125">mlir::Builder::getI64IntegerAttr()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00093">getOwnerOfValue()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8h_source.html#l00301">mlir::Type::isa()</a>, <a class="el" href="Value_8h_source.html#l00098">mlir::Value::isa()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00132">populateDynamicDimSizes()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00026">mlir::reifyResultShapes()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00543">mlir::Operation::setAttr()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>.</p>

</div>
</div>
<a id="a328e7c6d8ce499626dbf57ca19e482dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328e7c6d8ce499626dbf57ca19e482dd">&#9670;&nbsp;</a></span>allocationDoesNotEscape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::bufferization::allocationDoesNotEscape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a>&#160;</td>
          <td class="paramname"><em>opResult</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the allocation of the given op is guaranteed to not escape the containing block. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00099">99</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>.</p>

</div>
</div>
<a id="a79a75fc3cff64d1470cbf4a50eb0261e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a75fc3cff64d1470cbf4a50eb0261e">&#9670;&nbsp;</a></span>analyzeModuleOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::analyzeModuleOp </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>moduleOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze <code>moduleOp</code> and its nested ops. </p>
<p>Bufferization decisions are stored in <code>state</code>. </p>

<p class="definition">Definition at line <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00358">358</a> of file <a class="el" href="OneShotModuleBufferize_8cpp_source.html">OneShotModuleBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="FuncBufferizableOpInterfaceImpl_8h_source.html#l00066">mlir::bufferization::func_ext::FuncAnalysisState::analyzedFuncOps</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l01068">analyzeOp()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00307">mlir::bufferization::BufferizationOptions::bufferizeFunctionBoundaries</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00252">equivalenceAnalysis()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00283">getFuncOpsOrderedByCalls()</a>, <a class="el" href="OneShotAnalysis_8h_source.html#l00063">mlir::bufferization::OneShotAnalysisState::getOptions()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00081">getOrCreateFuncAnalysisState()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00349">mlir::bufferization::BufferizationOptions::isOpAllowed()</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00023">mlir::bufferization::func_ext::FuncAnalysisState::startFunctionAnalysis()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a1ec3ce210ab7a2c1c1e82a266bfb9e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec3ce210ab7a2c1c1e82a266bfb9e3f">&#9670;&nbsp;</a></span>analyzeOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::analyzeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze <code>op</code> and its nested ops. </p>
<p>Bufferization decisions are stored in <code>state</code>. </p>

<p class="definition">Definition at line <a class="el" href="OneShotAnalysis_8cpp_source.html#l01068">1068</a> of file <a class="el" href="OneShotAnalysis_8cpp_source.html">OneShotAnalysis.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00358">analyzeModuleOp()</a>.</p>

</div>
</div>
<a id="afb127f406f6c5e58ffe5ee4939037891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb127f406f6c5e58ffe5ee4939037891">&#9670;&nbsp;</a></span>bufferizeModuleOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::bufferizeModuleOp </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>moduleOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>. </p>
<p>Note: This function does not run One-Shot Analysis. No buffer copies are inserted except two cases:</p><ul>
<li><code>options.copyBeforeWrite</code> is set, in which case buffers are copied before every write.</li>
<li><code>options.copyBeforeWrite</code> is not set and <code>options.noAnalysisFuncFilter</code> is not empty. The FuncOps it contains were not analyzed. Buffer copies will be inserted only to these FuncOps. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00409">409</a> of file <a class="el" href="OneShotModuleBufferize_8cpp_source.html">OneShotModuleBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00427">bufferizeOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00336">foldMemRefCasts()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00283">getFuncOpsOrderedByCalls()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00401">removeBufferizationAttributesInModule()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a65e83004db3df49f8b47869e41af7ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e83004db3df49f8b47869e41af7ed7">&#9670;&nbsp;</a></span>bufferizeOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::bufferizeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copyBeforeWrite</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1bufferization_1_1OpFilter.html">OpFilter</a> *&#160;</td>
          <td class="paramname"><em>opFilter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>. </p>
<p>If <code>copyBeforeWrite</code>, buffers are duplicated and copied before any tensor use that bufferizes to a memory write.</p>
<p>Note: In the general case, it unsafe to run with <code>copyBeforeWrite = false</code> because read-after-write conflicts may materialize during bufferization. <code>copyBeforeWrite = false</code> is safe only if the input IR is guaranteed to <em>not</em> require any out-of-place bufferization.</p>
<p>Note: This function bufferizes ops without utilizing analysis results. It can be used to implement partial bufferization passes. </p>
<p>Check the result of bufferization. Return an error if an op was not bufferized, unless partial bufferization is allowed.</p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00427">427</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00409">bufferizeModuleOp()</a>.</p>

</div>
</div>
<a id="acf648dc804a1dcc39379e036051dbf82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf648dc804a1dcc39379e036051dbf82">&#9670;&nbsp;</a></span>castOrReallocMemRefValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::bufferization::castOrReallocMemRefValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to cast the given ranked MemRef-typed value to the given ranked MemRef type. </p>
<p>Insert a reallocation + copy if it cannot be statically guaranteed that a direct cast would be valid.</p>
<p>E.g., when casting from a ranked MemRef type with dynamic layout to a ranked MemRef type with static layout, it is not statically known whether the cast will succeed or not. Such <code>memref.cast</code> ops may fail at runtime. This function never generates such casts and conservatively inserts a copy.</p>
<p>This function returns <code><a class="el" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4" title="Utility function to generate a LogicalResult.">failure()</a></code> in case of unsupported casts. E.g., casts with differing element types or memory spaces. </p>

<p class="definition">Definition at line <a class="el" href="BufferizationOps_8cpp_source.html#l00028">28</a> of file <a class="el" href="BufferizationOps_8cpp_source.html">BufferizationOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00321">mlir::Type::cast()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00071">copy()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8h_source.html#l00501">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Value_8cpp_source.html#l00026">mlir::Value::getLoc()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00785">mlir::getStridesAndOffset()</a>, and <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00052">mlir::bufferization::BufferizeTypeConverter::BufferizeTypeConverter()</a>, and <a class="el" href="BufferizationOps_8cpp_source.html#l00088">foldToMemrefToTensorPair()</a>.</p>

</div>
</div>
<a id="adbadbbffeae2eddfac65c53b2f1cadba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbadbbffeae2eddfac65c53b2f1cadba">&#9670;&nbsp;</a></span>createBufferDeallocationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferDeallocationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the BufferDeallocation pass to free all allocated buffers. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocation_8cpp_source.html#l00724">724</a> of file <a class="el" href="BufferDeallocation_8cpp_source.html">BufferDeallocation.cpp</a>.</p>

</div>
</div>
<a id="a4b99b019001e22f13cbb9adaf483febe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b99b019001e22f13cbb9adaf483febe">&#9670;&nbsp;</a></span>createBufferHoistingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferHoistingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that moves allocations upwards to reduce the number of required copies that are inserted during the BufferDeallocation pass. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00435">435</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="aeb2bfa7b904999fa85ab33b9c7ad28e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2bfa7b904999fa85ab33b9c7ad28e0">&#9670;&nbsp;</a></span>createBufferizationBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferizationBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that bufferizes ops from the bufferization dialect. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00306">306</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

</div>
</div>
<a id="a94f24bfd4dabfbaa35cb099c0cc78480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f24bfd4dabfbaa35cb099c0cc78480">&#9670;&nbsp;</a></span>createBufferLoopHoistingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferLoopHoistingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that moves allocations upwards out of loops. </p>
<p>This avoids reallocations inside of loops. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00439">439</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="a98dcdd4f694419492c0a0b6adfc3c811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98dcdd4f694419492c0a0b6adfc3c811">&#9670;&nbsp;</a></span>createBufferResultsToOutParamsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferResultsToOutParamsPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferResultsToOutParamsOptions.html">BufferResultsToOutParamsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that converts memref function results to out-params. </p>

<p class="definition">Definition at line <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00221">221</a> of file <a class="el" href="BufferResultsToOutParams_8cpp_source.html">BufferResultsToOutParams.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="a1ef2e0a39b0ed448dd072072ac76c68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef2e0a39b0ed448dd072072ac76c68e">&#9670;&nbsp;</a></span>createDropEquivalentBufferResultsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createDropEquivalentBufferResultsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that drops memref function results that are equivalent to a function argument. </p>

<p class="definition">Definition at line <a class="el" href="DropEquivalentBufferResults_8cpp_source.html#l00157">157</a> of file <a class="el" href="DropEquivalentBufferResults_8cpp_source.html">DropEquivalentBufferResults.cpp</a>.</p>

</div>
</div>
<a id="a9d40b6466dba71592273b41aa9abd340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d40b6466dba71592273b41aa9abd340">&#9670;&nbsp;</a></span>createEmptyTensorEliminationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createEmptyTensorEliminationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that tries to eliminate tensor.empty ops that are anchored on insert_slice ops. </p>

<p class="definition">Definition at line <a class="el" href="EmptyTensorElimination_8cpp_source.html#l00278">278</a> of file <a class="el" href="EmptyTensorElimination_8cpp_source.html">EmptyTensorElimination.cpp</a>.</p>

</div>
</div>
<a id="aea1a94d4d5cc33f606dc0309a1d0b8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1a94d4d5cc33f606dc0309a1d0b8db">&#9670;&nbsp;</a></span>createEmptyTensorToAllocTensorPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createEmptyTensorToAllocTensorPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that rewrites tensor.empty to bufferization.alloc_tensor. </p>

<p class="definition">Definition at line <a class="el" href="EmptyTensorToAllocTensor_8cpp_source.html#l00068">68</a> of file <a class="el" href="EmptyTensorToAllocTensor_8cpp_source.html">EmptyTensorToAllocTensor.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00104">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a851c8abcfd5da0332cb96347484e750e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851c8abcfd5da0332cb96347484e750e">&#9670;&nbsp;</a></span>createFinalizingBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::bufferization::createFinalizingBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that finalizes a partial bufferization by removing remaining bufferization.to_tensor and bufferization.to_memref operations. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00320">320</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00057">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a8a438c09e875e0ca7b69ac35bd415812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a438c09e875e0ca7b69ac35bd415812">&#9670;&nbsp;</a></span>createOneShotBufferizePass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createOneShotBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that bufferizes all ops that implement BufferizableOpInterface with One-Shot Bufferize. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00310">310</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

</div>
</div>
<a id="a0e6db8eb7bfe512d8fdd2a3bcc14767b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6db8eb7bfe512d8fdd2a3bcc14767b">&#9670;&nbsp;</a></span>createOneShotBufferizePass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createOneShotBufferizePass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that bufferizes all ops that implement BufferizableOpInterface with One-Shot Bufferize and the specified bufferization options. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00314">314</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="a62a9fdbeb428d3911ee0fbfbc3854283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a9fdbeb428d3911ee0fbfbc3854283">&#9670;&nbsp;</a></span>createPromoteBuffersToStackPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createPromoteBuffersToStackPass </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;&#160;</td>
          <td class="paramname"><em>isSmallAlloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that promotes heap-based allocations to stack-based ones. </p>
<p>Only buffers smaller with <code>isSmallAlloc(alloc) == true</code> are promoted. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00449">449</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="aadd135f127fc250fb96fd3817f98ab9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd135f127fc250fb96fd3817f98ab9d">&#9670;&nbsp;</a></span>createPromoteBuffersToStackPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createPromoteBuffersToStackPass </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxAllocSizeInBytes</em> = <code>1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxRankOfAllocatedMemRef</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that promotes heap-based allocations to stack-based ones. </p>
<p>Only buffers smaller than the provided size are promoted. Dynamic shaped buffers are promoted up to the given rank. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00443">443</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="a8e9fe9c9234e2d22a86553a393f074d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9fe9c9234e2d22a86553a393f074d8">&#9670;&nbsp;</a></span>deallocateBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::deallocateBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run buffer deallocation. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocation_8cpp_source.html#l00676">676</a> of file <a class="el" href="BufferDeallocation_8cpp_source.html">BufferDeallocation.cpp</a>.</p>

</div>
</div>
<a id="ae342871cac8184abb98eb585dc44bf7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae342871cac8184abb98eb585dc44bf7e">&#9670;&nbsp;</a></span>dropEquivalentBufferResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::dropEquivalentBufferResults </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop all memref function results that are equivalent to a function argument. </p>

<p class="definition">Definition at line <a class="el" href="DropEquivalentBufferResults_8cpp_source.html#l00070">70</a> of file <a class="el" href="DropEquivalentBufferResults_8cpp_source.html">DropEquivalentBufferResults.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00052">mlir::WalkResult::advance()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>, <a class="el" href="DropEquivalentBufferResults_8cpp_source.html#l00048">getAssumedUniqueReturnOp()</a>, <a class="el" href="DropEquivalentBufferResults_8cpp_source.html#l00061">getCalledFunction()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00266">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="Builders_8h_source.html#l00379">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Visitors_8h_source.html#l00053">mlir::WalkResult::skip()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a9473807b294c626dc1fa8b7e14d3063e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9473807b294c626dc1fa8b7e14d3063e">&#9670;&nbsp;</a></span>eliminateEmptyTensors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::eliminateEmptyTensors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1bufferization.html#a9f555e6310adbe13cf6fd0163a345f65">AnchorMatchFn</a>&#160;</td>
          <td class="paramname"><em>anchorMatchFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1bufferization.html#afad8a6459f58b1a5a6772110aac8d93d">RewriteFn</a>&#160;</td>
          <td class="paramname"><em>rewriteFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to eliminate tensor::EmptyOps inside <code>op</code>. </p>
<ul>
<li><code>rewriteFunc</code> generates the replacement for the tensor::EmptyOp.</li>
<li><p class="startli">Only tensor::EmptyOps that are anchored on a matching <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> as per <code>anchorMatchFunc</code> are considered. "Anchored" means that there is a path on the reverse SSA use-def chain, starting from the <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> and always following the aliasing <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a>, that eventually ends at a single tensor::EmptyOp.</p>
<p class="startli">A tensor::EmptyOp is replaced with the result of <code>rewriteFunc</code> if it is anchored on a matching <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a>. "Anchored" means that there is a path on the reverse SSA use-def chain, starting from the <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> and always following the aliasing <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a>, that eventually ends at the tensor::EmptyOp.</p>
</li>
</ul>
<p>E.g.: %0 = tensor.empty() : tensor&lt;10xf32&gt; %1 = linalg.fill ... outs(%0 : tensor&lt;10xf32&gt;) %2 = tensor.insert_slice %0 into t ...</p>
<p>In the above example, the anchor is the source operand of the insert_slice op. When tracing back the reverse use-def chain, we end up at a tensor.empty op. </p>

<p class="definition">Definition at line <a class="el" href="EmptyTensorElimination_8cpp_source.html#l00116">116</a> of file <a class="el" href="EmptyTensorElimination_8cpp_source.html">EmptyTensorElimination.cpp</a>.</p>

</div>
</div>
<a id="a64f68223b1811698fd85780df73c4fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f68223b1811698fd85780df73c4fde">&#9670;&nbsp;</a></span>foldToMemrefToTensorPair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::foldToMemrefToTensorPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ToMemrefOp&#160;</td>
          <td class="paramname"><em>toMemref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to fold to_memref(to_tensor(x)). </p>
<p>If x's type and the result type of the to_memref op are different, a memref.cast is needed. </p>

<p class="definition">Definition at line <a class="el" href="BufferizationOps_8cpp_source.html#l00088">88</a> of file <a class="el" href="BufferizationOps_8cpp_source.html">BufferizationOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferizationOps_8cpp_source.html#l00028">castOrReallocMemRefValue()</a>, <a class="el" href="IR_2Types_8h_source.html#l00311">mlir::Type::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00266">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00482">mlir::RewriterBase::replaceOpWithNewOp()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="abf241364e9dfd1def82141c75035f4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf241364e9dfd1def82141c75035f4b0">&#9670;&nbsp;</a></span>getBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::bufferization::getBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup the buffer for the given value. </p>
<p>If the value was not bufferized yet, wrap it in a ToMemrefOp. Otherwise, it is the result of a ToTensorOp, from which the memref operand is returned. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00668">668</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Types_8h_source.html#l00311">mlir::Type::dyn_cast()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00659">ensureToMemrefOpIsValid()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00693">getBufferType()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8cpp_source.html#l00026">mlir::Value::getLoc()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, and <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00396">setInsertionPointAfter()</a>.</p>

</div>
</div>
<a id="aadc2d902756788c32c33244776d141c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc2d902756788c32c33244776d141c7">&#9670;&nbsp;</a></span>getBufferType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> &gt; mlir::bufferization::getBufferType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization without bufferizing any IR. </p>
<p>Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization.</p>
<p>Note: It should be sufficient to call <code><a class="el" href="namespacemlir_1_1bufferization.html#abf241364e9dfd1def82141c75035f4b0" title="Lookup the buffer for the given value.">getBuffer()</a>-&gt;getType()</code> in most cases. However, when a buffer type should be predicted without modifying any IR, this function can be used.</p>
<p>This function is a wrapper around BufferizableOpInterface::getBufferType. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00693">693</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00118">allocateTensorForShapedValue()</a>, and <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00668">getBuffer()</a>.</p>

</div>
</div>
<a id="a2de4a7671524f168224c818658f03bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de4a7671524f168224c818658f03bfb">&#9670;&nbsp;</a></span>getBufferType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> &gt; AllocTensorOp::getBufferType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fixedTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization without bufferizing any IR. </p>
<p>Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization.</p>
<p>If at any point during the type computation, the type of a value in <code>fixedTypes</code> in required, the mapped type is used.</p>
<p>Note: It should be sufficient to call <code><a class="el" href="namespacemlir_1_1bufferization.html#abf241364e9dfd1def82141c75035f4b0" title="Lookup the buffer for the given value.">getBuffer()</a>-&gt;getType()</code> in most cases. However, when a buffer type should be predicted without modifying any IR, this function can be used.</p>
<p>This function is a wrapper around BufferizableOpInterface::getBufferType. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00699">699</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, and <a class="el" href="IR_2Types_8h_source.html#l00301">mlir::Type::isa()</a>.</p>

</div>
</div>
<a id="ad5d6257f0fd8cb5e33cb24d6bcaf8470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d6257f0fd8cb5e33cb24d6bcaf8470">&#9670;&nbsp;</a></span>getEnclosingRepetitiveRegion() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Region.html">Region</a> * mlir::bufferization::getEnclosingRepetitiveRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the closest enclosing repetitive region around the given block. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00071">71</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8cpp_source.html#l00026">mlir::Block::getParent()</a>.</p>

</div>
</div>
<a id="a7b4161c8ecc07cf507a67acf1b5bfdc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4161c8ecc07cf507a67acf1b5bfdc0">&#9670;&nbsp;</a></span>getEnclosingRepetitiveRegion() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Region.html">Region</a> * mlir::bufferization::getEnclosingRepetitiveRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the closest enclosing repetitive region around the given op. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00053">53</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

</div>
</div>
<a id="ae3b13384af1c06bd70e869d0031b411f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b13384af1c06bd70e869d0031b411f">&#9670;&nbsp;</a></span>getEnclosingRepetitiveRegion() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Region.html">Region</a> * mlir::bufferization::getEnclosingRepetitiveRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the closest enclosing repetitive region around the place where the given value is defined. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00060">60</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8cpp_source.html#l00045">mlir::Region::getParentRegion()</a>, <a class="el" href="Value_8cpp_source.html#l00041">mlir::Value::getParentRegion()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00044">isRepetitiveRegion()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="ac429167681d191256dad3476d862bda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac429167681d191256dad3476d862bda2">&#9670;&nbsp;</a></span>getGlobalFor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; memref::GlobalOp &gt; mlir::bufferization::getGlobalFor </td>
          <td>(</td>
          <td class="paramtype">arith::ConstantOp&#160;</td>
          <td class="paramname"><em>constantOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BufferUtils_8cpp_source.html#l00150">150</a> of file <a class="el" href="BufferUtils_8cpp_source.html">BufferUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>.</p>

</div>
</div>
<a id="a660fa21f93f165f53aa703efc73fa210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660fa21f93f165f53aa703efc73fa210">&#9670;&nbsp;</a></span>getMemRefType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> mlir::bufferization::getMemRefType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefLayoutAttrInterface&#160;</td>
          <td class="paramname"><em>layout</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a MemRefType to which the type of the given value can be bufferized. </p>
<p>If possible, op bufferization implementations should not use this function and instead infer precise memref types for tensor results by themselves.</p>
<p>Unless a layout map was specified, <code>options.unknownTypeConverterFn</code> determines what kind of layout map will be used. For best composability (without copies), the fully dynamic layout map is used by default.</p>
<p>Note: Canonicalization patterns could clean up layout maps and infer more precise layout maps after bufferization. However, many possible canonicalizations are currently not implemented. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00806">806</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00321">mlir::Type::cast()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00957">mlir::bufferization::detail::defaultGetBufferType()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00638">mlir::sparse_tensor::reshapeValuesToLevels()</a>.</p>

</div>
</div>
<a id="af4daaf086abd1c64e90dc9529f76e1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4daaf086abd1c64e90dc9529f76e1d4">&#9670;&nbsp;</a></span>getMemRefTypeWithFullyDynamicLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> mlir::bufferization::getMemRefTypeWithFullyDynamicLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TensorType.html">TensorType</a>&#160;</td>
          <td class="paramname"><em>tensorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a MemRef type with fully dynamic layout. </p>
<p>If the given tensor type is unranked, return an unranked MemRef type. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00831">831</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00321">mlir::Type::cast()</a>, <a class="el" href="IR_2Types_8h_source.html#l00311">mlir::Type::dyn_cast()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00035">mlir::Type::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopEmitter_8cpp_source.html#l00343">mlir::sparse_tensor::LoopEmitter::initializeLoopEmit()</a>, and <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00377">mlir::bufferization::BufferizationOptions::setFunctionBoundaryTypeConversion()</a>.</p>

</div>
</div>
<a id="a05d01c9f4f43c19b51520658e24853d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d01c9f4f43c19b51520658e24853d6">&#9670;&nbsp;</a></span>getMemRefTypeWithStaticIdentityLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> mlir::bufferization::getMemRefTypeWithStaticIdentityLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TensorType.html">TensorType</a>&#160;</td>
          <td class="paramname"><em>tensorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a MemRef type with a static identity layout (i.e., no layout map). </p>
<p>If the given tensor type is unranked, return an unranked MemRef type. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00854">854</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00321">mlir::Type::cast()</a>, <a class="el" href="IR_2Types_8h_source.html#l00311">mlir::Type::dyn_cast()</a>, and <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00033">getBufferizationOptions()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00544">getPartialBufferizationOptions()</a>, and <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00377">mlir::bufferization::BufferizationOptions::setFunctionBoundaryTypeConversion()</a>.</p>

</div>
</div>
<a id="a8ab812aaab64b7b9fb0416797db2e146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab812aaab64b7b9fb0416797db2e146">&#9670;&nbsp;</a></span>getNextEnclosingRepetitiveRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Region.html">Region</a> * mlir::bufferization::getNextEnclosingRepetitiveRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assuming that the given region is repetitive, find the next enclosing repetitive region. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00083">83</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8cpp_source.html#l00045">mlir::Region::getParentRegion()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00044">isRepetitiveRegion()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotAnalysis_8cpp_source.html#l00384">canUseOpDominance()</a>.</p>

</div>
</div>
<a id="a25ed0ccb4e307d98675ecab129feddf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ed0ccb4e307d98675ecab129feddf5">&#9670;&nbsp;</a></span>getOwnerOfValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::bufferization::getOwnerOfValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the owner of the given value. </p>
<p>In case of a <a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a> that is the owner of the block. In case of an <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> that is the defining op. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00093">93</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00113">mlir::Value::cast()</a>, and <a class="el" href="Value_8h_source.html#l00103">mlir::Value::dyn_cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00118">allocateTensorForShapedValue()</a>.</p>

</div>
</div>
<a id="ac36c97b27b691ad7fcee01d70ca143a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36c97b27b691ad7fcee01d70ca143a9">&#9670;&nbsp;</a></span>getPartialBufferizationOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> mlir::bufferization::getPartialBufferizationOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00544">544</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00321">mlir::Type::cast()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00854">getMemRefTypeWithStaticIdentityLayout()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="ab004a404d72d988763971e34cad784d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab004a404d72d988763971e34cad784d0">&#9670;&nbsp;</a></span>insertSliceAnchoredEmptyTensorEliminationStep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::insertSliceAnchoredEmptyTensorEliminationStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to eliminate tensor::EmptyOps inside <code>op</code> that are anchored on an InsertSliceOp, i.e., if it is eventually inserted into another tensor (and some other conditions are met). </p>

<p class="definition">Definition at line <a class="el" href="EmptyTensorElimination_8cpp_source.html#l00236">236</a> of file <a class="el" href="EmptyTensorElimination_8cpp_source.html">EmptyTensorElimination.cpp</a>.</p>

</div>
</div>
<a id="aa163b2955215e8f16e7105f5caa3cb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa163b2955215e8f16e7105f5caa3cb27">&#9670;&nbsp;</a></span>insertTensorCopies() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::insertTensorCopies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">AnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve RaW and other conflicts by inserting bufferization.alloc_tensor ops. </p>
<p>After applying this transform, the IR can be bufferized without inserting additional buffer allocations. </p>

<p class="definition">Definition at line <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00124">124</a> of file <a class="el" href="TensorCopyInsertion_8cpp_source.html">TensorCopyInsertion.cpp</a>.</p>

</div>
</div>
<a id="a6da8751907537f3ff866a413457155a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da8751907537f3ff866a413457155a3">&#9670;&nbsp;</a></span>insertTensorCopies() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::insertTensorCopies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve RaW and other conflicts by inserting bufferization.alloc_tensor ops. </p>
<p>After applying this transform, the IR can be bufferized without inserting additional buffer allocations. </p>

<p class="definition">Definition at line <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00099">99</a> of file <a class="el" href="TensorCopyInsertion_8cpp_source.html">TensorCopyInsertion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00446">runOneShotModuleBufferize()</a>, and <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00104">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="aa24e592182e0b88ede8e85dbc3dcac5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24e592182e0b88ede8e85dbc3dcac5e">&#9670;&nbsp;</a></span>isFunctionArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::bufferization::isFunctionArgument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the given value is a <a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a> of a func::FuncOp. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00799">799</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00103">mlir::Value::dyn_cast()</a>.</p>

</div>
</div>
<a id="a6223871e93de2dbc611e8e54c5e4fb3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6223871e93de2dbc611e8e54c5e4fb3b">&#9670;&nbsp;</a></span>populateBufferizeMaterializationLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::populateBufferizeMaterializationLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks ops used by bufferization for type conversion materializations as "legal" in the given <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target.">ConversionTarget</a>. </p>
<p>This function should be called by all bufferization passes using <a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html" title="A helper type converter class that automatically populates the relevant materializations and type con...">BufferizeTypeConverter</a> so that materializations work properly. One exception is bufferization passes doing "full" conversions, where it can be desirable for even the materializations to remain illegal so that they are eliminated, such as via the patterns in populateEliminateBufferizeMaterializationsPatterns. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00092">92</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00817">mlir::ConversionTarget::addLegalOp()</a>.</p>

</div>
</div>
<a id="af7726e480700dfb860214b275d6a396d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7726e480700dfb860214b275d6a396d">&#9670;&nbsp;</a></span>populateDynamicDimSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::populateDynamicDimSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>shapedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dynamicDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate <code>dynamicDims</code> with tensor::DimOp / memref::DimOp results for all dynamic dimensions of the given shaped value. </p>

<p class="definition">Definition at line <a class="el" href="BufferizationOps_8cpp_source.html#l00132">132</a> of file <a class="el" href="BufferizationOps_8cpp_source.html">BufferizationOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00321">mlir::Type::cast()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, and <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00118">allocateTensorForShapedValue()</a>.</p>

</div>
</div>
<a id="a22345dcd836dbc3216a89bbd4ce26821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22345dcd836dbc3216a89bbd4ce26821">&#9670;&nbsp;</a></span>populateEliminateBufferizeMaterializationsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::populateEliminateBufferizeMaterializationsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns to eliminate bufferize materializations. </p>
<p>In particular, these are the tensor_load/buffer_cast ops. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00129">129</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a41285ff4926c59c44f84d013df399b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41285ff4926c59c44f84d013df399b83">&#9670;&nbsp;</a></span>populateEmptyTensorToAllocTensorPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::populateEmptyTensorToAllocTensorPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns to lower tensor.empty ops to bufferization.alloc_tensor ops. </p>

<p class="definition">Definition at line <a class="el" href="EmptyTensorToAllocTensor_8cpp_source.html#l00054">54</a> of file <a class="el" href="EmptyTensorToAllocTensor_8cpp_source.html">EmptyTensorToAllocTensor.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01734">mlir::RewritePatternSet::insert()</a>.</p>

</div>
</div>
<a id="a81eaa45c7ad5180067f4cffcf43e4b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81eaa45c7ad5180067f4cffcf43e4b41">&#9670;&nbsp;</a></span>promoteBufferResultsToOutParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::promoteBufferResultsToOutParams </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferResultsToOutParamsOptions.html">BufferResultsToOutParamsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace buffers that are returned from a function with an out parameter. </p>
<p>Also update all call sites. </p>

<p class="definition">Definition at line <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00184">184</a> of file <a class="el" href="BufferResultsToOutParams_8cpp_source.html">BufferResultsToOutParams.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00123">updateCalls()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00048">updateFuncOp()</a>, and <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00100">updateReturnOps()</a>.</p>

</div>
</div>
<a id="a6aabacf83eaecd5d832fcb2337eab274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aabacf83eaecd5d832fcb2337eab274">&#9670;&nbsp;</a></span>registerAllocationOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::registerAllocationOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register external models for AllocationOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocation_8cpp_source.html#l00712">712</a> of file <a class="el" href="BufferDeallocation_8cpp_source.html">BufferDeallocation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>.</p>

</div>
</div>
<a id="a2b2d5a6d2e5ab89ec76a879d71e32a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2d5a6d2e5ab89ec76a879d71e32a36">&#9670;&nbsp;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BufferizationTransformOps_8cpp_source.html#l00145">145</a> of file <a class="el" href="BufferizationTransformOps_8cpp_source.html">BufferizationTransformOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00185">mlir::DialectRegistry::addExtensions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00087">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="ac2cfedafe4d56324592c31cbe6c7ddb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2cfedafe4d56324592c31cbe6c7ddb1">&#9670;&nbsp;</a></span>removeBufferizationAttributesInModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::removeBufferizationAttributesInModule </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>moduleOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove bufferization attributes on every FuncOp arguments in the ModuleOp. </p>

<p class="definition">Definition at line <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00401">401</a> of file <a class="el" href="OneShotModuleBufferize_8cpp_source.html">OneShotModuleBufferize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00409">bufferizeModuleOp()</a>.</p>

</div>
</div>
<a id="a05561ae5b9cceea1c45832340484ad6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05561ae5b9cceea1c45832340484ad6b">&#9670;&nbsp;</a></span>replaceOpWithBufferizedValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::replaceOpWithBufferizedValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace an op with replacement values. </p>
<p>The op is deleted. Tensor OpResults must be replaced with memref values. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00723">723</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

</div>
</div>
<a id="a91366abfb8d491ea5701260487518959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91366abfb8d491ea5701260487518959">&#9670;&nbsp;</a></span>replaceOpWithNewBufferizedOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpTy mlir::bufferization::replaceOpWithNewBufferizedOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace an op with a new op. </p>
<p>The new op must have the same number of results as the replaced op. The new op may not return any tensor values. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8h_source.html#l00593">593</a> of file <a class="el" href="BufferizableOpInterface_8h_source.html">BufferizableOpInterface.h</a>.</p>

</div>
</div>
<a id="a02260c2ee96b5ef6845cf31eefabb24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02260c2ee96b5ef6845cf31eefabb24b">&#9670;&nbsp;</a></span>runOneShotBufferize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::runOneShotBufferize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run One-Shot Bufferize on the given op: Analysis + Bufferization. </p>

<p class="definition">Definition at line <a class="el" href="OneShotAnalysis_8cpp_source.html#l01111">1111</a> of file <a class="el" href="OneShotAnalysis_8cpp_source.html">OneShotAnalysis.cpp</a>.</p>

</div>
</div>
<a id="a3b77f5324f17a99ff8b568521bfaeadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b77f5324f17a99ff8b568521bfaeadd">&#9670;&nbsp;</a></span>runOneShotModuleBufferize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::runOneShotModuleBufferize </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>moduleOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">bufferization::OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run One-Shot Module Bufferization on the given module. </p>
<p>Performs a simple function call analysis to determine which function arguments are inplaceable. Then analyzes and bufferizes FuncOps one-by-one with One-Shot Bufferize. </p>

<p class="definition">Definition at line <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00446">446</a> of file <a class="el" href="OneShotModuleBufferize_8cpp_source.html">OneShotModuleBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00099">insertTensorCopies()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="a6db18d8594be09f305df7fc8cc2afedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db18d8594be09f305df7fc8cc2afedb">&#9670;&nbsp;</a></span>shouldDeallocateOpResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::bufferization::shouldDeallocateOpResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a>&#160;</td>
          <td class="paramname"><em>opResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the buffer of given <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> should be deallocated. </p>
<p>This function should be called during <code>BufferizableOpInterface::bufferize</code> implementations that allocate a new buffer for the given <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a>. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00275">275</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 4 2023 20:34:12 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
