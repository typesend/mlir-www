<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::memref Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">17.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1memref.html">memref</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::memref Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa6d03c4cab7fc5604ab8b5d105b31d4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#aa6d03c4cab7fc5604ab8b5d105b31d4b">foldMemRefCast</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Value.html">Value</a> inner=nullptr)</td></tr>
<tr class="memdesc:aa6d03c4cab7fc5604ab8b5d105b31d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a common utility used for patterns of the form "someop(memref.cast) -&gt; someop".  <a href="namespacemlir_1_1memref.html#aa6d03c4cab7fc5604ab8b5d105b31d4b">More...</a><br /></td></tr>
<tr class="separator:aa6d03c4cab7fc5604ab8b5d105b31d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593c42d0eefa6f2456d3ed618384de85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a593c42d0eefa6f2456d3ed618384de85">getTensorTypeFromMemRefType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memdesc:a593c42d0eefa6f2456d3ed618384de85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an unranked/ranked tensor type for the given unranked/ranked memref type.  <a href="namespacemlir_1_1memref.html#a593c42d0eefa6f2456d3ed618384de85">More...</a><br /></td></tr>
<tr class="separator:a593c42d0eefa6f2456d3ed618384de85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb87b9964b1655bdedbdd1b7656225d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a7bb87b9964b1655bdedbdd1b7656225d">findDealloc</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> allocValue)</td></tr>
<tr class="memdesc:a7bb87b9964b1655bdedbdd1b7656225d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a single dealloc operation for the given allocated value.  <a href="namespacemlir_1_1memref.html#a7bb87b9964b1655bdedbdd1b7656225d">More...</a><br /></td></tr>
<tr class="separator:a7bb87b9964b1655bdedbdd1b7656225d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c13e32e47a301b4ccac4b27404de51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ab0c13e32e47a301b4ccac4b27404de51">getMixedSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:ab0c13e32e47a301b4ccac4b27404de51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimensions of the given memref value.  <a href="namespacemlir_1_1memref.html#ab0c13e32e47a301b4ccac4b27404de51">More...</a><br /></td></tr>
<tr class="separator:ab0c13e32e47a301b4ccac4b27404de51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e796656fc119467035c6e1d1568a59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ae1e796656fc119467035c6e1d1568a59">createCanonicalRankReducingSubViewOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> memref, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; targetShape)</td></tr>
<tr class="memdesc:ae1e796656fc119467035c6e1d1568a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rank-reducing SubViewOp @[0 .  <a href="namespacemlir_1_1memref.html#ae1e796656fc119467035c6e1d1568a59">More...</a><br /></td></tr>
<tr class="separator:ae1e796656fc119467035c6e1d1568a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b49994f10e98cb119abfb38f23c0c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ac2b49994f10e98cb119abfb38f23c0c3">registerValueBoundsOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:ac2b49994f10e98cb119abfb38f23c0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1adc6a8d5aefc17867d0815b586c3b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ae1adc6a8d5aefc17867d0815b586c3b9">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:ae1adc6a8d5aefc17867d0815b586c3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a56931f8605b0783a017cf7d0d84b59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a1a56931f8605b0783a017cf7d0d84b59">registerBufferizableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a1a56931f8605b0783a017cf7d0d84b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c5916519d8d818c95097ef22e882ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#af6c5916519d8d818c95097ef22e882ee">populateComposeSubViewPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="separator:af6c5916519d8d818c95097ef22e882ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1c2ec5fd808a4c161c3e3757dcb2ac"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a9e1c2ec5fd808a4c161c3e3757dcb2ac">createExpandOpsPass</a> ()</td></tr>
<tr class="memdesc:a9e1c2ec5fd808a4c161c3e3757dcb2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the ExpandOps pass that legalizes memref dialect ops to be convertible to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="namespacemlir_1_1memref.html#a9e1c2ec5fd808a4c161c3e3757dcb2ac">More...</a><br /></td></tr>
<tr class="separator:a9e1c2ec5fd808a4c161c3e3757dcb2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02615680489f37f7981015da17f6ae01"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a02615680489f37f7981015da17f6ae01">createFoldMemRefAliasOpsPass</a> ()</td></tr>
<tr class="memdesc:a02615680489f37f7981015da17f6ae01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation pass to fold memref aliasing ops into consumer load/store ops into <code>patterns</code>.  <a href="namespacemlir_1_1memref.html#a02615680489f37f7981015da17f6ae01">More...</a><br /></td></tr>
<tr class="separator:a02615680489f37f7981015da17f6ae01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f45f2e0d1a2210dfe96f673be3b0e7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a83f45f2e0d1a2210dfe96f673be3b0e7">createNormalizeMemRefsPass</a> ()</td></tr>
<tr class="memdesc:a83f45f2e0d1a2210dfe96f673be3b0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an interprocedural pass to normalize memrefs to have a trivial (identity) layout map.  <a href="namespacemlir_1_1memref.html#a83f45f2e0d1a2210dfe96f673be3b0e7">More...</a><br /></td></tr>
<tr class="separator:a83f45f2e0d1a2210dfe96f673be3b0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731ed7504adb7700dcb4c013edd90444"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a731ed7504adb7700dcb4c013edd90444">createResolveRankedShapeTypeResultDimsPass</a> ()</td></tr>
<tr class="memdesc:a731ed7504adb7700dcb4c013edd90444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation pass to resolve <code>memref.dim</code> operations with values that are defined by operations that implement the <code>ReifyRankedShapeTypeShapeOpInterface</code>, in terms of shapes of its input operands.  <a href="namespacemlir_1_1memref.html#a731ed7504adb7700dcb4c013edd90444">More...</a><br /></td></tr>
<tr class="separator:a731ed7504adb7700dcb4c013edd90444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125072690f2eaadee614b98605a1a852"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a125072690f2eaadee614b98605a1a852">createResolveShapedTypeResultDimsPass</a> ()</td></tr>
<tr class="memdesc:a125072690f2eaadee614b98605a1a852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation pass to resolve <code>memref.dim</code> operations with values that are defined by operations that implement the <code>InferShapedTypeOpInterface</code> or the <code>ReifyRankedShapeTypeShapeOpInterface</code>, in terms of shapes of its input operands.  <a href="namespacemlir_1_1memref.html#a125072690f2eaadee614b98605a1a852">More...</a><br /></td></tr>
<tr class="separator:a125072690f2eaadee614b98605a1a852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c684ef24bae57bc6ac31147475bd5df"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a3c684ef24bae57bc6ac31147475bd5df">createExpandStridedMetadataPass</a> ()</td></tr>
<tr class="memdesc:a3c684ef24bae57bc6ac31147475bd5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation pass to expand some memref operation into easier to reason about operations.  <a href="namespacemlir_1_1memref.html#a3c684ef24bae57bc6ac31147475bd5df">More...</a><br /></td></tr>
<tr class="separator:a3c684ef24bae57bc6ac31147475bd5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fa7b00c1ccb23e5f4a528377dd4ee9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ad7fa7b00c1ccb23e5f4a528377dd4ee9">registerRuntimeVerifiableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:ad7fa7b00c1ccb23e5f4a528377dd4ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72dbb57f66b3381ca288a092d376802"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#aa72dbb57f66b3381ca288a092d376802">populateExpandOpsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aa72dbb57f66b3381ca288a092d376802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects a set of patterns to rewrite ops within the memref dialect.  <a href="namespacemlir_1_1memref.html#aa72dbb57f66b3381ca288a092d376802">More...</a><br /></td></tr>
<tr class="separator:aa72dbb57f66b3381ca288a092d376802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b92ea4d1067ac456aa6899baa8512a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a0b92ea4d1067ac456aa6899baa8512a9">populateFoldMemRefAliasOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a0b92ea4d1067ac456aa6899baa8512a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for folding memref aliasing ops into consumer load/store ops into <code>patterns</code>.  <a href="namespacemlir_1_1memref.html#a0b92ea4d1067ac456aa6899baa8512a9">More...</a><br /></td></tr>
<tr class="separator:a0b92ea4d1067ac456aa6899baa8512a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa4a24293483d5a062c0c96e56c68cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a2fa4a24293483d5a062c0c96e56c68cf">populateResolveRankedShapeTypeResultDimsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a2fa4a24293483d5a062c0c96e56c68cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns that resolve <code>memref.dim</code> operations with values that are defined by operations that implement the <code>ReifyRankedShapeTypeShapeOpInterface</code>, in terms of shapes of its input operands.  <a href="namespacemlir_1_1memref.html#a2fa4a24293483d5a062c0c96e56c68cf">More...</a><br /></td></tr>
<tr class="separator:a2fa4a24293483d5a062c0c96e56c68cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf97a8143d457b645153d6f40e6aed84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#aaf97a8143d457b645153d6f40e6aed84">populateResolveShapedTypeResultDimsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aaf97a8143d457b645153d6f40e6aed84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns that resolve <code>memref.dim</code> operations with values that are defined by operations that implement the <code>InferShapedTypeOpInterface</code>, in terms of shapes of its input operands.  <a href="namespacemlir_1_1memref.html#aaf97a8143d457b645153d6f40e6aed84">More...</a><br /></td></tr>
<tr class="separator:aaf97a8143d457b645153d6f40e6aed84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a91532e484d6485dc36756f1b1bace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ae0a91532e484d6485dc36756f1b1bace">populateExpandStridedMetadataPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ae0a91532e484d6485dc36756f1b1bace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for expanding memref operations that modify the metadata (sizes, offset, strides) of a memref into easier to analyze constructs.  <a href="namespacemlir_1_1memref.html#ae0a91532e484d6485dc36756f1b1bace">More...</a><br /></td></tr>
<tr class="separator:ae0a91532e484d6485dc36756f1b1bace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933e3cb75cf93999afc61710776fea07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a933e3cb75cf93999afc61710776fea07">populateResolveExtractStridedMetadataPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a933e3cb75cf93999afc61710776fea07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for resolving <code>memref.extract_strided_metadata</code> into <code>memref.extract_strided_metadata</code> of its source.  <a href="namespacemlir_1_1memref.html#a933e3cb75cf93999afc61710776fea07">More...</a><br /></td></tr>
<tr class="separator:a933e3cb75cf93999afc61710776fea07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51da475db04d0e27ef4a0a8f10c0c518"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a51da475db04d0e27ef4a0a8f10c0c518">populateMemRefWideIntEmulationPatterns</a> (<a class="el" href="classmlir_1_1arith_1_1WideIntEmulationConverter.html">arith::WideIntEmulationConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a51da475db04d0e27ef4a0a8f10c0c518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for emulating wide integer memref operations with ops over narrower integer types.  <a href="namespacemlir_1_1memref.html#a51da475db04d0e27ef4a0a8f10c0c518">More...</a><br /></td></tr>
<tr class="separator:a51da475db04d0e27ef4a0a8f10c0c518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0e1bd45d93d6da7bf22b61465492b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a6c0e1bd45d93d6da7bf22b61465492b9">populateMemRefWideIntEmulationConversions</a> (<a class="el" href="classmlir_1_1arith_1_1WideIntEmulationConverter.html">arith::WideIntEmulationConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:a6c0e1bd45d93d6da7bf22b61465492b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends type converions for emulating wide integer memref operations with ops over narrowe integer types.  <a href="namespacemlir_1_1memref.html#a6c0e1bd45d93d6da7bf22b61465492b9">More...</a><br /></td></tr>
<tr class="separator:a6c0e1bd45d93d6da7bf22b61465492b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637539fbb3044706f07e949413eac30d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; memref::AllocOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a637539fbb3044706f07e949413eac30d">multiBuffer</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, memref::AllocOp allocOp, unsigned multiplier, bool skipOverrideAnalysis=false)</td></tr>
<tr class="memdesc:a637539fbb3044706f07e949413eac30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation to do multi-buffering/array expansion to remove dependencies on the temporary allocation between consecutive loop iterations.  <a href="namespacemlir_1_1memref.html#a637539fbb3044706f07e949413eac30d">More...</a><br /></td></tr>
<tr class="separator:a637539fbb3044706f07e949413eac30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ffe31231e4fd88511f0d2446b4218d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; memref::AllocOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ae4ffe31231e4fd88511f0d2446b4218d">multiBuffer</a> (memref::AllocOp allocOp, unsigned multiplier, bool skipOverrideAnalysis=false)</td></tr>
<tr class="memdesc:ae4ffe31231e4fd88511f0d2446b4218d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call into <code>multiBuffer</code> with locally constructed <a class="el" href="classmlir_1_1IRRewriter.html" title="This class coordinates rewriting a piece of IR outside of a pattern rewrite, providing a way to keep ...">IRRewriter</a>.  <a href="namespacemlir_1_1memref.html#ae4ffe31231e4fd88511f0d2446b4218d">More...</a><br /></td></tr>
<tr class="separator:ae4ffe31231e4fd88511f0d2446b4218d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05667d80ad6b23301f24c722a4dbb28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ad05667d80ad6b23301f24c722a4dbb28">populateExtractAddressComputationsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ad05667d80ad6b23301f24c722a4dbb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for extracting address computations from the instructions with memory accesses such that these memory accesses use only a base pointer.  <a href="namespacemlir_1_1memref.html#ad05667d80ad6b23301f24c722a4dbb28">More...</a><br /></td></tr>
<tr class="separator:ad05667d80ad6b23301f24c722a4dbb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf86c211b0ab9ea0b1ea4943a4e6d6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a1bf86c211b0ab9ea0b1ea4943a4e6d6e">buildIndependentOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, AllocaOp allocaOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> independencies)</td></tr>
<tr class="memdesc:a1bf86c211b0ab9ea0b1ea4943a4e6d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a new memref::AllocaOp whose dynamic sizes are independent of all given independencies.  <a href="namespacemlir_1_1memref.html#a1bf86c211b0ab9ea0b1ea4943a4e6d6e">More...</a><br /></td></tr>
<tr class="separator:a1bf86c211b0ab9ea0b1ea4943a4e6d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390d7b6bfa73372eec5b1d2cd2bf937b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a390d7b6bfa73372eec5b1d2cd2bf937b">replaceWithIndependentOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, memref::AllocaOp allocaOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> independencies)</td></tr>
<tr class="memdesc:a390d7b6bfa73372eec5b1d2cd2bf937b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a new memref::AllocaOp whose dynamic sizes are independent of all given independencies.  <a href="namespacemlir_1_1memref.html#a390d7b6bfa73372eec5b1d2cd2bf937b">More...</a><br /></td></tr>
<tr class="separator:a390d7b6bfa73372eec5b1d2cd2bf937b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1bf86c211b0ab9ea0b1ea4943a4e6d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf86c211b0ab9ea0b1ea4943a4e6d6e">&#9670;&nbsp;</a></span>buildIndependentOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; mlir::memref::buildIndependentOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocaOp&#160;</td>
          <td class="paramname"><em>allocaOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>independencies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a new memref::AllocaOp whose dynamic sizes are independent of all given independencies. </p>
<p>If the op is already independent of all independencies, the same AllocaOp result is returned.</p>
<p>Failure indicates the no suitable upper bound for the dynamic sizes could be found. </p>

<p class="reference">Referenced by <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00172">replaceWithIndependentOp()</a>.</p>

</div>
</div>
<a id="ae1e796656fc119467035c6e1d1568a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e796656fc119467035c6e1d1568a59">&#9670;&nbsp;</a></span>createCanonicalRankReducingSubViewOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::memref::createCanonicalRankReducingSubViewOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>memref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>targetShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a rank-reducing SubViewOp @[0 . </p>
<p>. 0] with strides [1 .. 1] and appropriate sizes (i.e. <code>memref.getSizes()</code>) to reduce the rank of <code>memref</code> to that of <code>targetShape</code>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02963">2963</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00321">mlir::Type::cast()</a>, <a class="el" href="Builders_8h_source.html#l00501">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Builders_8cpp_source.html#l00121">mlir::Builder::getIndexAttr()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00111">getMixedSizes()</a>, and <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a9e1c2ec5fd808a4c161c3e3757dcb2ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1c2ec5fd808a4c161c3e3757dcb2ac">&#9670;&nbsp;</a></span>createExpandOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::memref::createExpandOpsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the ExpandOps pass that legalizes memref dialect ops to be convertible to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>
<p>For example, <code>memref.reshape</code> gets converted to <code>memref_reinterpret_cast</code>. </p>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2ExpandOps_8cpp_source.html#l00159">159</a> of file <a class="el" href="MemRef_2Transforms_2ExpandOps_8cpp_source.html">ExpandOps.cpp</a>.</p>

</div>
</div>
<a id="a3c684ef24bae57bc6ac31147475bd5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c684ef24bae57bc6ac31147475bd5df">&#9670;&nbsp;</a></span>createExpandStridedMetadataPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::memref::createExpandStridedMetadataPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an operation pass to expand some memref operation into easier to reason about operations. </p>

<p class="definition">Definition at line <a class="el" href="ExpandStridedMetadata_8cpp_source.html#l00950">950</a> of file <a class="el" href="ExpandStridedMetadata_8cpp_source.html">ExpandStridedMetadata.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00057">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a02615680489f37f7981015da17f6ae01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02615680489f37f7981015da17f6ae01">&#9670;&nbsp;</a></span>createFoldMemRefAliasOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::memref::createFoldMemRefAliasOpsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an operation pass to fold memref aliasing ops into consumer load/store ops into <code>patterns</code>. </p>

<p class="definition">Definition at line <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00698">698</a> of file <a class="el" href="FoldMemRefAliasOps_8cpp_source.html">FoldMemRefAliasOps.cpp</a>.</p>

</div>
</div>
<a id="a83f45f2e0d1a2210dfe96f673be3b0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f45f2e0d1a2210dfe96f673be3b0e7">&#9670;&nbsp;</a></span>createNormalizeMemRefsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::memref::createNormalizeMemRefsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an interprocedural pass to normalize memrefs to have a trivial (identity) layout map. </p>

<p class="definition">Definition at line <a class="el" href="NormalizeMemRefs_8cpp_source.html#l00057">57</a> of file <a class="el" href="NormalizeMemRefs_8cpp_source.html">NormalizeMemRefs.cpp</a>.</p>

</div>
</div>
<a id="a731ed7504adb7700dcb4c013edd90444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731ed7504adb7700dcb4c013edd90444">&#9670;&nbsp;</a></span>createResolveRankedShapeTypeResultDimsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::memref::createResolveRankedShapeTypeResultDimsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an operation pass to resolve <code>memref.dim</code> operations with values that are defined by operations that implement the <code>ReifyRankedShapeTypeShapeOpInterface</code>, in terms of shapes of its input operands. </p>

<p class="definition">Definition at line <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00158">158</a> of file <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html">ResolveShapedTypeResultDims.cpp</a>.</p>

</div>
</div>
<a id="a125072690f2eaadee614b98605a1a852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125072690f2eaadee614b98605a1a852">&#9670;&nbsp;</a></span>createResolveShapedTypeResultDimsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::memref::createResolveShapedTypeResultDimsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an operation pass to resolve <code>memref.dim</code> operations with values that are defined by operations that implement the <code>InferShapedTypeOpInterface</code> or the <code>ReifyRankedShapeTypeShapeOpInterface</code>, in terms of shapes of its input operands. </p>

<p class="definition">Definition at line <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00154">154</a> of file <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html">ResolveShapedTypeResultDims.cpp</a>.</p>

</div>
</div>
<a id="a7bb87b9964b1655bdedbdd1b7656225d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb87b9964b1655bdedbdd1b7656225d">&#9670;&nbsp;</a></span>findDealloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::memref::findDealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>allocValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a single dealloc operation for the given allocated value. </p>
<p>Finds the unique dealloc operation (if one exists) for <code>allocValue</code>.</p>
<p>If there are &gt; 1 deallocates for <code>allocValue</code>, returns std::nullopt, else returns the single deallocate if it exists or nullptr. </p>

<p class="definition">Definition at line <a class="el" href="MemRefDialect_8cpp_source.html#l00047">47</a> of file <a class="el" href="MemRefDialect_8cpp_source.html">MemRefDialect.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00217">mlir::Value::getUsers()</a>.</p>

</div>
</div>
<a id="aa6d03c4cab7fc5604ab8b5d105b31d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d03c4cab7fc5604ab8b5d105b31d4b">&#9670;&nbsp;</a></span>foldMemRefCast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::memref::foldMemRefCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>inner</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a common utility used for patterns of the form "someop(memref.cast) -&gt; someop". </p>
<p>This is a common class used for patterns of the form "someop(memrefcast) -&gt; someop".</p>
<p>It folds the source of any memref.cast into the root operation directly. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00088">88</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01825">mlir::affine::AffineDmaStartOp::fold()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01914">mlir::affine::AffineDmaWaitOp::fold()</a>.</p>

</div>
</div>
<a id="ab0c13e32e47a301b4ccac4b27404de51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c13e32e47a301b4ccac4b27404de51">&#9670;&nbsp;</a></span>getMixedSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::memref::getMixedSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the dimensions of the given memref value. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00111">111</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00321">mlir::Type::cast()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8cpp_source.html#l00121">mlir::Builder::getIndexAttr()</a>, and <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l02963">createCanonicalRankReducingSubViewOp()</a>.</p>

</div>
</div>
<a id="a593c42d0eefa6f2456d3ed618384de85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593c42d0eefa6f2456d3ed618384de85">&#9670;&nbsp;</a></span>getTensorTypeFromMemRefType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::memref::getTensorTypeFromMemRefType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an unranked/ranked tensor type for the given unranked/ranked memref type. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00103">103</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00311">mlir::Type::dyn_cast()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">mlir::get()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00035">mlir::Type::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l01564">parseGlobalMemrefOpTypeAndInitialValue()</a>.</p>

</div>
</div>
<a id="ae4ffe31231e4fd88511f0d2446b4218d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ffe31231e4fd88511f0d2446b4218d">&#9670;&nbsp;</a></span>multiBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; memref::AllocOp &gt; mlir::memref::multiBuffer </td>
          <td>(</td>
          <td class="paramtype">memref::AllocOp&#160;</td>
          <td class="paramname"><em>allocOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipOverrideAnalysis</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call into <code>multiBuffer</code> with locally constructed <a class="el" href="classmlir_1_1IRRewriter.html" title="This class coordinates rewriting a piece of IR outside of a pattern rewrite, providing a way to keep ...">IRRewriter</a>. </p>

<p class="definition">Definition at line <a class="el" href="MultiBuffer_8cpp_source.html#l00244">244</a> of file <a class="el" href="MultiBuffer_8cpp_source.html">MultiBuffer.cpp</a>.</p>

<p class="reference">References <a class="el" href="MultiBuffer_8cpp_source.html#l00099">multiBuffer()</a>.</p>

</div>
</div>
<a id="a637539fbb3044706f07e949413eac30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637539fbb3044706f07e949413eac30d">&#9670;&nbsp;</a></span>multiBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; memref::AllocOp &gt; mlir::memref::multiBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::AllocOp&#160;</td>
          <td class="paramname"><em>allocOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipOverrideAnalysis</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transformation to do multi-buffering/array expansion to remove dependencies on the temporary allocation between consecutive loop iterations. </p>
<p>It returns the new allocation if the original allocation was multi-buffered and returns <a class="el" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4" title="Utility function to generate a LogicalResult.">failure()</a> otherwise. When <code>skipOverrideAnalysis</code>, the pass will apply the transformation without checking thwt the buffer is overrided at the beginning of each iteration. This implies that user knows that there is no data carried across loop iterations. Example: </p><div class="fragment"><div class="line">%0 = memref.alloc() : memref&lt;4x128xf32&gt;</div>
<div class="line">scf.for %iv = %c1 to %c1024 step %c3 {</div>
<div class="line">  memref.copy %1, %0 : memref&lt;4x128xf32&gt; to memref&lt;4x128xf32&gt;</div>
<div class="line">  <span class="stringliteral">&quot;some_use&quot;</span>(%0) : (memref&lt;4x128xf32&gt;) -&gt; ()</div>
<div class="line">}</div>
</div><!-- fragment --><p> into: </p><div class="fragment"><div class="line">%0 = memref.alloc() : memref&lt;5x4x128xf32&gt;</div>
<div class="line">scf.for %iv = %c1 to %c1024 step %c3 {</div>
<div class="line">  %s = arith.subi %iv, %c1 : index</div>
<div class="line">  %d = arith.divsi %s, %c3 : index</div>
<div class="line">  %i = arith.remsi %d, %c5 : index</div>
<div class="line">  %sv = memref.subview %0[%i, 0, 0] [1, 4, 128] [1, 1, 1] :</div>
<div class="line">    memref&lt;5x4x128xf32&gt; to memref&lt;4x128xf32, strided&lt;[128, 1], offset: ?&gt;&gt;</div>
<div class="line">  memref.copy %1, %sv : memref&lt;4x128xf32&gt; to memref&lt;4x128xf32, strided&lt;...&gt;&gt;</div>
<div class="line">  <span class="stringliteral">&quot;some_use&quot;</span>(%sv) : (memref&lt;4x128xf32, strided&lt;...&gt;) -&gt; ()</div>
<div class="line">}</div>
</div><!-- fragment --> <p>Make sure there is no loop-carried dependency on the allocation.</p>

<p class="definition">Definition at line <a class="el" href="MultiBuffer_8cpp_source.html#l00099">99</a> of file <a class="el" href="MultiBuffer_8cpp_source.html">MultiBuffer.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00329">mlir::bindDims()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00030">DBGS</a>, <a class="el" href="Dominance_8h_source.html#l00141">mlir::DominanceInfo::dominates()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00285">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="MathExtras_8h_source.html#l00033">mlir::floorDiv()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00121">mlir::Builder::getIndexAttr()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00814">mlir::Operation::getUsers()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00057">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01284">mlir::affine::makeComposedAffineApply()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00034">overrideBuffer()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00045">replaceUsesAndPropagateType()</a>, <a class="el" href="Builders_8h_source.html#l00379">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00179">mlir::MemRefType::Builder::setShape()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MultiBuffer_8cpp_source.html#l00244">multiBuffer()</a>.</p>

</div>
</div>
<a id="af6c5916519d8d818c95097ef22e882ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c5916519d8d818c95097ef22e882ee">&#9670;&nbsp;</a></span>populateComposeSubViewPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateComposeSubViewPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ComposeSubView_8cpp_source.html#l00130">130</a> of file <a class="el" href="ComposeSubView_8cpp_source.html">ComposeSubView.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="aa72dbb57f66b3381ca288a092d376802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72dbb57f66b3381ca288a092d376802">&#9670;&nbsp;</a></span>populateExpandOpsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateExpandOpsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects a set of patterns to rewrite ops within the memref dialect. </p>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2ExpandOps_8cpp_source.html#l00154">154</a> of file <a class="el" href="MemRef_2Transforms_2ExpandOps_8cpp_source.html">ExpandOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ae0a91532e484d6485dc36756f1b1bace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a91532e484d6485dc36756f1b1bace">&#9670;&nbsp;</a></span>populateExpandStridedMetadataPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateExpandStridedMetadataPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for expanding memref operations that modify the metadata (sizes, offset, strides) of a memref into easier to analyze constructs. </p>

<p class="definition">Definition at line <a class="el" href="ExpandStridedMetadata_8cpp_source.html#l00902">902</a> of file <a class="el" href="ExpandStridedMetadata_8cpp_source.html">ExpandStridedMetadata.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ad05667d80ad6b23301f24c722a4dbb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05667d80ad6b23301f24c722a4dbb28">&#9670;&nbsp;</a></span>populateExtractAddressComputationsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateExtractAddressComputationsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for extracting address computations from the instructions with memory accesses such that these memory accesses use only a base pointer. </p>
<p>For instance, </p><div class="fragment"><div class="line">memref.load %base[%off0, ...]</div>
</div><!-- fragment --><p>Will be rewritten in: </p><div class="fragment"><div class="line">%new_base = memref.subview %base[%off0,...][1,...][1,...]</div>
<div class="line">memref.load %new_base[%c0,...]</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ExtractAddressComputations_8cpp_source.html#l00287">287</a> of file <a class="el" href="ExtractAddressComputations_8cpp_source.html">ExtractAddressComputations.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a0b92ea4d1067ac456aa6899baa8512a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b92ea4d1067ac456aa6899baa8512a9">&#9670;&nbsp;</a></span>populateFoldMemRefAliasOpPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateFoldMemRefAliasOpPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for folding memref aliasing ops into consumer load/store ops into <code>patterns</code>. </p>

<p class="definition">Definition at line <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00658">658</a> of file <a class="el" href="FoldMemRefAliasOps_8cpp_source.html">FoldMemRefAliasOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a6c0e1bd45d93d6da7bf22b61465492b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c0e1bd45d93d6da7bf22b61465492b9">&#9670;&nbsp;</a></span>populateMemRefWideIntEmulationConversions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateMemRefWideIntEmulationConversions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1arith_1_1WideIntEmulationConverter.html">arith::WideIntEmulationConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends type converions for emulating wide integer memref operations with ops over narrowe integer types. </p>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html#l00148">148</a> of file <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html">EmulateWideInt.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00146">mlir::TypeConverter::addConversion()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02901">mlir::TypeConverter::convertType()</a>, and <a class="el" href="WideIntEmulationConverter_8h_source.html#l00027">mlir::arith::WideIntEmulationConverter::getMaxTargetIntBitWidth()</a>.</p>

</div>
</div>
<a id="a51da475db04d0e27ef4a0a8f10c0c518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51da475db04d0e27ef4a0a8f10c0c518">&#9670;&nbsp;</a></span>populateMemRefWideIntEmulationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateMemRefWideIntEmulationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1arith_1_1WideIntEmulationConverter.html">arith::WideIntEmulationConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for emulating wide integer memref operations with ops over narrower integer types. </p>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html#l00140">140</a> of file <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html">EmulateWideInt.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a933e3cb75cf93999afc61710776fea07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933e3cb75cf93999afc61710776fea07">&#9670;&nbsp;</a></span>populateResolveExtractStridedMetadataPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateResolveExtractStridedMetadataPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for resolving <code>memref.extract_strided_metadata</code> into <code>memref.extract_strided_metadata</code> of its source. </p>

<p class="definition">Definition at line <a class="el" href="ExpandStridedMetadata_8cpp_source.html#l00918">918</a> of file <a class="el" href="ExpandStridedMetadata_8cpp_source.html">ExpandStridedMetadata.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a2fa4a24293483d5a062c0c96e56c68cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa4a24293483d5a062c0c96e56c68cf">&#9670;&nbsp;</a></span>populateResolveRankedShapeTypeResultDimsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateResolveRankedShapeTypeResultDimsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns that resolve <code>memref.dim</code> operations with values that are defined by operations that implement the <code>ReifyRankedShapeTypeShapeOpInterface</code>, in terms of shapes of its input operands. </p>

<p class="definition">Definition at line <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00124">124</a> of file <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html">ResolveShapedTypeResultDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DropUnitDims_8cpp_source.html#l00664">mlir::linalg::populateFoldUnitExtentDimsViaReshapesPatterns()</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00683">mlir::linalg::populateFoldUnitExtentDimsViaSlicesPatterns()</a>.</p>

</div>
</div>
<a id="aaf97a8143d457b645153d6f40e6aed84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf97a8143d457b645153d6f40e6aed84">&#9670;&nbsp;</a></span>populateResolveShapedTypeResultDimsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateResolveShapedTypeResultDimsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns that resolve <code>memref.dim</code> operations with values that are defined by operations that implement the <code>InferShapedTypeOpInterface</code>, in terms of shapes of its input operands. </p>

<p class="definition">Definition at line <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00131">131</a> of file <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html">ResolveShapedTypeResultDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DropUnitDims_8cpp_source.html#l00664">mlir::linalg::populateFoldUnitExtentDimsViaReshapesPatterns()</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00683">mlir::linalg::populateFoldUnitExtentDimsViaSlicesPatterns()</a>.</p>

</div>
</div>
<a id="a1a56931f8605b0783a017cf7d0d84b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a56931f8605b0783a017cf7d0d84b59">&#9670;&nbsp;</a></span>registerBufferizableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::registerBufferizableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00058">58</a> of file <a class="el" href="MemRef_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html">BufferizableOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00087">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="ad7fa7b00c1ccb23e5f4a528377dd4ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7fa7b00c1ccb23e5f4a528377dd4ee9">&#9670;&nbsp;</a></span>registerRuntimeVerifiableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::registerRuntimeVerifiableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RuntimeOpVerification_8cpp_source.html#l00181">181</a> of file <a class="el" href="RuntimeOpVerification_8cpp_source.html">RuntimeOpVerification.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="MLIRContext_8h_source.html#l00107">mlir::MLIRContext::loadDialect()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00087">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="ae1adc6a8d5aefc17867d0815b586c3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1adc6a8d5aefc17867d0815b586c3b9">&#9670;&nbsp;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefTransformOps_8cpp_source.html#l00174">174</a> of file <a class="el" href="MemRefTransformOps_8cpp_source.html">MemRefTransformOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00185">mlir::DialectRegistry::addExtensions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00087">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="ac2b49994f10e98cb119abfb38f23c0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b49994f10e98cb119abfb38f23c0c3">&#9670;&nbsp;</a></span>registerValueBoundsOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::registerValueBoundsOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRef_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00116">116</a> of file <a class="el" href="MemRef_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html">ValueBoundsOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00087">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a390d7b6bfa73372eec5b1d2cd2bf937b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390d7b6bfa73372eec5b1d2cd2bf937b">&#9670;&nbsp;</a></span>replaceWithIndependentOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::memref::replaceWithIndependentOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::AllocaOp&#160;</td>
          <td class="paramname"><em>allocaOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>independencies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a new memref::AllocaOp whose dynamic sizes are independent of all given independencies. </p>
<p>If the op is already independent of all independencies, the same AllocaOp result is returned.</p>
<p>The original AllocaOp is replaced with the new one, wrapped in a SubviewOp. The result type of the replacement is different from the original allocation type: it has the same shape, but a different layout map. This function updates all users that do not have a memref result or memref region block argument, and some frequently used memref dialect ops (such as memref.subview). It does not update other uses such as the init_arg of an scf.for op. Such uses are wrapped in unrealized_conversion_cast.</p>
<p>Failure indicates the no suitable upper bound for the dynamic sizes could be found.</p>
<p>Example (make independent of iv): </p><div class="fragment"><div class="line">scf.for %iv = %c0 to %sz step %c1 {</div>
<div class="line">  %0 = memref.alloca(%iv) : memref&lt;?xf32&gt;</div>
<div class="line">  %1 = memref.subview %0[0][5][1] : ...</div>
<div class="line">  linalg.generic outs(%1 : ...) ...</div>
<div class="line">  %2 = scf.for ... iter_arg(%arg0 = %0) ...</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>The above IR is rewritten to:</p>
<div class="fragment"><div class="line">scf.for %iv = %c0 to %sz step %c1 {</div>
<div class="line">  %0 = memref.alloca(%sz - 1) : memref&lt;?xf32&gt;</div>
<div class="line">  %0_subview = memref.subview %0[0][%iv][1]</div>
<div class="line">      : memref&lt;?xf32&gt; to memref&lt;?xf32, #map&gt;</div>
<div class="line">  %1 = memref.subview %0_subview[0][5][1] : ...</div>
<div class="line">  linalg.generic outs(%1 : ...) ...</div>
<div class="line">  %cast = unrealized_conversion_cast %0_subview</div>
<div class="line">      : memref&lt;?xf32, #map&gt; to memref&lt;?xf32&gt;</div>
<div class="line">  %2 = scf.for ... iter_arg(%arg0 = %cast) ...</div>
<div class="line"> ...</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00172">172</a> of file <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html">IndependenceTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1memref.html#a1bf86c211b0ab9ea0b1ea4943a4e6d6e">buildIndependentOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, and <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00102">replaceAndPropagateMemRefType()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 4 2023 20:34:13 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
