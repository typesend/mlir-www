<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">17.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mlir Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This header declares functions that assit transformations in the MemRef dialect.  
<a href="namespacemlir.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1acc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1acc.html">acc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1affine"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html">affine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1amdgpu"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1amdgpu.html">amdgpu</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1arith"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1arith.html">arith</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1async"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1async.html">async</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1AttributeTrait"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1AttributeTrait.html">AttributeTrait</a></td></tr>
<tr class="memdesc:namespacemlir_1_1AttributeTrait"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait is used to determine if an attribute is mutable or not. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1bufferization"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html">bufferization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1builtin__dialect__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1builtin__dialect__detail.html">builtin_dialect_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1bytecode"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bytecode.html">bytecode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1cf"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1cf.html">cf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1dataflow"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1dataflow.html">dataflow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespacemlir_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if any of the given parameter types has a sub-element handler. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1emitc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1emitc.html">emitc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1func"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1func.html">func</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1function__interface__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1function__interface__impl.html">function_interface_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1gpu"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1gpu.html">gpu</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html">impl</a></td></tr>
<tr class="memdesc:namespacemlir_1_1impl"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> collections provide a dictionary-like interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1index"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1index.html">index</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1intrange"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1intrange.html">intrange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1irdl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1irdl.html">irdl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1linalg"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html">linalg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1LLVM"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1lsp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1lsp.html">lsp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1matchers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1matchers.html">matchers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1math"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1math.html">math</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1MemoryEffects"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1MemoryEffects.html">MemoryEffects</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1memref"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html">memref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1nvgpu"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1nvgpu.html">nvgpu</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1NVVM"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1omp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1omp.html">omp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1op__definition__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html">op_definition_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1OpTrait"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait.html">OpTrait</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1pdl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1pdl.html">pdl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1pdl__interp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1pdl__interp.html">pdl_interp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1pdl__to__pdl__interp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1pdl__to__pdl__interp.html">pdl_to_pdl_interp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1pdll"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1pdll.html">pdll</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1presburger"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1presburger.html">presburger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1python"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1python.html">python</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1quant"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1quant.html">quant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1runtime"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1runtime.html">runtime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1scf"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html">scf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1shape"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1shape.html">shape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1SideEffects"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1SideEffects.html">SideEffects</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1sparse__tensor"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html">sparse_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1Speculation"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1Speculation.html">Speculation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1spirv"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html">spirv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1tblgen"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tblgen.html">tblgen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1tensor"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html">tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1tosa"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tosa.html">tosa</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1tracing"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tracing.html">tracing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1transform"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform.html">transform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1TypeTrait"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1TypeTrait.html">TypeTrait</a></td></tr>
<tr class="memdesc:namespacemlir_1_1TypeTrait"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait is used to determine if a type is a dynamic type or not; it should only be implemented by dynamic types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1vector"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html">vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1x86vector"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1x86vector.html">x86vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LocalAliasAnalysis.html">LocalAliasAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a local form of alias analysis that tries to identify the underlying values addressed by each value and performs a few basic checks to see if they alias.  <a href="classmlir_1_1LocalAliasAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AliasResult.html">AliasResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible results of an alias query.  <a href="classmlir_1_1AliasResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ModRefResult.html">ModRefResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible results of whether a memory access modifies or references a memory location.  <a href="classmlir_1_1ModRefResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AliasAnalysis.html">AliasAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the main alias analysis interface in MLIR.  <a href="classmlir_1_1AliasAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CallGraphNode.html">CallGraphNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single callable in the callgraph.  <a href="classmlir_1_1CallGraphNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CallGraph.html">CallGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CFGLoop.html">CFGLoop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a single loop formed by blocks.  <a href="classmlir_1_1CFGLoop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CFGLoopInfo.html">CFGLoopInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> LoopInfo instantiation for MLIR that provides access to CFG loops found in the dominator tree.  <a href="classmlir_1_1CFGLoopInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1GenericProgramPoint.html">GenericProgramPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for generic program points.  <a href="classmlir_1_1GenericProgramPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1GenericProgramPointBase.html">GenericProgramPointBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for generic program points based on a concrete program point type and a content key.  <a href="classmlir_1_1GenericProgramPointBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ProgramPoint.html">ProgramPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fundamental IR components are supported as first-class program points.  <a href="structmlir_1_1ProgramPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataFlowSolver.html">DataFlowSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The general data-flow analysis solver.  <a href="classmlir_1_1DataFlowSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AnalysisState.html">AnalysisState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for generic analysis states.  <a href="classmlir_1_1AnalysisState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataFlowAnalysis.html">DataFlowAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all data-flow analyses.  <a href="classmlir_1_1DataFlowAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores data layout objects for each operation that specifies the data layout above and below the given operation.  <a href="classmlir_1_1DataLayoutAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1FlatLinearConstraints.html" title="FlatLinearConstraints is an extension of IntegerPolyhedron.">FlatLinearConstraints</a> is an extension of IntegerPolyhedron.  <a href="classmlir_1_1FlatLinearConstraints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatLinearValueConstraints.html">FlatLinearValueConstraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1FlatLinearValueConstraints.html" title="FlatLinearValueConstraints represents an extension of FlatLinearConstraints where each non-local vari...">FlatLinearValueConstraints</a> represents an extension of <a class="el" href="classmlir_1_1FlatLinearConstraints.html" title="FlatLinearConstraints is an extension of IntegerPolyhedron.">FlatLinearConstraints</a> where each non-local variable can have an SSA <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> attached to it.  <a href="classmlir_1_1FlatLinearValueConstraints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Liveness.html">Liveness</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an analysis for computing liveness information from a given top-level operation.  <a href="classmlir_1_1Liveness.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LivenessBlockInfo.html">LivenessBlockInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents liveness information on block level.  <a href="classmlir_1_1LivenessBlockInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolTableAnalysis.html">SymbolTableAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple analysis that contains a symbol table collection and, for simplicity, a reference to the top-level symbol table.  <a href="classmlir_1_1SymbolTableAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParserState.html">AsmParserState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents state from a parsed MLIR textual format string.  <a href="classmlir_1_1AsmParserState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParserCodeCompleteContext.html">AsmParserCodeCompleteContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstract interface into the parser for hooking in code completion events.  <a href="classmlir_1_1AsmParserCodeCompleteContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectBytecodeReader.html">DialectBytecodeReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines a virtual interface for reading a bytecode stream, providing hooks into the bytecode reader.  <a href="classmlir_1_1DialectBytecodeReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectBytecodeWriter.html">DialectBytecodeWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines a virtual interface for writing to a bytecode stream, providing hooks into the bytecode writer.  <a href="classmlir_1_1DialectBytecodeWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectVersion.html">DialectVersion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to represent the version of a dialect, for the purpose of polymorphic destruction.  <a href="classmlir_1_1DialectVersion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BytecodeDialectInterface.html">BytecodeDialectInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BytecodeWriterConfig.html">BytecodeWriterConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains the configuration used for the bytecode writer.  <a href="classmlir_1_1BytecodeWriterConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> to transform an operation of a specific type.  <a href="classmlir_1_1OperationPass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ComplexStructBuilder.html">ComplexStructBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class that automatically populates legalization information for different <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> ops.  <a href="classmlir_1_1LLVMConversionTarget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to control the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> lowering.  <a href="classmlir_1_1LowerToLLVMOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MemRefDescriptor.html">MemRefDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to produce <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect operations extracting or inserting elements of a MemRef descriptor.  <a href="classmlir_1_1MemRefDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MemRefDescriptorView.html">MemRefDescriptorView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class allowing the user to access a range of Values that correspond to an unpacked memref descriptor using named accessors.  <a href="classmlir_1_1MemRefDescriptorView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1UnrankedMemRefDescriptor.html">UnrankedMemRefDescriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConvertToLLVMPattern.html">ConvertToLLVMPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for operation conversions targeting the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect.  <a href="classmlir_1_1ConvertToLLVMPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConvertOpToLLVMPattern.html">ConvertOpToLLVMPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for operation conversions targeting the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect that match exactly one source operation.  <a href="classmlir_1_1ConvertOpToLLVMPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OneToOneConvertToLLVMPattern.html">OneToOneConvertToLLVMPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic implementation of one-to-one conversion from "SourceOp" to "TargetOp" where the latter belongs to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect or an equivalent.  <a href="classmlir_1_1OneToOneConvertToLLVMPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StructBuilder.html">StructBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to produce <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect operations extracting or inserting values to a struct.  <a href="classmlir_1_1StructBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion from types to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect.  <a href="classmlir_1_1LLVMTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttrConvertPassThrough.html">AttrConvertPassThrough</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1VectorConvertToLLVMPattern.html">VectorConvertToLLVMPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic lowering implementation to rewrite Ops with just one result to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> <a class="el" href="classmlir_1_1Dialect.html" title="Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the...">Dialect</a>.  <a href="classmlir_1_1VectorConvertToLLVMPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AllocationOpLLVMLowering.html">AllocationOpLLVMLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowering for memory allocation ops.  <a href="structmlir_1_1AllocationOpLLVMLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AllocLikeOpLLVMLowering.html">AllocLikeOpLLVMLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowering for AllocOp and AllocaOp.  <a href="structmlir_1_1AllocLikeOpLLVMLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataDescriptor.html">DataDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to produce <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect operations inserting elements to a Data descriptor.  <a href="classmlir_1_1DataDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> to transform an operation that implements the given interface.  <a href="classmlir_1_1InterfacePass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ScfToSPIRVContext.html">ScfToSPIRVContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SPIRVToLLVMConversion.html">SPIRVToLLVMConversion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">When lowering an N-d vector transfer op to an (N-1)-d vector transfer op, a temporary buffer is created through which individual (N-1)-d vector are staged.  <a href="structmlir_1_1VectorTransferToSCFOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpWithOffsetSizesAndStridesConstantArgumentFolder.html">OpWithOffsetSizesAndStridesConstantArgumentFolder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to rewrite a subview op with constant arguments.  <a href="classmlir_1_1OpWithOffsetSizesAndStridesConstantArgumentFolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ArithBuilder.html">ArithBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct to build simple arithmetic quantities with minimal type inference support.  <a href="structmlir_1_1ArithBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BufferViewFlowAnalysis.html">BufferViewFlowAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A straight-forward alias analysis which ensures that all dependencies of all values will be determined.  <a href="classmlir_1_1BufferViewFlowAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataLayoutEntryAttr.html">DataLayoutEntryAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data layout entry attribute is a key-value pair where the key is a type or an identifier and the value is another attribute.  <a href="classmlir_1_1DataLayoutEntryAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataLayoutSpecAttr.html">DataLayoutSpecAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data layout specification is a list of entries that specify (partial) data layout information.  <a href="classmlir_1_1DataLayoutSpecAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1HasDefaultDLTIDataLayout.html">HasDefaultDLTIDataLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to be used by operations willing to use the implementation of the data layout interfaces provided by the Target dialect.  <a href="classmlir_1_1HasDefaultDLTIDataLayout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueDecomposer.html">ValueDecomposer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a hook that expands one <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> into multiple <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>'s, with a TypeConverter-inspired callback registration mechanism.  <a href="classmlir_1_1ValueDecomposer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MathPolynomialApproximationOptions.html">MathPolynomialApproximationOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the Sparsification pass.  <a href="structmlir_1_1SparsificationOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SparseTensorTypeToPtrConverter.html">SparseTensorTypeToPtrConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse tensor type converter into an opaque pointer.  <a href="classmlir_1_1SparseTensorTypeToPtrConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SparseTensorConversionOptions.html">SparseTensorConversionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SparseTensorConversion options.  <a href="structmlir_1_1SparseTensorConversionOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SparseTensorTypeToBufferConverter.html">SparseTensorTypeToBufferConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse tensor type converter into an actual buffer.  <a href="classmlir_1_1SparseTensorTypeToBufferConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageSpecifierToLLVMTypeConverter.html">StorageSpecifierToLLVMTypeConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SPIRVConversionOptions.html">SPIRVConversionOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> conversion from builtin types to SPIR-V types for shader interface.  <a href="classmlir_1_1SPIRVTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SPIRVConversionTarget.html">SPIRVConversionTarget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1VulkanLayoutUtils.html">VulkanLayoutUtils</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">According to the Vulkan spec "15.6.4. Offset and Stride Assignment": "There are different alignment requirements depending on the specific resources and on the features enabled on the device.  <a href="classmlir_1_1VulkanLayoutUtils.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class acts as an owning reference to an op, and will automatically destroy the held op on destruction if the held op is valid.  <a href="classmlir_1_1OwningOpRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of a transform IR operation application.  <a href="classmlir_1_1DiagnosedSilenceableFailure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DiagnosedDefiniteFailure.html">DiagnosedDefiniteFailure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compatibility class connecting <code><a class="el" href="classmlir_1_1InFlightDiagnostic.html" title="This class represents a diagnostic that is inflight and set to be reported.">InFlightDiagnostic</a></code> to <code><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html" title="The result of a transform IR operation application.">DiagnosedSilenceableFailure</a></code> while providing an interface similar to the former.  <a href="classmlir_1_1DiagnosedDefiniteFailure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RaggedArray.html">RaggedArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D array where each row may have different length.  <a href="classmlir_1_1RaggedArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ComposeReassociativeReshapeOps.html">ComposeReassociativeReshapeOps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to collapse producer/consumer reshape ops that are both collapsing dimensions or are both expanding dimensions.  <a href="structmlir_1_1ComposeReassociativeReshapeOps.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ComposeCollapseOfExpandOp.html">ComposeCollapseOfExpandOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to compose <code>collapse_shape(expand_shape(src, reassociation_1), reassociation_2)</code>.  <a href="structmlir_1_1ComposeCollapseOfExpandOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ComposeExpandOfCollapseOp.html">ComposeExpandOfCollapseOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1Range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a range (offset, size, and stride) where each element of the triple may be dynamic or static.  <a href="structmlir_1_1Range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StructuredGenerator.html">StructuredGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper <a class="el" href="classmlir_1_1StructuredGenerator.html" title="Helper StructuredGenerator class to manipulate and rewrite ops with StructuredOpInterface.">StructuredGenerator</a> class to manipulate and rewrite ops with <code>StructuredOpInterface</code>.  <a href="classmlir_1_1StructuredGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SimpleObjectCache.html">SimpleObjectCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple object cache following Lang's LLJITWithObjectCache example.  <a href="classmlir_1_1SimpleObjectCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ExecutionEngineOptions.html">ExecutionEngineOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ExecutionEngine.html">ExecutionEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">JIT-backed execution engine for MLIR.  <a href="classmlir_1_1ExecutionEngine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1JitRunnerOptions.html">JitRunnerOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">JitRunner command line options used by <a class="el" href="structmlir_1_1JitRunnerConfig.html" title="Configuration to override functionality of the JitRunner.">JitRunnerConfig</a> methods.  <a href="structmlir_1_1JitRunnerOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1JitRunnerConfig.html">JitRunnerConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration to override functionality of the JitRunner.  <a href="structmlir_1_1JitRunnerConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OwningMemRef.html">OwningMemRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owning MemRef type that abstracts over the runtime type for ranked strided memref.  <a href="classmlir_1_1OwningMemRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1CallInterfaceCallable.html">CallInterfaceCallable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callable is either a symbol, or an SSA value, that is referenced by a call-like operation.  <a href="structmlir_1_1CallInterfaceCallable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SuccessorOperands.html">SuccessorOperands</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class models how operands are forwarded to block arguments in control flow.  <a href="classmlir_1_1SuccessorOperands.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RegionSuccessor.html">RegionSuccessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a successor of a region.  <a href="classmlir_1_1RegionSuccessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InvocationBounds.html">InvocationBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents upper and lower bounds on the number of times a region of a <code>RegionBranchOpInterface</code> can be invoked.  <a href="classmlir_1_1InvocationBounds.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataLayoutDialectInterface.html">DataLayoutDialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface to be implemented by dialects that can have identifiers in the data layout specification entries.  <a href="classmlir_1_1DataLayoutDialectInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main mechanism for performing data layout queries.  <a href="classmlir_1_1DataLayout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpOperandVector.html">OpOperandVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> vector that implicitly converts to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> vector.  <a href="structmlir_1_1OpOperandVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectFoldInterface.html">DialectFoldInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a fold interface to allow for dialects to control specific aspects of the folding behavior for operations they define.  <a href="classmlir_1_1DialectFoldInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConstantIntRanges.html">ConstantIntRanges</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of arbitrary-precision integers representing bounds on a given integer value.  <a href="classmlir_1_1ConstantIntRanges.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ShapeAdaptor.html">ShapeAdaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor class to abstract the differences between whether value is from a ShapedType or <a class="el" href="classmlir_1_1ShapedTypeComponents.html" title="ShapedTypeComponents that represents the components of a ShapedType.">ShapedTypeComponents</a> or DenseIntElementsAttribute.  <a href="classmlir_1_1ShapeAdaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ShapedTypeComponents.html">ShapedTypeComponents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1ShapedTypeComponents.html" title="ShapedTypeComponents that represents the components of a ShapedType.">ShapedTypeComponents</a> that represents the components of a ShapedType.  <a href="classmlir_1_1ShapedTypeComponents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueShapeRange.html">ValueShapeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1Range.html" title="Represents a range (offset, size, and stride) where each element of the triple may be dynamic or stat...">Range</a> of values and shapes (corresponding effectively to Shapes dialect's ValueShape type concept).  <a href="classmlir_1_1ValueShapeRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemorySlot.html">MemorySlot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a slot in memory.  <a href="structmlir_1_1MemorySlot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TilingResult.html">TilingResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for result values of tiling.  <a href="structmlir_1_1TilingResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html">ValueBoundsConstraintSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to be used with <code>ValueBoundsOpInterface</code>.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1DstValueBoundsOpInterfaceExternalModel.html">DstValueBoundsOpInterfaceExternalModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation for destination style ops: Tied OpResults and OpOperands have the same type.  <a href="structmlir_1_1DstValueBoundsOpInterfaceExternalModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for affine expression.  <a href="classmlir_1_1AffineExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineBinaryOpExpr.html">AffineBinaryOpExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Affine binary operation expression.  <a href="classmlir_1_1AffineBinaryOpExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDimExpr.html">AffineDimExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimensional identifier appearing in an affine expression.  <a href="classmlir_1_1AffineDimExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineSymbolExpr.html">AffineSymbolExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A symbolic identifier appearing in an affine expression.  <a href="classmlir_1_1AffineSymbolExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineConstantExpr.html">AffineConstantExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer constant appearing in affine expression.  <a href="classmlir_1_1AffineConstantExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineExprVisitor.html">AffineExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> visitors/walkers.  <a href="classmlir_1_1AffineExprVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SimpleAffineExprFlattener.html">SimpleAffineExprFlattener</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-dimensional affine map Affine map's are immutable like <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a>'s, and they are uniqued.  <a href="classmlir_1_1AffineMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MutableAffineMap.html">MutableAffineMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable affine map. Its affine expressions are however unique.  <a href="structmlir_1_1MutableAffineMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmResourceBlob.html">AsmResourceBlob</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following classes enable support for parsing and printing resources within MLIR assembly formats.  <a href="classmlir_1_1AsmResourceBlob.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1HeapAsmResourceBlob.html">HeapAsmResourceBlob</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a simple utility wrapper for creating heap allocated AsmResourceBlobs.  <a href="classmlir_1_1HeapAsmResourceBlob.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1UnmanagedAsmResourceBlob.html">UnmanagedAsmResourceBlob</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a simple utility wrapper for creating "unmanaged" AsmResourceBlobs.  <a href="classmlir_1_1UnmanagedAsmResourceBlob.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmResourceBuilder.html">AsmResourceBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to build resource entries for use by the printer.  <a href="classmlir_1_1AsmResourceBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParsedResourceEntry.html">AsmParsedResourceEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single parsed resource entry.  <a href="classmlir_1_1AsmParsedResourceEntry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmResourceParser.html">AsmResourceParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an instance of a resource parser.  <a href="classmlir_1_1AsmResourceParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmResourcePrinter.html">AsmResourcePrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an instance of a resource printer.  <a href="classmlir_1_1AsmResourcePrinter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FallbackAsmResourceMap.html">FallbackAsmResourceMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fallback map containing external resources not explicitly handled by another parser/printer.  <a href="classmlir_1_1FallbackAsmResourceMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a configuration for the MLIR assembly parser.  <a href="classmlir_1_1ParserConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmState.html">AsmState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides management for the lifetime of the state used when printing the IR.  <a href="classmlir_1_1AsmState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes are known-constant values of operations.  <a href="classmlir_1_1Attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1NamedAttribute.html" title="NamedAttribute represents a combination of a name and an Attribute value.">NamedAttribute</a> represents a combination of a name and an <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> value.  <a href="classmlir_1_1NamedAttribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler_3_01NamedAttribute_01_4.html">AttrTypeSubElementHandler&lt; NamedAttribute &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow walking and replacing the subelements of a <a class="el" href="classmlir_1_1NamedAttribute.html" title="NamedAttribute represents a combination of a name and an Attribute value.">NamedAttribute</a>.  <a href="structmlir_1_1AttrTypeSubElementHandler_3_01NamedAttribute_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttributeInterface.html">AttributeInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base of an attribute interface.  <a href="classmlir_1_1AttributeInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AbstractAttribute.html">AbstractAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the static information common to all instances of a registered <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>.  <a href="classmlir_1_1AbstractAttribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttributeStorage.html">AttributeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base storage class appearing in an attribute.  <a href="classmlir_1_1AttributeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttrTypeWalker.html">AttrTypeWalker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1AttrTypeWalker.html" title="AttrTypeWalker.">AttrTypeWalker</a>.  <a href="classmlir_1_1AttrTypeWalker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttrTypeReplacer.html">AttrTypeReplacer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1AttrTypeReplacer.html" title="AttrTypeReplacer.">AttrTypeReplacer</a>.  <a href="classmlir_1_1AttrTypeReplacer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttrTypeImmediateSubElementWalker.html">AttrTypeImmediateSubElementWalker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler.html" title="This class provides support for interacting with the SubElementInterfaces for different types of para...">AttrTypeSubElementHandler</a>.  <a href="classmlir_1_1AttrTypeImmediateSubElementWalker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttrTypeSubElementReplacements.html">AttrTypeSubElementReplacements</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used by <a class="el" href="structmlir_1_1AttrTypeSubElementHandler.html" title="This class provides support for interacting with the SubElementInterfaces for different types of para...">AttrTypeSubElementHandler</a> instances to process sub element replacements.  <a href="classmlir_1_1AttrTypeSubElementReplacements.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler.html">AttrTypeSubElementHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides support for interacting with the SubElementInterfaces for different types of parameters.  <a href="structmlir_1_1AttrTypeSubElementHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_ca2937af926ee576a78a661a53d1729d.html">AttrTypeSubElementHandler&lt; T, std::enable_if_t&lt; std::is_base_of_v&lt; Attribute, T &gt;||std::is_base_of_v&lt; Type, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for derived Attributes and Types.  <a href="structmlir_1_1AttrTypeSubElementHandler_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_ca2937af926ee576a78a661a53d1729d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler_3_01ArrayRef_3_01T_01_4_00_01std_1_1enable__if__t_3_01ha2f4efb8dddd480d9444418f314b80830.html">AttrTypeSubElementHandler&lt; ArrayRef&lt; T &gt;, std::enable_if_t&lt; has_sub_attr_or_type_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for derived ArrayRef.  <a href="structmlir_1_1AttrTypeSubElementHandler_3_01ArrayRef_3_01T_01_4_00_01std_1_1enable__if__t_3_01ha2f4efb8dddd480d9444418f314b80830.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_00_01std_1_1enable__i69d64aa7e3ec1bb340acfeb6d320e346.html">AttrTypeSubElementHandler&lt; std::tuple&lt; Ts... &gt;, std::enable_if_t&lt; has_sub_attr_or_type_v&lt; Ts... &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for Tuple.  <a href="structmlir_1_1AttrTypeSubElementHandler_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_00_01std_1_1enable__i69d64aa7e3ec1bb340acfeb6d320e346.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements iteration on the types of a given range of values.  <a href="classmlir_1_1ValueTypeRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Block.html">Block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a></code> represents an ordered list of <code><a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a></code>s.  <a href="classmlir_1_1Block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BlockOperand.html">BlockOperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block operand represents an operand that holds a reference to a <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a>, e.g.  <a href="classmlir_1_1BlockOperand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PredecessorIterator.html">PredecessorIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement a predecessor iterator for blocks.  <a href="classmlir_1_1PredecessorIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SuccessorRange.html">SuccessorRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the successor iterators for <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a>.  <a href="classmlir_1_1SuccessorRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BlockRange.html">BlockRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the different types of ranges over Blocks.  <a href="classmlir_1_1BlockRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html">Builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a general helper class for creating context-global objects like types, attributes, and affine expressions.  <a href="classmlir_1_1Builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class helps build Operations.  <a href="classmlir_1_1OpBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1DialectResourceBlobHandle.html">DialectResourceBlobHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines a dialect specific handle to a resource blob.  <a href="structmlir_1_1DialectResourceBlobHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a dense vector or tensor object.  <a href="classmlir_1_1DenseElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SplatElementsAttr.html">SplatElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a splat vector or tensor constant, meaning all of the elements have the same value.  <a href="classmlir_1_1SplatElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BoolAttr.html">BoolAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special case of IntegerAttr to represent boolean integers, i.e., signless i1 integers.  <a href="classmlir_1_1BoolAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatSymbolRefAttr.html">FlatSymbolRefAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A symbol reference with a reference path containing a single element.  <a href="classmlir_1_1FlatSymbolRefAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseFPElementsAttr.html">DenseFPElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a dense float vector or tensor object.  <a href="classmlir_1_1DenseFPElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a dense integer vector or tensor object.  <a href="classmlir_1_1DenseIntElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FloatType.html">FloatType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TensorType.html">TensorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor types represent multi-dimensional arrays, and have two variants: RankedTensorType and UnrankedTensorType.  <a href="classmlir_1_1TensorType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a shared interface for ranked and unranked memref types.  <a href="classmlir_1_1BaseMemRefType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DiagnosticArgument.html">DiagnosticArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant type that holds a single argument for a diagnostic.  <a href="classmlir_1_1DiagnosticArgument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the information necessary to report a diagnostic to the <a class="el" href="classmlir_1_1DiagnosticEngine.html" title="This class is the main interface for diagnostics.">DiagnosticEngine</a>.  <a href="classmlir_1_1Diagnostic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a diagnostic that is inflight and set to be reported.  <a href="classmlir_1_1InFlightDiagnostic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DiagnosticEngine.html">DiagnosticEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the main interface for diagnostics.  <a href="classmlir_1_1DiagnosticEngine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ScopedDiagnosticHandler.html">ScopedDiagnosticHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This diagnostic handler is a simple RAII class that registers and erases a diagnostic handler on a given context.  <a href="classmlir_1_1ScopedDiagnosticHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html">SourceMgrDiagnosticHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a utility diagnostic handler for use with llvm::SourceMgr.  <a href="classmlir_1_1SourceMgrDiagnosticHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SourceMgrDiagnosticVerifierHandler.html">SourceMgrDiagnosticVerifierHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a utility diagnostic handler for use with llvm::SourceMgr that verifies that emitted diagnostics match 'expected-*' lines on the corresponding line of the source file.  <a href="classmlir_1_1SourceMgrDiagnosticVerifierHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ParallelDiagnosticHandler.html">ParallelDiagnosticHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a utility diagnostic handler for use when multi-threading some part of the compiler where diagnostics may be emitted.  <a href="classmlir_1_1ParallelDiagnosticHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Dialect.html">Dialect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the entire group.  <a href="classmlir_1_1Dialect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a pure-virtual base class that exposes the asmprinter hooks necessary to implement a custom printAttribute/printType() method on a dialect.  <a href="classmlir_1_1DialectAsmPrinter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectAsmParser.html">DialectAsmParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1DialectAsmParser.html" title="The DialectAsmParser has methods for interacting with the asm parser when parsing attributes and type...">DialectAsmParser</a> has methods for interacting with the asm parser when parsing attributes and types.  <a href="classmlir_1_1DialectAsmParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser.html">FieldParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a template class that can be specialized by users to dispatch to parsers.  <a href="structmlir_1_1FieldParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01AttributeT_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_3_01Afbf44e752e28f353857b0de6053d0e60.html">FieldParser&lt; AttributeT, std::enable_if_t&lt; std::is_base_of&lt; Attribute, AttributeT &gt;::value, AttributeT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an attribute.  <a href="structmlir_1_1FieldParser_3_01AttributeT_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_3_01Afbf44e752e28f353857b0de6053d0e60.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01TypeT_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_3_01Type_0346a91898fcc3a5091d4a6bb97af4903.html">FieldParser&lt; TypeT, std::enable_if_t&lt; std::is_base_of&lt; Type, TypeT &gt;::value, TypeT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an attribute.  <a href="structmlir_1_1FieldParser_3_01TypeT_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_3_01Type_0346a91898fcc3a5091d4a6bb97af4903.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01IntT_00_01std_1_1enable__if__t_3_01std_1_1is__integral_3_01IntT_01_4_1_1value_00_01IntT_01_4_01_4.html">FieldParser&lt; IntT, std::enable_if_t&lt; std::is_integral&lt; IntT &gt;::value, IntT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse any integer.  <a href="structmlir_1_1FieldParser_3_01IntT_00_01std_1_1enable__if__t_3_01std_1_1is__integral_3_01IntT_01_4_1_1value_00_01IntT_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01std_1_1string_01_4.html">FieldParser&lt; std::string &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a string.  <a href="structmlir_1_1FieldParser_3_01std_1_1string_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01std_1_1optional_3_01AttributeT_01_4_00_01std_1_1enable__if__t_3_01a9544224247644e900417ec0332b0042.html">FieldParser&lt; std::optional&lt; AttributeT &gt;, std::enable_if_t&lt; std::is_base_of&lt; Attribute, AttributeT &gt;::value, std::optional&lt; AttributeT &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an Optional attribute.  <a href="structmlir_1_1FieldParser_3_01std_1_1optional_3_01AttributeT_01_4_00_01std_1_1enable__if__t_3_01a9544224247644e900417ec0332b0042.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01std_1_1optional_3_01IntT_01_4_00_01std_1_1enable__if__t_3_01std_1_6359b16273171b8ce58b2c2f1b4d06a0.html">FieldParser&lt; std::optional&lt; IntT &gt;, std::enable_if_t&lt; std::is_integral&lt; IntT &gt;::value, std::optional&lt; IntT &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an Optional integer.  <a href="structmlir_1_1FieldParser_3_01std_1_1optional_3_01IntT_01_4_00_01std_1_1enable__if__t_3_01std_1_6359b16273171b8ce58b2c2f1b4d06a0.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01ContainerT_00_01std_1_1enable__if__t_3_01llvm_1_1is__detected_3_0112cbbc78ed0c7bbf669a3991e3076f4f.html">FieldParser&lt; ContainerT, std::enable_if_t&lt; llvm::is_detected&lt; detail::has_push_back_t, ContainerT &gt;::value, ContainerT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse any container that supports back insertion as a list.  <a href="structmlir_1_1FieldParser_3_01ContainerT_00_01std_1_1enable__if__t_3_01llvm_1_1is__detected_3_0112cbbc78ed0c7bbf669a3991e3076f4f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01AffineMap_01_4.html">FieldParser&lt; AffineMap &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an affine map.  <a href="structmlir_1_1FieldParser_3_01AffineMap_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectInterface.html">DialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an interface overridden for a single dialect.  <a href="classmlir_1_1DialectInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectInterfaceCollection.html">DialectInterfaceCollection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of dialect interfaces within a context, for a given concrete interface type.  <a href="classmlir_1_1DialectInterfaceCollection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectExtensionBase.html">DialectExtensionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an opaque dialect extension.  <a href="classmlir_1_1DialectExtensionBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectExtension.html">DialectExtension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a dialect extension anchored on the given set of dialects.  <a href="classmlir_1_1DialectExtension.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1DialectRegistry.html" title="The DialectRegistry maps a dialect namespace to a constructor for the matching dialect.">DialectRegistry</a> maps a dialect namespace to a constructor for the matching dialect.  <a href="classmlir_1_1DialectRegistry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectResourceBlobManager.html">DialectResourceBlobManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines a manager for dialect resource blobs.  <a href="classmlir_1_1DialectResourceBlobManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ResourceBlobManagerDialectInterface.html">ResourceBlobManagerDialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a dialect interface that provides common functionality for interacting with a resource blob manager.  <a href="classmlir_1_1ResourceBlobManagerDialectInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ResourceBlobManagerDialectInterfaceBase.html">ResourceBlobManagerDialectInterfaceBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a base class for dialects implementing the resource blob interface.  <a href="classmlir_1_1ResourceBlobManagerDialectInterfaceBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for computing basic dominance information.  <a href="classmlir_1_1DominanceInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PostDominanceInfo.html">PostDominanceInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for computing basic postdominance information.  <a href="classmlir_1_1PostDominanceInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicAttrDefinition.html">DynamicAttrDefinition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a dynamic attribute.  <a href="classmlir_1_1DynamicAttrDefinition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicAttr.html">DynamicAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic attribute instance.  <a href="classmlir_1_1DynamicAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicTypeDefinition.html">DynamicTypeDefinition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a dynamic type.  <a href="classmlir_1_1DynamicTypeDefinition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicType.html">DynamicType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic type instance.  <a href="classmlir_1_1DynamicType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicOpDefinition.html">DynamicOpDefinition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a dynamic op.  <a href="classmlir_1_1DynamicOpDefinition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ExtensibleDialect.html">ExtensibleDialect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dialect that can be extended with new operations/types/attributes at runtime.  <a href="classmlir_1_1ExtensibleDialect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicDialect.html">DynamicDialect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dialect that can be defined at runtime.  <a href="classmlir_1_1DynamicDialect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html" title="ImplicitLocOpBuilder maintains a &#39;current location&#39;, allowing use of the create&lt;&gt; method without spec...">ImplicitLocOpBuilder</a> maintains a 'current location', allowing use of the create&lt;&gt; method without specifying the location.  <a href="classmlir_1_1ImplicitLocOpBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer set representing a conjunction of one or more affine equalities and inequalities.  <a href="classmlir_1_1IntegerSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a utility class for mapping one set of IR entities to another.  <a href="classmlir_1_1IRMapping.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ReverseIterator.html">ReverseIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This iterator enumerates elements in "reverse" order.  <a href="structmlir_1_1ReverseIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ForwardDominanceIterator.html">ForwardDominanceIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This iterator enumerates elements according to their dominance relationship.  <a href="structmlir_1_1ForwardDominanceIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ReverseDominanceIterator.html">ReverseDominanceIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This iterator enumerates elements according to their reverse dominance relationship.  <a href="structmlir_1_1ReverseDominanceIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> objects represent source locations information in MLIR.  <a href="classmlir_1_1LocationAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Location.html">Location</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around a <a class="el" href="classmlir_1_1LocationAttr.html" title="Location objects represent source locations information in MLIR.">LocationAttr</a>.  <a href="classmlir_1_1Location.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FusedLocWith.html">FusedLocWith</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a fused location whose metadata is known to be an instance of the given type.  <a href="classmlir_1_1FusedLocWith.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler_3_01Location_01_4.html">AttrTypeSubElementHandler&lt; Location &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable locations to be introspected as sub-elements.  <a href="structmlir_1_1AttrTypeSubElementHandler_3_01Location_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> is the top-level object for a collection of MLIR operations.  <a href="classmlir_1_1MLIRContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements <code>Optional</code> functionality for <a class="el" href="classmlir_1_1ParseResult.html" title="This class represents success/failure for parsing-like operations that find it important to chain tog...">ParseResult</a>.  <a href="classmlir_1_1OptionalParseResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1EmptyProperties.html">EmptyProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used by default as a "marker" when no "Properties" are set on an <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>.  <a href="structmlir_1_1EmptyProperties.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PropertiesSelector.html">PropertiesSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits to detect whether an <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> defined a <code>Properties</code> type, otherwise it'll default to <code><a class="el" href="structmlir_1_1EmptyProperties.html" title="Structure used by default as a &quot;marker&quot; when no &quot;Properties&quot; are set on an Operation.">EmptyProperties</a></code>.  <a href="structmlir_1_1PropertiesSelector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PropertiesSelector_3_01Op_00_01std_1_1void__t_3_01typename_01Op_1_1Properties_01_4_01_4.html">PropertiesSelector&lt; Op, std::void_t&lt; typename Op::Properties &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html">OpState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the concrete base class that holds the operation pointer and has non-generic methods that only depend on State (to avoid having them instantiated on template types that don't affect them.  <a href="classmlir_1_1OpState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single result from folding an operation.  <a href="classmlir_1_1OpFoldResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html">Op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides public APIs that all operations should have.  <a href="classmlir_1_1Op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpInterface.html">OpInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base of an operation interface.  <a href="classmlir_1_1OpInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Operation.html">Operation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> is the basic unit of execution within MLIR.  <a href="classmlir_1_1Operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpaqueProperties.html">OpaqueProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple wrapper around a void* in order to express generically how to pass in op properties through APIs.  <a href="classmlir_1_1OpaqueProperties.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RegisteredOperationName.html">RegisteredOperationName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a "type erased" representation of a registered operation.  <a href="classmlir_1_1RegisteredOperationName.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1NamedAttrList.html" title="NamedAttrList is array of NamedAttributes that tracks whether it is sorted and does some basic work t...">NamedAttrList</a> is array of NamedAttributes that tracks whether it is sorted and does some basic work to remain sorted.  <a href="classmlir_1_1NamedAttrList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents an operation in an abstracted form, suitable for use with the builder APIs.  <a href="structmlir_1_1OperationState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of flags used to control the behavior of the various IR print methods (e.g.  <a href="classmlir_1_1OpPrintingFlags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OperationEquivalence.html">OperationEquivalence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides utilities for computing if two operations are equivalent.  <a href="structmlir_1_1OperationEquivalence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationFingerPrint.html">OperationFingerPrint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique fingerprint for a specific operation, and all of it's internal operations.  <a href="classmlir_1_1OperationFingerPrint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmDialectResourceHandle.html">AsmDialectResourceHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an opaque handle to a dialect resource entry.  <a href="classmlir_1_1AsmDialectResourceHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmDialectResourceHandleBase.html">AsmDialectResourceHandleBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a CRTP base class for dialect resource handles.  <a href="classmlir_1_1AsmDialectResourceHandleBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base class exposes generic asm printer hooks, usable across the various derived printers.  <a href="classmlir_1_1AsmPrinter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a pure-virtual base class that exposes the asmprinter hooks necessary to implement a custom <a class="el" href="SPIRVAttributes_8cpp.html#ab9c11536098442a052918c34cb6e4864">print()</a> method.  <a href="classmlir_1_1OpAsmPrinter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html">AsmParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base class exposes generic asm parser hooks, usable across the various derived parsers.  <a href="classmlir_1_1AsmParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1OpAsmParser.html" title="The OpAsmParser has methods for interacting with the asm parser: parsing things from it,...">OpAsmParser</a> has methods for interacting with the asm parser: parsing things from it, emitting errors etc.  <a href="classmlir_1_1OpAsmParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmDialectInterface.html">OpAsmDialectInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the benefit of a pattern match in a unitless scheme that ranges from 0 (very little benefit) to 65K.  <a href="classmlir_1_1PatternBenefit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Pattern.html">Pattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the data related to a pattern, but does not contain any methods or logic for the actual matching.  <a href="classmlir_1_1Pattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePattern.html">RewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements.">RewritePattern</a> is the common base class for all DAG to DAG replacements.  <a href="classmlir_1_1RewritePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpRewritePattern.html">OpRewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1OpRewritePattern.html" title="OpRewritePattern is a wrapper around RewritePattern that allows for matching and rewriting against an...">OpRewritePattern</a> is a wrapper around <a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements.">RewritePattern</a> that allows for matching and rewriting against an instance of a derived operation class as opposed to a raw <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>.  <a href="structmlir_1_1OpRewritePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpInterfaceRewritePattern.html">OpInterfaceRewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1OpInterfaceRewritePattern.html" title="OpInterfaceRewritePattern is a wrapper around RewritePattern that allows for matching and rewriting a...">OpInterfaceRewritePattern</a> is a wrapper around <a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements.">RewritePattern</a> that allows for matching and rewriting against an instance of an operation interface instead of a raw <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>.  <a href="structmlir_1_1OpInterfaceRewritePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTraitRewritePattern.html">OpTraitRewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1OpTraitRewritePattern.html" title="OpTraitRewritePattern is a wrapper around RewritePattern that allows for matching and rewriting again...">OpTraitRewritePattern</a> is a wrapper around <a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements.">RewritePattern</a> that allows for matching and rewriting against instances of an operation that possess a given trait.  <a href="classmlir_1_1OpTraitRewritePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class coordinates the application of a rewrite on a set of IR, providing a way for clients to track mutations and create new operations.  <a href="classmlir_1_1RewriterBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IRRewriter.html">IRRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class coordinates rewriting a piece of IR outside of a pattern rewrite, providing a way to keep track of the mutations made to the IR.  <a href="classmlir_1_1IRRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special type of <code><a class="el" href="classmlir_1_1RewriterBase.html" title="This class coordinates the application of a rewrite on a set of IR, providing a way for clients to tr...">RewriterBase</a></code> that coordinates the application of a rewrite pattern on the current IR being matched, providing a way to keep track of any mutations made.  <a href="classmlir_1_1PatternRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage type of byte-code interpreter values.  <a href="classmlir_1_1PDLValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PDLResultList.html">PDLResultList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class represents a list of PDL results, returned by a native rewrite method.  <a href="classmlir_1_1PDLResultList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PDLPatternConfig.html">PDLPatternConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An individual configuration for a pattern, which can be accessed by native functions via the <a class="el" href="classmlir_1_1PDLPatternConfigSet.html" title="This class contains a set of configurations for a specific pattern.">PDLPatternConfigSet</a>.  <a href="classmlir_1_1PDLPatternConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PDLPatternConfigBase.html">PDLPatternConfigBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a base class for users implementing a type of pattern configuration.  <a href="classmlir_1_1PDLPatternConfigBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PDLPatternConfigSet.html">PDLPatternConfigSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains a set of configurations for a specific pattern.  <a href="classmlir_1_1PDLPatternConfigSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PDLPatternModule.html">PDLPatternModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the necessary data for a set of PDL patterns, or pattern rewrites specified in the form of the PDL dialect.  <a href="classmlir_1_1PDLPatternModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Region.html">Region</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains a list of basic blocks and a link to the parent operation it is attached to.  <a href="classmlir_1_1Region.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the different types of ranges over Regions.  <a href="classmlir_1_1RegionRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolTable.html">SymbolTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows for representing and managing the symbol table used by operations with the '<a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a>' trait.  <a href="classmlir_1_1SymbolTable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a collection of <code><a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a></code>s.  <a href="classmlir_1_1SymbolTableCollection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LockedSymbolTableCollection.html">LockedSymbolTableCollection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a lock-based shared wrapper around a symbol table collection that allows shared access to the collection of symbol tables.  <a href="classmlir_1_1LockedSymbolTableCollection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolUserMap.html">SymbolUserMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a map of symbols to users, and provides efficient implementations of symbol queries related to users; such as collecting the users of a symbol, replacing all uses, etc.  <a href="classmlir_1_1SymbolUserMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the various different ranges of value types.  <a href="classmlir_1_1TypeRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeRangeRange.html">TypeRangeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction for a range of <a class="el" href="classmlir_1_1TypeRange.html" title="This class provides an abstraction over the various different ranges of value types.">TypeRange</a>.  <a href="classmlir_1_1TypeRangeRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueTypeIterator.html">ValueTypeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements iteration on the types of a given range of values.  <a href="classmlir_1_1ValueTypeIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler_3_01TypeRange_01_4.html">AttrTypeSubElementHandler&lt; TypeRange &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable <a class="el" href="classmlir_1_1TypeRange.html" title="This class provides an abstraction over the various different ranges of value types.">TypeRange</a> to be introspected for sub-elements.  <a href="structmlir_1_1AttrTypeSubElementHandler_3_01TypeRange_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html">Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instances of the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> class are uniqued, have an immutable identifier and an optional mutable component.  <a href="classmlir_1_1Type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeInterface.html">TypeInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base of a type interface.  <a href="classmlir_1_1TypeInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AbstractType.html">AbstractType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the static information common to all instances of a registered <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a>.  <a href="classmlir_1_1AbstractType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base storage class appearing in a <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a>.  <a href="classmlir_1_1TypeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperandElementTypeIterator.html">OperandElementTypeIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ResultElementTypeIterator.html">ResultElementTypeIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IRUnit.html">IRUnit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1IRUnit.html" title="IRUnit is a union of the different types of IR objects that consistute the IR structure (other than T...">IRUnit</a> is a union of the different types of IR objects that consistute the IR structure (other than <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> and <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>), that is <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>, <a class="el" href="classmlir_1_1Region.html" title="This class contains a list of basic blocks and a link to the parent operation it is attached to.">Region</a>, and <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a>.  <a href="classmlir_1_1IRUnit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueUseIterator.html">ValueUseIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator class that allows for iterating over the uses of an IR operand type.  <a href="classmlir_1_1ValueUseIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FilteredValueUseIterator.html">FilteredValueUseIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueUserIterator.html">ValueUserIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over the users of an IRObject.  <a href="classmlir_1_1ValueUserIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IROperand.html">IROperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to a value, suitable for use as an operand of an operation.  <a href="classmlir_1_1IROperand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IRObjectWithUseList.html">IRObjectWithUseList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single IR object that contains a use list.  <a href="classmlir_1_1IRObjectWithUseList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Value.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an instance of an SSA value in the MLIR system, representing a computable value that has a type and a set of users.  <a href="classmlir_1_1Value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an operand of an operation.  <a href="classmlir_1_1OpOperand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an argument of a <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a>.  <a href="classmlir_1_1BlockArgument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a value defined by a result of an operation.  <a href="classmlir_1_1OpResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the operand iterators for the <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> class.  <a href="classmlir_1_1OperandRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperandRangeRange.html">OperandRangeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a contiguous range of operand ranges, e.g.  <a href="classmlir_1_1OperandRangeRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MutableOperandRange.html">MutableOperandRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a mutable adaptor for a range of operands.  <a href="classmlir_1_1MutableOperandRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MutableOperandRangeRange.html">MutableOperandRangeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a contiguous range of mutable operand ranges, e.g.  <a href="classmlir_1_1MutableOperandRangeRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ResultRange.html">ResultRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the result iterators for the <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> class.  <a href="classmlir_1_1ResultRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the different types of ranges over Values.  <a href="classmlir_1_1ValueRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility result that is used to signal how to proceed with an ongoing walk:  <a href="classmlir_1_1WalkResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ForwardIterator.html">ForwardIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This iterator enumerates the elements in "forward" order.  <a href="structmlir_1_1ForwardIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1WalkStage.html">WalkStage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to encode the current walk stage for "generic" walkers.  <a href="classmlir_1_1WalkStage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AnalysisManager.html">AnalysisManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an analysis manager for a particular operation instance.  <a href="classmlir_1_1AnalysisManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ModuleAnalysisManager.html">ModuleAnalysisManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An analysis manager class specifically for the top-level operation.  <a href="classmlir_1_1ModuleAnalysisManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Pass.html">Pass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base pass class.  <a href="classmlir_1_1Pass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationPass_3_01void_01_4.html">OperationPass&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> to transform an operation.  <a href="classmlir_1_1OperationPass_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassWrapper.html">PassWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a CRTP wrapper around a base pass class to define several necessary utility methods.  <a href="classmlir_1_1PassWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassInstrumentation.html">PassInstrumentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1PassInstrumentation.html" title="PassInstrumentation provides several entry points into the pass manager infrastructure.">PassInstrumentation</a> provides several entry points into the pass manager infrastructure.  <a href="classmlir_1_1PassInstrumentation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassInstrumentor.html">PassInstrumentor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class holds a collection of <a class="el" href="classmlir_1_1PassInstrumentation.html" title="PassInstrumentation provides several entry points into the pass manager infrastructure.">PassInstrumentation</a> objects, and invokes their respective call backs.  <a href="classmlir_1_1PassInstrumentor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a pass manager that runs passes on either a specific operation type, or any isolated operation.  <a href="classmlir_1_1OpPassManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassManager.html">PassManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main pass manager and pipeline builder.  <a href="classmlir_1_1PassManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassPipelineOptions.html">PassPipelineOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclasses of <a class="el" href="classmlir_1_1PassPipelineOptions.html" title="Subclasses of PassPipelineOptions provide a set of options that can be used to initialize a pass pipe...">PassPipelineOptions</a> provide a set of options that can be used to initialize a pass pipeline.  <a href="classmlir_1_1PassPipelineOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1EmptyPipelineOptions.html">EmptyPipelineOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default empty option struct to be used for passes that do not need to take any options.  <a href="structmlir_1_1EmptyPipelineOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassRegistryEntry.html">PassRegistryEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to group information about a passes and pass pipelines (argument to invoke via mlir-opt, description, pass pipeline builder).  <a href="classmlir_1_1PassRegistryEntry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassPipelineInfo.html">PassPipelineInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to represent the information of a registered pass pipeline.  <a href="classmlir_1_1PassPipelineInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassInfo.html">PassInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to represent the information for a derived pass class.  <a href="classmlir_1_1PassInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassRegistration.html">PassRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1PassRegistration.html" title="PassRegistration provides a global initializer that registers a Pass allocation routine for a concret...">PassRegistration</a> provides a global initializer that registers a <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> allocation routine for a concrete pass instance.  <a href="structmlir_1_1PassRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassPipelineRegistration.html">PassPipelineRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> provides a global initializer that registers a <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> pipeline builder routine.  <a href="structmlir_1_1PassPipelineRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassPipelineRegistration_3_01EmptyPipelineOptions_01_4.html">PassPipelineRegistration&lt; EmptyPipelineOptions &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience specialization of <a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> for EmptyPassOptions that does not pass an empty options struct to the pass builder function.  <a href="structmlir_1_1PassPipelineRegistration_3_01EmptyPipelineOptions_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassPipelineCLParser.html">PassPipelineCLParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a command-line parser for MLIR passes.  <a href="classmlir_1_1PassPipelineCLParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassNameCLParser.html">PassNameCLParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a command-line parser specifically for MLIR pass names.  <a href="classmlir_1_1PassNameCLParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassReproducerOptions.html">PassReproducerOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ReductionNode.html">ReductionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReductionTreePass will build a reduction tree during module reduction and the <a class="el" href="classmlir_1_1ReductionNode.html" title="ReductionTreePass will build a reduction tree during module reduction and the ReductionNode represent...">ReductionNode</a> represents the vertex of the tree.  <a href="classmlir_1_1ReductionNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectReductionPatternInterface.html">DialectReductionPatternInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to report the reduction patterns for a <a class="el" href="classmlir_1_1Dialect.html" title="Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the...">Dialect</a>.  <a href="classmlir_1_1DialectReductionPatternInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Tester.html">Tester</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to keep track of the testing environment of the tool.  <a href="classmlir_1_1Tester.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a frozen set of patterns that can be processed by a pattern applicator.  <a href="classmlir_1_1FrozenRewritePatternSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ApplyPatternAction.html">ApplyPatternAction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of Action that is dispatched when a pattern is applied.  <a href="classmlir_1_1ApplyPatternAction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PatternApplicator.html">PatternApplicator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class manages the application of a group of rewrite patterns, with a user-provided cost model.  <a href="classmlir_1_1PatternApplicator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1raw__indented__ostream.html">raw_indented_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">raw_ostream subclass that simplifies indention a sequence of code.  <a href="classmlir_1_1raw__indented__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an efficient way to signal success or failure.  <a href="structmlir_1_1LogicalResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides support for representing a failure result, or a valid value of type <code>T</code>.  <a href="classmlir_1_1FailureOr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents success/failure for parsing-like operations that find it important to chain together failable operations with <code>||</code>.  <a href="classmlir_1_1ParseResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html">StorageUniquer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to get or create instances of "storage classes".  <a href="classmlir_1_1StorageUniquer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ThreadLocalCache.html">ThreadLocalCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides support for defining a thread local object with non static storage duration.  <a href="classmlir_1_1ThreadLocalCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TimingIdentifier.html">TimingIdentifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represesents a uniqued string owned by a <code><a class="el" href="classmlir_1_1TimingManager.html" title="This class represents facilities to measure execution time.">TimingManager</a></code>.  <a href="classmlir_1_1TimingIdentifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TimingManager.html">TimingManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents facilities to measure execution time.  <a href="classmlir_1_1TimingManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle for a timer in a <code><a class="el" href="classmlir_1_1TimingManager.html" title="This class represents facilities to measure execution time.">TimingManager</a></code>.  <a href="classmlir_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TimingScope.html">TimingScope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An RAII-style wrapper around a timer that ensures the timer is properly started and stopped.  <a href="classmlir_1_1TimingScope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DefaultTimingManager.html">DefaultTimingManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facilities for time measurement and report printing to an output stream.  <a href="classmlir_1_1DefaultTimingManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an efficient unique identifier for a specific C++ type.  <a href="classmlir_1_1TypeID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeIDAllocator.html">TypeIDAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a way to define new TypeIDs at runtime.  <a href="classmlir_1_1TypeIDAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SelfOwningTypeID.html">SelfOwningTypeID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a> for each instance of this class by using a pointer to the instance.  <a href="classmlir_1_1SelfOwningTypeID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1GenInfo.html">GenInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to group information about a generator (argument to invoke via mlir-tblgen, description, and generator function).  <a href="classmlir_1_1GenInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GenRegistration.html">GenRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1GenRegistration.html" title="GenRegistration provides a global initializer that registers a generator function.">GenRegistration</a> provides a global initializer that registers a generator function.  <a href="structmlir_1_1GenRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GenNameParser.html">GenNameParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds command line option for each registered generator.  <a href="structmlir_1_1GenNameParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMImportDialectInterface.html">LLVMImportDialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for dialect interfaces used to import <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR.  <a href="classmlir_1_1LLVMImportDialectInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMImportInterface.html">LLVMImportInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface collection for the import of <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR that dispatches to a concrete dialect interface implementation.  <a href="classmlir_1_1LLVMImportInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTranslationDialectInterface.html">LLVMTranslationDialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for dialect interfaces providing translation to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR.  <a href="classmlir_1_1LLVMTranslationDialectInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTranslationInterface.html">LLVMTranslationInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface collection for translation to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR, dispatches to a concrete interface implementation based on the dialect to which the given op belongs.  <a href="classmlir_1_1LLVMTranslationInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MlirOptMainConfig.html">MlirOptMainConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration options for the mlir-opt tool.  <a href="classmlir_1_1MlirOptMainConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Translation.html">Translation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the components necessary for performing a translation.  <a href="classmlir_1_1Translation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslateToMLIRRegistration.html">TranslateToMLIRRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Translate[ToMLIR|FromMLIR]Registration as an initializer that registers a function and associates it with name.  <a href="structmlir_1_1TranslateToMLIRRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslateFromMLIRRegistration.html">TranslateFromMLIRRegistration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslateRegistration.html">TranslateRegistration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslationParser.html">TranslationParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A command line parser for translation functions.  <a href="structmlir_1_1TranslationParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1DialectPluginLibraryInfo.html">DialectPluginLibraryInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the plugin required to load its dialects &amp; passes.  <a href="structmlir_1_1DialectPluginLibraryInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectPlugin.html">DialectPlugin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A loaded dialect plugin.  <a href="classmlir_1_1DialectPlugin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassPluginLibraryInfo.html">PassPluginLibraryInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the plugin required to load its passes.  <a href="structmlir_1_1PassPluginLibraryInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassPlugin.html">PassPlugin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A loaded pass plugin.  <a href="classmlir_1_1PassPlugin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> conversion class.  <a href="classmlir_1_1TypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConversionPattern.html">ConversionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for the conversion patterns.  <a href="classmlir_1_1ConversionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpConversionPattern.html">OpConversionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1OpConversionPattern.html" title="OpConversionPattern is a wrapper around ConversionPattern that allows for matching and rewriting agai...">OpConversionPattern</a> is a wrapper around <a class="el" href="classmlir_1_1ConversionPattern.html" title="Base class for the conversion patterns.">ConversionPattern</a> that allows for matching and rewriting against an instance of a derived operation class as opposed to a raw <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>.  <a href="classmlir_1_1OpConversionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpInterfaceConversionPattern.html">OpInterfaceConversionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1OpInterfaceConversionPattern.html" title="OpInterfaceConversionPattern is a wrapper around ConversionPattern that allows for matching and rewri...">OpInterfaceConversionPattern</a> is a wrapper around <a class="el" href="classmlir_1_1ConversionPattern.html" title="Base class for the conversion patterns.">ConversionPattern</a> that allows for matching and rewriting against an instance of an <a class="el" href="classmlir_1_1OpInterface.html" title="This class represents the base of an operation interface.">OpInterface</a> class as opposed to a raw <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>.  <a href="classmlir_1_1OpInterfaceConversionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConversionPatternRewriter.html">ConversionPatternRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a pattern rewriter for use with ConversionPatterns.  <a href="classmlir_1_1ConversionPatternRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class describes a specific conversion target.  <a href="classmlir_1_1ConversionTarget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PDLConversionConfig.html">PDLConversionConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A PDL configuration that is used to supported dialect conversion functionality.  <a href="classmlir_1_1PDLConversionConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class for folding operations, and unifying duplicated constants generated along the way.  <a href="classmlir_1_1OperationFolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows control over how the GreedyPatternRewriteDriver works.  <a href="classmlir_1_1GreedyRewriteConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectInlinerInterface.html">DialectInlinerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the interface that must be implemented by the dialects of operations to be inlined.  <a href="classmlir_1_1DialectInlinerInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface provides the hooks into the inlining interface.  <a href="classmlir_1_1InlinerInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OneToNTypeConverter.html">OneToNTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends <code><a class="el" href="classmlir_1_1TypeConverter.html" title="Type conversion class.">TypeConverter</a></code> with 1:N target materializations.  <a href="classmlir_1_1OneToNTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OneToNTypeMapping.html">OneToNTypeMapping</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 1:N mapping of types and provides several useful accessors.  <a href="classmlir_1_1OneToNTypeMapping.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePatternWithConverter.html">RewritePatternWithConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the basic <code><a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements.">RewritePattern</a></code> class with a type converter member and some accessors to it.  <a href="classmlir_1_1RewritePatternWithConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OneToNPatternRewriter.html">OneToNPatternRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code><a class="el" href="classmlir_1_1PatternRewriter.html" title="A special type of RewriterBase that coordinates the application of a rewrite pattern on the current I...">PatternRewriter</a></code> that <code><a class="el" href="classmlir_1_1OneToNConversionPattern.html" title="Base class for patterns with 1:N type conversions.">OneToNConversionPattern</a></code>s use.  <a href="classmlir_1_1OneToNPatternRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OneToNConversionPattern.html">OneToNConversionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for patterns with 1:N type conversions.  <a href="classmlir_1_1OneToNConversionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OneToNOpConversionPattern.html">OneToNOpConversionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a wrapper around <code><a class="el" href="classmlir_1_1OneToNConversionPattern.html" title="Base class for patterns with 1:N type conversions.">OneToNConversionPattern</a></code> for matching against instances of a particular op class.  <a href="classmlir_1_1OneToNOpConversionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Lexer.html">Lexer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class breaks up the current file into a token stream.  <a href="classmlir_1_1Lexer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Token.html">Token</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents a token in the MLIR syntax.  <a href="classmlir_1_1Token.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PyPrintAccumulator.html">PyPrintAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulates into a python string from a method that accepts an MlirStringCallback.  <a href="structmlir_1_1PyPrintAccumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PyFileAccumulator.html">PyFileAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulates int a python file-like object, either writing text (default) or binary.  <a href="classmlir_1_1PyFileAccumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PySinglePartStringAccumulator.html">PySinglePartStringAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulates into a python string from a method that is expected to make one (no more, no less) call to the callback (asserts internally on violation).  <a href="structmlir_1_1PySinglePartStringAccumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Sliceable.html">Sliceable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CRTP base class for pseudo-containers willing to support Python-type slicing access on top of indexed access.  <a href="classmlir_1_1Sliceable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ExternalPass.html">ExternalPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pass class wraps external passes defined in other languages using the MLIR C-interface.  <a href="classmlir_1_1ExternalPass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUFuncOpLowering.html">GPUFuncOpLowering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUPrintfOpToHIPLowering.html">GPUPrintfOpToHIPLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lowering of gpu.printf to a call to HIP hostcalls.  <a href="structmlir_1_1GPUPrintfOpToHIPLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUPrintfOpToLLVMCallLowering.html">GPUPrintfOpToLLVMCallLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lowering of gpu.printf to a call to an external printf() function.  <a href="structmlir_1_1GPUPrintfOpToLLVMCallLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUPrintfOpToVPrintfLowering.html">GPUPrintfOpToVPrintfLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowering of gpu.printf to a vprintf standard library.  <a href="structmlir_1_1GPUPrintfOpToVPrintfLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUReturnOpLowering.html">GPUReturnOpLowering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ScalarizeVectorOpLowering.html">ScalarizeVectorOpLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewriting that unrolls SourceOp to scalars if it's operating on vectors.  <a href="structmlir_1_1ScalarizeVectorOpLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUIndexIntrinsicOpLowering.html">GPUIndexIntrinsicOpLowering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpToFuncCallLowering.html">OpToFuncCallLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewriting that replace SourceOp with a CallOp to <code>f32Func</code> or <code>f64Func</code> depending on the element type that <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a> operates upon.  <a href="structmlir_1_1OpToFuncCallLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ScfToSPIRVContextImpl.html">ScfToSPIRVContextImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler_3_01LLVM_1_1detail_1_1LLVMStructTypeStorage_1_1Key_01_4.html">AttrTypeSubElementHandler&lt; LLVM::detail::LLVMStructTypeStorage::Key &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow walking and replacing the subelements of a LLVMStructTypeStorage key.  <a href="structmlir_1_1AttrTypeSubElementHandler_3_01LLVM_1_1detail_1_1LLVMStructTypeStorage_1_1Key_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MLIRContextImpl.html">MLIRContextImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the implementation of the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> class, using the pImpl idiom.  <a href="classmlir_1_1MLIRContextImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassExecutionAction.html">PassExecutionAction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulate the "action" of executing a single pass, used for the MLIR tracing infrastructure.  <a href="structmlir_1_1PassExecutionAction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a611e5b4f126ef025a241fda803748304"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td></tr>
<tr class="memdesc:a611e5b4f126ef025a241fda803748304"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> of the condition to limit the propagation of transitive use-defs.  <a href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">More...</a><br /></td></tr>
<tr class="separator:a611e5b4f126ef025a241fda803748304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0d8f38577d05b87e540d717a7ba9c5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afd0d8f38577d05b87e540d717a7ba9c5">OwnedBlob</a> = std::unique_ptr&lt; std::vector&lt; char &gt; &gt;</td></tr>
<tr class="separator:afd0d8f38577d05b87e540d717a7ba9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5aaca5fea0016501841c1e98a14e7ab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af5aaca5fea0016501841c1e98a14e7ab">BlobGenerator</a> = std::function&lt; <a class="el" href="namespacemlir.html#afd0d8f38577d05b87e540d717a7ba9c5">OwnedBlob</a>(const std::string &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, StringRef)&gt;</td></tr>
<tr class="separator:af5aaca5fea0016501841c1e98a14e7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594a45ae9aa1ccffd960f369da94d156"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a594a45ae9aa1ccffd960f369da94d156">LoweringCallback</a> = std::function&lt; std::unique_ptr&lt; llvm::Module &gt;(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, llvm::LLVMContext &amp;, StringRef)&gt;</td></tr>
<tr class="separator:a594a45ae9aa1ccffd960f369da94d156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae809ff18bf496d00671a691c71795f68"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae809ff18bf496d00671a691c71795f68">NewYieldValueFn</a> = std::function&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt; newBBArgs)&gt;</td></tr>
<tr class="memdesc:ae809ff18bf496d00671a691c71795f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the <code>loop</code> with <code>newIterOperands</code> added as new initialization values.  <a href="namespacemlir.html#ae809ff18bf496d00671a691c71795f68">More...</a><br /></td></tr>
<tr class="separator:ae809ff18bf496d00671a691c71795f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c8735b67af7a64e4deff16477a06eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; scf::ForOp, 8 &gt;</td></tr>
<tr class="memdesc:ad5c8735b67af7a64e4deff16477a06eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile a nest of standard for loops rooted at <code>rootForOp</code> by finding such parametric tile sizes that the outer loops have a fixed number of iterations as defined in <code>sizes</code>.  <a href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">More...</a><br /></td></tr>
<tr class="separator:ad5c8735b67af7a64e4deff16477a06eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0d45d0562d47acc2c42934ccbfea19"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3f0d45d0562d47acc2c42934ccbfea19">TileLoops</a> = std::pair&lt; <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>, <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a> &gt;</td></tr>
<tr class="separator:a3f0d45d0562d47acc2c42934ccbfea19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab973fb931221b9539fe0ffd408e261ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 2 &gt;</td></tr>
<tr class="separator:ab973fb931221b9539fe0ffd408e261ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed845b40509fa999492a04654211321"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7ed845b40509fa999492a04654211321">ReassociationIndicesRef</a> = <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;</td></tr>
<tr class="separator:a7ed845b40509fa999492a04654211321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cf0e24a954fa30fb469105d4ca5dd8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae5cf0e24a954fa30fb469105d4ca5dd8">ReassociationExprs</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2 &gt;</td></tr>
<tr class="separator:ae5cf0e24a954fa30fb469105d4ca5dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9afb3b6f82b256aea9f20e913e8afd5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac9afb3b6f82b256aea9f20e913e8afd5">AllocFunType</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; void *(size_t)&gt;</td></tr>
<tr class="separator:ac9afb3b6f82b256aea9f20e913e8afd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae076c6e0e79ca32d89266007db06f358"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae076c6e0e79ca32d89266007db06f358"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae076c6e0e79ca32d89266007db06f358">ElementWiseVisitor</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; void(T &amp;ptr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;)&gt;</td></tr>
<tr class="memdesc:ae076c6e0e79ca32d89266007db06f358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient callback to "visit" a memref element by element.  <a href="namespacemlir.html#ae076c6e0e79ca32d89266007db06f358">More...</a><br /></td></tr>
<tr class="separator:ae076c6e0e79ca32d89266007db06f358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33732a3813b186ef51131421fac26f4a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a33732a3813b186ef51131421fac26f4a">DataLayoutEntryKey</a> = <a class="el" href="classllvm_1_1PointerUnion.html">llvm::PointerUnion</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, StringAttr &gt;</td></tr>
<tr class="separator:a33732a3813b186ef51131421fac26f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a4f77607d05cf551b24ceb9362c034"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a72a4f77607d05cf551b24ceb9362c034">DataLayoutEntryList</a> = <a class="el" href="classllvm_1_1SmallVector.html">llvm::SmallVector</a>&lt; DataLayoutEntryInterface, 4 &gt;</td></tr>
<tr class="separator:a72a4f77607d05cf551b24ceb9362c034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577834e9b93afb653df29d66a6975ecf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a> = <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; DataLayoutEntryInterface &gt;</td></tr>
<tr class="separator:a577834e9b93afb653df29d66a6975ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408db684234b50da0ac6888331842065"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a408db684234b50da0ac6888331842065">SetIntRangeFn</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Value.html">Value</a>, const <a class="el" href="classmlir_1_1ConstantIntRanges.html">ConstantIntRanges</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a408db684234b50da0ac6888331842065"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the <code>setResultRanges</code> callback provided to ops implementing InferIntRangeInterface.  <a href="namespacemlir.html#a408db684234b50da0ac6888331842065">More...</a><br /></td></tr>
<tr class="separator:a408db684234b50da0ac6888331842065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5ee68dc80640e6ac9c4a6011d18bc1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0a5ee68dc80640e6ac9c4a6011d18bc1">ReifiedRankedShapedTypeDims</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;</td></tr>
<tr class="separator:a0a5ee68dc80640e6ac9c4a6011d18bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c852d22f676b319b260b86ad21499ac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9c852d22f676b319b260b86ad21499ac">ValueDimList</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; std::pair&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, std::optional&lt; int64_t &gt; &gt;&gt;</td></tr>
<tr class="separator:a9c852d22f676b319b260b86ad21499ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759bdae349015b16ce375bdd46c1e16c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a759bdae349015b16ce375bdd46c1e16c">DefaultAttributeStorage</a> = <a class="el" href="classmlir_1_1AttributeStorage.html">AttributeStorage</a></td></tr>
<tr class="memdesc:a759bdae349015b16ce375bdd46c1e16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default storage type for attributes that require no additional initialization or storage.  <a href="namespacemlir.html#a759bdae349015b16ce375bdd46c1e16c">More...</a><br /></td></tr>
<tr class="separator:a759bdae349015b16ce375bdd46c1e16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8f5011648c4f698028afb8a96b31ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aad8f5011648c4f698028afb8a96b31ce">AttributeStorageAllocator</a> = <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td></tr>
<tr class="separator:aad8f5011648c4f698028afb8a96b31ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ea1893e6ad27965d15e12d6f545008"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a16ea1893e6ad27965d15e12d6f545008">AttrSubElementReplacements</a> = <a class="el" href="classmlir_1_1AttrTypeSubElementReplacements.html">AttrTypeSubElementReplacements</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td></tr>
<tr class="separator:a16ea1893e6ad27965d15e12d6f545008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdd84a4516a711493014c535e027b86"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9cdd84a4516a711493014c535e027b86">TypeSubElementReplacements</a> = <a class="el" href="classmlir_1_1AttrTypeSubElementReplacements.html">AttrTypeSubElementReplacements</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;</td></tr>
<tr class="separator:a9cdd84a4516a711493014c535e027b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6841368c88bd98143c5b7fc3174fc663"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6841368c88bd98143c5b7fc3174fc663">DenseResourceElementsHandle</a> = <a class="el" href="structmlir_1_1DialectResourceBlobHandle.html">DialectResourceBlobHandle</a>&lt; BuiltinDialect &gt;</td></tr>
<tr class="separator:a6841368c88bd98143c5b7fc3174fc663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dffb2feeebaff96012a0f11534ecb42"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7dffb2feeebaff96012a0f11534ecb42">DenseBoolArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt; bool &gt;</td></tr>
<tr class="separator:a7dffb2feeebaff96012a0f11534ecb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90796fd9f1813081632c1402c9ab0f5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab90796fd9f1813081632c1402c9ab0f5">DenseI8ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt; int8_t &gt;</td></tr>
<tr class="separator:ab90796fd9f1813081632c1402c9ab0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684fa3991fcdc7c970ec8a74aa461a77"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a684fa3991fcdc7c970ec8a74aa461a77">DenseI16ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt; int16_t &gt;</td></tr>
<tr class="separator:a684fa3991fcdc7c970ec8a74aa461a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9107ae5cb34fa1aa00e0fd1377ad89"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ace9107ae5cb34fa1aa00e0fd1377ad89">DenseI32ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt; int32_t &gt;</td></tr>
<tr class="separator:ace9107ae5cb34fa1aa00e0fd1377ad89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50858f49b4d3e313809688de651162e3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt; int64_t &gt;</td></tr>
<tr class="separator:a50858f49b4d3e313809688de651162e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057c3db4d18f7bc0ebd0e5943ab4f6f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a057c3db4d18f7bc0ebd0e5943ab4f6f8">DenseF32ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt; float &gt;</td></tr>
<tr class="separator:a057c3db4d18f7bc0ebd0e5943ab4f6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd8e5d82c207ff36cbbf5abad9ca288"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#accd8e5d82c207ff36cbbf5abad9ca288">DenseF64ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt; double &gt;</td></tr>
<tr class="separator:accd8e5d82c207ff36cbbf5abad9ca288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1691413cd0a4f426cddf9c9ec13c0523"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1691413cd0a4f426cddf9c9ec13c0523">DenseBoolResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; bool &gt;</td></tr>
<tr class="separator:a1691413cd0a4f426cddf9c9ec13c0523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c8652ae83dca72bfa8476f790a779e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a80c8652ae83dca72bfa8476f790a779e">DenseI8ResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; int8_t &gt;</td></tr>
<tr class="separator:a80c8652ae83dca72bfa8476f790a779e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313e0d370789a4ea8efc263c0212e445"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a313e0d370789a4ea8efc263c0212e445">DenseI16ResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; int16_t &gt;</td></tr>
<tr class="separator:a313e0d370789a4ea8efc263c0212e445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82486c15d0b4b7a7c6aeaf299655cae4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a82486c15d0b4b7a7c6aeaf299655cae4">DenseI32ResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; int32_t &gt;</td></tr>
<tr class="separator:a82486c15d0b4b7a7c6aeaf299655cae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702b9fea87b463a5d46d215e2a41b434"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a702b9fea87b463a5d46d215e2a41b434">DenseI64ResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; int64_t &gt;</td></tr>
<tr class="separator:a702b9fea87b463a5d46d215e2a41b434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be9cf4f237c5eb1d4ae5ceedca018e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0be9cf4f237c5eb1d4ae5ceedca018e8">DenseUI8ResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; uint8_t &gt;</td></tr>
<tr class="separator:a0be9cf4f237c5eb1d4ae5ceedca018e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d38dcceb11bdea46ed3a87eae2c0e4e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9d38dcceb11bdea46ed3a87eae2c0e4e">DenseUI16ResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; uint16_t &gt;</td></tr>
<tr class="separator:a9d38dcceb11bdea46ed3a87eae2c0e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62ce2fff3156992f2755bc853f1f85f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad62ce2fff3156992f2755bc853f1f85f">DenseUI32ResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; uint32_t &gt;</td></tr>
<tr class="separator:ad62ce2fff3156992f2755bc853f1f85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2b788b2acc9e11d299d1bdfc6ab941"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aac2b788b2acc9e11d299d1bdfc6ab941">DenseUI64ResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; uint64_t &gt;</td></tr>
<tr class="separator:aac2b788b2acc9e11d299d1bdfc6ab941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af658dc01559125b6634401cc7a8128d1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af658dc01559125b6634401cc7a8128d1">DenseF32ResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; float &gt;</td></tr>
<tr class="separator:af658dc01559125b6634401cc7a8128d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af761c00f33889d6ec2a2247517748327"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af761c00f33889d6ec2a2247517748327">DenseF64ResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; double &gt;</td></tr>
<tr class="separator:af761c00f33889d6ec2a2247517748327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e943fa4f63d44d69d846e504c16d5f6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2e943fa4f63d44d69d846e504c16d5f6">DialectAllocatorFunction</a> = std::function&lt; <a class="el" href="classmlir_1_1Dialect.html">Dialect</a> *(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="separator:a2e943fa4f63d44d69d846e504c16d5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffd752ab3a9dd88587958c328e34e70"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6ffd752ab3a9dd88587958c328e34e70">DialectAllocatorFunctionRef</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1Dialect.html">Dialect</a> *(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="separator:a6ffd752ab3a9dd88587958c328e34e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226a6f936696eac398cee8be0368046b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a226a6f936696eac398cee8be0368046b">DynamicDialectPopulationFunction</a> = std::function&lt; void(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *, <a class="el" href="classmlir_1_1DynamicDialect.html">DynamicDialect</a> *)&gt;</td></tr>
<tr class="separator:a226a6f936696eac398cee8be0368046b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbc3d0362a57c5175f05dd95fb59641"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aedbc3d0362a57c5175f05dd95fb59641">DominanceInfoNode</a> = llvm::DomTreeNodeBase&lt; <a class="el" href="classmlir_1_1Block.html">Block</a> &gt;</td></tr>
<tr class="separator:aedbc3d0362a57c5175f05dd95fb59641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0887111bf825d1f766ef9e0911394d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab0887111bf825d1f766ef9e0911394d5">OpAsmSetValueNameFn</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Value.html">Value</a>, StringRef)&gt;</td></tr>
<tr class="memdesc:ab0887111bf825d1f766ef9e0911394d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor used to set the name of the start of a result group of an operation.  <a href="namespacemlir.html#ab0887111bf825d1f766ef9e0911394d5">More...</a><br /></td></tr>
<tr class="separator:ab0887111bf825d1f766ef9e0911394d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d45da2e2b2d5f705d618b778e36d52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af2d45da2e2b2d5f705d618b778e36d52">OpAsmSetBlockNameFn</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Block.html">Block</a> *, StringRef)&gt;</td></tr>
<tr class="memdesc:af2d45da2e2b2d5f705d618b778e36d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor used to set the name of blocks in regions directly nested under an operation.  <a href="namespacemlir.html#af2d45da2e2b2d5f705d618b778e36d52">More...</a><br /></td></tr>
<tr class="separator:af2d45da2e2b2d5f705d618b778e36d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e9dd2cd47f4932caf7412344a0d902"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac8e9dd2cd47f4932caf7412344a0d902">PDLConstraintFunction</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a> &gt;)&gt;</td></tr>
<tr class="memdesc:ac8e9dd2cd47f4932caf7412344a0d902"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic PDL pattern constraint function.  <a href="namespacemlir.html#ac8e9dd2cd47f4932caf7412344a0d902">More...</a><br /></td></tr>
<tr class="separator:ac8e9dd2cd47f4932caf7412344a0d902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1dbc894e93a039d9b57063dd5efa569"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af1dbc894e93a039d9b57063dd5efa569">PDLRewriteFunction</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;, <a class="el" href="classmlir_1_1PDLResultList.html">PDLResultList</a> &amp;, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a> &gt;)&gt;</td></tr>
<tr class="memdesc:af1dbc894e93a039d9b57063dd5efa569"><td class="mdescLeft">&#160;</td><td class="mdescRight">A native PDL rewrite function.  <a href="namespacemlir.html#af1dbc894e93a039d9b57063dd5efa569">More...</a><br /></td></tr>
<tr class="separator:af1dbc894e93a039d9b57063dd5efa569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bff85dd5cf397b62e521086d55e2d37"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3bff85dd5cf397b62e521086d55e2d37">TypeRangeRangeIterator</a> = llvm::mapped_iterator&lt; llvm::iota_range&lt; unsigned &gt;::iterator, std::function&lt; <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>(unsigned)&gt; &gt;</td></tr>
<tr class="separator:a3bff85dd5cf397b62e521086d55e2d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b36f0e85767ed4e793d86f40bd8fe55"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8b36f0e85767ed4e793d86f40bd8fe55">DefaultTypeStorage</a> = <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td></tr>
<tr class="memdesc:a8b36f0e85767ed4e793d86f40bd8fe55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default storage type for types that require no additional initialization or storage.  <a href="namespacemlir.html#a8b36f0e85767ed4e793d86f40bd8fe55">More...</a><br /></td></tr>
<tr class="separator:a8b36f0e85767ed4e793d86f40bd8fe55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e9069ef9040ccc727d541c02d49ecd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a01e9069ef9040ccc727d541c02d49ecd">TypeStorageAllocator</a> = <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td></tr>
<tr class="memdesc:a01e9069ef9040ccc727d541c02d49ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a utility allocator used to allocate memory for instances of derived Types.  <a href="namespacemlir.html#a01e9069ef9040ccc727d541c02d49ecd">More...</a><br /></td></tr>
<tr class="separator:a01e9069ef9040ccc727d541c02d49ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3789e28c54bcaf5d2c3baf5f99eb615f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3789e28c54bcaf5d2c3baf5f99eb615f">OperandElementTypeRange</a> = <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1OperandElementTypeIterator.html">OperandElementTypeIterator</a> &gt;</td></tr>
<tr class="separator:a3789e28c54bcaf5d2c3baf5f99eb615f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253b95ef2aaf79bdc612ae40fddc0732"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a253b95ef2aaf79bdc612ae40fddc0732">ResultElementTypeRange</a> = <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1ResultElementTypeIterator.html">ResultElementTypeIterator</a> &gt;</td></tr>
<tr class="separator:a253b95ef2aaf79bdc612ae40fddc0732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39768b5816332d4970911da09de5cec4"><td class="memTemplParams" colspan="2">template&lt;typename Ty , typename Value  = mlir::Value&gt; </td></tr>
<tr class="memitem:a39768b5816332d4970911da09de5cec4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a39768b5816332d4970911da09de5cec4">TypedValue</a> = std::conditional_t&lt; std::is_same_v&lt; Ty, <a class="el" href="classmlir_1_1Type.html">mlir::Type</a> &gt;, <a class="el" href="classmlir_1_1Value.html">mlir::Value</a>, <a class="el" href="structmlir_1_1detail_1_1TypedValue.html">detail::TypedValue</a>&lt; Ty &gt; &gt;</td></tr>
<tr class="memdesc:a39768b5816332d4970911da09de5cec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Ty is <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">mlir::Type</a> this will select <code><a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a></code> instead of having a wrapper around it.  <a href="namespacemlir.html#a39768b5816332d4970911da09de5cec4">More...</a><br /></td></tr>
<tr class="separator:a39768b5816332d4970911da09de5cec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ccb1e7accf2ec0c57b1aea967ccd02"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af4ccb1e7accf2ec0c57b1aea967ccd02">PassRegistryFunction</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;, StringRef <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(const Twine &amp;)&gt; errorHandler)&gt;</td></tr>
<tr class="memdesc:af4ccb1e7accf2ec0c57b1aea967ccd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">A registry function that adds passes to the given pass manager.  <a href="namespacemlir.html#af4ccb1e7accf2ec0c57b1aea967ccd02">More...</a><br /></td></tr>
<tr class="separator:af4ccb1e7accf2ec0c57b1aea967ccd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48db7fd5d49bfa7ca8c81e5a6a058683"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a48db7fd5d49bfa7ca8c81e5a6a058683">PassAllocatorFunction</a> = std::function&lt; std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;()&gt;</td></tr>
<tr class="separator:a48db7fd5d49bfa7ca8c81e5a6a058683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087da824f0d25f4e19913ab4f2688c7b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Enable  = void&gt; </td></tr>
<tr class="memitem:a087da824f0d25f4e19913ab4f2688c7b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a087da824f0d25f4e19913ab4f2688c7b">DenseMapInfo</a> = <a class="el" href="structllvm_1_1DenseMapInfo.html">llvm::DenseMapInfo</a>&lt; T, Enable &gt;</td></tr>
<tr class="separator:a087da824f0d25f4e19913ab4f2688c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f731697783a754f6f0e3821d1264b2"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename KeyInfoT  = DenseMapInfo&lt;KeyT&gt;, typename BucketT  = llvm::detail::DenseMapPair&lt;KeyT, ValueT&gt;&gt; </td></tr>
<tr class="memitem:ad7f731697783a754f6f0e3821d1264b2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a> = <a class="el" href="classllvm_1_1DenseMap.html">llvm::DenseMap</a>&lt; KeyT, ValueT, KeyInfoT, BucketT &gt;</td></tr>
<tr class="separator:ad7f731697783a754f6f0e3821d1264b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d6aae8a616cd9d13c8b1edb1095948"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueInfoT  = DenseMapInfo&lt;ValueT&gt;&gt; </td></tr>
<tr class="memitem:a59d6aae8a616cd9d13c8b1edb1095948"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a> = <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt; ValueT, ValueInfoT &gt;</td></tr>
<tr class="separator:a59d6aae8a616cd9d13c8b1edb1095948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637916a3aeba97d795fa40975fbd7bd6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Vector  = std::vector&lt;T&gt;, typename Set  = DenseSet&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a637916a3aeba97d795fa40975fbd7bd6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a> = <a class="el" href="classllvm_1_1SetVector.html">llvm::SetVector</a>&lt; T, <a class="el" href="structVector.html">Vector</a>, Set &gt;</td></tr>
<tr class="separator:a637916a3aeba97d795fa40975fbd7bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b3592ab67f8512cb18e62375d7ff4b"><td class="memTemplParams" colspan="2">template&lt;typename AllocatorTy  = llvm::MallocAllocator&gt; </td></tr>
<tr class="memitem:ac2b3592ab67f8512cb18e62375d7ff4b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac2b3592ab67f8512cb18e62375d7ff4b">StringSet</a> = <a class="el" href="classllvm_1_1StringSet.html">llvm::StringSet</a>&lt; AllocatorTy &gt;</td></tr>
<tr class="separator:ac2b3592ab67f8512cb18e62375d7ff4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac474b9f30a56412e090d9919e4dd8b34"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = T&gt; </td></tr>
<tr class="memitem:ac474b9f30a56412e090d9919e4dd8b34"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac474b9f30a56412e090d9919e4dd8b34">StringSwitch</a> = <a class="el" href="classllvm_1_1StringSwitch.html">llvm::StringSwitch</a>&lt; T, R &gt;</td></tr>
<tr class="separator:ac474b9f30a56412e090d9919e4dd8b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf44d03780c99376ac0c1dd1caed0f4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ResultT  = void&gt; </td></tr>
<tr class="memitem:abcf44d03780c99376ac0c1dd1caed0f4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abcf44d03780c99376ac0c1dd1caed0f4">TypeSwitch</a> = <a class="el" href="classllvm_1_1TypeSwitch.html">llvm::TypeSwitch</a>&lt; T, ResultT &gt;</td></tr>
<tr class="separator:abcf44d03780c99376ac0c1dd1caed0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bff6226b7c81b6134b8c1130403a172"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a0bff6226b7c81b6134b8c1130403a172"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; Fn &gt;</td></tr>
<tr class="separator:a0bff6226b7c81b6134b8c1130403a172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb0c2458571cd80ebb876d979e24346"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aafb0c2458571cd80ebb876d979e24346">ChunkBufferHandler</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(std::unique_ptr&lt; llvm::MemoryBuffer &gt; chunkBuffer, raw_ostream &amp;os)&gt;</td></tr>
<tr class="separator:aafb0c2458571cd80ebb876d979e24346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddb6704fdaa06a1d6d81b12d73eac94"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4ddb6704fdaa06a1d6d81b12d73eac94">GenFunction</a> = std::function&lt; bool(const llvm::RecordKeeper &amp;recordKeeper, raw_ostream &amp;os)&gt;</td></tr>
<tr class="memdesc:a4ddb6704fdaa06a1d6d81b12d73eac94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generator function to invoke.  <a href="namespacemlir.html#a4ddb6704fdaa06a1d6d81b12d73eac94">More...</a><br /></td></tr>
<tr class="separator:a4ddb6704fdaa06a1d6d81b12d73eac94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22124ccf5219095aee552486366ccc0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa22124ccf5219095aee552486366ccc0">PassPipelineFn</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;pm)&gt;</td></tr>
<tr class="memdesc:aa22124ccf5219095aee552486366ccc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This defines the function type used to setup the pass manager.  <a href="namespacemlir.html#aa22124ccf5219095aee552486366ccc0">More...</a><br /></td></tr>
<tr class="separator:aa22124ccf5219095aee552486366ccc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2fc3e0eaaa708d4f579d33d914aafb4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab2fc3e0eaaa708d4f579d33d914aafb4">TranslateSourceMgrToMLIRFunction</a> = std::function&lt; <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;(const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="memdesc:ab2fc3e0eaaa708d4f579d33d914aafb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that translates the sources managed by <code>sourceMgr</code> to MLIR.  <a href="namespacemlir.html#ab2fc3e0eaaa708d4f579d33d914aafb4">More...</a><br /></td></tr>
<tr class="separator:ab2fc3e0eaaa708d4f579d33d914aafb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e66fd933b3c9e825ff92ccea2450120"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2e66fd933b3c9e825ff92ccea2450120">TranslateRawSourceMgrToMLIRFunction</a> = std::function&lt; <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;(llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="separator:a2e66fd933b3c9e825ff92ccea2450120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7afe9f2206cbd31d4c274a8a496fcc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9e7afe9f2206cbd31d4c274a8a496fcc">TranslateStringRefToMLIRFunction</a> = std::function&lt; <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;(llvm::StringRef, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="memdesc:a9e7afe9f2206cbd31d4c274a8a496fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that translates the given string to MLIR.  <a href="namespacemlir.html#a9e7afe9f2206cbd31d4c274a8a496fcc">More...</a><br /></td></tr>
<tr class="separator:a9e7afe9f2206cbd31d4c274a8a496fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f6096a57734eed0290d2ab34ad5e79"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a86f6096a57734eed0290d2ab34ad5e79">TranslateFromMLIRFunction</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, llvm::raw_ostream &amp;output)&gt;</td></tr>
<tr class="memdesc:a86f6096a57734eed0290d2ab34ad5e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that translates MLIR to a different format and outputs the result to a stream.  <a href="namespacemlir.html#a86f6096a57734eed0290d2ab34ad5e79">More...</a><br /></td></tr>
<tr class="separator:a86f6096a57734eed0290d2ab34ad5e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a36971a2ce3497d801451c71cabd7f0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0a36971a2ce3497d801451c71cabd7f0">TranslateFunction</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, llvm::raw_ostream &amp;output, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="memdesc:a0a36971a2ce3497d801451c71cabd7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that performs file-to-file translation involving MLIR.  <a href="namespacemlir.html#a0a36971a2ce3497d801451c71cabd7f0">More...</a><br /></td></tr>
<tr class="separator:a0a36971a2ce3497d801451c71cabd7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4308db4537fab4bd6031bf3ba2206525"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4308db4537fab4bd6031bf3ba2206525">DialectRegistrationFunction</a> = std::function&lt; void(<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a4308db4537fab4bd6031bf3ba2206525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that adds all dialects and dialect extensions used for the translation to the given <a class="el" href="classmlir_1_1DialectRegistry.html" title="The DialectRegistry maps a dialect namespace to a constructor for the matching dialect.">DialectRegistry</a>.  <a href="namespacemlir.html#a4308db4537fab4bd6031bf3ba2206525">More...</a><br /></td></tr>
<tr class="separator:a4308db4537fab4bd6031bf3ba2206525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70a1dffc17ef544b387b99ba05784d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae70a1dffc17ef544b387b99ba05784d2">MemorySpaceMapping</a> = std::function&lt; unsigned(gpu::AddressSpace gpuAddressSpace)&gt;</td></tr>
<tr class="memdesc:ae70a1dffc17ef544b387b99ba05784d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that maps a MemorySpace enum to a target-specific integer value.  <a href="namespacemlir.html#ae70a1dffc17ef544b387b99ba05784d2">More...</a><br /></td></tr>
<tr class="separator:ae70a1dffc17ef544b387b99ba05784d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2c02a386e5ba59c4c88f83ac471f999d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> { <a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999da4bac8cdf0a968472b519b3b295d0d48b">NoChange</a>
, <a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999daf4ec5f57bd4d31b803312d873be40da9">Change</a>
 }</td></tr>
<tr class="memdesc:a2c02a386e5ba59c4c88f83ac471f999d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A result type used to indicate if a change happened.  <a href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">More...</a><br /></td></tr>
<tr class="separator:a2c02a386e5ba59c4c88f83ac471f999d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781474aef998ccce168b69ae973cd832"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832">SparseParallelizationStrategy</a> { <br />
&#160;&#160;<a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832a35c3ace1970663a16e5c65baa5941b13">kNone</a>
, <a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832a09e4a3d1c3e70c9426528f102480e6e7">kDenseOuterLoop</a>
, <a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832afe3590ad05890d8754eef93504f9b7af">kAnyStorageOuterLoop</a>
, <a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832a0d7778373362fd80feddcb9b38a354b8">kDenseAnyLoop</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832a3b1257bf6747bc07f90c215e9aafd4a7">kAnyStorageAnyLoop</a>
<br />
 }</td></tr>
<tr class="memdesc:a781474aef998ccce168b69ae973cd832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a parallelization strategy.  <a href="namespacemlir.html#a781474aef998ccce168b69ae973cd832">More...</a><br /></td></tr>
<tr class="separator:a781474aef998ccce168b69ae973cd832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6dfcab9b0dbfb18cf218eef50ba36ca"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36ca">SparseToSparseConversionStrategy</a> { <a class="el" href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36caaa8c857c2f1b000c92f9794ebf53888d7">kAuto</a>
, <a class="el" href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36caad0d3b7e52553c0a403cfe727b3ce47b3">kViaCOO</a>
, <a class="el" href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36caaa9a2bb1cd77c7a81a96b73f10722040e">kDirect</a>
 }</td></tr>
<tr class="memdesc:ad6dfcab9b0dbfb18cf218eef50ba36ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a strategy for implementing sparse-to-sparse conversion.  <a href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36ca">More...</a><br /></td></tr>
<tr class="separator:ad6dfcab9b0dbfb18cf218eef50ba36ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b49fcd2b613b6c30ffc13f35b8675c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a98b49fcd2b613b6c30ffc13f35b8675c">DeletionKind</a> { <a class="el" href="namespacemlir.html#a98b49fcd2b613b6c30ffc13f35b8675ca02bce93bff905887ad2233110bf9c49e">Keep</a>
, <a class="el" href="namespacemlir.html#a98b49fcd2b613b6c30ffc13f35b8675caf2a6c498fb90ee345d997f888fce3b18">Delete</a>
 }</td></tr>
<tr class="memdesc:a98b49fcd2b613b6c30ffc13f35b8675c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returned by operation promotion logic requesting the deletion of an operation.  <a href="namespacemlir.html#a98b49fcd2b613b6c30ffc13f35b8675c">More...</a><br /></td></tr>
<tr class="separator:a98b49fcd2b613b6c30ffc13f35b8675c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3b7fd763c24274db6c115579084133"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a> { <br />
&#160;&#160;<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133aec211f7c20af43e742bf2570c3cb84f9">Add</a>
, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a62b6d55816cf737bfc6f42e60df1a3f2">Mul</a>
, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a7aeb0277500c86e4aa6bd23f9a737942">Mod</a>
, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133abaa422535e7ce48b442cc07089e64e7a">FloorDiv</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a30c212eb3184a5ed41f01a25c8124e8a">CeilDiv</a>
, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a4be6ccd8c4af006587a76a5fd3e7dc24">LAST_AFFINE_BINARY_OP</a> = CeilDiv
, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">Constant</a>
, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133ab49b848e4bb608f4d5650e4b2817c641">DimId</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133aea00d3c6059a4ff11d351696747fc7ff">SymbolId</a>
<br />
 }</td></tr>
<tr class="separator:a6d3b7fd763c24274db6c115579084133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84871bcca0aaa0176d43dbdbffe9a6c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac84871bcca0aaa0176d43dbdbffe9a6c">AsmResourceEntryKind</a> { <a class="el" href="namespacemlir.html#ac84871bcca0aaa0176d43dbdbffe9a6cae8016c85ada38bdc5fac616ec1318047">Blob</a>
, <a class="el" href="namespacemlir.html#ac84871bcca0aaa0176d43dbdbffe9a6cac26f15e86e3de4c398a8273272aba034">Bool</a>
, <a class="el" href="namespacemlir.html#ac84871bcca0aaa0176d43dbdbffe9a6ca27118326006d3829667a400ad23d5d98">String</a>
 }</td></tr>
<tr class="memdesc:ac84871bcca0aaa0176d43dbdbffe9a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum represents the different kinds of resource values.  <a href="namespacemlir.html#ac84871bcca0aaa0176d43dbdbffe9a6c">More...</a><br /></td></tr>
<tr class="separator:ac84871bcca0aaa0176d43dbdbffe9a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11353e6611651b85531ad95629c57d75"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">SliceVerificationResult</a> { <br />
&#160;&#160;<a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a505a83f220c02df2f85c3810cd9ceb38">Success</a>
, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a780dd32ee9af184442cea3f2a2a75271">RankTooLarge</a>
, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a87c69361ccd090c9c844e19d08432a26">SizeMismatch</a>
, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a6341e1bfc09d56fa49bb1b9400459d8e">ElemTypeMismatch</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a36a2220daadd84aaba239b031cf4cd23">MemSpaceMismatch</a>
, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a36297823a9892f9936fba1805a1c52ca">LayoutMismatch</a>
<br />
 }</td></tr>
<tr class="memdesc:a11353e6611651b85531ad95629c57d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum that captures information related to verifier error conditions on slice insert/extract type of ops.  <a href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">More...</a><br /></td></tr>
<tr class="separator:a11353e6611651b85531ad95629c57d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247bc9a6d1f1577f2d876cb55e2ea752"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752">DiagnosticSeverity</a> { <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a3b0649c72650c313a357338dcdfb64ec">Note</a>
, <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a0eaadb4fcb48a0a0ed7bc9868be9fbaa">Warning</a>
, <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">Error</a>
, <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a91921ada405fd6ba65dff028df047cb6">Remark</a>
 }</td></tr>
<tr class="memdesc:a247bc9a6d1f1577f2d876cb55e2ea752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the different supported severity of a diagnostic.  <a href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752">More...</a><br /></td></tr>
<tr class="separator:a247bc9a6d1f1577f2d876cb55e2ea752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb30aa1b062bf437bf3ea2b843a2ae1"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abeb30aa1b062bf437bf3ea2b843a2ae1">RegionKind</a> { <a class="el" href="namespacemlir.html#abeb30aa1b062bf437bf3ea2b843a2ae1abfd486e5c2cad6a0ba13ec4e1951815b">SSACFG</a>
, <a class="el" href="namespacemlir.html#abeb30aa1b062bf437bf3ea2b843a2ae1a4cdbd2bafa8193091ba09509cedf94fd">Graph</a>
 }</td></tr>
<tr class="memdesc:abeb30aa1b062bf437bf3ea2b843a2ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kinds of regions contained in an operation.  <a href="namespacemlir.html#abeb30aa1b062bf437bf3ea2b843a2ae1">More...</a><br /></td></tr>
<tr class="separator:abeb30aa1b062bf437bf3ea2b843a2ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fa9dd53c74f1ca73aa7ef263c94adc"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> { <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc">PreOrder</a>
, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163">PostOrder</a>
 }</td></tr>
<tr class="memdesc:a59fa9dd53c74f1ca73aa7ef263c94adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traversal order for region, block and operation walk utilities.  <a href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">More...</a><br /></td></tr>
<tr class="separator:a59fa9dd53c74f1ca73aa7ef263c94adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64460ede39d8480e398fd2e6810d95b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95b">PassDisplayMode</a> { <a class="el" href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95ba4ee29ca12c7d126654bd0e5275de6135">List</a>
, <a class="el" href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95baaeaeaec51b4e6b88122f10ad96a8de72">Pipeline</a>
 }</td></tr>
<tr class="memdesc:ab64460ede39d8480e398fd2e6810d95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum describing the different display modes for the information within the pass manager.  <a href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95b">More...</a><br /></td></tr>
<tr class="separator:ab64460ede39d8480e398fd2e6810d95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4d5a3d224089fd8a2ebc3e933d08b5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5">TraversalMode</a> { <a class="el" href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5ab8166871d66f03feaa6948b3f5727c96">SinglePath</a>
, <a class="el" href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5ad4f6ed581fb2f9d06c062711e30c13e1">Backtrack</a>
, <a class="el" href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5a9addc7d66f740728689b7f9abde66593">MultiPath</a>
 }</td></tr>
<tr class="memdesc:a9e4d5a3d224089fd8a2ebc3e933d08b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the traversal method options to be used in the reduction tree traversal.  <a href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5">More...</a><br /></td></tr>
<tr class="separator:a9e4d5a3d224089fd8a2ebc3e933d08b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb0dcd5ae75936e3c6f177223c9d5eb"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acbb0dcd5ae75936e3c6f177223c9d5eb">GreedyRewriteStrictness</a> { <a class="el" href="namespacemlir.html#acbb0dcd5ae75936e3c6f177223c9d5eba97d3def284d4e3d3bef99205c339fceb">AnyOp</a>
, <a class="el" href="namespacemlir.html#acbb0dcd5ae75936e3c6f177223c9d5eba8fc95fc7cfbd316cce7d887ab38f6120">ExistingAndNewOps</a>
, <a class="el" href="namespacemlir.html#acbb0dcd5ae75936e3c6f177223c9d5eba475f4ba4004dc37c3764009114b6e69b">ExistingOps</a>
 }</td></tr>
<tr class="memdesc:acbb0dcd5ae75936e3c6f177223c9d5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum controls which ops are put on the worklist during a greedy pattern rewrite.  <a href="namespacemlir.html#acbb0dcd5ae75936e3c6f177223c9d5eb">More...</a><br /></td></tr>
<tr class="separator:acbb0dcd5ae75936e3c6f177223c9d5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af8130946445de43cbbe975607457e51c"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af8130946445de43cbbe975607457e51c">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1AliasResult.html">AliasResult</a> &amp;result)</td></tr>
<tr class="separator:af8130946445de43cbbe975607457e51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8ea3e011d372d1f5b3bc1fb34e1286"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0e8ea3e011d372d1f5b3bc1fb34e1286">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1ModRefResult.html">ModRefResult</a> &amp;result)</td></tr>
<tr class="separator:a0e8ea3e011d372d1f5b3bc1fb34e1286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef74da457499b5816049abe29cc25d04"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aef74da457499b5816049abe29cc25d04">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Block.html">mlir::Block</a> &amp;block)</td></tr>
<tr class="separator:aef74da457499b5816049abe29cc25d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609ab9ceb7a2ad554864c86fc7ece4fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a609ab9ceb7a2ad554864c86fc7ece4fd">operator|</a> (<a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> lhs, <a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> rhs)</td></tr>
<tr class="separator:a609ab9ceb7a2ad554864c86fc7ece4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001ec055bf293748f02c00aff842dc38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a001ec055bf293748f02c00aff842dc38">operator|=</a> (<a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> &amp;lhs, <a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> rhs)</td></tr>
<tr class="separator:a001ec055bf293748f02c00aff842dc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5d450d84010aaf140c9cccddf00804"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4f5d450d84010aaf140c9cccddf00804">operator&amp;</a> (<a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> lhs, <a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> rhs)</td></tr>
<tr class="separator:a4f5d450d84010aaf140c9cccddf00804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90cebc5db982e1f7b1147c8c6595595"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa90cebc5db982e1f7b1147c8c6595595">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1AnalysisState.html">AnalysisState</a> &amp;state)</td></tr>
<tr class="separator:aa90cebc5db982e1f7b1147c8c6595595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66be8071673bc737aec05de131f066cf"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a66be8071673bc737aec05de131f066cf">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="structmlir_1_1ProgramPoint.html">ProgramPoint</a> point)</td></tr>
<tr class="separator:a66be8071673bc737aec05de131f066cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787e2019eb81129624ee13f365dcfd03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a787e2019eb81129624ee13f365dcfd03">getFlattenedAffineExpr</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, unsigned numDims, unsigned numSymbols, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *flattenedExpr, <a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a> *cst=nullptr)</td></tr>
<tr class="memdesc:a787e2019eb81129624ee13f365dcfd03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens 'expr' into 'flattenedExpr', which contains the coefficients of the dimensions, symbols, and additional variables that represent floor divisions of dimensions, symbols, and in turn other floor divisions.  <a href="namespacemlir.html#a787e2019eb81129624ee13f365dcfd03">More...</a><br /></td></tr>
<tr class="separator:a787e2019eb81129624ee13f365dcfd03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb13d4a8ddc5d1ed24afc4287ffc60d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9cb13d4a8ddc5d1ed24afc4287ffc60d">getFlattenedAffineExprs</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *flattenedExprs, <a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a> *cst=nullptr)</td></tr>
<tr class="memdesc:a9cb13d4a8ddc5d1ed24afc4287ffc60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens the result expressions of the map to their corresponding flattened forms and set in 'flattenedExprs'.  <a href="namespacemlir.html#a9cb13d4a8ddc5d1ed24afc4287ffc60d">More...</a><br /></td></tr>
<tr class="separator:a9cb13d4a8ddc5d1ed24afc4287ffc60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d3ec2b375b73649766ce133c49aa1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a99d3ec2b375b73649766ce133c49aa1e">getFlattenedAffineExprs</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *flattenedExprs, <a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a> *cst=nullptr)</td></tr>
<tr class="separator:a99d3ec2b375b73649766ce133c49aa1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb248e9fd529c9528e4e235a52941e67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeb248e9fd529c9528e4e235a52941e67">getMultiAffineFunctionFromMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1presburger_1_1MultiAffineFunction.html">presburger::MultiAffineFunction</a> &amp;multiAff)</td></tr>
<tr class="separator:aeb248e9fd529c9528e4e235a52941e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcc9dc786aa8f64a60f1d51cdad3361"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5bcc9dc786aa8f64a60f1d51cdad3361">alignAffineMapWithValues</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> dims, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> syms, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *newSyms=nullptr)</td></tr>
<tr class="memdesc:a5bcc9dc786aa8f64a60f1d51cdad3361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-indexes the dimensions and symbols of an affine map with given <code>operands</code> values to align with <code>dims</code> and <code>syms</code> values.  <a href="namespacemlir.html#a5bcc9dc786aa8f64a60f1d51cdad3361">More...</a><br /></td></tr>
<tr class="separator:a5bcc9dc786aa8f64a60f1d51cdad3361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac046ca544c3373919620bd8c704f95e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac046ca544c3373919620bd8c704f95e4">getForwardSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *forwardSlice, <a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a> filter=nullptr, bool inclusive=false)</td></tr>
<tr class="memdesc:ac046ca544c3373919620bd8c704f95e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills <code>forwardSlice</code> with the computed forward slice (i.e.  <a href="namespacemlir.html#ac046ca544c3373919620bd8c704f95e4">More...</a><br /></td></tr>
<tr class="separator:ac046ca544c3373919620bd8c704f95e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104c4215efb1da3eeadeb9d21a3f70d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a104c4215efb1da3eeadeb9d21a3f70d1">getForwardSlice</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> root, <a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *forwardSlice, <a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a> filter=nullptr, bool inclusive=false)</td></tr>
<tr class="memdesc:a104c4215efb1da3eeadeb9d21a3f70d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value-rooted version of <code>getForwardSlice</code>.  <a href="namespacemlir.html#a104c4215efb1da3eeadeb9d21a3f70d1">More...</a><br /></td></tr>
<tr class="separator:a104c4215efb1da3eeadeb9d21a3f70d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0562ab78d537c81de4f7c55795c42d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeb0562ab78d537c81de4f7c55795c42d">getBackwardSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *backwardSlice, <a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a> filter=nullptr, bool inclusive=false)</td></tr>
<tr class="memdesc:aeb0562ab78d537c81de4f7c55795c42d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills <code>backwardSlice</code> with the computed backward slice (i.e.  <a href="namespacemlir.html#aeb0562ab78d537c81de4f7c55795c42d">More...</a><br /></td></tr>
<tr class="separator:aeb0562ab78d537c81de4f7c55795c42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e9895417040ce49f83fc36f100ee72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a65e9895417040ce49f83fc36f100ee72">getBackwardSlice</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> root, <a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *backwardSlice, <a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a> filter=nullptr, bool inclusive=false)</td></tr>
<tr class="memdesc:a65e9895417040ce49f83fc36f100ee72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value-rooted version of <code>getBackwardSlice</code>.  <a href="namespacemlir.html#a65e9895417040ce49f83fc36f100ee72">More...</a><br /></td></tr>
<tr class="separator:a65e9895417040ce49f83fc36f100ee72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8315b4bdb757698beea82cf7535dae7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8315b4bdb757698beea82cf7535dae7d">getSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a> backwardFilter=nullptr, <a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a> forwardFilter=nullptr, bool inclusive=false)</td></tr>
<tr class="memdesc:a8315b4bdb757698beea82cf7535dae7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratively computes backward slices and forward slices until a fixed point is reached.  <a href="namespacemlir.html#a8315b4bdb757698beea82cf7535dae7d">More...</a><br /></td></tr>
<tr class="separator:a8315b4bdb757698beea82cf7535dae7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb30909b4006046e7b4248b8d5a5a26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afbb30909b4006046e7b4248b8d5a5a26">topologicalSort</a> (const <a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;toSort)</td></tr>
<tr class="memdesc:afbb30909b4006046e7b4248b8d5a5a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-root DAG topological sort.  <a href="namespacemlir.html#afbb30909b4006046e7b4248b8d5a5a26">More...</a><br /></td></tr>
<tr class="separator:afbb30909b4006046e7b4248b8d5a5a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc751bc8f30d71ad4cb771c0fcc788b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6bc751bc8f30d71ad4cb771c0fcc788b">matchReduction</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt; iterCarriedArgs, unsigned redPos, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;combinerOps)</td></tr>
<tr class="memdesc:a6bc751bc8f30d71ad4cb771c0fcc788b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to match a generic reduction given a list of iteration-carried arguments, <code>iterCarriedArgs</code> and the position of the potential reduction argument within the list, <code>redPos</code>.  <a href="namespacemlir.html#a6bc751bc8f30d71ad4cb771c0fcc788b">More...</a><br /></td></tr>
<tr class="separator:a6bc751bc8f30d71ad4cb771c0fcc788b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce4d766139754b57d04b314aefacea5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2ce4d766139754b57d04b314aefacea5">parseAsmSourceFile</a> (const llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config, <a class="el" href="classmlir_1_1AsmParserState.html">AsmParserState</a> *asmState=nullptr, <a class="el" href="classmlir_1_1AsmParserCodeCompleteContext.html">AsmParserCodeCompleteContext</a> *codeCompleteContext=nullptr)</td></tr>
<tr class="memdesc:a2ce4d766139754b57d04b314aefacea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated SourceMgr and appends parsed operations to the given block.  <a href="namespacemlir.html#a2ce4d766139754b57d04b314aefacea5">More...</a><br /></td></tr>
<tr class="separator:a2ce4d766139754b57d04b314aefacea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6658f887276425945e0ebe6fcc194c23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6658f887276425945e0ebe6fcc194c23">parseAttribute</a> (llvm::StringRef attrStr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1Type.html">Type</a> type={}, size_t *numRead=nullptr, bool isKnownNullTerminated=false)</td></tr>
<tr class="memdesc:a6658f887276425945e0ebe6fcc194c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single MLIR attribute to an MLIR context if it was valid.  <a href="namespacemlir.html#a6658f887276425945e0ebe6fcc194c23">More...</a><br /></td></tr>
<tr class="separator:a6658f887276425945e0ebe6fcc194c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab8375de28e1d1916659a658e7ad318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abab8375de28e1d1916659a658e7ad318">parseType</a> (llvm::StringRef typeStr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, size_t *numRead=nullptr, bool isKnownNullTerminated=false)</td></tr>
<tr class="memdesc:abab8375de28e1d1916659a658e7ad318"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single MLIR type to an MLIR context if it was valid.  <a href="namespacemlir.html#abab8375de28e1d1916659a658e7ad318">More...</a><br /></td></tr>
<tr class="separator:abab8375de28e1d1916659a658e7ad318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351183b9c1036310349dea952c1f2d5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a351183b9c1036310349dea952c1f2d5a">parseAffineMap</a> (llvm::StringRef str, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a351183b9c1036310349dea952c1f2d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single IntegerSet/AffineMap to an MLIR context if it was valid.  <a href="namespacemlir.html#a351183b9c1036310349dea952c1f2d5a">More...</a><br /></td></tr>
<tr class="separator:a351183b9c1036310349dea952c1f2d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda383f3d69ddb866ea67abc7ba9e75e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acda383f3d69ddb866ea67abc7ba9e75e">parseIntegerSet</a> (llvm::StringRef str, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="separator:acda383f3d69ddb866ea67abc7ba9e75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef4c7804d8356c0813ce04f87b2b1ff"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a2ef4c7804d8356c0813ce04f87b2b1ff"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2ef4c7804d8356c0813ce04f87b2b1ff">readResourceHandle</a> (<a class="el" href="classmlir_1_1DialectBytecodeReader.html">DialectBytecodeReader</a> &amp;reader, <a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; T &gt; &amp;value, Ts &amp;&amp;...params)</td></tr>
<tr class="memdesc:a2ef4c7804d8356c0813ce04f87b2b1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for resource handle reading that returns <a class="el" href="structmlir_1_1LogicalResult.html" title="This class represents an efficient way to signal success or failure.">LogicalResult</a>.  <a href="namespacemlir.html#a2ef4c7804d8356c0813ce04f87b2b1ff">More...</a><br /></td></tr>
<tr class="separator:a2ef4c7804d8356c0813ce04f87b2b1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4871db68c59a176135e0e35a3625e73"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:ab4871db68c59a176135e0e35a3625e73"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab4871db68c59a176135e0e35a3625e73">get</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, Ts &amp;&amp;...params)</td></tr>
<tr class="memdesc:ab4871db68c59a176135e0e35a3625e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method that injects context only if needed, this helps unify some of the attribute construction methods.  <a href="namespacemlir.html#ab4871db68c59a176135e0e35a3625e73">More...</a><br /></td></tr>
<tr class="separator:ab4871db68c59a176135e0e35a3625e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336eaa1f1417cbe1468e56b34ce866a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a336eaa1f1417cbe1468e56b34ce866a1">isBytecode</a> (llvm::MemoryBufferRef buffer)</td></tr>
<tr class="memdesc:a336eaa1f1417cbe1468e56b34ce866a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given buffer starts with the magic bytes that signal MLIR bytecode.  <a href="namespacemlir.html#a336eaa1f1417cbe1468e56b34ce866a1">More...</a><br /></td></tr>
<tr class="separator:a336eaa1f1417cbe1468e56b34ce866a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b71d67f0d7fe035e455a121e826f08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad3b71d67f0d7fe035e455a121e826f08">readBytecodeFile</a> (llvm::MemoryBufferRef buffer, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config)</td></tr>
<tr class="memdesc:ad3b71d67f0d7fe035e455a121e826f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the operations defined within the given memory buffer, containing MLIR bytecode, into the provided block.  <a href="namespacemlir.html#ad3b71d67f0d7fe035e455a121e826f08">More...</a><br /></td></tr>
<tr class="separator:ad3b71d67f0d7fe035e455a121e826f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98f1102c5f82e37f4e4cf21be1736f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af98f1102c5f82e37f4e4cf21be1736f8">readBytecodeFile</a> (const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config)</td></tr>
<tr class="memdesc:af98f1102c5f82e37f4e4cf21be1736f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload with a source manager whose main file buffer is used for parsing.  <a href="namespacemlir.html#af98f1102c5f82e37f4e4cf21be1736f8">More...</a><br /></td></tr>
<tr class="separator:af98f1102c5f82e37f4e4cf21be1736f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17b909cf0c32c717226432e6a65f61e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae17b909cf0c32c717226432e6a65f61e">writeBytecodeToFile</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, raw_ostream &amp;os, const <a class="el" href="classmlir_1_1BytecodeWriterConfig.html">BytecodeWriterConfig</a> &amp;config={})</td></tr>
<tr class="memdesc:ae17b909cf0c32c717226432e6a65f61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the bytecode for the given operation to the provided output stream.  <a href="namespacemlir.html#ae17b909cf0c32c717226432e6a65f61e">More...</a><br /></td></tr>
<tr class="separator:ae17b909cf0c32c717226432e6a65f61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7856a3b7ff811204524bbc9959c8c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aee7856a3b7ff811204524bbc9959c8c9">populateAffineToStdConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aee7856a3b7ff811204524bbc9959c8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the Affine dialect to the Standard dialect, in particular convert structured affine control flow into CFG branch-based control flow.  <a href="namespacemlir.html#aee7856a3b7ff811204524bbc9959c8c9">More...</a><br /></td></tr>
<tr class="separator:aee7856a3b7ff811204524bbc9959c8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a984b6da6b0bf690f727bd2e20dd31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad6a984b6da6b0bf690f727bd2e20dd31">populateAffineToVectorConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ad6a984b6da6b0bf690f727bd2e20dd31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert vector-related Affine ops to the <a class="el" href="structVector.html">Vector</a> dialect.  <a href="namespacemlir.html#ad6a984b6da6b0bf690f727bd2e20dd31">More...</a><br /></td></tr>
<tr class="separator:ad6a984b6da6b0bf690f727bd2e20dd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4cd463c8738400fd147e2f040e89948"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af4cd463c8738400fd147e2f040e89948">lowerAffineLowerBound</a> (affine::AffineForOp op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:af4cd463c8738400fd147e2f040e89948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that computes the lower bound of the given affine loop using standard arithmetic operations.  <a href="namespacemlir.html#af4cd463c8738400fd147e2f040e89948">More...</a><br /></td></tr>
<tr class="separator:af4cd463c8738400fd147e2f040e89948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b670d3c5d9075cd52ef9d183168708"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a59b670d3c5d9075cd52ef9d183168708">lowerAffineUpperBound</a> (affine::AffineForOp op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:a59b670d3c5d9075cd52ef9d183168708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that computes the upper bound of the given affine loop using standard arithmetic operations.  <a href="namespacemlir.html#a59b670d3c5d9075cd52ef9d183168708">More...</a><br /></td></tr>
<tr class="separator:a59b670d3c5d9075cd52ef9d183168708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09ce34232ab009ce688d7cdc63695a8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae09ce34232ab009ce688d7cdc63695a8">createLowerAffinePass</a> ()</td></tr>
<tr class="memdesc:ae09ce34232ab009ce688d7cdc63695a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowers affine control flow operations (ForStmt, IfStmt and AffineApplyOp) to equivalent lower-level constructs (flow of basic blocks and arithmetic primitives).  <a href="namespacemlir.html#ae09ce34232ab009ce688d7cdc63695a8">More...</a><br /></td></tr>
<tr class="separator:ae09ce34232ab009ce688d7cdc63695a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dca6cbddde02ebb60f3f7d61835e63a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9dca6cbddde02ebb60f3f7d61835e63a">populateAMDGPUToROCDLConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="structmlir_1_1amdgpu_1_1Chipset.html">amdgpu::Chipset</a> chipset)</td></tr>
<tr class="separator:a9dca6cbddde02ebb60f3f7d61835e63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1b32f0e812af513c57185c972dc0ae"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4e1b32f0e812af513c57185c972dc0ae">createConvertAMDGPUToROCDLPass</a> ()</td></tr>
<tr class="separator:a4e1b32f0e812af513c57185c972dc0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f6113274b77800e7c3b22dd83771e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a45f6113274b77800e7c3b22dd83771e0">populateConvertArmNeon2dToIntrPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a45f6113274b77800e7c3b22dd83771e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns for the lowering of Arm NEON 2D ops to intrinsics.  <a href="namespacemlir.html#a45f6113274b77800e7c3b22dd83771e0">More...</a><br /></td></tr>
<tr class="separator:a45f6113274b77800e7c3b22dd83771e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4655b459042808cdaf22b54faf67aaf6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4655b459042808cdaf22b54faf67aaf6">createConvertArmNeon2dToIntrPass</a> ()</td></tr>
<tr class="memdesc:a4655b459042808cdaf22b54faf67aaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to lower Arm NEON 2D ops to intrinsics, i.e.  <a href="namespacemlir.html#a4655b459042808cdaf22b54faf67aaf6">More...</a><br /></td></tr>
<tr class="separator:a4655b459042808cdaf22b54faf67aaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9659670212051d0795efd99cf38772ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9659670212051d0795efd99cf38772ed">populateAsyncStructuralTypeConversionsAndLegality</a> (<a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a9659670212051d0795efd99cf38772ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns for async structural type conversions.  <a href="namespacemlir.html#a9659670212051d0795efd99cf38772ed">More...</a><br /></td></tr>
<tr class="separator:a9659670212051d0795efd99cf38772ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbd8691a3dda5dad95817bf02cdd3cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acfbd8691a3dda5dad95817bf02cdd3cd">populateBufferizationToMemRefConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:acfbd8691a3dda5dad95817bf02cdd3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert memory-related operations from the Bufferization dialect to the MemRef dialect.  <a href="namespacemlir.html#acfbd8691a3dda5dad95817bf02cdd3cd">More...</a><br /></td></tr>
<tr class="separator:acfbd8691a3dda5dad95817bf02cdd3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01b05ed73bc512e7ae40bc6d37ae1a0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae01b05ed73bc512e7ae40bc6d37ae1a0">createBufferizationToMemRefPass</a> ()</td></tr>
<tr class="separator:ae01b05ed73bc512e7ae40bc6d37ae1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af655a0b587c08462a963b23b6c656ca5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af655a0b587c08462a963b23b6c656ca5">populateComplexToLibmConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit)</td></tr>
<tr class="memdesc:af655a0b587c08462a963b23b6c656ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Complex to Libm calls.  <a href="namespacemlir.html#af655a0b587c08462a963b23b6c656ca5">More...</a><br /></td></tr>
<tr class="separator:af655a0b587c08462a963b23b6c656ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3204f9ba36eb541a03f8bf0ed4a9a7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1c3204f9ba36eb541a03f8bf0ed4a9a7">createConvertComplexToLibmPass</a> ()</td></tr>
<tr class="memdesc:a1c3204f9ba36eb541a03f8bf0ed4a9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Complex operations to libm calls.  <a href="namespacemlir.html#a1c3204f9ba36eb541a03f8bf0ed4a9a7">More...</a><br /></td></tr>
<tr class="separator:a1c3204f9ba36eb541a03f8bf0ed4a9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75bf16b29d948811335c75976eb7b876"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a75bf16b29d948811335c75976eb7b876">populateComplexToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a75bf16b29d948811335c75976eb7b876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Complex to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="namespacemlir.html#a75bf16b29d948811335c75976eb7b876">More...</a><br /></td></tr>
<tr class="separator:a75bf16b29d948811335c75976eb7b876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85f17cc052c1e0019cecc9053c5afb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af85f17cc052c1e0019cecc9053c5afb6">populateComplexToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:af85f17cc052c1e0019cecc9053c5afb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating Complex ops to SPIR-V ops.  <a href="namespacemlir.html#af85f17cc052c1e0019cecc9053c5afb6">More...</a><br /></td></tr>
<tr class="separator:af85f17cc052c1e0019cecc9053c5afb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09be0ab6e12c19fefea09a6cb423c54d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a09be0ab6e12c19fefea09a6cb423c54d">populateComplexToStandardConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a09be0ab6e12c19fefea09a6cb423c54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Complex to Standard.  <a href="namespacemlir.html#a09be0ab6e12c19fefea09a6cb423c54d">More...</a><br /></td></tr>
<tr class="separator:a09be0ab6e12c19fefea09a6cb423c54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad891730d98fe42a400b188049ff923f2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad891730d98fe42a400b188049ff923f2">createConvertComplexToStandardPass</a> ()</td></tr>
<tr class="memdesc:ad891730d98fe42a400b188049ff923f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Complex operations to the Standard dialect.  <a href="namespacemlir.html#ad891730d98fe42a400b188049ff923f2">More...</a><br /></td></tr>
<tr class="separator:ad891730d98fe42a400b188049ff923f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0b6795b3be074dc19b6445f2cc687a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3d0b6795b3be074dc19b6445f2cc687a">createConvertControlFlowToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a3d0b6795b3be074dc19b6445f2cc687a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert ControlFlow ops to SPIR-V ops.  <a href="namespacemlir.html#a3d0b6795b3be074dc19b6445f2cc687a">More...</a><br /></td></tr>
<tr class="separator:a3d0b6795b3be074dc19b6445f2cc687a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa6b16e02f4faa0e2d43ac82fca0185"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aefa6b16e02f4faa0e2d43ac82fca0185">populateFuncToLLVMFuncOpConversionPattern</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aefa6b16e02f4faa0e2d43ac82fca0185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the default pattern to convert a FuncOp to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <a href="namespacemlir.html#aefa6b16e02f4faa0e2d43ac82fca0185">More...</a><br /></td></tr>
<tr class="separator:aefa6b16e02f4faa0e2d43ac82fca0185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6caa6cc89d0b3c43a871101ba9fe6216"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6caa6cc89d0b3c43a871101ba9fe6216">populateFuncToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a6caa6cc89d0b3c43a871101ba9fe6216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the patterns to convert from the Func dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="namespacemlir.html#a6caa6cc89d0b3c43a871101ba9fe6216">More...</a><br /></td></tr>
<tr class="separator:a6caa6cc89d0b3c43a871101ba9fe6216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9ec4369b7b5946147ad4545d22d6c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6b9ec4369b7b5946147ad4545d22d6c6">populateFuncToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a6b9ec4369b7b5946147ad4545d22d6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating Func ops to SPIR-V ops.  <a href="namespacemlir.html#a6b9ec4369b7b5946147ad4545d22d6c6">More...</a><br /></td></tr>
<tr class="separator:a6b9ec4369b7b5946147ad4545d22d6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1face754eadd25641ccf594efd52ba7b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1face754eadd25641ccf594efd52ba7b">createConvertFuncToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a1face754eadd25641ccf594efd52ba7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert Func ops to SPIR-V ops.  <a href="namespacemlir.html#a1face754eadd25641ccf594efd52ba7b">More...</a><br /></td></tr>
<tr class="separator:a1face754eadd25641ccf594efd52ba7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a18674fd61de5e49caca18b463db1b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6a18674fd61de5e49caca18b463db1b7">populateGpuToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, StringRef gpuBinaryAnnotation={}, bool kernelBarePtrCallConv=false)</td></tr>
<tr class="memdesc:a6a18674fd61de5e49caca18b463db1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> and populate converter for gpu types.  <a href="namespacemlir.html#a6a18674fd61de5e49caca18b463db1b7">More...</a><br /></td></tr>
<tr class="separator:a6a18674fd61de5e49caca18b463db1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23560b6de94f046854c32398b275f8b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVM::LLVMStructType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a23560b6de94f046854c32398b275f8b6">convertMMAToLLVMType</a> (<a class="el" href="classmlir_1_1gpu_1_1MMAMatrixType.html">gpu::MMAMatrixType</a> type)</td></tr>
<tr class="memdesc:a23560b6de94f046854c32398b275f8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the LLVMStructureType corresponding to the MMAMatrixType <code>type</code>.  <a href="namespacemlir.html#a23560b6de94f046854c32398b275f8b6">More...</a><br /></td></tr>
<tr class="separator:a23560b6de94f046854c32398b275f8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa896c9229c786edc4a7970b960b208"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7fa896c9229c786edc4a7970b960b208">configureGpuToNVVMConversionLegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a7fa896c9229c786edc4a7970b960b208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure target to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>.  <a href="namespacemlir.html#a7fa896c9229c786edc4a7970b960b208">More...</a><br /></td></tr>
<tr class="separator:a7fa896c9229c786edc4a7970b960b208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cfe15e8fb355926517f8b4dc0d0c0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac0cfe15e8fb355926517f8b4dc0d0c0a">populateGpuToNVVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ac0cfe15e8fb355926517f8b4dc0d0c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>.  <a href="namespacemlir.html#ac0cfe15e8fb355926517f8b4dc0d0c0a">More...</a><br /></td></tr>
<tr class="separator:ac0cfe15e8fb355926517f8b4dc0d0c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f6887e784993598ab77e0fb8f7e7bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac7f6887e784993598ab77e0fb8f7e7bf">populateGpuSubgroupReduceOpLoweringPattern</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ac7f6887e784993598ab77e0fb8f7e7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate GpuSubgroupReduce pattern to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>.  <a href="namespacemlir.html#ac7f6887e784993598ab77e0fb8f7e7bf">More...</a><br /></td></tr>
<tr class="separator:ac7f6887e784993598ab77e0fb8f7e7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea1280606a190334088962debe41bf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abea1280606a190334088962debe41bf0">populateGpuWMMAToNVVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:abea1280606a190334088962debe41bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert WMMA ops from GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>.  <a href="namespacemlir.html#abea1280606a190334088962debe41bf0">More...</a><br /></td></tr>
<tr class="separator:abea1280606a190334088962debe41bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4e20598665a8f48288a9f03ddc8772"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; gpu::GPUModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abf4e20598665a8f48288a9f03ddc8772">createLowerGpuOpsToNVVMOpsPass</a> (unsigned indexBitwidth=<a class="el" href="namespacemlir.html#a2887883f00b094c5ca61c631d7b093a0">kDeriveIndexBitwidthFromDataLayout</a>, bool hasRedux=false)</td></tr>
<tr class="memdesc:abf4e20598665a8f48288a9f03ddc8772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that lowers GPU dialect operations to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> counterparts.  <a href="namespacemlir.html#abf4e20598665a8f48288a9f03ddc8772">More...</a><br /></td></tr>
<tr class="separator:abf4e20598665a8f48288a9f03ddc8772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6de97155f64d87208f5ce9e4041885a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac6de97155f64d87208f5ce9e4041885a">populateGpuToROCDLConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="namespacemlir_1_1gpu_1_1amd.html#a8637afbd01b984be30dbd1cdb78ae45f">gpu::amd::Runtime</a> runtime)</td></tr>
<tr class="memdesc:ac6de97155f64d87208f5ce9e4041885a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the GPU dialect to ROCDL.  <a href="namespacemlir.html#ac6de97155f64d87208f5ce9e4041885a">More...</a><br /></td></tr>
<tr class="separator:ac6de97155f64d87208f5ce9e4041885a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c490624b02da7c5cb78aa071e0aa2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a65c490624b02da7c5cb78aa071e0aa2a">configureGpuToROCDLConversionLegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a65c490624b02da7c5cb78aa071e0aa2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure target to convert from the GPU dialect to ROCDL.  <a href="namespacemlir.html#a65c490624b02da7c5cb78aa071e0aa2a">More...</a><br /></td></tr>
<tr class="separator:a65c490624b02da7c5cb78aa071e0aa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb6ab100d4d15861d7ed00e702ff0ed"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; gpu::GPUModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6cb6ab100d4d15861d7ed00e702ff0ed">createLowerGpuOpsToROCDLOpsPass</a> (const std::string &amp;chipset=&quot;gfx900&quot;, unsigned indexBitwidth=<a class="el" href="namespacemlir.html#a2887883f00b094c5ca61c631d7b093a0">kDeriveIndexBitwidthFromDataLayout</a>, bool useBarePtrCallConv=false, <a class="el" href="namespacemlir_1_1gpu_1_1amd.html#a8637afbd01b984be30dbd1cdb78ae45f">gpu::amd::Runtime</a> runtime=gpu::amd::Runtime::Unknown)</td></tr>
<tr class="memdesc:a6cb6ab100d4d15861d7ed00e702ff0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that lowers GPU dialect operations to ROCDL counterparts.  <a href="namespacemlir.html#a6cb6ab100d4d15861d7ed00e702ff0ed">More...</a><br /></td></tr>
<tr class="separator:a6cb6ab100d4d15861d7ed00e702ff0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822bcc3b680bed98c042cdabebc7f94a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a822bcc3b680bed98c042cdabebc7f94a">populateGPUToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a822bcc3b680bed98c042cdabebc7f94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating GPU Ops to SPIR-V ops.  <a href="namespacemlir.html#a822bcc3b680bed98c042cdabebc7f94a">More...</a><br /></td></tr>
<tr class="separator:a822bcc3b680bed98c042cdabebc7f94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b62af15c65e051633cba1f6022fb5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a66b62af15c65e051633cba1f6022fb5a">populateGpuWMMAToSPIRVConversionPatterns</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a66b62af15c65e051633cba1f6022fb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert WMMA ops from GPU dialect to SPIRV.  <a href="namespacemlir.html#a66b62af15c65e051633cba1f6022fb5a">More...</a><br /></td></tr>
<tr class="separator:a66b62af15c65e051633cba1f6022fb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa20dcaf31535f42f49b54af6cb7a890"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1spirv_1_1CooperativeMatrixNVType.html">spirv::CooperativeMatrixNVType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aaa20dcaf31535f42f49b54af6cb7a890">convertMMAToSPIRVType</a> (<a class="el" href="classmlir_1_1gpu_1_1MMAMatrixType.html">gpu::MMAMatrixType</a> type)</td></tr>
<tr class="memdesc:aaa20dcaf31535f42f49b54af6cb7a890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the LLVMStructureType corresponding to the MMAMatrixType <code>type</code>.  <a href="namespacemlir.html#aaa20dcaf31535f42f49b54af6cb7a890">More...</a><br /></td></tr>
<tr class="separator:aaa20dcaf31535f42f49b54af6cb7a890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112698688acfebc3284b59e6ffa4d155"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a112698688acfebc3284b59e6ffa4d155">createConvertGPUToSPIRVPass</a> (bool mapMemorySpace=true)</td></tr>
<tr class="memdesc:a112698688acfebc3284b59e6ffa4d155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert GPU kernel ops to corresponding SPIR-V ops.  <a href="namespacemlir.html#a112698688acfebc3284b59e6ffa4d155">More...</a><br /></td></tr>
<tr class="separator:a112698688acfebc3284b59e6ffa4d155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39c9d3321b2f5f4aee088b02b535f9b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; mlir::ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad39c9d3321b2f5f4aee088b02b535f9b">createConvertGpuLaunchFuncToVulkanLaunchFuncPass</a> ()</td></tr>
<tr class="separator:ad39c9d3321b2f5f4aee088b02b535f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1602ebfb960be063051996895d9eae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2f1602ebfb960be063051996895d9eae">populateLinalgToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a2f1602ebfb960be063051996895d9eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Linalg to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="namespacemlir.html#a2f1602ebfb960be063051996895d9eae">More...</a><br /></td></tr>
<tr class="separator:a2f1602ebfb960be063051996895d9eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb33f39a4ad0d4d52396f132bee84cf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aefb33f39a4ad0d4d52396f132bee84cf">createConvertLinalgToStandardPass</a> ()</td></tr>
<tr class="memdesc:aefb33f39a4ad0d4d52396f132bee84cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations to the Standard dialect.  <a href="namespacemlir.html#aefb33f39a4ad0d4d52396f132bee84cf">More...</a><br /></td></tr>
<tr class="separator:aefb33f39a4ad0d4d52396f132bee84cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f16fcf3a83d26d5a59da3bf0138ca24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6f16fcf3a83d26d5a59da3bf0138ca24">structFuncArgTypeConverter</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a6f16fcf3a83d26d5a59da3bf0138ca24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to convert function argument types.  <a href="namespacemlir.html#a6f16fcf3a83d26d5a59da3bf0138ca24">More...</a><br /></td></tr>
<tr class="separator:a6f16fcf3a83d26d5a59da3bf0138ca24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173d145c5b783b4fe092fc78fd6879ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a173d145c5b783b4fe092fc78fd6879ec">barePtrFuncArgTypeConverter</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a173d145c5b783b4fe092fc78fd6879ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to convert function argument types.  <a href="namespacemlir.html#a173d145c5b783b4fe092fc78fd6879ec">More...</a><br /></td></tr>
<tr class="separator:a173d145c5b783b4fe092fc78fd6879ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d02c131fc732f88a4f4bbd96470b159"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7d02c131fc732f88a4f4bbd96470b159">populateMathToLibmConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a7d02c131fc732f88a4f4bbd96470b159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Math to Libm calls.  <a href="namespacemlir.html#a7d02c131fc732f88a4f4bbd96470b159">More...</a><br /></td></tr>
<tr class="separator:a7d02c131fc732f88a4f4bbd96470b159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0be8ab8e597910498a4a64215faa2fb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa0be8ab8e597910498a4a64215faa2fb">createConvertMathToLibmPass</a> ()</td></tr>
<tr class="memdesc:aa0be8ab8e597910498a4a64215faa2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Math operations to libm calls.  <a href="namespacemlir.html#aa0be8ab8e597910498a4a64215faa2fb">More...</a><br /></td></tr>
<tr class="separator:aa0be8ab8e597910498a4a64215faa2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9136f1dde93f4d0f24d7aaeb6e91743"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae9136f1dde93f4d0f24d7aaeb6e91743">populateMathToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool approximateLog1p=true)</td></tr>
<tr class="separator:ae9136f1dde93f4d0f24d7aaeb6e91743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a0a3321fbef0b7dcd1fe6e0bfba227"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac7a0a3321fbef0b7dcd1fe6e0bfba227">populateMathToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ac7a0a3321fbef0b7dcd1fe6e0bfba227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating Math ops to SPIR-V ops.  <a href="namespacemlir.html#ac7a0a3321fbef0b7dcd1fe6e0bfba227">More...</a><br /></td></tr>
<tr class="separator:ac7a0a3321fbef0b7dcd1fe6e0bfba227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c8995bd3756d7b1e15813d96b2b2ad"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a10c8995bd3756d7b1e15813d96b2b2ad">createConvertMathToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a10c8995bd3756d7b1e15813d96b2b2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert Math ops to SPIR-V ops.  <a href="namespacemlir.html#a10c8995bd3756d7b1e15813d96b2b2ad">More...</a><br /></td></tr>
<tr class="separator:a10c8995bd3756d7b1e15813d96b2b2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d10b46e0e40ef1301b7492f47596ba4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5d10b46e0e40ef1301b7492f47596ba4">populateFinalizeMemRefToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a5d10b46e0e40ef1301b7492f47596ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert memory-related operations from the MemRef dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <a href="namespacemlir.html#a5d10b46e0e40ef1301b7492f47596ba4">More...</a><br /></td></tr>
<tr class="separator:a5d10b46e0e40ef1301b7492f47596ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c0c6dd7df034b1f340ca9a14c9a0a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a95c0c6dd7df034b1f340ca9a14c9a0a6">populateMemRefToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a95c0c6dd7df034b1f340ca9a14c9a0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating MemRef ops to SPIR-V ops.  <a href="namespacemlir.html#a95c0c6dd7df034b1f340ca9a14c9a0a6">More...</a><br /></td></tr>
<tr class="separator:a95c0c6dd7df034b1f340ca9a14c9a0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5b68602e237b1c1c3209ae71184cd2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0c5b68602e237b1c1c3209ae71184cd2">createMapMemRefStorageClassPass</a> ()</td></tr>
<tr class="memdesc:a0c5b68602e237b1c1c3209ae71184cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to map numeric MemRef memory spaces to symbolic SPIR-V storage classes.  <a href="namespacemlir.html#a0c5b68602e237b1c1c3209ae71184cd2">More...</a><br /></td></tr>
<tr class="separator:a0c5b68602e237b1c1c3209ae71184cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bec430062ec4285c83eccbab6ebbe29"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3bec430062ec4285c83eccbab6ebbe29">createConvertMemRefToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a3bec430062ec4285c83eccbab6ebbe29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert MemRef ops to SPIR-V ops.  <a href="namespacemlir.html#a3bec430062ec4285c83eccbab6ebbe29">More...</a><br /></td></tr>
<tr class="separator:a3bec430062ec4285c83eccbab6ebbe29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a68bf61fe2cf12c77f265e4851897c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6a68bf61fe2cf12c77f265e4851897c8">populateNVGPUToNVVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a6a68bf61fe2cf12c77f265e4851897c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075dcb844c996870c4c38bf277a4d175"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a075dcb844c996870c4c38bf277a4d175">populateOpenACCToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a075dcb844c996870c4c38bf277a4d175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the patterns to convert from the OpenACC dialect LLVMIR dialect.  <a href="namespacemlir.html#a075dcb844c996870c4c38bf277a4d175">More...</a><br /></td></tr>
<tr class="separator:a075dcb844c996870c4c38bf277a4d175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725b3caed685f9615fba2027124f359f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a725b3caed685f9615fba2027124f359f">populateOpenACCToSCFConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a725b3caed685f9615fba2027124f359f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the patterns to convert from the OpenACC dialect to OpenACC with SCF dialect.  <a href="namespacemlir.html#a725b3caed685f9615fba2027124f359f">More...</a><br /></td></tr>
<tr class="separator:a725b3caed685f9615fba2027124f359f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1dc4bc47a3830e063b709a36e0ab91"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3c1dc4bc47a3830e063b709a36e0ab91">createConvertOpenACCToSCFPass</a> ()</td></tr>
<tr class="memdesc:a3c1dc4bc47a3830e063b709a36e0ab91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert the OpenACC dialect into the LLVMIR dialect.  <a href="namespacemlir.html#a3c1dc4bc47a3830e063b709a36e0ab91">More...</a><br /></td></tr>
<tr class="separator:a3c1dc4bc47a3830e063b709a36e0ab91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732e2b51952bf0b2c474784272e790b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a732e2b51952bf0b2c474784272e790b4">configureOpenMPToLLVMConversionLegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:a732e2b51952bf0b2c474784272e790b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure dynamic conversion legality of regionless operations from OpenMP to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="namespacemlir.html#a732e2b51952bf0b2c474784272e790b4">More...</a><br /></td></tr>
<tr class="separator:a732e2b51952bf0b2c474784272e790b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1111bfc29c10d7cd2ebba33996e38509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1111bfc29c10d7cd2ebba33996e38509">populateOpenMPToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a1111bfc29c10d7cd2ebba33996e38509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from OpenMP to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="namespacemlir.html#a1111bfc29c10d7cd2ebba33996e38509">More...</a><br /></td></tr>
<tr class="separator:a1111bfc29c10d7cd2ebba33996e38509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af882e712b4e426905d73c1c74bd0f353"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af882e712b4e426905d73c1c74bd0f353">createPDLToPDLInterpPass</a> ()</td></tr>
<tr class="memdesc:af882e712b4e426905d73c1c74bd0f353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a pass to convert PDL ops to PDL interpreter ops.  <a href="namespacemlir.html#af882e712b4e426905d73c1c74bd0f353">More...</a><br /></td></tr>
<tr class="separator:af882e712b4e426905d73c1c74bd0f353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b51cc369e6be47cad63fe35c030ca3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae7b51cc369e6be47cad63fe35c030ca3">createPDLToPDLInterpPass</a> (<a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1PDLPatternConfigSet.html">PDLPatternConfigSet</a> * &gt; &amp;configMap)</td></tr>
<tr class="memdesc:ae7b51cc369e6be47cad63fe35c030ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a pass to convert PDL ops to PDL interpreter ops.  <a href="namespacemlir.html#ae7b51cc369e6be47cad63fe35c030ca3">More...</a><br /></td></tr>
<tr class="separator:ae7b51cc369e6be47cad63fe35c030ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab06609d5a7ea6d475070dcc8d271725"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aab06609d5a7ea6d475070dcc8d271725">createReconcileUnrealizedCastsPass</a> ()</td></tr>
<tr class="memdesc:aab06609d5a7ea6d475070dcc8d271725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that eliminates noop <code>unrealized_conversion_cast</code> operation sequences.  <a href="namespacemlir.html#aab06609d5a7ea6d475070dcc8d271725">More...</a><br /></td></tr>
<tr class="separator:aab06609d5a7ea6d475070dcc8d271725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c65dfcafc10b8117f172e7c150ac1ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7c65dfcafc10b8117f172e7c150ac1ad">populateReconcileUnrealizedCastsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a7c65dfcafc10b8117f172e7c150ac1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with rewrite patterns that eliminate noop <code>unrealized_conversion_cast</code> operation sequences.  <a href="namespacemlir.html#a7c65dfcafc10b8117f172e7c150ac1ad">More...</a><br /></td></tr>
<tr class="separator:a7c65dfcafc10b8117f172e7c150ac1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc663ae01ea2b6384c3f6ce299be3b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9fc663ae01ea2b6384c3f6ce299be3b0">populateSCFToControlFlowConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a9fc663ae01ea2b6384c3f6ce299be3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert SCF operations to CFG branch-based operations within the ControlFlow dialect.  <a href="namespacemlir.html#a9fc663ae01ea2b6384c3f6ce299be3b0">More...</a><br /></td></tr>
<tr class="separator:a9fc663ae01ea2b6384c3f6ce299be3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877c34cdb063f52ff5ea4efd82807621"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a877c34cdb063f52ff5ea4efd82807621">createConvertSCFToCFPass</a> ()</td></tr>
<tr class="memdesc:a877c34cdb063f52ff5ea4efd82807621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert SCF operations to CFG branch-based operation in the ControlFlow dialect.  <a href="namespacemlir.html#a877c34cdb063f52ff5ea4efd82807621">More...</a><br /></td></tr>
<tr class="separator:a877c34cdb063f52ff5ea4efd82807621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e36f1b7aaec9319e5ba11077079aa4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4e36f1b7aaec9319e5ba11077079aa4e">convertAffineLoopNestToGPULaunch</a> (affine::AffineForOp forOp, unsigned numBlockDims, unsigned numThreadDims)</td></tr>
<tr class="memdesc:a4e36f1b7aaec9319e5ba11077079aa4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a perfect affine loop nest with the outermost loop identified by <code>forOp</code> into a gpu::Launch operation.  <a href="namespacemlir.html#a4e36f1b7aaec9319e5ba11077079aa4e">More...</a><br /></td></tr>
<tr class="separator:a4e36f1b7aaec9319e5ba11077079aa4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1727b1783cbf671c6ee60cc2a5c2f132"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1727b1783cbf671c6ee60cc2a5c2f132">populateParallelLoopToGPUPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a1727b1783cbf671c6ee60cc2a5c2f132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the conversion pattern from <code>scf.parallel</code> to <code>gpu.launch</code> to the provided pattern list.  <a href="namespacemlir.html#a1727b1783cbf671c6ee60cc2a5c2f132">More...</a><br /></td></tr>
<tr class="separator:a1727b1783cbf671c6ee60cc2a5c2f132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01d59b73ef695a82338e96055101c16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af01d59b73ef695a82338e96055101c16">configureParallelLoopToGPULegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:af01d59b73ef695a82338e96055101c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the rewrite target such that only <code>scf.parallel</code> operations that are not rewritten by the provided patterns are legal.  <a href="namespacemlir.html#af01d59b73ef695a82338e96055101c16">More...</a><br /></td></tr>
<tr class="separator:af01d59b73ef695a82338e96055101c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b8cb2bfcf870fb9909b4805c0aad13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a04b8cb2bfcf870fb9909b4805c0aad13">finalizeParallelLoopToGPUConversion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a04b8cb2bfcf870fb9909b4805c0aad13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after applyPartialConversion/applyFullConversion call.  <a href="namespacemlir.html#a04b8cb2bfcf870fb9909b4805c0aad13">More...</a><br /></td></tr>
<tr class="separator:a04b8cb2bfcf870fb9909b4805c0aad13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec40c7aecb333928b9b4e9e409f0670"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a>&lt; FunctionOpInterface &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0ec40c7aecb333928b9b4e9e409f0670">createAffineForToGPUPass</a> (unsigned numBlockDims, unsigned numThreadDims)</td></tr>
<tr class="memdesc:a0ec40c7aecb333928b9b4e9e409f0670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that converts loop nests into GPU kernels.  <a href="namespacemlir.html#a0ec40c7aecb333928b9b4e9e409f0670">More...</a><br /></td></tr>
<tr class="separator:a0ec40c7aecb333928b9b4e9e409f0670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec305cc3472323a62580de136ce81cc3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a>&lt; FunctionOpInterface &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aec305cc3472323a62580de136ce81cc3">createAffineForToGPUPass</a> ()</td></tr>
<tr class="separator:aec305cc3472323a62580de136ce81cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f36107d7ffc6c1f873c746385d9de0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa2f36107d7ffc6c1f873c746385d9de0">createParallelLoopToGpuPass</a> ()</td></tr>
<tr class="memdesc:aa2f36107d7ffc6c1f873c746385d9de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that converts scf.parallel operations into a gpu.launch operation.  <a href="namespacemlir.html#aa2f36107d7ffc6c1f873c746385d9de0">More...</a><br /></td></tr>
<tr class="separator:aa2f36107d7ffc6c1f873c746385d9de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3094753f32222ddd712d5b2321c38eea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3094753f32222ddd712d5b2321c38eea">populateSCFToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="structmlir_1_1ScfToSPIRVContext.html">ScfToSPIRVContext</a> &amp;scfToSPIRVContext, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a3094753f32222ddd712d5b2321c38eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects a set of patterns to lower from scf.for, scf.if, and loop.terminator to CFG operations within the SPIR-V dialect.  <a href="namespacemlir.html#a3094753f32222ddd712d5b2321c38eea">More...</a><br /></td></tr>
<tr class="separator:a3094753f32222ddd712d5b2321c38eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c87a4d7e914dda62d03a97cf7e8963"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a74c87a4d7e914dda62d03a97cf7e8963">createConvertSCFToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a74c87a4d7e914dda62d03a97cf7e8963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert SCF ops into SPIR-V ops.  <a href="namespacemlir.html#a74c87a4d7e914dda62d03a97cf7e8963">More...</a><br /></td></tr>
<tr class="separator:a74c87a4d7e914dda62d03a97cf7e8963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d32c331310df6a35924ac128fa789f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9d32c331310df6a35924ac128fa789f3">populateShapeToStandardConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a9d32c331310df6a35924ac128fa789f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9ecc9afba558cb026032d0453a7c95"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abc9ecc9afba558cb026032d0453a7c95">createConvertShapeToStandardPass</a> ()</td></tr>
<tr class="separator:abc9ecc9afba558cb026032d0453a7c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e66615eb7e50976ed8c89b2bb05adc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae6e66615eb7e50976ed8c89b2bb05adc">populateConvertShapeConstraintsConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:ae6e66615eb7e50976ed8c89b2bb05adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85b8b89468b7fc2b347d361b512e8d3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac85b8b89468b7fc2b347d361b512e8d3">createConvertShapeConstraintsPass</a> ()</td></tr>
<tr class="separator:ac85b8b89468b7fc2b347d361b512e8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8075944125730fed529e3b93dcfed5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab8075944125730fed529e3b93dcfed5b">encodeBindAttribute</a> (ModuleOp module)</td></tr>
<tr class="memdesc:ab8075944125730fed529e3b93dcfed5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes global variable's descriptor set and binding into its name if they both exist.  <a href="namespacemlir.html#ab8075944125730fed529e3b93dcfed5b">More...</a><br /></td></tr>
<tr class="separator:ab8075944125730fed529e3b93dcfed5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae66c52897a19a19fdec8d7022372b7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aae66c52897a19a19fdec8d7022372b7d">populateSPIRVToLLVMTypeConversion</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:aae66c52897a19a19fdec8d7022372b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates type conversions with additional SPIR-V types.  <a href="namespacemlir.html#aae66c52897a19a19fdec8d7022372b7d">More...</a><br /></td></tr>
<tr class="separator:aae66c52897a19a19fdec8d7022372b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7de728c22748c6b736dd346296b69f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeb7de728c22748c6b736dd346296b69f">populateSPIRVToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aeb7de728c22748c6b736dd346296b69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the given list with patterns that convert from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="namespacemlir.html#aeb7de728c22748c6b736dd346296b69f">More...</a><br /></td></tr>
<tr class="separator:aeb7de728c22748c6b736dd346296b69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eaf01d677b8c5bc75e77f5093d9ca8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1eaf01d677b8c5bc75e77f5093d9ca8f">populateSPIRVToLLVMFunctionConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a1eaf01d677b8c5bc75e77f5093d9ca8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the given list with patterns for function conversion from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="namespacemlir.html#a1eaf01d677b8c5bc75e77f5093d9ca8f">More...</a><br /></td></tr>
<tr class="separator:a1eaf01d677b8c5bc75e77f5093d9ca8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a0a0e3398946973ed32c1fb07d8936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa1a0a0e3398946973ed32c1fb07d8936">populateSPIRVToLLVMModuleConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aa1a0a0e3398946973ed32c1fb07d8936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the given patterns for module conversion from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="namespacemlir.html#aa1a0a0e3398946973ed32c1fb07d8936">More...</a><br /></td></tr>
<tr class="separator:aa1a0a0e3398946973ed32c1fb07d8936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8ecf548ab4c5b21eddf5ee62e618e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5b8ecf548ab4c5b21eddf5ee62e618e8">populateTensorToLinalgPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a5b8ecf548ab4c5b21eddf5ee62e618e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating tensor ops to Linalg ops.  <a href="namespacemlir.html#a5b8ecf548ab4c5b21eddf5ee62e618e8">More...</a><br /></td></tr>
<tr class="separator:a5b8ecf548ab4c5b21eddf5ee62e618e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff30b5a742e19dd8d8fea41d953fbe4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2ff30b5a742e19dd8d8fea41d953fbe4">createConvertTensorToLinalgPass</a> ()</td></tr>
<tr class="memdesc:a2ff30b5a742e19dd8d8fea41d953fbe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert Tensor ops to Linalg ops.  <a href="namespacemlir.html#a2ff30b5a742e19dd8d8fea41d953fbe4">More...</a><br /></td></tr>
<tr class="separator:a2ff30b5a742e19dd8d8fea41d953fbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf6b62cc455701b989bc81364a091f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abaf6b62cc455701b989bc81364a091f7">populateTensorToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, int64_t byteCountThreshold, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:abaf6b62cc455701b989bc81364a091f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating tensor ops to SPIR-V ops.  <a href="namespacemlir.html#abaf6b62cc455701b989bc81364a091f7">More...</a><br /></td></tr>
<tr class="separator:abaf6b62cc455701b989bc81364a091f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d3655f76a6db563fa528a741573691"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a81d3655f76a6db563fa528a741573691">createConvertTensorToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a81d3655f76a6db563fa528a741573691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert Tensor ops to SPIR-V ops.  <a href="namespacemlir.html#a81d3655f76a6db563fa528a741573691">More...</a><br /></td></tr>
<tr class="separator:a81d3655f76a6db563fa528a741573691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10daa5ecf515d29ea9079368f9b9b08d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a10daa5ecf515d29ea9079368f9b9b08d">populatePrepareVectorToMMAPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool useNvGpu=false)</td></tr>
<tr class="memdesc:a10daa5ecf515d29ea9079368f9b9b08d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to transform vector ops into a canonical form to convert to MMA matrix operations.  <a href="namespacemlir.html#a10daa5ecf515d29ea9079368f9b9b08d">More...</a><br /></td></tr>
<tr class="separator:a10daa5ecf515d29ea9079368f9b9b08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d71d5f26ac7f264365e6fb7a6aadff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af7d71d5f26ac7f264365e6fb7a6aadff">convertVectorToMMAOps</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *rootOp)</td></tr>
<tr class="memdesc:af7d71d5f26ac7f264365e6fb7a6aadff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert vector ops to MMA matrix operations nested under <code>rootOp</code>.  <a href="namespacemlir.html#af7d71d5f26ac7f264365e6fb7a6aadff">More...</a><br /></td></tr>
<tr class="separator:af7d71d5f26ac7f264365e6fb7a6aadff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d66f364335bd7ca0a98bb53f82f0a77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8d66f364335bd7ca0a98bb53f82f0a77">convertVectorToNVVMCompatibleMMASync</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *rootOp)</td></tr>
<tr class="memdesc:a8d66f364335bd7ca0a98bb53f82f0a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert vector ops ops nested under <code>rootOp</code> to vector and GPU operaitons compatible with the <code>nvvm.mma.sync</code> lowering path.  <a href="namespacemlir.html#a8d66f364335bd7ca0a98bb53f82f0a77">More...</a><br /></td></tr>
<tr class="separator:a8d66f364335bd7ca0a98bb53f82f0a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e64d4460362ea3cdb2edc8b746396c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad3e64d4460362ea3cdb2edc8b746396c">createConvertVectorToGPUPass</a> (bool useNvGpu=false)</td></tr>
<tr class="memdesc:ad3e64d4460362ea3cdb2edc8b746396c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from vector to GPU ops.  <a href="namespacemlir.html#ad3e64d4460362ea3cdb2edc8b746396c">More...</a><br /></td></tr>
<tr class="separator:ad3e64d4460362ea3cdb2edc8b746396c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cce579ffaa7f6e5b4da65897ae4e41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a75cce579ffaa7f6e5b4da65897ae4e41">populateVectorToLLVMMatrixConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a75cce579ffaa7f6e5b4da65897ae4e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from <a class="el" href="structVector.html">Vector</a> contractions to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> Matrix Intrinsics.  <a href="namespacemlir.html#a75cce579ffaa7f6e5b4da65897ae4e41">More...</a><br /></td></tr>
<tr class="separator:a75cce579ffaa7f6e5b4da65897ae4e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a70c08f12898f5942f022ea27ba371"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a75a70c08f12898f5942f022ea27ba371">populateVectorToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool reassociateFPReductions=false, bool force32BitVectorIndices=false)</td></tr>
<tr class="memdesc:a75a70c08f12898f5942f022ea27ba371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="namespacemlir.html#a75a70c08f12898f5942f022ea27ba371">More...</a><br /></td></tr>
<tr class="separator:a75a70c08f12898f5942f022ea27ba371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c6c9c53e199da9b2def6f5e62eec02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a96c6c9c53e199da9b2def6f5e62eec02">populateVectorToSCFConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>=<a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>())</td></tr>
<tr class="memdesc:a96c6c9c53e199da9b2def6f5e62eec02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to SCF + func.  <a href="namespacemlir.html#a96c6c9c53e199da9b2def6f5e62eec02">More...</a><br /></td></tr>
<tr class="separator:a96c6c9c53e199da9b2def6f5e62eec02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c71e471d7d8cdda288a27d1ae75642"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac5c71e471d7d8cdda288a27d1ae75642">createConvertVectorToSCFPass</a> (const <a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>=<a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>())</td></tr>
<tr class="memdesc:ac5c71e471d7d8cdda288a27d1ae75642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert a subset of vector ops to SCF.  <a href="namespacemlir.html#ac5c71e471d7d8cdda288a27d1ae75642">More...</a><br /></td></tr>
<tr class="separator:ac5c71e471d7d8cdda288a27d1ae75642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32404bdce26e3b9e768fa1e790e77a44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a32404bdce26e3b9e768fa1e790e77a44">populateVectorToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a32404bdce26e3b9e768fa1e790e77a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating <a class="el" href="structVector.html">Vector</a> Ops to SPIR-V ops.  <a href="namespacemlir.html#a32404bdce26e3b9e768fa1e790e77a44">More...</a><br /></td></tr>
<tr class="separator:a32404bdce26e3b9e768fa1e790e77a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdbf57d9d955aea59286a07c5c3c03a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7fdbf57d9d955aea59286a07c5c3c03a">populateVectorReductionToSPIRVDotProductPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a7fdbf57d9d955aea59286a07c5c3c03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns to convert vector reduction of the form:  <a href="namespacemlir.html#a7fdbf57d9d955aea59286a07c5c3c03a">More...</a><br /></td></tr>
<tr class="separator:a7fdbf57d9d955aea59286a07c5c3c03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8113c1109f8cc9f8d47492fce5d7723f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8113c1109f8cc9f8d47492fce5d7723f">createConvertVectorToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a8113c1109f8cc9f8d47492fce5d7723f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert <a class="el" href="structVector.html">Vector</a> Ops to SPIR-V ops.  <a href="namespacemlir.html#a8113c1109f8cc9f8d47492fce5d7723f">More...</a><br /></td></tr>
<tr class="separator:a8113c1109f8cc9f8d47492fce5d7723f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37afe16f80bc8bacb6914dd6f0b869c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a37afe16f80bc8bacb6914dd6f0b869c0">setupDebuggerExecutionContextHook</a> (<a class="el" href="classmlir_1_1tracing_1_1ExecutionContext.html">tracing::ExecutionContext</a> &amp;executionContext)</td></tr>
<tr class="separator:a37afe16f80bc8bacb6914dd6f0b869c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996cc8b761f1373132a5d77b16d2076a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a996cc8b761f1373132a5d77b16d2076a">populateAMXLegalizeForLLVMExportPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a996cc8b761f1373132a5d77b16d2076a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to lower AMX ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="namespacemlir.html#a996cc8b761f1373132a5d77b16d2076a">More...</a><br /></td></tr>
<tr class="separator:a996cc8b761f1373132a5d77b16d2076a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3c1de7f45b21ef1f9deddb22b03655"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acc3c1de7f45b21ef1f9deddb22b03655">configureAMXLegalizeForExportTarget</a> (<a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:acc3c1de7f45b21ef1f9deddb22b03655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the target to support lowering AMX ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="namespacemlir.html#acc3c1de7f45b21ef1f9deddb22b03655">More...</a><br /></td></tr>
<tr class="separator:acc3c1de7f45b21ef1f9deddb22b03655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7736bcb70dbd9f242cd5182dd443031"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">detail::op_matcher</a>&lt; <a class="el" href="classmlir_1_1arith_1_1ConstantIndexOp.html">arith::ConstantIndexOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac7736bcb70dbd9f242cd5182dd443031">matchConstantIndex</a> ()</td></tr>
<tr class="memdesc:ac7736bcb70dbd9f242cd5182dd443031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a ConstantIndexOp.  <a href="namespacemlir.html#ac7736bcb70dbd9f242cd5182dd443031">More...</a><br /></td></tr>
<tr class="separator:ac7736bcb70dbd9f242cd5182dd443031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cdbb0a157a6008648d2e54c55bd46c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac3cdbb0a157a6008648d2e54c55bd46c">foldDynamicIndexList</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;b, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;ofrs)</td></tr>
<tr class="memdesc:ac3cdbb0a157a6008648d2e54c55bd46c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>success</code> when any of the elements in <code>ofrs</code> was produced by <a class="el" href="classmlir_1_1arith_1_1ConstantIndexOp.html" title="Specialization of arith.constant op that returns an integer of index type.">arith::ConstantIndexOp</a>.  <a href="namespacemlir.html#ac3cdbb0a157a6008648d2e54c55bd46c">More...</a><br /></td></tr>
<tr class="separator:ac3cdbb0a157a6008648d2e54c55bd46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bdf7e87740dbe0f603efdbc83c0a68"><td class="memItemLeft" align="right" valign="top">llvm::SmallBitVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac1bdf7e87740dbe0f603efdbc83c0a68">getPositionsOfShapeOne</a> (unsigned rank, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape)</td></tr>
<tr class="separator:ac1bdf7e87740dbe0f603efdbc83c0a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa058eb9c12d3b97deb073543c1372195"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa058eb9c12d3b97deb073543c1372195">getValueOrCreateConstantIndexOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr)</td></tr>
<tr class="memdesc:aa058eb9c12d3b97deb073543c1372195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="namespacemlir.html#aa058eb9c12d3b97deb073543c1372195">More...</a><br /></td></tr>
<tr class="separator:aa058eb9c12d3b97deb073543c1372195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09c62516a7b31fc96892014feeae832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab09c62516a7b31fc96892014feeae832">getValueOrCreateConstantIndexOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; valueOrAttrVec)</td></tr>
<tr class="memdesc:ab09c62516a7b31fc96892014feeae832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the other overload, but converts multiple OpFoldResults into Values.  <a href="namespacemlir.html#ab09c62516a7b31fc96892014feeae832">More...</a><br /></td></tr>
<tr class="separator:ab09c62516a7b31fc96892014feeae832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8bbfc3d0c15e92f5cba28e5ef447b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7d8bbfc3d0c15e92f5cba28e5ef447b5">getValueOrCreateCastToIndexLike</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> targetType, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a7d8bbfc3d0c15e92f5cba28e5ef447b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a cast from an index-like value (index or integer) to another index-like value.  <a href="namespacemlir.html#a7d8bbfc3d0c15e92f5cba28e5ef447b5">More...</a><br /></td></tr>
<tr class="separator:a7d8bbfc3d0c15e92f5cba28e5ef447b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d383da63b1370b9cf5c13c252b391d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a10d383da63b1370b9cf5c13c252b391d">convertScalarToDtype</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> operand, <a class="el" href="classmlir_1_1Type.html">Type</a> toType, bool isUnsignedCast)</td></tr>
<tr class="memdesc:a10d383da63b1370b9cf5c13c252b391d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a scalar value <code>operand</code> to type <code>toType</code>.  <a href="namespacemlir.html#a10d383da63b1370b9cf5c13c252b391d">More...</a><br /></td></tr>
<tr class="separator:a10d383da63b1370b9cf5c13c252b391d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f862550b655bdc6a10caa74ce4ae0af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6f862550b655bdc6a10caa74ce4ae0af">populateArmSVELegalizeForLLVMExportPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a6f862550b655bdc6a10caa74ce4ae0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to lower ArmSVE ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="namespacemlir.html#a6f862550b655bdc6a10caa74ce4ae0af">More...</a><br /></td></tr>
<tr class="separator:a6f862550b655bdc6a10caa74ce4ae0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026c18765c0bc2d44d9ab120174d36ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a026c18765c0bc2d44d9ab120174d36ae">configureArmSVELegalizeForExportTarget</a> (<a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a026c18765c0bc2d44d9ab120174d36ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the target to support lowering ArmSVE ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="namespacemlir.html#a026c18765c0bc2d44d9ab120174d36ae">More...</a><br /></td></tr>
<tr class="separator:a026c18765c0bc2d44d9ab120174d36ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4239fe8f68fb32a8788127f7a6850950"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4239fe8f68fb32a8788127f7a6850950">createAsyncParallelForPass</a> ()</td></tr>
<tr class="separator:a4239fe8f68fb32a8788127f7a6850950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755ae56707350858331f8a2d72036f86"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a755ae56707350858331f8a2d72036f86">createAsyncParallelForPass</a> (bool asyncDispatch, int32_t numWorkerThreads, int32_t minTaskSize)</td></tr>
<tr class="separator:a755ae56707350858331f8a2d72036f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ea90e10c603e639fe6b6cbc9f24265"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa9ea90e10c603e639fe6b6cbc9f24265">populateAsyncFuncToAsyncRuntimeConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="separator:aa9ea90e10c603e639fe6b6cbc9f24265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef286aa7b84037b9a4b9b638c57d20c1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aef286aa7b84037b9a4b9b638c57d20c1">createAsyncFuncToAsyncRuntimePass</a> ()</td></tr>
<tr class="separator:aef286aa7b84037b9a4b9b638c57d20c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda37b3719dc71d8caddd1d39ca215db"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acda37b3719dc71d8caddd1d39ca215db">createAsyncToAsyncRuntimePass</a> ()</td></tr>
<tr class="separator:acda37b3719dc71d8caddd1d39ca215db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74b480a928c4e1972270a410dd3e214"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac74b480a928c4e1972270a410dd3e214">createAsyncRuntimeRefCountingPass</a> ()</td></tr>
<tr class="separator:ac74b480a928c4e1972270a410dd3e214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29ec7fe477dccf07bddf61bec9c3ac7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac29ec7fe477dccf07bddf61bec9c3ac7">createAsyncRuntimeRefCountingOptPass</a> ()</td></tr>
<tr class="separator:ac29ec7fe477dccf07bddf61bec9c3ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c5cda96fda85b96d4c5786f58680bd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a89c5cda96fda85b96d4c5786f58680bd">createAsyncRuntimePolicyBasedRefCountingPass</a> ()</td></tr>
<tr class="separator:a89c5cda96fda85b96d4c5786f58680bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dbd0711a153c12e79337d0d141ec37"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class CalculationT  = function_ref&lt;              std::optional&lt;ElementValueT&gt;(ElementValueT, ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:a94dbd0711a153c12e79337d0d141ec37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a94dbd0711a153c12e79337d0d141ec37">constFoldBinaryOpConditional</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, const CalculationT &amp;calculate)</td></tr>
<tr class="memdesc:a94dbd0711a153c12e79337d0d141ec37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs constant folding <code>calculate</code> with element-wise behavior on the two attributes in <code>operands</code> and returns the result if possible.  <a href="namespacemlir.html#a94dbd0711a153c12e79337d0d141ec37">More...</a><br /></td></tr>
<tr class="separator:a94dbd0711a153c12e79337d0d141ec37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae516571eecf95b88edc5de8b3133936b"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class CalculationT  = function_ref&lt;              std::optional&lt;ElementValueT&gt;(ElementValueT, ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:ae516571eecf95b88edc5de8b3133936b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae516571eecf95b88edc5de8b3133936b">constFoldBinaryOpConditional</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, const CalculationT &amp;calculate)</td></tr>
<tr class="memdesc:ae516571eecf95b88edc5de8b3133936b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs constant folding <code>calculate</code> with element-wise behavior on the two attributes in <code>operands</code> and returns the result if possible.  <a href="namespacemlir.html#ae516571eecf95b88edc5de8b3133936b">More...</a><br /></td></tr>
<tr class="separator:ae516571eecf95b88edc5de8b3133936b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeded9a4bf948b50af55435652f46e4ff"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class CalculationT  = function_ref&lt;ElementValueT(ElementValueT, ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:aeded9a4bf948b50af55435652f46e4ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeded9a4bf948b50af55435652f46e4ff">constFoldBinaryOp</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, const CalculationT &amp;calculate)</td></tr>
<tr class="separator:aeded9a4bf948b50af55435652f46e4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3b3bbe9e749975af2eb5358df6f5fe"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class CalculationT  = function_ref&lt;ElementValueT(ElementValueT, ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:a5d3b3bbe9e749975af2eb5358df6f5fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5d3b3bbe9e749975af2eb5358df6f5fe">constFoldBinaryOp</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, const CalculationT &amp;calculate)</td></tr>
<tr class="separator:a5d3b3bbe9e749975af2eb5358df6f5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4426b1d36447ba782a881c857b05b00"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class CalculationT  = function_ref&lt;std::optional&lt;ElementValueT&gt;(ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:ae4426b1d36447ba782a881c857b05b00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae4426b1d36447ba782a881c857b05b00">constFoldUnaryOpConditional</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, const CalculationT &amp;&amp;calculate)</td></tr>
<tr class="memdesc:ae4426b1d36447ba782a881c857b05b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs constant folding <code>calculate</code> with element-wise behavior on the one attributes in <code>operands</code> and returns the result if possible.  <a href="namespacemlir.html#ae4426b1d36447ba782a881c857b05b00">More...</a><br /></td></tr>
<tr class="separator:ae4426b1d36447ba782a881c857b05b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb2ddb434a672f458f2ae6ab2a11570"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class CalculationT  = function_ref&lt;ElementValueT(ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:a8fb2ddb434a672f458f2ae6ab2a11570"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8fb2ddb434a672f458f2ae6ab2a11570">constFoldUnaryOp</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, const CalculationT &amp;&amp;calculate)</td></tr>
<tr class="separator:a8fb2ddb434a672f458f2ae6ab2a11570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac450f976e30737567db650586c193a92"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT , class TargetAttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class TargetElementValueT  = typename TargetAttrElementT::ValueType, class CalculationT  = function_ref&lt;TargetElementValueT(ElementValueT, bool)&gt;&gt; </td></tr>
<tr class="memitem:ac450f976e30737567db650586c193a92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac450f976e30737567db650586c193a92">constFoldCastOp</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, <a class="el" href="classmlir_1_1Type.html">Type</a> resType, const CalculationT &amp;calculate)</td></tr>
<tr class="separator:ac450f976e30737567db650586c193a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ee5fd8a8bcd80a922acd227a213e2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a65ee5fd8a8bcd80a922acd227a213e2e">populateDecomposeCallGraphTypesPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1ValueDecomposer.html">ValueDecomposer</a> &amp;decomposer, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a65ee5fd8a8bcd80a922acd227a213e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the patterns needed to drive the conversion process for decomposing call graph types with the given <code><a class="el" href="classmlir_1_1ValueDecomposer.html" title="This class provides a hook that expands one Value into multiple Value&#39;s, with a TypeConverter-inspire...">ValueDecomposer</a></code>.  <a href="namespacemlir.html#a65ee5fd8a8bcd80a922acd227a213e2e">More...</a><br /></td></tr>
<tr class="separator:a65ee5fd8a8bcd80a922acd227a213e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155010c68de4c682e3cb8890e9460283"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a155010c68de4c682e3cb8890e9460283">populateCallOpTypeConversionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="memdesc:a155010c68de4c682e3cb8890e9460283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pattern to the given pattern list to convert the operand and result types of a CallOp with the given type converter.  <a href="namespacemlir.html#a155010c68de4c682e3cb8890e9460283">More...</a><br /></td></tr>
<tr class="separator:a155010c68de4c682e3cb8890e9460283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df32552b0e40b3e55a3a098fb0f8f52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3df32552b0e40b3e55a3a098fb0f8f52">populateBranchOpInterfaceTypeConversionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(BranchOpInterface branchOp, int idx)&gt; shouldConvertBranchOperand=nullptr)</td></tr>
<tr class="memdesc:a3df32552b0e40b3e55a3a098fb0f8f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pattern to the given pattern list to rewrite branch operations to use operands that have been legalized by the conversion framework.  <a href="namespacemlir.html#a3df32552b0e40b3e55a3a098fb0f8f52">More...</a><br /></td></tr>
<tr class="separator:a3df32552b0e40b3e55a3a098fb0f8f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af233cbc2b6252b0f87bbc95f2bc8c553"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af233cbc2b6252b0f87bbc95f2bc8c553">isLegalForBranchOpInterfaceTypeConversionPattern</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="memdesc:af233cbc2b6252b0f87bbc95f2bc8c553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if op is a BranchOpInterface op whose operands are all legal according to converter.  <a href="namespacemlir.html#af233cbc2b6252b0f87bbc95f2bc8c553">More...</a><br /></td></tr>
<tr class="separator:af233cbc2b6252b0f87bbc95f2bc8c553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb02814adc084d318ce037a93a326df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2eb02814adc084d318ce037a93a326df">populateReturnOpTypeConversionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="memdesc:a2eb02814adc084d318ce037a93a326df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pattern to the given pattern list to rewrite <code>return</code> ops to use operands that have been legalized by the conversion framework.  <a href="namespacemlir.html#a2eb02814adc084d318ce037a93a326df">More...</a><br /></td></tr>
<tr class="separator:a2eb02814adc084d318ce037a93a326df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b78043105c4babf3635efc8a0c5db1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab6b78043105c4babf3635efc8a0c5db1">isLegalForReturnOpTypeConversionPattern</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter, bool returnOpAlwaysLegal=false)</td></tr>
<tr class="memdesc:ab6b78043105c4babf3635efc8a0c5db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">For ReturnLike ops (except <code>return</code>), return True.  <a href="namespacemlir.html#ab6b78043105c4babf3635efc8a0c5db1">More...</a><br /></td></tr>
<tr class="separator:ab6b78043105c4babf3635efc8a0c5db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625259a35e521a9f6d7b7fe115423e87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a625259a35e521a9f6d7b7fe115423e87">isNotBranchOpInterfaceOrReturnLikeOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a625259a35e521a9f6d7b7fe115423e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if op is neither BranchOpInterface nor ReturnLike.  <a href="namespacemlir.html#a625259a35e521a9f6d7b7fe115423e87">More...</a><br /></td></tr>
<tr class="separator:a625259a35e521a9f6d7b7fe115423e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa68a69789ad46739cf87f7166e52cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5aa68a69789ad46739cf87f7166e52cf">populateFuncTypeConversionPatterns</a> (<a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a5aa68a69789ad46739cf87f7166e52cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7173c36d6b113dcdb0599eb672526b43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7173c36d6b113dcdb0599eb672526b43">promoteToWorkgroupMemory</a> (gpu::GPUFuncOp op, unsigned arg)</td></tr>
<tr class="memdesc:a7173c36d6b113dcdb0599eb672526b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes a function argument to workgroup memory in the given function.  <a href="namespacemlir.html#a7173c36d6b113dcdb0599eb672526b43">More...</a><br /></td></tr>
<tr class="separator:a7173c36d6b113dcdb0599eb672526b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66200178a198c2f8aae15e94882f0788"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a66200178a198c2f8aae15e94882f0788">createGpuLauchSinkIndexComputationsPass</a> ()</td></tr>
<tr class="memdesc:a66200178a198c2f8aae15e94882f0788"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> that moves ops which are likely an index computation into gpu.launch body.  <a href="namespacemlir.html#a66200178a198c2f8aae15e94882f0788">More...</a><br /></td></tr>
<tr class="separator:a66200178a198c2f8aae15e94882f0788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae628f55b8a69b490ef848ceb63d234b9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae628f55b8a69b490ef848ceb63d234b9">createGpuKernelOutliningPass</a> (StringRef dataLayoutStr=StringRef())</td></tr>
<tr class="memdesc:ae628f55b8a69b490ef848ceb63d234b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces <code>gpu.launch</code> with <code>gpu.launch_func</code> by moving the region into a separate kernel function.  <a href="namespacemlir.html#ae628f55b8a69b490ef848ceb63d234b9">More...</a><br /></td></tr>
<tr class="separator:ae628f55b8a69b490ef848ceb63d234b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd2637570ab4c74519de8ed73747b5f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8bd2637570ab4c74519de8ed73747b5f">createGpuAsyncRegionPass</a> ()</td></tr>
<tr class="memdesc:a8bd2637570ab4c74519de8ed73747b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites a function region so that GPU ops execute asynchronously.  <a href="namespacemlir.html#a8bd2637570ab4c74519de8ed73747b5f">More...</a><br /></td></tr>
<tr class="separator:a8bd2637570ab4c74519de8ed73747b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc65540e2fcc88965c99cf18236192b4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acc65540e2fcc88965c99cf18236192b4">createGpuMapParallelLoopsPass</a> ()</td></tr>
<tr class="memdesc:acc65540e2fcc88965c99cf18236192b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the parallel loops found in the given function to workgroups.  <a href="namespacemlir.html#acc65540e2fcc88965c99cf18236192b4">More...</a><br /></td></tr>
<tr class="separator:acc65540e2fcc88965c99cf18236192b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9701a7692a76e65edd69bd6f22156776"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9701a7692a76e65edd69bd6f22156776">populateGpuAllReducePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a9701a7692a76e65edd69bd6f22156776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to rewrite all-reduce ops within the GPU dialect.  <a href="namespacemlir.html#a9701a7692a76e65edd69bd6f22156776">More...</a><br /></td></tr>
<tr class="separator:a9701a7692a76e65edd69bd6f22156776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae1d309360c9e54edaa39ddb48d3ea1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4ae1d309360c9e54edaa39ddb48d3ea1">populateGpuRewritePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a4ae1d309360c9e54edaa39ddb48d3ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect all patterns to rewrite ops within the GPU dialect.  <a href="namespacemlir.html#a4ae1d309360c9e54edaa39ddb48d3ea1">More...</a><br /></td></tr>
<tr class="separator:a4ae1d309360c9e54edaa39ddb48d3ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408ccd7b20bede5af6274d2243aaf4ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a408ccd7b20bede5af6274d2243aaf4ce">registerGpuSerializeToCubinPass</a> ()</td></tr>
<tr class="memdesc:a408ccd7b20bede5af6274d2243aaf4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register pass to serialize GPU kernel functions to a CUBIN binary annotation.  <a href="namespacemlir.html#a408ccd7b20bede5af6274d2243aaf4ce">More...</a><br /></td></tr>
<tr class="separator:a408ccd7b20bede5af6274d2243aaf4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309cdd85b1689eff02c2259ef8d0bb6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a309cdd85b1689eff02c2259ef8d0bb6c">registerGpuSerializeToHsacoPass</a> ()</td></tr>
<tr class="memdesc:a309cdd85b1689eff02c2259ef8d0bb6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register pass to serialize GPU kernel functions to a HSAco binary annotation.  <a href="namespacemlir.html#a309cdd85b1689eff02c2259ef8d0bb6c">More...</a><br /></td></tr>
<tr class="separator:a309cdd85b1689eff02c2259ef8d0bb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94e0df03210ed9f9748882cd5a70a47"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac94e0df03210ed9f9748882cd5a70a47">createGpuSerializeToCubinPass</a> (StringRef triple, StringRef chip, StringRef features)</td></tr>
<tr class="memdesc:ac94e0df03210ed9f9748882cd5a70a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an instance of the GPU kernel function to CUBIN binary serialization pass.  <a href="namespacemlir.html#ac94e0df03210ed9f9748882cd5a70a47">More...</a><br /></td></tr>
<tr class="separator:ac94e0df03210ed9f9748882cd5a70a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c464614f40cbae1452d716d1a35636"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a67c464614f40cbae1452d716d1a35636">createGpuSerializeToHsacoPass</a> (StringRef triple, StringRef arch, StringRef features, int optLevel)</td></tr>
<tr class="memdesc:a67c464614f40cbae1452d716d1a35636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an instance of the GPU kernel function to HSAco binary serialization pass.  <a href="namespacemlir.html#a67c464614f40cbae1452d716d1a35636">More...</a><br /></td></tr>
<tr class="separator:a67c464614f40cbae1452d716d1a35636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9152a09d079148a1a2f40d4946f7c17"><td class="memItemLeft" align="right" valign="top">gpu::GPUFuncOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae9152a09d079148a1a2f40d4946f7c17">outlineKernelFunc</a> (gpu::LaunchOp launchOp, StringRef kernelFnName, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;operands)</td></tr>
<tr class="memdesc:ae9152a09d079148a1a2f40d4946f7c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a gpu.func created from outlining the region of a gpu.launch op with the given <code>kernelFnName</code>.  <a href="namespacemlir.html#ae9152a09d079148a1a2f40d4946f7c17">More...</a><br /></td></tr>
<tr class="separator:ae9152a09d079148a1a2f40d4946f7c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e007ae66428f560626d4ba3c58dfe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa6e007ae66428f560626d4ba3c58dfe2">sinkOperationsIntoLaunchOp</a> (gpu::LaunchOp launchOp, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; isSinkingBeneficiary)</td></tr>
<tr class="memdesc:aa6e007ae66428f560626d4ba3c58dfe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink operations into the <code>launchOp</code> to reduce the number of values that are used within the region of the operation, but defined outside of the region.  <a href="namespacemlir.html#aa6e007ae66428f560626d4ba3c58dfe2">More...</a><br /></td></tr>
<tr class="separator:aa6e007ae66428f560626d4ba3c58dfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc492b94e5d0848e7244b2682da91021"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abc492b94e5d0848e7244b2682da91021">createConvertElementwiseToLinalgPass</a> ()</td></tr>
<tr class="separator:abc492b94e5d0848e7244b2682da91021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa750e27e8b520efa98466e75aece0f7b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa750e27e8b520efa98466e75aece0f7b">createLinalgFoldUnitExtentDimsPass</a> ()</td></tr>
<tr class="separator:aa750e27e8b520efa98466e75aece0f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa174a4f487204b0e8221ed0ab2dfb737"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa174a4f487204b0e8221ed0ab2dfb737">createLinalgElementwiseOpFusionPass</a> ()</td></tr>
<tr class="separator:aa174a4f487204b0e8221ed0ab2dfb737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcdb1d516a9d3198ae11daf05637b05"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0fcdb1d516a9d3198ae11daf05637b05">createFoldReshapeOpsByLinearizationPass</a> ()</td></tr>
<tr class="separator:a0fcdb1d516a9d3198ae11daf05637b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad448648b1ff12e114f53247cbad44e5c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad448648b1ff12e114f53247cbad44e5c">createLinalgNamedOpConversionPass</a> ()</td></tr>
<tr class="separator:ad448648b1ff12e114f53247cbad44e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1086a21637aa5a39c59574052b80c17"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae1086a21637aa5a39c59574052b80c17">createLinalgInlineScalarOperandsPass</a> ()</td></tr>
<tr class="separator:ae1086a21637aa5a39c59574052b80c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048ca3f94f0e3472846128d08e1db05f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a048ca3f94f0e3472846128d08e1db05f">createConvertLinalgToLoopsPass</a> ()</td></tr>
<tr class="memdesc:a048ca3f94f0e3472846128d08e1db05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations to scf.for loops and memref.load/memref.store accesses.  <a href="namespacemlir.html#a048ca3f94f0e3472846128d08e1db05f">More...</a><br /></td></tr>
<tr class="separator:a048ca3f94f0e3472846128d08e1db05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2eb8ccd7e77282559488dfb6408a632"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac2eb8ccd7e77282559488dfb6408a632">createConvertLinalgToParallelLoopsPass</a> ()</td></tr>
<tr class="memdesc:ac2eb8ccd7e77282559488dfb6408a632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations to scf.parallel loops and memref.load/memref.store accesses.  <a href="namespacemlir.html#ac2eb8ccd7e77282559488dfb6408a632">More...</a><br /></td></tr>
<tr class="separator:ac2eb8ccd7e77282559488dfb6408a632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b8d9d8ebc6d954a9bb1d61ff789bc0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a49b8d9d8ebc6d954a9bb1d61ff789bc0">createConvertLinalgToAffineLoopsPass</a> ()</td></tr>
<tr class="memdesc:a49b8d9d8ebc6d954a9bb1d61ff789bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations to affine.for loops and affine_load/affine_store accesses.  <a href="namespacemlir.html#a49b8d9d8ebc6d954a9bb1d61ff789bc0">More...</a><br /></td></tr>
<tr class="separator:a49b8d9d8ebc6d954a9bb1d61ff789bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc6c56dc4a5f06f5a3dbff9a70f2126"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aacc6c56dc4a5f06f5a3dbff9a70f2126">createLinalgBufferizePass</a> ()</td></tr>
<tr class="memdesc:aacc6c56dc4a5f06f5a3dbff9a70f2126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations which work on tensors to use buffers instead.  <a href="namespacemlir.html#aacc6c56dc4a5f06f5a3dbff9a70f2126">More...</a><br /></td></tr>
<tr class="separator:aacc6c56dc4a5f06f5a3dbff9a70f2126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbac2762b3662cb64525cf03fbf69f83"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abbac2762b3662cb64525cf03fbf69f83">createLinalgGeneralizationPass</a> ()</td></tr>
<tr class="memdesc:abbac2762b3662cb64525cf03fbf69f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert named Linalg operations to Linalg generic operations.  <a href="namespacemlir.html#abbac2762b3662cb64525cf03fbf69f83">More...</a><br /></td></tr>
<tr class="separator:abbac2762b3662cb64525cf03fbf69f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888e0ad22e8609a0c5042ccecdb7adc7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a888e0ad22e8609a0c5042ccecdb7adc7">createLinalgDetensorizePass</a> ()</td></tr>
<tr class="memdesc:a888e0ad22e8609a0c5042ccecdb7adc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations to equivalent operations that work on primitive types, if possible.  <a href="namespacemlir.html#a888e0ad22e8609a0c5042ccecdb7adc7">More...</a><br /></td></tr>
<tr class="separator:a888e0ad22e8609a0c5042ccecdb7adc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad882bbe96acab6803e205bac71f694fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad882bbe96acab6803e205bac71f694fe">populateExpandCtlzPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:ad882bbe96acab6803e205bac71f694fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e85fbc0b8884dd2405be7b78b0c8e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a84e85fbc0b8884dd2405be7b78b0c8e7">populateExpandTanPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a84e85fbc0b8884dd2405be7b78b0c8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbc60c17752a76af9b0f28ffa36d4f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2fbc60c17752a76af9b0f28ffa36d4f9">populateExpandTanhPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a2fbc60c17752a76af9b0f28ffa36d4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377a5d6d036008ba5e6416dc651dba6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a377a5d6d036008ba5e6416dc651dba6e">populateExpandFmaFPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a377a5d6d036008ba5e6416dc651dba6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d52687fa07fb3c88f0d4f19471094a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af4d52687fa07fb3c88f0d4f19471094a">populateExpandFloorFPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:af4d52687fa07fb3c88f0d4f19471094a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d2110655a5086ecee6eac3405c8e25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac9d2110655a5086ecee6eac3405c8e25">populateExpandCeilFPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:ac9d2110655a5086ecee6eac3405c8e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d2ac5ca6fe4c18adb5d7c32da4d914"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab7d2ac5ca6fe4c18adb5d7c32da4d914">populateExpandExp2FPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:ab7d2ac5ca6fe4c18adb5d7c32da4d914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760b455909b9e4e765071fa20fbd6aef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a760b455909b9e4e765071fa20fbd6aef">populateExpandPowFPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a760b455909b9e4e765071fa20fbd6aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7559586e5b98d3d19dd9b234ee93b39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa7559586e5b98d3d19dd9b234ee93b39">populateExpandRoundFPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:aa7559586e5b98d3d19dd9b234ee93b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53fc446b430869ef74c6382f675b1ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae53fc446b430869ef74c6382f675b1ba">populateExpandRoundEvenPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:ae53fc446b430869ef74c6382f675b1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747b91bacc09bde115c3e891deb5ebe5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a747b91bacc09bde115c3e891deb5ebe5">populateMathAlgebraicSimplificationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a747b91bacc09bde115c3e891deb5ebe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada84ecb306c38b4e2a547962acc98dfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ada84ecb306c38b4e2a547962acc98dfd">populateMathPolynomialApproximationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="structmlir_1_1MathPolynomialApproximationOptions.html">MathPolynomialApproximationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>={})</td></tr>
<tr class="separator:ada84ecb306c38b4e2a547962acc98dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e879c874e4fdc6aaf9d4742abdb876"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac7e879c874e4fdc6aaf9d4742abdb876">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="structmlir_1_1Range.html">Range</a> &amp;range)</td></tr>
<tr class="separator:ac7e879c874e4fdc6aaf9d4742abdb876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e134959101de052e7dbfd12610b5d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a>, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a45e134959101de052e7dbfd12610b5d6">getOrCreateRanges</a> (OffsetSizeAndStrideOpInterface op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a45e134959101de052e7dbfd12610b5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of <a class="el" href="structmlir_1_1Range.html" title="Represents a range (offset, size, and stride) where each element of the triple may be dynamic or stat...">Range</a> (i.e.  <a href="namespacemlir.html#a45e134959101de052e7dbfd12610b5d6">More...</a><br /></td></tr>
<tr class="separator:a45e134959101de052e7dbfd12610b5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2a7464fefab1d85cec445e487f0d0c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8c2a7464fefab1d85cec445e487f0d0c">createSCFBufferizePass</a> ()</td></tr>
<tr class="memdesc:a8c2a7464fefab1d85cec445e487f0d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that bufferizes the SCF dialect.  <a href="namespacemlir.html#a8c2a7464fefab1d85cec445e487f0d0c">More...</a><br /></td></tr>
<tr class="separator:a8c2a7464fefab1d85cec445e487f0d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d49e4ae28aeaaa552466850cc5e04ec"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1d49e4ae28aeaaa552466850cc5e04ec">createForLoopSpecializationPass</a> ()</td></tr>
<tr class="memdesc:a1d49e4ae28aeaaa552466850cc5e04ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that specializes for loop for unrolling and vectorization.  <a href="namespacemlir.html#a1d49e4ae28aeaaa552466850cc5e04ec">More...</a><br /></td></tr>
<tr class="separator:a1d49e4ae28aeaaa552466850cc5e04ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acfeadb8fff74a53be77ccf540be99b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7acfeadb8fff74a53be77ccf540be99b">createForLoopPeelingPass</a> ()</td></tr>
<tr class="memdesc:a7acfeadb8fff74a53be77ccf540be99b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that peels for loops at their upper bounds for better vectorization.  <a href="namespacemlir.html#a7acfeadb8fff74a53be77ccf540be99b">More...</a><br /></td></tr>
<tr class="separator:a7acfeadb8fff74a53be77ccf540be99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f8ebf7a2133d1c68cea6e20fba0ea8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac7f8ebf7a2133d1c68cea6e20fba0ea8">createSCFForLoopCanonicalizationPass</a> ()</td></tr>
<tr class="memdesc:ac7f8ebf7a2133d1c68cea6e20fba0ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that canonicalizes affine.min and affine.max operations inside of scf.for loops with known lower and upper bounds.  <a href="namespacemlir.html#ac7f8ebf7a2133d1c68cea6e20fba0ea8">More...</a><br /></td></tr>
<tr class="separator:ac7f8ebf7a2133d1c68cea6e20fba0ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03de4687b73fcc63bfde7e0dda6b741"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab03de4687b73fcc63bfde7e0dda6b741">createTestSCFParallelLoopCollapsingPass</a> ()</td></tr>
<tr class="memdesc:ab03de4687b73fcc63bfde7e0dda6b741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that transforms a single ParallelLoop over N induction variables into another ParallelLoop over less than N induction variables.  <a href="namespacemlir.html#ab03de4687b73fcc63bfde7e0dda6b741">More...</a><br /></td></tr>
<tr class="separator:ab03de4687b73fcc63bfde7e0dda6b741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00701d01638289dd08ec9e255076f50"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad00701d01638289dd08ec9e255076f50">createParallelLoopFusionPass</a> ()</td></tr>
<tr class="memdesc:ad00701d01638289dd08ec9e255076f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop fusion pass which fuses parallel loops.  <a href="namespacemlir.html#ad00701d01638289dd08ec9e255076f50">More...</a><br /></td></tr>
<tr class="separator:ad00701d01638289dd08ec9e255076f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b9f8678ec66eed9c66536834540184"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a16b9f8678ec66eed9c66536834540184">createParallelLoopSpecializationPass</a> ()</td></tr>
<tr class="memdesc:a16b9f8678ec66eed9c66536834540184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that specializes parallel loop for unrolling and vectorization.  <a href="namespacemlir.html#a16b9f8678ec66eed9c66536834540184">More...</a><br /></td></tr>
<tr class="separator:a16b9f8678ec66eed9c66536834540184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213571bc56b32e75bc35cf02098982a1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a213571bc56b32e75bc35cf02098982a1">createParallelLoopTilingPass</a> (<a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; int64_t &gt; tileSize={}, bool noMinMaxBounds=false)</td></tr>
<tr class="memdesc:a213571bc56b32e75bc35cf02098982a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which tiles innermost parallel loops.  <a href="namespacemlir.html#a213571bc56b32e75bc35cf02098982a1">More...</a><br /></td></tr>
<tr class="separator:a213571bc56b32e75bc35cf02098982a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6597022fdb6de5a99b895b2bfc9e0a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2a6597022fdb6de5a99b895b2bfc9e0a">createForLoopRangeFoldingPass</a> ()</td></tr>
<tr class="memdesc:a2a6597022fdb6de5a99b895b2bfc9e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which folds arith ops on induction variable into loop range.  <a href="namespacemlir.html#a2a6597022fdb6de5a99b895b2bfc9e0a">More...</a><br /></td></tr>
<tr class="separator:a2a6597022fdb6de5a99b895b2bfc9e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76018eef454fd668d103ea3cc6afc52a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a76018eef454fd668d103ea3cc6afc52a">createForToWhileLoopPass</a> ()</td></tr>
<tr class="separator:a76018eef454fd668d103ea3cc6afc52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f20cbb6f6483971021fdfdf5b731ba1"><td class="memItemLeft" align="right" valign="top">scf::ForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6f20cbb6f6483971021fdfdf5b731ba1">replaceLoopWithNewYields</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, scf::ForOp loop, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newIterOperands, const <a class="el" href="namespacemlir.html#ae809ff18bf496d00671a691c71795f68">NewYieldValueFn</a> &amp;newYieldValuesFn, bool replaceIterOperandsUsesInLoop=true)</td></tr>
<tr class="separator:a6f20cbb6f6483971021fdfdf5b731ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85035789b8e28cd6a8eb8ebcb2f6c07"><td class="memItemLeft" align="right" valign="top">scf::ForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac85035789b8e28cd6a8eb8ebcb2f6c07">replaceLoopWithNewYields</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, scf::ForOp loop, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newIterOperands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newYields, bool replaceIterOperandsUsesInLoop=true)</td></tr>
<tr class="separator:ac85035789b8e28cd6a8eb8ebcb2f6c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac397605c6399939f433c2e9d15975954"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; scf::ForOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac397605c6399939f433c2e9d15975954">replaceLoopNestWithNewYields</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt; loopNest, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newIterOperands, const <a class="el" href="namespacemlir.html#ae809ff18bf496d00671a691c71795f68">NewYieldValueFn</a> &amp;newYieldValueFn, bool replaceIterOperandsUsesInLoop=true)</td></tr>
<tr class="memdesc:ac397605c6399939f433c2e9d15975954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a perfectly nested loop nest to yield new values from the innermost loop and propagating it up through the loop nest.  <a href="namespacemlir.html#ac397605c6399939f433c2e9d15975954">More...</a><br /></td></tr>
<tr class="separator:ac397605c6399939f433c2e9d15975954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdec8fa23b93085ee2e142defd7c5599"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; func::FuncOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abdec8fa23b93085ee2e142defd7c5599">outlineSingleBlockRegion</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, StringRef funcName, func::CallOp *callOp=nullptr)</td></tr>
<tr class="memdesc:abdec8fa23b93085ee2e142defd7c5599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outline a region with a single block into a new FuncOp.  <a href="namespacemlir.html#abdec8fa23b93085ee2e142defd7c5599">More...</a><br /></td></tr>
<tr class="separator:abdec8fa23b93085ee2e142defd7c5599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10aad3624e000c0585087c96357ea857"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a10aad3624e000c0585087c96357ea857">outlineIfOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, scf::IfOp ifOp, func::FuncOp *thenFn, StringRef thenFnName, func::FuncOp *elseFn, StringRef elseFnName)</td></tr>
<tr class="memdesc:a10aad3624e000c0585087c96357ea857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outline the then and/or else regions of <code>ifOp</code> as follows:  <a href="namespacemlir.html#a10aad3624e000c0585087c96357ea857">More...</a><br /></td></tr>
<tr class="separator:a10aad3624e000c0585087c96357ea857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820f3296c3cd59eaed418f42f874a217"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a820f3296c3cd59eaed418f42f874a217">getInnermostParallelLoops</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *rootOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; scf::ParallelOp &gt; &amp;result)</td></tr>
<tr class="memdesc:a820f3296c3cd59eaed418f42f874a217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of innermost parallel loops contained in <code>rootOp</code>.  <a href="namespacemlir.html#a820f3296c3cd59eaed418f42f874a217">More...</a><br /></td></tr>
<tr class="separator:a820f3296c3cd59eaed418f42f874a217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22ed238130b85dadcd9f75892b540b1"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::pair&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab22ed238130b85dadcd9f75892b540b1">getSCFMinMaxExpr</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dims, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;symbols, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; loopFilter=nullptr)</td></tr>
<tr class="memdesc:ab22ed238130b85dadcd9f75892b540b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the min/max expressions for <code>value</code> if it is an induction variable from scf.for or scf.parallel loop.  <a href="namespacemlir.html#ab22ed238130b85dadcd9f75892b540b1">More...</a><br /></td></tr>
<tr class="separator:ab22ed238130b85dadcd9f75892b540b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d3795f1b83fc9e56398102edb81bd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad6d3795f1b83fc9e56398102edb81bd4">coalesceLoops</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt; loops)</td></tr>
<tr class="memdesc:ad6d3795f1b83fc9e56398102edb81bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a perfect nest of "for" loops with a single linearized loop.  <a href="namespacemlir.html#ad6d3795f1b83fc9e56398102edb81bd4">More...</a><br /></td></tr>
<tr class="separator:ad6d3795f1b83fc9e56398102edb81bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225e1cd29fad1b00f569d9567bc6cb2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a225e1cd29fad1b00f569d9567bc6cb2e">collapseParallelLoops</a> (scf::ParallelOp loops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::vector&lt; unsigned &gt;&gt; combinedDimensions)</td></tr>
<tr class="memdesc:a225e1cd29fad1b00f569d9567bc6cb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the ParallelLoop and for each set of dimension indices, combine them into a single dimension.  <a href="namespacemlir.html#a225e1cd29fad1b00f569d9567bc6cb2e">More...</a><br /></td></tr>
<tr class="separator:a225e1cd29fad1b00f569d9567bc6cb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e4727751a2af7968a7f722b77620ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab5e4727751a2af7968a7f722b77620ff">promoteIfSingleIteration</a> (scf::ForOp forOp)</td></tr>
<tr class="memdesc:ab5e4727751a2af7968a7f722b77620ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes the loop body of a scf::ForOp to its containing block if the loop was known to have a single iteration.  <a href="namespacemlir.html#ab5e4727751a2af7968a7f722b77620ff">More...</a><br /></td></tr>
<tr class="separator:ab5e4727751a2af7968a7f722b77620ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040c47f3f5d15eecb05a18c6343df489"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a040c47f3f5d15eecb05a18c6343df489">loopUnrollByFactor</a> (scf::ForOp forOp, uint64_t unrollFactor, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(unsigned, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt; annotateFn=nullptr)</td></tr>
<tr class="memdesc:a040c47f3f5d15eecb05a18c6343df489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls this for operation by the specified unroll factor.  <a href="namespacemlir.html#a040c47f3f5d15eecb05a18c6343df489">More...</a><br /></td></tr>
<tr class="separator:a040c47f3f5d15eecb05a18c6343df489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdaa20d0acb7aec0f05cb700b1e09df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a3f0d45d0562d47acc2c42934ccbfea19">TileLoops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aecdaa20d0acb7aec0f05cb700b1e09df">extractFixedOuterLoops</a> (scf::ForOp rootFOrOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes)</td></tr>
<tr class="separator:aecdaa20d0acb7aec0f05cb700b1e09df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15bd4c107bb9ea52b7fcc11c283c129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab15bd4c107bb9ea52b7fcc11c283c129">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt; targets)</td></tr>
<tr class="memdesc:ab15bd4c107bb9ea52b7fcc11c283c129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tiling fo imperfectly nested loops (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under each of the <code>targets</code>.  <a href="namespacemlir.html#ab15bd4c107bb9ea52b7fcc11c283c129">More...</a><br /></td></tr>
<tr class="separator:ab15bd4c107bb9ea52b7fcc11c283c129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3ac25a4d763e0e5234f6b347c7f17a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adb3ac25a4d763e0e5234f6b347c7f17a">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizes, scf::ForOp target)</td></tr>
<tr class="memdesc:adb3ac25a4d763e0e5234f6b347c7f17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tiling (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under <code>target</code>.  <a href="namespacemlir.html#adb3ac25a4d763e0e5234f6b347c7f17a">More...</a><br /></td></tr>
<tr class="separator:adb3ac25a4d763e0e5234f6b347c7f17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76588ffa46e04caaa584360fa5cdde4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a76588ffa46e04caaa584360fa5cdde4c">tilePerfectlyNested</a> (scf::ForOp rootForOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizes)</td></tr>
<tr class="memdesc:a76588ffa46e04caaa584360fa5cdde4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile a nest of scf::ForOp loops rooted at <code>rootForOp</code> with the given (parametric) sizes.  <a href="namespacemlir.html#a76588ffa46e04caaa584360fa5cdde4c">More...</a><br /></td></tr>
<tr class="separator:a76588ffa46e04caaa584360fa5cdde4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002c6258ba17b3a08e25cde241861c3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a002c6258ba17b3a08e25cde241861c3f">getPerfectlyNestedLoops</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; scf::ForOp &gt; &amp;nestedLoops, scf::ForOp root)</td></tr>
<tr class="memdesc:a002c6258ba17b3a08e25cde241861c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get perfectly nested sequence of loops starting at root of loop nest (the first op being another AffineFor, and the second op - a terminator).  <a href="namespacemlir.html#a002c6258ba17b3a08e25cde241861c3f">More...</a><br /></td></tr>
<tr class="separator:a002c6258ba17b3a08e25cde241861c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050e7653e9cef5f155370ca0425994e9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a050e7653e9cef5f155370ca0425994e9">createShapeToShapeLowering</a> ()</td></tr>
<tr class="memdesc:a050e7653e9cef5f155370ca0425994e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the ShapeToShapeLowering pass that legalizes Shape dialect to be convertible to Arith.  <a href="namespacemlir.html#a050e7653e9cef5f155370ca0425994e9">More...</a><br /></td></tr>
<tr class="separator:a050e7653e9cef5f155370ca0425994e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068b739b7424900d4d98c15c81e4609e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a068b739b7424900d4d98c15c81e4609e">populateShapeRewritePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a068b739b7424900d4d98c15c81e4609e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects a set of patterns to rewrite ops within the Shape dialect.  <a href="namespacemlir.html#a068b739b7424900d4d98c15c81e4609e">More...</a><br /></td></tr>
<tr class="separator:a068b739b7424900d4d98c15c81e4609e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac260b877914dd5ce7bf80eb50ff87a4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac260b877914dd5ce7bf80eb50ff87a4b">populateRemoveShapeConstraintsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:ac260b877914dd5ce7bf80eb50ff87a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79c79f5d3c3fd8668be6d76e33bad9a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad79c79f5d3c3fd8668be6d76e33bad9a">createRemoveShapeConstraintsPass</a> ()</td></tr>
<tr class="separator:ad79c79f5d3c3fd8668be6d76e33bad9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801d4bb16485795a758c5c60d8413c6f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a801d4bb16485795a758c5c60d8413c6f">createShapeBufferizePass</a> ()</td></tr>
<tr class="separator:a801d4bb16485795a758c5c60d8413c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb4bec758f757740b983d352319eccb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4bb4bec758f757740b983d352319eccb">createOutlineShapeComputationPass</a> ()</td></tr>
<tr class="memdesc:a4bb4bec758f757740b983d352319eccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outline the shape computation part by adding shape.func and populate conrresponding mapping infomation into ShapeMappingAnalysis.  <a href="namespacemlir.html#a4bb4bec758f757740b983d352319eccb">More...</a><br /></td></tr>
<tr class="separator:a4bb4bec758f757740b983d352319eccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f7f8933f0baf6ebeddfdc698327c31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a86f7f8933f0baf6ebeddfdc698327c31">populateSparsificationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>=<a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a>())</td></tr>
<tr class="memdesc:a86f7f8933f0baf6ebeddfdc698327c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up sparsification rewriting rules with the given options.  <a href="namespacemlir.html#a86f7f8933f0baf6ebeddfdc698327c31">More...</a><br /></td></tr>
<tr class="separator:a86f7f8933f0baf6ebeddfdc698327c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0be4f778219bfb3917a2c7d3e7e1bd0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae0be4f778219bfb3917a2c7d3e7e1bd0">createSparsificationPass</a> ()</td></tr>
<tr class="separator:ae0be4f778219bfb3917a2c7d3e7e1bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b0dcc4a707e4e560a7a2f69a95a7c9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a11b0dcc4a707e4e560a7a2f69a95a7c9">createSparsificationPass</a> (const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="separator:a11b0dcc4a707e4e560a7a2f69a95a7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa1a4192d65a00261a1f969b16c3e8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36ca">SparseToSparseConversionStrategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3aa1a4192d65a00261a1f969b16c3e8a">sparseToSparseConversionStrategy</a> (int32_t flag)</td></tr>
<tr class="memdesc:a3aa1a4192d65a00261a1f969b16c3e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts command-line sparse2sparse flag to the strategy enum.  <a href="namespacemlir.html#a3aa1a4192d65a00261a1f969b16c3e8a">More...</a><br /></td></tr>
<tr class="separator:a3aa1a4192d65a00261a1f969b16c3e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e144d2e73a085c2781475b2808bb059"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7e144d2e73a085c2781475b2808bb059">populateSparseTensorConversionPatterns</a> (<a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="structmlir_1_1SparseTensorConversionOptions.html">SparseTensorConversionOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>=<a class="el" href="structmlir_1_1SparseTensorConversionOptions.html">SparseTensorConversionOptions</a>())</td></tr>
<tr class="memdesc:a7e144d2e73a085c2781475b2808bb059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up sparse tensor conversion rules.  <a href="namespacemlir.html#a7e144d2e73a085c2781475b2808bb059">More...</a><br /></td></tr>
<tr class="separator:a7e144d2e73a085c2781475b2808bb059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fe6af993ee7df395f88312234f0dc0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a50fe6af993ee7df395f88312234f0dc0">createSparseTensorConversionPass</a> ()</td></tr>
<tr class="separator:a50fe6af993ee7df395f88312234f0dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8654e2dbbf377b3df5383b90c7f9b2c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa8654e2dbbf377b3df5383b90c7f9b2c">createSparseTensorConversionPass</a> (const <a class="el" href="structmlir_1_1SparseTensorConversionOptions.html">SparseTensorConversionOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="separator:aa8654e2dbbf377b3df5383b90c7f9b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09b2f8703a1dd600360ce7154d53993"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae09b2f8703a1dd600360ce7154d53993">populateSparseTensorCodegenPatterns</a> (<a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool createSparseDeallocs, bool enableBufferInitialization)</td></tr>
<tr class="memdesc:ae09b2f8703a1dd600360ce7154d53993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up sparse tensor conversion rules.  <a href="namespacemlir.html#ae09b2f8703a1dd600360ce7154d53993">More...</a><br /></td></tr>
<tr class="separator:ae09b2f8703a1dd600360ce7154d53993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1444af92cb6556316a97dbd17dc10ea4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1444af92cb6556316a97dbd17dc10ea4">createSparseTensorCodegenPass</a> ()</td></tr>
<tr class="separator:a1444af92cb6556316a97dbd17dc10ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11d8839f833db69a07242adf6894472"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad11d8839f833db69a07242adf6894472">createSparseTensorCodegenPass</a> (bool createSparseDeallocs, bool enableBufferInitialization)</td></tr>
<tr class="separator:ad11d8839f833db69a07242adf6894472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667f68e2860101c8caec8f46732e316e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a667f68e2860101c8caec8f46732e316e">populatePreSparsificationRewriting</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a667f68e2860101c8caec8f46732e316e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6abc74515648dc477ae4f5af8cbf310"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa6abc74515648dc477ae4f5af8cbf310">createPreSparsificationRewritePass</a> ()</td></tr>
<tr class="separator:aa6abc74515648dc477ae4f5af8cbf310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03e3926df8ddc0e88e2f37216bb0924"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af03e3926df8ddc0e88e2f37216bb0924">populatePostSparsificationRewriting</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool enableRT, bool enableForeach, bool enableConvert)</td></tr>
<tr class="separator:af03e3926df8ddc0e88e2f37216bb0924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0453f43fae9c5d6de063d3b2076bbeb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af0453f43fae9c5d6de063d3b2076bbeb">createPostSparsificationRewritePass</a> ()</td></tr>
<tr class="separator:af0453f43fae9c5d6de063d3b2076bbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c396e4212b7c922cfacb6f0509316b5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9c396e4212b7c922cfacb6f0509316b5">createPostSparsificationRewritePass</a> (bool enableRT, bool enableForeach=true, bool enableConvert=true)</td></tr>
<tr class="separator:a9c396e4212b7c922cfacb6f0509316b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf4f84eb4b51c520a9697b10967438f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7cf4f84eb4b51c520a9697b10967438f">populateStorageSpecifierToLLVMPatterns</a> (<a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a7cf4f84eb4b51c520a9697b10967438f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52fe837d33ee51beba517a1d44dbea3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa52fe837d33ee51beba517a1d44dbea3">createStorageSpecifierToLLVMPass</a> ()</td></tr>
<tr class="separator:aa52fe837d33ee51beba517a1d44dbea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4218327a76c03ad88d87dee6df15c634"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4218327a76c03ad88d87dee6df15c634">createSparsificationAndBufferizationPass</a> (const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">bufferization::OneShotBufferizationOptions</a> &amp;bufferizationOptions, const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;sparsificationOptions, const <a class="el" href="structmlir_1_1SparseTensorConversionOptions.html">SparseTensorConversionOptions</a> &amp;sparseTensorConversionOptions, bool createSparseDeallocs, bool enableRuntimeLibrary, bool enableBufferInitialization, unsigned vectorLength, bool enableVLAVectorization, bool enableSIMDIndex32)</td></tr>
<tr class="separator:a4218327a76c03ad88d87dee6df15c634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6168f425252f728e066433be9ee022b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6168f425252f728e066433be9ee022b2">populateSparseBufferRewriting</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool enableBufferInitialization)</td></tr>
<tr class="separator:a6168f425252f728e066433be9ee022b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52922b4f9a9b71d07318a65565e1d95d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a52922b4f9a9b71d07318a65565e1d95d">createSparseBufferRewritePass</a> ()</td></tr>
<tr class="separator:a52922b4f9a9b71d07318a65565e1d95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c5d254155d499befa419181f2539ea"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa9c5d254155d499befa419181f2539ea">createSparseBufferRewritePass</a> (bool enableBufferInitialization)</td></tr>
<tr class="separator:aa9c5d254155d499befa419181f2539ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76dc06de29760922469c1e4bd10a62c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a76dc06de29760922469c1e4bd10a62c9">populateSparseVectorizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, unsigned vectorLength, bool enableVLAVectorization, bool enableSIMDIndex32)</td></tr>
<tr class="memdesc:a76dc06de29760922469c1e4bd10a62c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the given patterns list with vectorization rules.  <a href="namespacemlir.html#a76dc06de29760922469c1e4bd10a62c9">More...</a><br /></td></tr>
<tr class="separator:a76dc06de29760922469c1e4bd10a62c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a9ca41ccfad286cda8688e8d66f588"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a06a9ca41ccfad286cda8688e8d66f588">createSparseVectorizationPass</a> ()</td></tr>
<tr class="separator:a06a9ca41ccfad286cda8688e8d66f588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3399bec16625e6af75488bb739d48d4c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3399bec16625e6af75488bb739d48d4c">createSparseVectorizationPass</a> (unsigned vectorLength, bool enableVLAVectorization, bool enableSIMDIndex32)</td></tr>
<tr class="separator:a3399bec16625e6af75488bb739d48d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48873e0e6f944a5579b28be3cc1c944"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad48873e0e6f944a5579b28be3cc1c944">populateSparseGPUCodegenPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, unsigned numThreads)</td></tr>
<tr class="separator:ad48873e0e6f944a5579b28be3cc1c944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa7d8a0754783f37e6e38a77c7e8116"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2fa7d8a0754783f37e6e38a77c7e8116">createSparseGPUCodegenPass</a> ()</td></tr>
<tr class="separator:a2fa7d8a0754783f37e6e38a77c7e8116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145b51940ed730f152b315db4e82cae5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a145b51940ed730f152b315db4e82cae5">createSparseGPUCodegenPass</a> (unsigned numThreads)</td></tr>
<tr class="separator:a145b51940ed730f152b315db4e82cae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdbef9427aac1eeac4dbf017bae583b"><td class="memTemplParams" colspan="2">template&lt;typename EnumClass , typename ParserType &gt; </td></tr>
<tr class="memitem:a4cdbef9427aac1eeac4dbf017bae583b"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4cdbef9427aac1eeac4dbf017bae583b">parseEnumKeywordAttr</a> (EnumClass &amp;value, ParserType &amp;parser, StringRef attrName=spirv::attributeName&lt; EnumClass &gt;())</td></tr>
<tr class="memdesc:a4cdbef9427aac1eeac4dbf017bae583b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the next keyword in <code>parser</code> as an enumerant of the given <code>EnumClass</code>.  <a href="namespacemlir.html#a4cdbef9427aac1eeac4dbf017bae583b">More...</a><br /></td></tr>
<tr class="separator:a4cdbef9427aac1eeac4dbf017bae583b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9a918bfb0fc3727c4d2490164be0c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3a9a918bfb0fc3727c4d2490164be0c3">populateBuiltinFuncToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a3a9a918bfb0fc3727c4d2490164be0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating the builtin <code>func</code> op to the SPIR-V dialect.  <a href="namespacemlir.html#a3a9a918bfb0fc3727c4d2490164be0c3">More...</a><br /></td></tr>
<tr class="separator:a3a9a918bfb0fc3727c4d2490164be0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7739fe988f31077f0005b73f457eb373"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DiagnosedDefiniteFailure.html">DiagnosedDefiniteFailure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7739fe988f31077f0005b73f457eb373">emitDefiniteFailure</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message)</td></tr>
<tr class="memdesc:a7739fe988f31077f0005b73f457eb373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a definite failure with the given message.  <a href="namespacemlir.html#a7739fe988f31077f0005b73f457eb373">More...</a><br /></td></tr>
<tr class="separator:a7739fe988f31077f0005b73f457eb373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f82005038ea404596c74643db0d564f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DiagnosedDefiniteFailure.html">DiagnosedDefiniteFailure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1f82005038ea404596c74643db0d564f">emitDefiniteFailure</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const Twine &amp;message={})</td></tr>
<tr class="separator:a1f82005038ea404596c74643db0d564f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428b91d18eabd5b259a3ed6e0f27f60c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a428b91d18eabd5b259a3ed6e0f27f60c">emitSilenceableFailure</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message={})</td></tr>
<tr class="memdesc:a428b91d18eabd5b259a3ed6e0f27f60c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a silenceable failure with the given message.  <a href="namespacemlir.html#a428b91d18eabd5b259a3ed6e0f27f60c">More...</a><br /></td></tr>
<tr class="separator:a428b91d18eabd5b259a3ed6e0f27f60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078c07e9f16a6122a56bae420ce94308"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a078c07e9f16a6122a56bae420ce94308">emitSilenceableFailure</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const Twine &amp;message={})</td></tr>
<tr class="separator:a078c07e9f16a6122a56bae420ce94308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93db6f545964ed23f06b57618f09b33a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a93db6f545964ed23f06b57618f09b33a">computeSuffixProduct</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes)</td></tr>
<tr class="memdesc:a93db6f545964ed23f06b57618f09b33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of sizes, return the suffix product.  <a href="namespacemlir.html#a93db6f545964ed23f06b57618f09b33a">More...</a><br /></td></tr>
<tr class="separator:a93db6f545964ed23f06b57618f09b33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f80386c0deb6ec32cbf4c8f3b929c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a41f80386c0deb6ec32cbf4c8f3b929c3">computeStrides</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes)</td></tr>
<tr class="separator:a41f80386c0deb6ec32cbf4c8f3b929c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7ccdb269314ad17ee4550b4bcb608a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1c7ccdb269314ad17ee4550b4bcb608a">computeElementwiseMul</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; v1, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; v2)</td></tr>
<tr class="memdesc:a1c7ccdb269314ad17ee4550b4bcb608a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing llvm::zip_equal(v1, v2) multiplied elementwise.  <a href="namespacemlir.html#a1c7ccdb269314ad17ee4550b4bcb608a">More...</a><br /></td></tr>
<tr class="separator:a1c7ccdb269314ad17ee4550b4bcb608a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c157bd2c9cf4949b45235593f6ef994"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9c157bd2c9cf4949b45235593f6ef994">computeMaxLinearIndex</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; basis)</td></tr>
<tr class="memdesc:a9c157bd2c9cf4949b45235593f6ef994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements of basis (i.e.  <a href="namespacemlir.html#a9c157bd2c9cf4949b45235593f6ef994">More...</a><br /></td></tr>
<tr class="separator:a9c157bd2c9cf4949b45235593f6ef994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84b6a6dfd9d9eb78ca02c17cabbebed"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac84b6a6dfd9d9eb78ca02c17cabbebed">linearize</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; offsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; basis)</td></tr>
<tr class="memdesc:ac84b6a6dfd9d9eb78ca02c17cabbebed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linearized index of 'offsets' w.r.t.  <a href="namespacemlir.html#ac84b6a6dfd9d9eb78ca02c17cabbebed">More...</a><br /></td></tr>
<tr class="separator:ac84b6a6dfd9d9eb78ca02c17cabbebed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448d2cc69bc47c1304f4f1608937c3c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a448d2cc69bc47c1304f4f1608937c3c4">delinearize</a> (int64_t linearIndex, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; strides)</td></tr>
<tr class="memdesc:a448d2cc69bc47c1304f4f1608937c3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the strides together with a linear index in the dimension space, return the vector-space offsets in each dimension for a de-linearized index.  <a href="namespacemlir.html#a448d2cc69bc47c1304f4f1608937c3c4">More...</a><br /></td></tr>
<tr class="separator:a448d2cc69bc47c1304f4f1608937c3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c2ae63c247a9ba4509c8d1181127b0"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad1c2ae63c247a9ba4509c8d1181127b0">computeShapeRatio</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; subShape)</td></tr>
<tr class="memdesc:ad1c2ae63c247a9ba4509c8d1181127b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the multi-dimensional integral ratio of <code>subShape</code> to the trailing dimensions of <code>shape</code>.  <a href="namespacemlir.html#ad1c2ae63c247a9ba4509c8d1181127b0">More...</a><br /></td></tr>
<tr class="separator:ad1c2ae63c247a9ba4509c8d1181127b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530d6a928389d2f4c0234b059442a03a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a530d6a928389d2f4c0234b059442a03a">computeSuffixProduct</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; sizes)</td></tr>
<tr class="memdesc:a530d6a928389d2f4c0234b059442a03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of sizes, return the suffix product.  <a href="namespacemlir.html#a530d6a928389d2f4c0234b059442a03a">More...</a><br /></td></tr>
<tr class="separator:a530d6a928389d2f4c0234b059442a03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b9af9c7621d308e75814d488a9f6d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a53b9af9c7621d308e75814d488a9f6d7">computeStrides</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; sizes)</td></tr>
<tr class="separator:a53b9af9c7621d308e75814d488a9f6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f77472da918076c9d2a222a501823f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad0f77472da918076c9d2a222a501823f">computeElementwiseMul</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; v1, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; v2)</td></tr>
<tr class="memdesc:ad0f77472da918076c9d2a222a501823f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing llvm::zip_equal(v1, v2) multiplied elementwise.  <a href="namespacemlir.html#ad0f77472da918076c9d2a222a501823f">More...</a><br /></td></tr>
<tr class="separator:ad0f77472da918076c9d2a222a501823f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2248838afeb293df08c1731f2d12fc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac2248838afeb293df08c1731f2d12fc2">computeMaxLinearIndex</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; basis)</td></tr>
<tr class="memdesc:ac2248838afeb293df08c1731f2d12fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements of basis (i.e.  <a href="namespacemlir.html#ac2248838afeb293df08c1731f2d12fc2">More...</a><br /></td></tr>
<tr class="separator:ac2248838afeb293df08c1731f2d12fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e83fe20fc8231df5769e1eebe268bdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3e83fe20fc8231df5769e1eebe268bdd">linearize</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; offsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; basis)</td></tr>
<tr class="memdesc:a3e83fe20fc8231df5769e1eebe268bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linearized index of 'offsets' w.r.t.  <a href="namespacemlir.html#a3e83fe20fc8231df5769e1eebe268bdd">More...</a><br /></td></tr>
<tr class="separator:a3e83fe20fc8231df5769e1eebe268bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0b8417b72fde91ffbc7d792fc97121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1c0b8417b72fde91ffbc7d792fc97121">linearize</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; offsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; basis)</td></tr>
<tr class="separator:a1c0b8417b72fde91ffbc7d792fc97121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1041856e784cdbf7811cd10bc5a5ffd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1041856e784cdbf7811cd10bc5a5ffd6">delinearize</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> linearIndex, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; strides)</td></tr>
<tr class="memdesc:a1041856e784cdbf7811cd10bc5a5ffd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the strides together with a linear index in the dimension space, return the vector-space offsets in each dimension for a de-linearized index.  <a href="namespacemlir.html#a1041856e784cdbf7811cd10bc5a5ffd6">More...</a><br /></td></tr>
<tr class="separator:a1041856e784cdbf7811cd10bc5a5ffd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2830e5f60c269c339ef24c33d8f7fbf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2830e5f60c269c339ef24c33d8f7fbf0">delinearize</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> linearIndex, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; strides)</td></tr>
<tr class="separator:a2830e5f60c269c339ef24c33d8f7fbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcff71555e8c1965e508f324f43a55a"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned N&gt; </td></tr>
<tr class="memitem:adbcff71555e8c1965e508f324f43a55a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adbcff71555e8c1965e508f324f43a55a">applyPermutationToVector</a> (<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T, N &gt; &amp;inVec, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; permutation)</td></tr>
<tr class="memdesc:adbcff71555e8c1965e508f324f43a55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the permutation defined by <code>permutation</code> to <code>inVec</code>.  <a href="namespacemlir.html#adbcff71555e8c1965e508f324f43a55a">More...</a><br /></td></tr>
<tr class="separator:adbcff71555e8c1965e508f324f43a55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc254f56cba37671e1e5b2b933c6a090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afc254f56cba37671e1e5b2b933c6a090">invertPermutationVector</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; permutation)</td></tr>
<tr class="memdesc:afc254f56cba37671e1e5b2b933c6a090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to apply to inverse a permutation.  <a href="namespacemlir.html#afc254f56cba37671e1e5b2b933c6a090">More...</a><br /></td></tr>
<tr class="separator:afc254f56cba37671e1e5b2b933c6a090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb49fb26d8c1e3dc571db7ff9e34cb7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeb49fb26d8c1e3dc571db7ff9e34cb7f">isPermutationVector</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; interchange)</td></tr>
<tr class="memdesc:aeb49fb26d8c1e3dc571db7ff9e34cb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to check if an interchange vector is a permutation.  <a href="namespacemlir.html#aeb49fb26d8c1e3dc571db7ff9e34cb7f">More...</a><br /></td></tr>
<tr class="separator:aeb49fb26d8c1e3dc571db7ff9e34cb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eab61c26bfef3d7aaf3db051d58230b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6eab61c26bfef3d7aaf3db051d58230b">computePermutationVector</a> (int64_t permSize, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; positions, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; desiredPositions)</td></tr>
<tr class="memdesc:a6eab61c26bfef3d7aaf3db051d58230b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a permutation vector of size permSize that would result in moving positions into desiredPositions.  <a href="namespacemlir.html#a6eab61c26bfef3d7aaf3db051d58230b">More...</a><br /></td></tr>
<tr class="separator:a6eab61c26bfef3d7aaf3db051d58230b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84637d8636fade36ebdd466b38527c23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a84637d8636fade36ebdd466b38527c23">getI64SubArray</a> (ArrayAttr arrayAttr, unsigned <a class="el" href="CRunnerUtils_8h.html#aa3eaa688e40e1afbf39c1a4736aae30b">dropFront</a>=0, unsigned dropBack=0)</td></tr>
<tr class="memdesc:a84637d8636fade36ebdd466b38527c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to return a subset of <code>arrayAttr</code> as a vector of int64_t.  <a href="namespacemlir.html#a84637d8636fade36ebdd466b38527c23">More...</a><br /></td></tr>
<tr class="separator:a84637d8636fade36ebdd466b38527c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12acf2020ef95ce0a5d7c3f2bbb6af14"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a12acf2020ef95ce0a5d7c3f2bbb6af14">getReassociationAttrName</a> ()</td></tr>
<tr class="memdesc:a12acf2020ef95ce0a5d7c3f2bbb6af14"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> name for the ArrayAttr which encodes reassociation indices.  <a href="namespacemlir.html#a12acf2020ef95ce0a5d7c3f2bbb6af14">More...</a><br /></td></tr>
<tr class="separator:a12acf2020ef95ce0a5d7c3f2bbb6af14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab965622bbf0ccdfcb51384517fd3117"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aab965622bbf0ccdfcb51384517fd3117">composeReassociationIndices</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; producerReassociations, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; consumerReassociations, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:aab965622bbf0ccdfcb51384517fd3117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose reassociation maps that are used in pair of reshape ops where one is a producer and other is the consumer.  <a href="namespacemlir.html#aab965622bbf0ccdfcb51384517fd3117">More...</a><br /></td></tr>
<tr class="separator:aab965622bbf0ccdfcb51384517fd3117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2799e8f52860dadc460b88a8f2df32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2 &gt;, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9b2799e8f52860dadc460b88a8f2df32">convertReassociationIndicesToExprs</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; reassociationIndices)</td></tr>
<tr class="memdesc:a9b2799e8f52860dadc460b88a8f2df32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert reassociation indices to affine expressions.  <a href="namespacemlir.html#a9b2799e8f52860dadc460b88a8f2df32">More...</a><br /></td></tr>
<tr class="separator:a9b2799e8f52860dadc460b88a8f2df32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561d5231fcefc471a4c9069fce2eaf87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a561d5231fcefc471a4c9069fce2eaf87">getSymbolLessAffineMaps</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ae5cf0e24a954fa30fb469105d4ca5dd8">ReassociationExprs</a> &gt; reassociation)</td></tr>
<tr class="memdesc:a561d5231fcefc471a4c9069fce2eaf87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs affine maps out of Array&lt;Array&lt;AffineExpr&gt;&gt;.  <a href="namespacemlir.html#a561d5231fcefc471a4c9069fce2eaf87">More...</a><br /></td></tr>
<tr class="separator:a561d5231fcefc471a4c9069fce2eaf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecbdeef85cdbc2ce3b49a088fa5946a"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8ecbdeef85cdbc2ce3b49a088fa5946a">getReassociationIndicesAttribute</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; reassociation)</td></tr>
<tr class="memdesc:a8ecbdeef85cdbc2ce3b49a088fa5946a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a list of reassociations in an ArrayAttr.  <a href="namespacemlir.html#a8ecbdeef85cdbc2ce3b49a088fa5946a">More...</a><br /></td></tr>
<tr class="separator:a8ecbdeef85cdbc2ce3b49a088fa5946a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ef18cead6fd6974a5031544f3c46cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af3ef18cead6fd6974a5031544f3c46cb">convertReassociationMapsToIndices</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ae5cf0e24a954fa30fb469105d4ca5dd8">ReassociationExprs</a> &gt; reassociationExprs)</td></tr>
<tr class="memdesc:af3ef18cead6fd6974a5031544f3c46cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Array&lt;Array&lt;AffineExpr&gt;&gt; to Array&lt;Array&lt;int64_t&gt;&gt;.  <a href="namespacemlir.html#af3ef18cead6fd6974a5031544f3c46cb">More...</a><br /></td></tr>
<tr class="separator:af3ef18cead6fd6974a5031544f3c46cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6783c78835273b8062a5b5e2a710d863"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6783c78835273b8062a5b5e2a710d863">getReassociationIndicesForReshape</a> (ShapedType sourceType, ShapedType targetType)</td></tr>
<tr class="memdesc:a6783c78835273b8062a5b5e2a710d863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reassociations maps to use to reshape given the source type and the target type when possible.  <a href="namespacemlir.html#a6783c78835273b8062a5b5e2a710d863">More...</a><br /></td></tr>
<tr class="separator:a6783c78835273b8062a5b5e2a710d863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b303e750705222900d23e44f2a22ce"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a76b303e750705222900d23e44f2a22ce">getReassociationIndicesForCollapse</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sourceShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; targetShape)</td></tr>
<tr class="memdesc:a76b303e750705222900d23e44f2a22ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reassociation maps to collapse <code>sourceShape</code> to <code>targetShape</code> if possible.  <a href="namespacemlir.html#a76b303e750705222900d23e44f2a22ce">More...</a><br /></td></tr>
<tr class="separator:a76b303e750705222900d23e44f2a22ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3d6f94b6a941066c3e7e5535817a9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9e3d6f94b6a941066c3e7e5535817a9b">isReassociationValid</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; reassociation, int *invalidIndex=nullptr)</td></tr>
<tr class="memdesc:a9e3d6f94b6a941066c3e7e5535817a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the reassociation specification is valid, false otherwise.  <a href="namespacemlir.html#a9e3d6f94b6a941066c3e7e5535817a9b">More...</a><br /></td></tr>
<tr class="separator:a9e3d6f94b6a941066c3e7e5535817a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0271e4a2b1e694242618a6e91a9c37"><td class="memTemplParams" colspan="2">template&lt;typename ReshapeOpTy , typename InverseReshapeOpTy &gt; </td></tr>
<tr class="memitem:a2b0271e4a2b1e694242618a6e91a9c37"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2b0271e4a2b1e694242618a6e91a9c37">foldReshapeOp</a> (ReshapeOpTy reshapeOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands)</td></tr>
<tr class="separator:a2b0271e4a2b1e694242618a6e91a9c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e37ef38e035b072204c4cc6f2bc6a5"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename T &gt; </td></tr>
<tr class="memitem:a59e37ef38e035b072204c4cc6f2bc6a5"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a59e37ef38e035b072204c4cc6f2bc6a5">verifyReshapeLikeTypes</a> (<a class="el" href="classmlir_1_1Op.html">Op</a> op, T expandedType, T collapsedType, bool isExpansion)</td></tr>
<tr class="memdesc:a59e37ef38e035b072204c4cc6f2bc6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common verifier for reshape-like types.  <a href="namespacemlir.html#a59e37ef38e035b072204c4cc6f2bc6a5">More...</a><br /></td></tr>
<tr class="separator:a59e37ef38e035b072204c4cc6f2bc6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a364dd32a6190474be758d1a6b9d5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a64a364dd32a6190474be758d1a6b9d5f">reshapeLikeShapesAreCompatible</a> (<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(const Twine &amp;)&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; collapsedShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; expandedShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; reassociationMaps, bool isExpandingReshape)</td></tr>
<tr class="memdesc:a64a364dd32a6190474be758d1a6b9d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that shapes of the reshaped types using following rules 1) if a dimension in the collapsed type is static, then the corresponding dimensions in the expanded shape should be a) static b) the product should be same as the collaped shape.  <a href="namespacemlir.html#a64a364dd32a6190474be758d1a6b9d5f">More...</a><br /></td></tr>
<tr class="separator:a64a364dd32a6190474be758d1a6b9d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29ab36fc05840316f3a7e56271818a6"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:ad29ab36fc05840316f3a7e56271818a6"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad29ab36fc05840316f3a7e56271818a6">verifyReshapeLikeShapes</a> (OpTy op, ShapedType collapsedType, ShapedType expandedType, bool isExpandingReshape)</td></tr>
<tr class="separator:ad29ab36fc05840316f3a7e56271818a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1858ec5ab152ee2a09d4ceaf95cf2811"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1858ec5ab152ee2a09d4ceaf95cf2811">hasNonIdentityLayout</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memdesc:a1858ec5ab152ee2a09d4ceaf95cf2811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the type is a MemRefType and has a non-identity layout.  <a href="namespacemlir.html#a1858ec5ab152ee2a09d4ceaf95cf2811">More...</a><br /></td></tr>
<tr class="separator:a1858ec5ab152ee2a09d4ceaf95cf2811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10337918edd90e6a270db09d71d66dc5"><td class="memItemLeft" align="right" valign="top">llvm::SmallBitVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a10337918edd90e6a270db09d71d66dc5">getSlicedDimensions</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sliceInputShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; sliceParams)</td></tr>
<tr class="memdesc:a10337918edd90e6a270db09d71d66dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input parameters <code>offsets</code>, <code>sizes</code>, <code>strides</code> specify a rectangular non rank-reducing slice of the collapse_shape output.  <a href="namespacemlir.html#a10337918edd90e6a270db09d71d66dc5">More...</a><br /></td></tr>
<tr class="separator:a10337918edd90e6a270db09d71d66dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace39a548030ae8416f5ae52af1eb24e1"><td class="memItemLeft" align="right" valign="top">llvm::SmallBitVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ace39a548030ae8416f5ae52af1eb24e1">getLinearizedDimensions</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; reassociationIndices)</td></tr>
<tr class="memdesc:ace39a548030ae8416f5ae52af1eb24e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine which dimensions are linearized by a <code>tensor.collapse_shape</code> op by inspecting its reassociation indices.  <a href="namespacemlir.html#ace39a548030ae8416f5ae52af1eb24e1">More...</a><br /></td></tr>
<tr class="separator:ace39a548030ae8416f5ae52af1eb24e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04dd9fbdfc3426b88a910e2e7ded495c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a04dd9fbdfc3426b88a910e2e7ded495c">isZeroIndex</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> v)</td></tr>
<tr class="memdesc:a04dd9fbdfc3426b88a910e2e7ded495c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <code>v</code> is an IntegerAttr with value <code>0</code> of a ConstantIndexOp with attribute with value <code>0</code>.  <a href="namespacemlir.html#a04dd9fbdfc3426b88a910e2e7ded495c">More...</a><br /></td></tr>
<tr class="separator:a04dd9fbdfc3426b88a910e2e7ded495c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d96a98d184d13853b53c410d814775c"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0d96a98d184d13853b53c410d814775c">getOffsetsSizesAndStrides</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; ranges)</td></tr>
<tr class="memdesc:a0d96a98d184d13853b53c410d814775c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an array of <a class="el" href="structmlir_1_1Range.html" title="Represents a range (offset, size, and stride) where each element of the triple may be dynamic or stat...">Range</a> values, return a tuple of (offset vector, sizes vector, and strides vector) formed by separating out the individual elements of each range.  <a href="namespacemlir.html#a0d96a98d184d13853b53c410d814775c">More...</a><br /></td></tr>
<tr class="separator:a0d96a98d184d13853b53c410d814775c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9a8d86f0213b02a553c01aea31e6e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abf9a8d86f0213b02a553c01aea31e6e4">dispatchIndexOpFoldResult</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dynamicVec, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;staticVec)</td></tr>
<tr class="memdesc:abf9a8d86f0213b02a553c01aea31e6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to dispatch an <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> into <code>staticVec</code> if: a) it is an IntegerAttr In other cases, the <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> is dispached to the <code>dynamicVec</code>.  <a href="namespacemlir.html#abf9a8d86f0213b02a553c01aea31e6e4">More...</a><br /></td></tr>
<tr class="separator:abf9a8d86f0213b02a553c01aea31e6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923d05c8f39df57cf19f1ec709bbe5a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a923d05c8f39df57cf19f1ec709bbe5a5">dispatchIndexOpFoldResults</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ofrs, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dynamicVec, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;staticVec)</td></tr>
<tr class="memdesc:a923d05c8f39df57cf19f1ec709bbe5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to dispatch multiple OpFoldResults according to the behavior of <code>dispatchIndexOpFoldResult(<a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> ofr</code> for a single <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>.  <a href="namespacemlir.html#a923d05c8f39df57cf19f1ec709bbe5a5">More...</a><br /></td></tr>
<tr class="separator:a923d05c8f39df57cf19f1ec709bbe5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48355da3ce92decf18a91c2148e3d4c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a48355da3ce92decf18a91c2148e3d4c6">extractFromI64ArrayAttr</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:a48355da3ce92decf18a91c2148e3d4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract int64_t values from the assumed ArrayAttr of IntegerAttr.  <a href="namespacemlir.html#a48355da3ce92decf18a91c2148e3d4c6">More...</a><br /></td></tr>
<tr class="separator:a48355da3ce92decf18a91c2148e3d4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19b7af1333485b34ebfe4bf6300c362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac19b7af1333485b34ebfe4bf6300c362">getAsOpFoldResult</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:ac19b7af1333485b34ebfe4bf6300c362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a value, try to extract a constant <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>.  <a href="namespacemlir.html#ac19b7af1333485b34ebfe4bf6300c362">More...</a><br /></td></tr>
<tr class="separator:ac19b7af1333485b34ebfe4bf6300c362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4688956ac5cd539b0b3e134af30248"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0f4688956ac5cd539b0b3e134af30248">getAsOpFoldResult</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values)</td></tr>
<tr class="memdesc:a0f4688956ac5cd539b0b3e134af30248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an array of values, try to extract a constant <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> from each value.  <a href="namespacemlir.html#a0f4688956ac5cd539b0b3e134af30248">More...</a><br /></td></tr>
<tr class="separator:a0f4688956ac5cd539b0b3e134af30248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622f03f8cb8e4cfde7e34c30e9aa02b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a622f03f8cb8e4cfde7e34c30e9aa02b6">getAsOpFoldResult</a> (ArrayAttr arrayAttr)</td></tr>
<tr class="memdesc:a622f03f8cb8e4cfde7e34c30e9aa02b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <code>arrayAttr</code> to a vector of <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>.  <a href="namespacemlir.html#a622f03f8cb8e4cfde7e34c30e9aa02b6">More...</a><br /></td></tr>
<tr class="separator:a622f03f8cb8e4cfde7e34c30e9aa02b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c18958fe34840cfafad41a1226f7a68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0c18958fe34840cfafad41a1226f7a68">getAsIndexOpFoldResult</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, int64_t val)</td></tr>
<tr class="memdesc:a0c18958fe34840cfafad41a1226f7a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert int64_t to integer attributes of index type and return them as <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>.  <a href="namespacemlir.html#a0c18958fe34840cfafad41a1226f7a68">More...</a><br /></td></tr>
<tr class="separator:a0c18958fe34840cfafad41a1226f7a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18214f3aabbab8c3e5197b719ba72dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa18214f3aabbab8c3e5197b719ba72dc">getAsIndexOpFoldResult</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="separator:aa18214f3aabbab8c3e5197b719ba72dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bfcc5fa9deffb32e7c39183f732c90"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a22bfcc5fa9deffb32e7c39183f732c90">getConstantIntValue</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr)</td></tr>
<tr class="memdesc:a22bfcc5fa9deffb32e7c39183f732c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">If ofr is a constant integer or an IntegerAttr, return the integer.  <a href="namespacemlir.html#a22bfcc5fa9deffb32e7c39183f732c90">More...</a><br /></td></tr>
<tr class="separator:a22bfcc5fa9deffb32e7c39183f732c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043789541ff1881513700b717bf5491d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a043789541ff1881513700b717bf5491d">isConstantIntValue</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr, int64_t value)</td></tr>
<tr class="memdesc:a043789541ff1881513700b717bf5491d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <code>ofr</code> is constant integer equal to <code>value</code>.  <a href="namespacemlir.html#a043789541ff1881513700b717bf5491d">More...</a><br /></td></tr>
<tr class="separator:a043789541ff1881513700b717bf5491d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee77c6f0feb82212b1b817785f95f48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2ee77c6f0feb82212b1b817785f95f48">isEqualConstantIntOrValue</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr1, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr2)</td></tr>
<tr class="memdesc:a2ee77c6f0feb82212b1b817785f95f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if ofr1 and ofr2 are the same integer constant attribute values or the same SSA value.  <a href="namespacemlir.html#a2ee77c6f0feb82212b1b817785f95f48">More...</a><br /></td></tr>
<tr class="separator:a2ee77c6f0feb82212b1b817785f95f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03d63917414f04e985c804f24086b76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab03d63917414f04e985c804f24086b76">isEqualConstantIntOrValueArray</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ofrs1, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ofrs2)</td></tr>
<tr class="separator:ab03d63917414f04e985c804f24086b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe07ed04a2b4a8d370ba318bb94316a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abe07ed04a2b4a8d370ba318bb94316a2">getMixedValues</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; staticValues, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> dynamicValues, <a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;b)</td></tr>
<tr class="memdesc:abe07ed04a2b4a8d370ba318bb94316a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of OpFoldResults with the same size a staticValues, but all elements for which ShapedType::isDynamic is true, will be replaced by dynamicValues.  <a href="namespacemlir.html#abe07ed04a2b4a8d370ba318bb94316a2">More...</a><br /></td></tr>
<tr class="separator:abe07ed04a2b4a8d370ba318bb94316a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7485a65ba54d86caa67a0639e38504d3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; ArrayAttr, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7485a65ba54d86caa67a0639e38504d3">decomposeMixedValues</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;b, const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;mixedValues)</td></tr>
<tr class="memdesc:a7485a65ba54d86caa67a0639e38504d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a vector of mixed static or dynamic values into the corresponding pair of arrays.  <a href="namespacemlir.html#a7485a65ba54d86caa67a0639e38504d3">More...</a><br /></td></tr>
<tr class="separator:a7485a65ba54d86caa67a0639e38504d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b5c05e14ade6108624f49c4c8bf104"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae8b5c05e14ade6108624f49c4c8bf104">getValuesSortedByKey</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; keys, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; values, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt; compare)</td></tr>
<tr class="memdesc:ae8b5c05e14ade6108624f49c4c8bf104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to sort <code>values</code> according to matching <code>keys</code>.  <a href="namespacemlir.html#ae8b5c05e14ade6108624f49c4c8bf104">More...</a><br /></td></tr>
<tr class="separator:ae8b5c05e14ade6108624f49c4c8bf104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ec25d896f63f835649e57fa1156deb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af3ec25d896f63f835649e57fa1156deb">getValuesSortedByKey</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; keys, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; values, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt; compare)</td></tr>
<tr class="separator:af3ec25d896f63f835649e57fa1156deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2bf7271ea0c5e95377e621f7923baa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad2bf7271ea0c5e95377e621f7923baa7">getValuesSortedByKey</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; keys, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt; compare)</td></tr>
<tr class="separator:ad2bf7271ea0c5e95377e621f7923baa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694b6ad2c919c4bcef792aca11deda42"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a694b6ad2c919c4bcef792aca11deda42">constantTripCount</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> lb, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ub, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> step)</td></tr>
<tr class="memdesc:a694b6ad2c919c4bcef792aca11deda42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of iterations for a loop with a lower bound <code>lb</code>, upper bound <code>ub</code> and step <code>step</code>.  <a href="namespacemlir.html#a694b6ad2c919c4bcef792aca11deda42">More...</a><br /></td></tr>
<tr class="separator:a694b6ad2c919c4bcef792aca11deda42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53f9bcf99efe125a11237ad6b64642c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae53f9bcf99efe125a11237ad6b64642c">isRowMajorMatmul</a> (ArrayAttr indexingMaps)</td></tr>
<tr class="memdesc:ae53f9bcf99efe125a11237ad6b64642c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given maps describe a row major matmul.  <a href="namespacemlir.html#ae53f9bcf99efe125a11237ad6b64642c">More...</a><br /></td></tr>
<tr class="separator:ae53f9bcf99efe125a11237ad6b64642c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfea8ee2dd0eba944b0cd299591ccf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0dfea8ee2dd0eba944b0cd299591ccf9">isColumnMajorMatmul</a> (ArrayAttr indexingMaps)</td></tr>
<tr class="memdesc:a0dfea8ee2dd0eba944b0cd299591ccf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given maps describe a column major matmul.  <a href="namespacemlir.html#a0dfea8ee2dd0eba944b0cd299591ccf9">More...</a><br /></td></tr>
<tr class="separator:a0dfea8ee2dd0eba944b0cd299591ccf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28d7afae3a8e6d54489b5857b938d07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa28d7afae3a8e6d54489b5857b938d07">isRowMajorBatchMatmul</a> (ArrayAttr indexingMaps)</td></tr>
<tr class="memdesc:aa28d7afae3a8e6d54489b5857b938d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given maps describe a row major batch matmul.  <a href="namespacemlir.html#aa28d7afae3a8e6d54489b5857b938d07">More...</a><br /></td></tr>
<tr class="separator:aa28d7afae3a8e6d54489b5857b938d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb672e2258ecd8657ec36b0fd391208a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adb672e2258ecd8657ec36b0fd391208a">findPositionsOfType</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt; iteratorTypes, utils::IteratorType iteratorTypeName, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; unsigned &gt; &amp;res)</td></tr>
<tr class="memdesc:adb672e2258ecd8657ec36b0fd391208a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return positions in <code>iteratorTypes</code> that match <code>iteratorTypeName</code>.  <a href="namespacemlir.html#adb672e2258ecd8657ec36b0fd391208a">More...</a><br /></td></tr>
<tr class="separator:adb672e2258ecd8657ec36b0fd391208a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07dda6e0df087e91b18fdb2b8bfe5aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab07dda6e0df087e91b18fdb2b8bfe5aa">clone</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> newResultTypes, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newOperands)</td></tr>
<tr class="separator:ab07dda6e0df087e91b18fdb2b8bfe5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75b562b2c25a3d66295d10efde0b996"><td class="memTemplParams" colspan="2">template&lt;typename OpT &gt; </td></tr>
<tr class="memitem:aa75b562b2c25a3d66295d10efde0b996"><td class="memTemplItemLeft" align="right" valign="top">OpT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa75b562b2c25a3d66295d10efde0b996">clone</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, OpT op, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> newResultTypes, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newOperands)</td></tr>
<tr class="separator:aa75b562b2c25a3d66295d10efde0b996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49429f945b2bca0efdd4c315bb68505b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a49429f945b2bca0efdd4c315bb68505b">cloneWithoutRegions</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> newResultTypes, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newOperands)</td></tr>
<tr class="separator:a49429f945b2bca0efdd4c315bb68505b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba376b9b63ed400e64bb041e459a62e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeba376b9b63ed400e64bb041e459a62e">getPrunedAttributeList</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt; elidedAttrs)</td></tr>
<tr class="separator:aeba376b9b63ed400e64bb041e459a62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ec093f212c96c69468a9e7df149fb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac1ec093f212c96c69468a9e7df149fb5">populateX86VectorLegalizeForLLVMExportPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ac1ec093f212c96c69468a9e7df149fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to lower X86Vector ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="namespacemlir.html#ac1ec093f212c96c69468a9e7df149fb5">More...</a><br /></td></tr>
<tr class="separator:ac1ec093f212c96c69468a9e7df149fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8013cee2241cd53aa923b23e4e3575"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afa8013cee2241cd53aa923b23e4e3575">configureX86VectorLegalizeForExportTarget</a> (<a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:afa8013cee2241cd53aa923b23e4e3575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the target to support lowering X86Vector ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="namespacemlir.html#afa8013cee2241cd53aa923b23e4e3575">More...</a><br /></td></tr>
<tr class="separator:afa8013cee2241cd53aa923b23e4e3575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfe9337070eb0f67cb7a3098ee136ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4bfe9337070eb0f67cb7a3098ee136ee">JitRunnerMain</a> (int argc, char **argv, const <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry, <a class="el" href="structmlir_1_1JitRunnerConfig.html">JitRunnerConfig</a> config={})</td></tr>
<tr class="memdesc:a4bfe9337070eb0f67cb7a3098ee136ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for all CPU runners.  <a href="namespacemlir.html#a4bfe9337070eb0f67cb7a3098ee136ee">More...</a><br /></td></tr>
<tr class="separator:a4bfe9337070eb0f67cb7a3098ee136ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643fb5da616fe37fef528fbcf735b8ec"><td class="memItemLeft" align="right" valign="top">std::function&lt; llvm::Error(llvm::Module *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a643fb5da616fe37fef528fbcf735b8ec">makeOptimizingTransformer</a> (unsigned optLevel, unsigned sizeLevel, llvm::TargetMachine *targetMachine)</td></tr>
<tr class="memdesc:a643fb5da616fe37fef528fbcf735b8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a module transformer function for MLIR <a class="el" href="classmlir_1_1ExecutionEngine.html" title="JIT-backed execution engine for MLIR.">ExecutionEngine</a> that runs <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR passes corresponding to the given speed and size optimization levels (e.g.  <a href="namespacemlir.html#a643fb5da616fe37fef528fbcf735b8ec">More...</a><br /></td></tr>
<tr class="separator:a643fb5da616fe37fef528fbcf735b8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe55df95d48191f0fa2c5ab8f4e81e34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afe55df95d48191f0fa2c5ab8f4e81e34">registerAllDialects</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:afe55df95d48191f0fa2c5ab8f4e81e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all the MLIR dialects to the provided registry.  <a href="namespacemlir.html#afe55df95d48191f0fa2c5ab8f4e81e34">More...</a><br /></td></tr>
<tr class="separator:afe55df95d48191f0fa2c5ab8f4e81e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcd07e2ad26a58627d961ce8e544f1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5fcd07e2ad26a58627d961ce8e544f1b">registerAllDialects</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a5fcd07e2ad26a58627d961ce8e544f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append all the MLIR dialects to the registry contained in the given context.  <a href="namespacemlir.html#a5fcd07e2ad26a58627d961ce8e544f1b">More...</a><br /></td></tr>
<tr class="separator:a5fcd07e2ad26a58627d961ce8e544f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb552a159c6c887b98b3583dfd5cbe5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afb552a159c6c887b98b3583dfd5cbe5d">registerAllPasses</a> ()</td></tr>
<tr class="separator:afb552a159c6c887b98b3583dfd5cbe5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a267e7e7ec38e0a09285a20831414d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7a267e7e7ec38e0a09285a20831414d3">registerFromLLVMIRTranslation</a> ()</td></tr>
<tr class="separator:a7a267e7e7ec38e0a09285a20831414d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ef91a9901d4d87a042990ccb79f2be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a51ef91a9901d4d87a042990ccb79f2be">registerFromSPIRVTranslation</a> ()</td></tr>
<tr class="separator:a51ef91a9901d4d87a042990ccb79f2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520bc0aa5f34c15a39f2202fdf521382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a520bc0aa5f34c15a39f2202fdf521382">registerToCppTranslation</a> ()</td></tr>
<tr class="separator:a520bc0aa5f34c15a39f2202fdf521382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003d72c96a8bffacc207ba165212e2db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a003d72c96a8bffacc207ba165212e2db">registerToLLVMIRTranslation</a> ()</td></tr>
<tr class="separator:a003d72c96a8bffacc207ba165212e2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f5d34c37689ae9b05537a040d9e0a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af7f5d34c37689ae9b05537a040d9e0a0">registerToSPIRVTranslation</a> ()</td></tr>
<tr class="separator:af7f5d34c37689ae9b05537a040d9e0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d16808b31b66905b067720d428adf61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8d16808b31b66905b067720d428adf61">registerAllTranslations</a> ()</td></tr>
<tr class="separator:a8d16808b31b66905b067720d428adf61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426b7e62d7400b01d368a3db835df9d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a426b7e62d7400b01d368a3db835df9d3">insideMutuallyExclusiveRegions</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *a, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *b)</td></tr>
<tr class="memdesc:a426b7e62d7400b01d368a3db835df9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>a</code> and <code>b</code> are in mutually exclusive regions as per RegionBranchOpInterface.  <a href="namespacemlir.html#a426b7e62d7400b01d368a3db835df9d3">More...</a><br /></td></tr>
<tr class="separator:a426b7e62d7400b01d368a3db835df9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59222c6d1f54e57a5f71291f205911da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a59222c6d1f54e57a5f71291f205911da">getEnclosingRepetitiveRegion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a59222c6d1f54e57a5f71291f205911da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first enclosing region of the given op that may be executed repetitively as per RegionBranchOpInterface or <code>nullptr</code> if no such region exists.  <a href="namespacemlir.html#a59222c6d1f54e57a5f71291f205911da">More...</a><br /></td></tr>
<tr class="separator:a59222c6d1f54e57a5f71291f205911da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea4281da1b0006e0c9622cff14858a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abea4281da1b0006e0c9622cff14858a7">getEnclosingRepetitiveRegion</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:abea4281da1b0006e0c9622cff14858a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first enclosing region of the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> that may be executed repetitively as per RegionBranchOpInterface or <code>nullptr</code> if no such region exists.  <a href="namespacemlir.html#abea4281da1b0006e0c9622cff14858a7">More...</a><br /></td></tr>
<tr class="separator:abea4281da1b0006e0c9622cff14858a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9220af1b0ef10468f05c1e37e24371e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9220af1b0ef10468f05c1e37e24371e4">isRegionReturnLike</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *operation)</td></tr>
<tr class="memdesc:a9220af1b0ef10468f05c1e37e24371e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given operation is either annotated with the <code>ReturnLike</code> trait or implements the <code>RegionBranchTerminatorOpInterface</code>.  <a href="namespacemlir.html#a9220af1b0ef10468f05c1e37e24371e4">More...</a><br /></td></tr>
<tr class="separator:a9220af1b0ef10468f05c1e37e24371e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f0d71a753f94ea84efabe636ea4da7"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1MutableOperandRange.html">MutableOperandRange</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a27f0d71a753f94ea84efabe636ea4da7">getMutableRegionBranchSuccessorOperands</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *operation, std::optional&lt; unsigned &gt; regionIndex)</td></tr>
<tr class="memdesc:a27f0d71a753f94ea84efabe636ea4da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mutable operands that are passed to the region with the given <code>regionIndex</code>.  <a href="namespacemlir.html#a27f0d71a753f94ea84efabe636ea4da7">More...</a><br /></td></tr>
<tr class="separator:a27f0d71a753f94ea84efabe636ea4da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4b4f99b16bb38cda262c81fd2ad933"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5e4b4f99b16bb38cda262c81fd2ad933">getRegionBranchSuccessorOperands</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *operation, std::optional&lt; unsigned &gt; regionIndex)</td></tr>
<tr class="memdesc:a5e4b4f99b16bb38cda262c81fd2ad933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the read only operands that are passed to the region with the given <code>regionIndex</code>.  <a href="namespacemlir.html#a5e4b4f99b16bb38cda262c81fd2ad933">More...</a><br /></td></tr>
<tr class="separator:a5e4b4f99b16bb38cda262c81fd2ad933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24aeba82a83b5f51bfe338ed5156887a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a24aeba82a83b5f51bfe338ed5156887a">reifyResultShapes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0a5ee68dc80640e6ac9c4a6011d18bc1">ReifiedRankedShapedTypeDims</a> &amp;reifiedReturnShapes)</td></tr>
<tr class="memdesc:a24aeba82a83b5f51bfe338ed5156887a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reify the shape of the result of an operation (typically in terms of the shape of its operands).  <a href="namespacemlir.html#a24aeba82a83b5f51bfe338ed5156887a">More...</a><br /></td></tr>
<tr class="separator:a24aeba82a83b5f51bfe338ed5156887a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775618793f22a592cfb8ccf36831ca44"><td class="memTemplParams" colspan="2">template&lt;typename EffectTy &gt; </td></tr>
<tr class="memitem:a775618793f22a592cfb8ccf36831ca44"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a775618793f22a592cfb8ccf36831ca44">hasSingleEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Value.html">Value</a> value=nullptr)</td></tr>
<tr class="memdesc:a775618793f22a592cfb8ccf36831ca44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>op</code> has only an effect of type <code>EffectTy</code> (and of no other type) on <code>value</code>.  <a href="namespacemlir.html#a775618793f22a592cfb8ccf36831ca44">More...</a><br /></td></tr>
<tr class="separator:a775618793f22a592cfb8ccf36831ca44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421cf43aced4fd4aff1907fa48080b4e"><td class="memTemplParams" colspan="2">template&lt;typename... EffectTys&gt; </td></tr>
<tr class="memitem:a421cf43aced4fd4aff1907fa48080b4e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a421cf43aced4fd4aff1907fa48080b4e">hasEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Value.html">Value</a> value=nullptr)</td></tr>
<tr class="memdesc:a421cf43aced4fd4aff1907fa48080b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>op</code> has an effect of type <code>EffectTy</code> on <code>value</code>.  <a href="namespacemlir.html#a421cf43aced4fd4aff1907fa48080b4e">More...</a><br /></td></tr>
<tr class="separator:a421cf43aced4fd4aff1907fa48080b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8583719d6a8f0699c36ac4c4b53057f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8583719d6a8f0699c36ac4c4b53057f2">isOpTriviallyDead</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a8583719d6a8f0699c36ac4c4b53057f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given operation is unused, and has no side effects on memory that prevent erasing.  <a href="namespacemlir.html#a8583719d6a8f0699c36ac4c4b53057f2">More...</a><br /></td></tr>
<tr class="separator:a8583719d6a8f0699c36ac4c4b53057f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655db45ed8c23d04d5ed5ee0abe041ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a655db45ed8c23d04d5ed5ee0abe041ad">wouldOpBeTriviallyDead</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a655db45ed8c23d04d5ed5ee0abe041ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given operation would be dead if unused, and has no side effects on memory that would prevent erasing.  <a href="namespacemlir.html#a655db45ed8c23d04d5ed5ee0abe041ad">More...</a><br /></td></tr>
<tr class="separator:a655db45ed8c23d04d5ed5ee0abe041ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5799849a369b839d27241c96a9572de7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5799849a369b839d27241c96a9572de7">isMemoryEffectFree</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a5799849a369b839d27241c96a9572de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given operation is free of memory effects.  <a href="namespacemlir.html#a5799849a369b839d27241c96a9572de7">More...</a><br /></td></tr>
<tr class="separator:a5799849a369b839d27241c96a9572de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2c465ce654633415e61167b64b8a91"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7a2c465ce654633415e61167b64b8a91">isSpeculatable</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a7a2c465ce654633415e61167b64b8a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given operation is speculatable, i.e.  <a href="namespacemlir.html#a7a2c465ce654633415e61167b64b8a91">More...</a><br /></td></tr>
<tr class="separator:a7a2c465ce654633415e61167b64b8a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550cdaef652bf5d59dfe33a15dc81af5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a550cdaef652bf5d59dfe33a15dc81af5">isPure</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a550cdaef652bf5d59dfe33a15dc81af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given operation is pure, i.e., is speculatable that does not touch memory.  <a href="namespacemlir.html#a550cdaef652bf5d59dfe33a15dc81af5">More...</a><br /></td></tr>
<tr class="separator:a550cdaef652bf5d59dfe33a15dc81af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c681ca596f8f10e3b69a87aa9973c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad4c681ca596f8f10e3b69a87aa9973c6">printDynamicIndexList</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a> values, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; integers, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a> delimiter=<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a>)</td></tr>
<tr class="memdesc:ad4c681ca596f8f10e3b69a87aa9973c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Printer hook for custom directive in assemblyFormat.  <a href="namespacemlir.html#ad4c681ca596f8f10e3b69a87aa9973c6">More...</a><br /></td></tr>
<tr class="separator:ad4c681ca596f8f10e3b69a87aa9973c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f4b6d36ff77aeffcb446b5822022c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac7f4b6d36ff77aeffcb446b5822022c5">parseDynamicIndexList</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;values, <a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a> &amp;integers, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a> delimiter=<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a>)</td></tr>
<tr class="memdesc:ac7f4b6d36ff77aeffcb446b5822022c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pasrer hook for custom directive in assemblyFormat.  <a href="namespacemlir.html#ac7f4b6d36ff77aeffcb446b5822022c5">More...</a><br /></td></tr>
<tr class="separator:ac7f4b6d36ff77aeffcb446b5822022c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a1c57fc94caa37e2b98499a48eea86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad1a1c57fc94caa37e2b98499a48eea86">verifyListOfOperandsOrIntegers</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, StringRef name, unsigned expectedNumElements, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; attr, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values)</td></tr>
<tr class="memdesc:ad1a1c57fc94caa37e2b98499a48eea86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that a the <code>values</code> has as many elements as the number of entries in <code>attr</code> for which <code>isDynamic</code> evaluates to true.  <a href="namespacemlir.html#ad1a1c57fc94caa37e2b98499a48eea86">More...</a><br /></td></tr>
<tr class="separator:ad1a1c57fc94caa37e2b98499a48eea86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9141d8b586a68549d2ecaccbce99a69"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad9141d8b586a68549d2ecaccbce99a69">hash_value</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> arg)</td></tr>
<tr class="memdesc:ad9141d8b586a68549d2ecaccbce99a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> hashable.  <a href="namespacemlir.html#ad9141d8b586a68549d2ecaccbce99a69">More...</a><br /></td></tr>
<tr class="separator:ad9141d8b586a68549d2ecaccbce99a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6f52bcd2d859c9d9a6f393ad5481c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8f6f52bcd2d859c9d9a6f393ad5481c1">operator+</a> (int64_t val, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="separator:a8f6f52bcd2d859c9d9a6f393ad5481c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9137193b56dc5134c3092273b13e3f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9137193b56dc5134c3092273b13e3f47">operator*</a> (int64_t val, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="separator:a9137193b56dc5134c3092273b13e3f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72aa3fc8e169b33e5d4a63f593172d4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a72aa3fc8e169b33e5d4a63f593172d4e">operator-</a> (int64_t val, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="separator:a72aa3fc8e169b33e5d4a63f593172d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfd4323ef72147332661606b030d04d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">getAffineDimExpr</a> (unsigned position, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:addfd4323ef72147332661606b030d04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">These free functions allow clients of the API to not use classes in detail.  <a href="namespacemlir.html#addfd4323ef72147332661606b030d04d">More...</a><br /></td></tr>
<tr class="separator:addfd4323ef72147332661606b030d04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb7ba5a55b4f16631528884d3617a47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aefb7ba5a55b4f16631528884d3617a47">getAffineSymbolExpr</a> (unsigned position, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="separator:aefb7ba5a55b4f16631528884d3617a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26cdced424aa629fde4150cc8674d50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">getAffineConstantExpr</a> (int64_t constant, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="separator:ab26cdced424aa629fde4150cc8674d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8a0f44c623301035b6151ca51cca4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6e8a0f44c623301035b6151ca51cca4d">getAffineBinaryOpExpr</a> (<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a> kind, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> lhs, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> rhs)</td></tr>
<tr class="separator:a6e8a0f44c623301035b6151ca51cca4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad71c14bebce843758768ff160e2283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8ad71c14bebce843758768ff160e2283">getAffineExprFromFlatForm</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; flatExprs, unsigned numDims, unsigned numSymbols, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; localExprs, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a8ad71c14bebce843758768ff160e2283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an affine expression from a flat ArrayRef.  <a href="namespacemlir.html#a8ad71c14bebce843758768ff160e2283">More...</a><br /></td></tr>
<tr class="separator:a8ad71c14bebce843758768ff160e2283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69078b1d3f3263a1769df2e0f1730df"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae69078b1d3f3263a1769df2e0f1730df">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="separator:ae69078b1d3f3263a1769df2e0f1730df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf369c69cfb613cd018ef4ce188809c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acbf369c69cfb613cd018ef4ce188809c">simplifyAffineExpr</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, unsigned numDims, unsigned numSymbols)</td></tr>
<tr class="memdesc:acbf369c69cfb613cd018ef4ce188809c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify an affine expression by flattening and some amount of simple analysis.  <a href="namespacemlir.html#acbf369c69cfb613cd018ef4ce188809c">More...</a><br /></td></tr>
<tr class="separator:acbf369c69cfb613cd018ef4ce188809c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d147ba82716614172eb7e9b5209d3eb"><td class="memTemplParams" colspan="2">template&lt;typename... AffineExprTy&gt; </td></tr>
<tr class="memitem:a3d147ba82716614172eb7e9b5209d3eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3d147ba82716614172eb7e9b5209d3eb">bindDims</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, AffineExprTy &amp;...exprs)</td></tr>
<tr class="memdesc:a3d147ba82716614172eb7e9b5209d3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a list of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> references to DimExpr at positions: [0 .  <a href="namespacemlir.html#a3d147ba82716614172eb7e9b5209d3eb">More...</a><br /></td></tr>
<tr class="separator:a3d147ba82716614172eb7e9b5209d3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c870d90073423151a32e2c0f2afa506"><td class="memTemplParams" colspan="2">template&lt;typename AffineExprTy &gt; </td></tr>
<tr class="memitem:a2c870d90073423151a32e2c0f2afa506"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2c870d90073423151a32e2c0f2afa506">bindDimsList</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineExprTy &gt; exprs)</td></tr>
<tr class="separator:a2c870d90073423151a32e2c0f2afa506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df39b3ef750e258dbe3dfe5b251cea5"><td class="memTemplParams" colspan="2">template&lt;typename... AffineExprTy&gt; </td></tr>
<tr class="memitem:a8df39b3ef750e258dbe3dfe5b251cea5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8df39b3ef750e258dbe3dfe5b251cea5">bindSymbols</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, AffineExprTy &amp;...exprs)</td></tr>
<tr class="memdesc:a8df39b3ef750e258dbe3dfe5b251cea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a list of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> references to SymbolExpr at positions: [0 .  <a href="namespacemlir.html#a8df39b3ef750e258dbe3dfe5b251cea5">More...</a><br /></td></tr>
<tr class="separator:a8df39b3ef750e258dbe3dfe5b251cea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af523defc0429b26ab3f85b7023748822"><td class="memTemplParams" colspan="2">template&lt;typename AffineExprTy &gt; </td></tr>
<tr class="memitem:af523defc0429b26ab3f85b7023748822"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af523defc0429b26ab3f85b7023748822">bindSymbolsList</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineExprTy &gt; exprs)</td></tr>
<tr class="separator:af523defc0429b26ab3f85b7023748822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032c893ca9a2fff3b16e5a7cb6d413cd"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a032c893ca9a2fff3b16e5a7cb6d413cd">hash_value</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> arg)</td></tr>
<tr class="separator:a032c893ca9a2fff3b16e5a7cb6d413cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014d8e82c51794d145267690b2b5bd58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a014d8e82c51794d145267690b2b5bd58">simplifyAffineMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a014d8e82c51794d145267690b2b5bd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies an affine map by simplifying its underlying <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> results.  <a href="namespacemlir.html#a014d8e82c51794d145267690b2b5bd58">More...</a><br /></td></tr>
<tr class="separator:a014d8e82c51794d145267690b2b5bd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05caafff59182b2191e4645cdceb5d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab05caafff59182b2191e4645cdceb5d5">compressDims</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, const llvm::SmallBitVector &amp;unusedDims)</td></tr>
<tr class="memdesc:ab05caafff59182b2191e4645cdceb5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the dims that are listed in <code>unusedDims</code>.  <a href="namespacemlir.html#ab05caafff59182b2191e4645cdceb5d5">More...</a><br /></td></tr>
<tr class="separator:ab05caafff59182b2191e4645cdceb5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f84d2ce14eec6c85a20251582e5cc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a99f84d2ce14eec6c85a20251582e5cc1">compressUnusedDims</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a99f84d2ce14eec6c85a20251582e5cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the dims that are not used.  <a href="namespacemlir.html#a99f84d2ce14eec6c85a20251582e5cc1">More...</a><br /></td></tr>
<tr class="separator:a99f84d2ce14eec6c85a20251582e5cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a3cbce4381f83b710fe6cfc9a867c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae2a3cbce4381f83b710fe6cfc9a867c9">compressUnusedDims</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps)</td></tr>
<tr class="memdesc:ae2a3cbce4381f83b710fe6cfc9a867c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the dims that are not used by any of the individual maps in <code>maps</code>.  <a href="namespacemlir.html#ae2a3cbce4381f83b710fe6cfc9a867c9">More...</a><br /></td></tr>
<tr class="separator:ae2a3cbce4381f83b710fe6cfc9a867c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de5b9ec7c351db7ed870d0df7248342"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6de5b9ec7c351db7ed870d0df7248342">compressSymbols</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, const llvm::SmallBitVector &amp;unusedSymbols)</td></tr>
<tr class="memdesc:a6de5b9ec7c351db7ed870d0df7248342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the symbols that are listed in <code>unusedSymbols</code>.  <a href="namespacemlir.html#a6de5b9ec7c351db7ed870d0df7248342">More...</a><br /></td></tr>
<tr class="separator:a6de5b9ec7c351db7ed870d0df7248342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c401a074fdcc1cb0efb7e5369b2ef3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae4c401a074fdcc1cb0efb7e5369b2ef3">compressUnusedSymbols</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:ae4c401a074fdcc1cb0efb7e5369b2ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the symbols that are not used.  <a href="namespacemlir.html#ae4c401a074fdcc1cb0efb7e5369b2ef3">More...</a><br /></td></tr>
<tr class="separator:ae4c401a074fdcc1cb0efb7e5369b2ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a26d1a643586acb4362f535168be129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4a26d1a643586acb4362f535168be129">compressUnusedSymbols</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps)</td></tr>
<tr class="memdesc:a4a26d1a643586acb4362f535168be129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the symbols that are not used by any of the individual maps in <code>maps</code>.  <a href="namespacemlir.html#a4a26d1a643586acb4362f535168be129">More...</a><br /></td></tr>
<tr class="separator:a4a26d1a643586acb4362f535168be129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa0a7e84eb2af3d70c98d59fc9ccbd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1fa0a7e84eb2af3d70c98d59fc9ccbd3">removeDuplicateExprs</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a1fa0a7e84eb2af3d70c98d59fc9ccbd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map with the same dimension and symbol count as <code>map</code>, but whose results are the unique affine expressions of <code>map</code>.  <a href="namespacemlir.html#a1fa0a7e84eb2af3d70c98d59fc9ccbd3">More...</a><br /></td></tr>
<tr class="separator:a1fa0a7e84eb2af3d70c98d59fc9ccbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b322818d83a2256d4e4391acbf78a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a52b322818d83a2256d4e4391acbf78a2">inversePermutation</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a52b322818d83a2256d4e4391acbf78a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map of codomain to domain dimensions such that the first codomain dimension for a particular domain dimension is selected.  <a href="namespacemlir.html#a52b322818d83a2256d4e4391acbf78a2">More...</a><br /></td></tr>
<tr class="separator:a52b322818d83a2256d4e4391acbf78a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39612be2ef116102866d3bb9c6a8ca88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a39612be2ef116102866d3bb9c6a8ca88">inverseAndBroadcastProjectedPermutation</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a39612be2ef116102866d3bb9c6a8ca88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reverse map of a projected permutation where the projected dimensions are transformed into 0s.  <a href="namespacemlir.html#a39612be2ef116102866d3bb9c6a8ca88">More...</a><br /></td></tr>
<tr class="separator:a39612be2ef116102866d3bb9c6a8ca88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d24d64d6db077b8d5c88316b0d6c717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6d24d64d6db077b8d5c88316b0d6c717">concatAffineMaps</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps)</td></tr>
<tr class="memdesc:a6d24d64d6db077b8d5c88316b0d6c717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a list of <code>maps</code> into a single <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a>, stepping over potentially empty maps.  <a href="namespacemlir.html#a6d24d64d6db077b8d5c88316b0d6c717">More...</a><br /></td></tr>
<tr class="separator:a6d24d64d6db077b8d5c88316b0d6c717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1261e0343cefe25ab1724c67005b7d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae1261e0343cefe25ab1724c67005b7d2">projectDims</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, const llvm::SmallBitVector &amp;projectedDimensions, bool compressDimsFlag=false)</td></tr>
<tr class="memdesc:ae1261e0343cefe25ab1724c67005b7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map that results from projecting out the dimensions specified in <code>projectedDimensions</code>.  <a href="namespacemlir.html#ae1261e0343cefe25ab1724c67005b7d2">More...</a><br /></td></tr>
<tr class="separator:ae1261e0343cefe25ab1724c67005b7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ec6082bc5758f83f4b0938b00b160d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae5ec6082bc5758f83f4b0938b00b160d">projectSymbols</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, const llvm::SmallBitVector &amp;projectedSymbols, bool compressSymbolsFlag=false)</td></tr>
<tr class="memdesc:ae5ec6082bc5758f83f4b0938b00b160d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol counterpart of <code>projectDims</code>.  <a href="namespacemlir.html#ae5ec6082bc5758f83f4b0938b00b160d">More...</a><br /></td></tr>
<tr class="separator:ae5ec6082bc5758f83f4b0938b00b160d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45e3ce76869b05848f96a5f8b97fc90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab45e3ce76869b05848f96a5f8b97fc90">getProjectedMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, const llvm::SmallBitVector &amp;projectedDimensions, bool compressDimsFlag=true, bool compressSymbolsFlag=true)</td></tr>
<tr class="memdesc:ab45e3ce76869b05848f96a5f8b97fc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>projectDims(map, projectedDimensions, compressDimsFlag)</code>.  <a href="namespacemlir.html#ab45e3ce76869b05848f96a5f8b97fc90">More...</a><br /></td></tr>
<tr class="separator:ab45e3ce76869b05848f96a5f8b97fc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61c6bb6068af953a0711cf404a99645"><td class="memItemLeft" align="right" valign="top">llvm::SmallBitVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac61c6bb6068af953a0711cf404a99645">getUnusedDimsBitVector</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps)</td></tr>
<tr class="separator:ac61c6bb6068af953a0711cf404a99645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2798707e1d2321021e16802305d3c152"><td class="memItemLeft" align="right" valign="top">llvm::SmallBitVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2798707e1d2321021e16802305d3c152">getUnusedSymbolsBitVector</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps)</td></tr>
<tr class="separator:a2798707e1d2321021e16802305d3c152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbb3252a45b5feab49c0bac2a68779c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0bbb3252a45b5feab49c0bac2a68779c">expandDimsToRank</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, int64_t rank, const llvm::SmallBitVector &amp;projectedDimensions)</td></tr>
<tr class="memdesc:a0bbb3252a45b5feab49c0bac2a68779c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand <code>map</code> to operate on <code>rank</code> dims while projecting out the dims in <code>projectedDimensions</code>.  <a href="namespacemlir.html#a0bbb3252a45b5feab49c0bac2a68779c">More...</a><br /></td></tr>
<tr class="separator:a0bbb3252a45b5feab49c0bac2a68779c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f93a44db5e2d93372201d5a594e51cd"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6f93a44db5e2d93372201d5a594e51cd">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="separator:a6f93a44db5e2d93372201d5a594e51cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b76f177cd65bd4fd394f9dc65d20be2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b76f177cd65bd4fd394f9dc65d20be2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2b76f177cd65bd4fd394f9dc65d20be2">applyPermutationMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; T &gt; source)</td></tr>
<tr class="memdesc:a2b76f177cd65bd4fd394f9dc65d20be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a permutation from <code>map</code> to <code>source</code> and return the result.  <a href="namespacemlir.html#a2b76f177cd65bd4fd394f9dc65d20be2">More...</a><br /></td></tr>
<tr class="separator:a2b76f177cd65bd4fd394f9dc65d20be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74485bec820f2186ce852a09f45ebd47"><td class="memTemplParams" colspan="2">template&lt;typename AffineExprContainer &gt; </td></tr>
<tr class="memitem:a74485bec820f2186ce852a09f45ebd47"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a74485bec820f2186ce852a09f45ebd47">getMaxDimAndSymbol</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineExprContainer &gt; exprsList, int64_t &amp;maxDim, int64_t &amp;maxSym)</td></tr>
<tr class="memdesc:a74485bec820f2186ce852a09f45ebd47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates maximum dimension and symbol positions from the expressions in <code>exprsLists</code> and stores them in <code>maxDim</code> and <code>maxSym</code> respectively.  <a href="namespacemlir.html#a74485bec820f2186ce852a09f45ebd47">More...</a><br /></td></tr>
<tr class="separator:a74485bec820f2186ce852a09f45ebd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e5dd60111e86e0df4b52a7d3befd33"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a23e5dd60111e86e0df4b52a7d3befd33">toString</a> (<a class="el" href="namespacemlir.html#ac84871bcca0aaa0176d43dbdbffe9a6c">AsmResourceEntryKind</a> kind)</td></tr>
<tr class="separator:a23e5dd60111e86e0df4b52a7d3befd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894a08aa6ed051f55e57bc35859a379f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a894a08aa6ed051f55e57bc35859a379f">registerAsmPrinterCLOptions</a> ()</td></tr>
<tr class="memdesc:a894a08aa6ed051f55e57bc35859a379f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of useful command-line options that can be used to configure various flags within the <a class="el" href="classmlir_1_1AsmPrinter.html" title="This base class exposes generic asm printer hooks, usable across the various derived printers.">AsmPrinter</a>.  <a href="namespacemlir.html#a894a08aa6ed051f55e57bc35859a379f">More...</a><br /></td></tr>
<tr class="separator:a894a08aa6ed051f55e57bc35859a379f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8f0e932c305de3ac1584560d1b03d0"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5e8f0e932c305de3ac1584560d1b03d0">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="separator:a5e8f0e932c305de3ac1584560d1b03d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bae84b1d7cdba11b048d9af3478a07"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a68bae84b1d7cdba11b048d9af3478a07">hash_value</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> arg)</td></tr>
<tr class="separator:a68bae84b1d7cdba11b048d9af3478a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b795f2f972c070efff53082563f976"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa4b795f2f972c070efff53082563f976">hash_value</a> (const <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &amp;arg)</td></tr>
<tr class="separator:aa4b795f2f972c070efff53082563f976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543c4328a4fa5ed530aa88a9d7d158a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a543c4328a4fa5ed530aa88a9d7d158a9">operator==</a> (StringAttr lhs, std::nullptr_t)</td></tr>
<tr class="memdesc:a543c4328a4fa5ed530aa88a9d7d158a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define comparisons for StringAttr against nullptr and itself to avoid the StringRef overloads from being chosen when not desirable.  <a href="namespacemlir.html#a543c4328a4fa5ed530aa88a9d7d158a9">More...</a><br /></td></tr>
<tr class="separator:a543c4328a4fa5ed530aa88a9d7d158a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db56ba5c170b04848e194937be59a56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8db56ba5c170b04848e194937be59a56">operator!=</a> (StringAttr lhs, std::nullptr_t)</td></tr>
<tr class="separator:a8db56ba5c170b04848e194937be59a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ce38cb70a016263f28574d4982475b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a40ce38cb70a016263f28574d4982475b">operator==</a> (StringAttr lhs, StringAttr rhs)</td></tr>
<tr class="separator:a40ce38cb70a016263f28574d4982475b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb385e3105982b905c5ef4db9f9f21b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6bb385e3105982b905c5ef4db9f9f21b">operator!=</a> (StringAttr lhs, StringAttr rhs)</td></tr>
<tr class="separator:a6bb385e3105982b905c5ef4db9f9f21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075d7bf5dfe5d33c409763bc28330180"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a075d7bf5dfe5d33c409763bc28330180">operator==</a> (StringAttr lhs, StringRef rhs)</td></tr>
<tr class="memdesc:a075d7bf5dfe5d33c409763bc28330180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow direct comparison with StringRef.  <a href="namespacemlir.html#a075d7bf5dfe5d33c409763bc28330180">More...</a><br /></td></tr>
<tr class="separator:a075d7bf5dfe5d33c409763bc28330180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48146d74baebce1c83140c378053f3c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a48146d74baebce1c83140c378053f3c2">operator!=</a> (StringAttr lhs, StringRef rhs)</td></tr>
<tr class="separator:a48146d74baebce1c83140c378053f3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c46bfb0a0fbbe700ef6c07a611dbf8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a50c46bfb0a0fbbe700ef6c07a611dbf8">operator==</a> (StringRef lhs, StringAttr rhs)</td></tr>
<tr class="separator:a50c46bfb0a0fbbe700ef6c07a611dbf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfbb1c5941d2cc005eb3f483e881202"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4bfbb1c5941d2cc005eb3f483e881202">operator!=</a> (StringRef lhs, StringAttr rhs)</td></tr>
<tr class="separator:a4bfbb1c5941d2cc005eb3f483e881202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923fafcbdcfdcb3b735fab2ab293a1ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a923fafcbdcfdcb3b735fab2ab293a1ad">makeStridedLinearLayoutMap</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; strides, int64_t offset, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a923fafcbdcfdcb3b735fab2ab293a1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of strides (in which ShapedType::kDynamic represents a dynamic value), return the single result <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> which represents the linearized strided layout map.  <a href="namespacemlir.html#a923fafcbdcfdcb3b735fab2ab293a1ad">More...</a><br /></td></tr>
<tr class="separator:a923fafcbdcfdcb3b735fab2ab293a1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f62cebc6176c66cb358ddbc17e3df7"><td class="memItemLeft" align="right" valign="top">std::optional&lt; llvm::SmallDenseSet&lt; unsigned &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa9f62cebc6176c66cb358ddbc17e3df7">computeRankReductionMask</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; originalShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; reducedShape)</td></tr>
<tr class="memdesc:aa9f62cebc6176c66cb358ddbc17e3df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an <code>originalShape</code> and a <code>reducedShape</code> assumed to be a subset of <code>originalShape</code> with some <code>1</code> entries erased, return the set of indices that specifies which of the entries of <code>originalShape</code> are dropped to obtain <code>reducedShape</code>.  <a href="namespacemlir.html#aa9f62cebc6176c66cb358ddbc17e3df7">More...</a><br /></td></tr>
<tr class="separator:aa9f62cebc6176c66cb358ddbc17e3df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae209f096d9240a818927afbab10f43b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">SliceVerificationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae209f096d9240a818927afbab10f43b8">isRankReducedType</a> (ShapedType originalType, ShapedType candidateReducedType)</td></tr>
<tr class="memdesc:ae209f096d9240a818927afbab10f43b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>originalType</code> can be rank reduced to <code>candidateReducedType</code> type by dropping some dimensions with static size <code>1</code>.  <a href="namespacemlir.html#ae209f096d9240a818927afbab10f43b8">More...</a><br /></td></tr>
<tr class="separator:ae209f096d9240a818927afbab10f43b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506c478f802ab2f874c0b34a18bc091b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a506c478f802ab2f874c0b34a18bc091b">getStridesAndOffset</a> (MemRefType t, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;strides, int64_t &amp;offset)</td></tr>
<tr class="memdesc:a506c478f802ab2f874c0b34a18bc091b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the strides of the MemRef if the layout map is in strided form.  <a href="namespacemlir.html#a506c478f802ab2f874c0b34a18bc091b">More...</a><br /></td></tr>
<tr class="separator:a506c478f802ab2f874c0b34a18bc091b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91209454b6a2bc993c1d3ebc2ac3aab1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a91209454b6a2bc993c1d3ebc2ac3aab1">getStridesAndOffset</a> (MemRefType t)</td></tr>
<tr class="memdesc:a91209454b6a2bc993c1d3ebc2ac3aab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around getStridesAndOffset(MemRefType, SmallVectorImpl&lt;int64_t&gt;, int64_t) that will assert if the logical result is not succeeded.  <a href="namespacemlir.html#a91209454b6a2bc993c1d3ebc2ac3aab1">More...</a><br /></td></tr>
<tr class="separator:a91209454b6a2bc993c1d3ebc2ac3aab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dcfbd64b4c5038926d874e46edeea2"><td class="memItemLeft" align="right" valign="top">MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a80dcfbd64b4c5038926d874e46edeea2">canonicalizeStridedLayout</a> (MemRefType t)</td></tr>
<tr class="memdesc:a80dcfbd64b4c5038926d874e46edeea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a version of <code>t</code> with identity layout if it can be determined statically that the layout is the canonical contiguous strided layout.  <a href="namespacemlir.html#a80dcfbd64b4c5038926d874e46edeea2">More...</a><br /></td></tr>
<tr class="separator:a80dcfbd64b4c5038926d874e46edeea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac603376cc0dac0b2bd27c2dcde3c2e14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac603376cc0dac0b2bd27c2dcde3c2e14">makeCanonicalStridedLayoutExpr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; exprs, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ac603376cc0dac0b2bd27c2dcde3c2e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given MemRef <code>sizes</code> that are either static or dynamic, returns the canonical "contiguous" strides <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a>.  <a href="namespacemlir.html#ac603376cc0dac0b2bd27c2dcde3c2e14">More...</a><br /></td></tr>
<tr class="separator:ac603376cc0dac0b2bd27c2dcde3c2e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25cd8672ecb721d7a4f0ecd22bac6e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad25cd8672ecb721d7a4f0ecd22bac6e8">makeCanonicalStridedLayoutExpr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ad25cd8672ecb721d7a4f0ecd22bac6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of makeCanonicalStrudedLayoutExpr for the common case where <code>exprs</code> is {d0, d1, .., d_(sizes.size()-1)}.  <a href="namespacemlir.html#ad25cd8672ecb721d7a4f0ecd22bac6e8">More...</a><br /></td></tr>
<tr class="separator:ad25cd8672ecb721d7a4f0ecd22bac6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c26bcf64137533f38f2cda9abd75af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad0c26bcf64137533f38f2cda9abd75af">isStrided</a> (MemRefType t)</td></tr>
<tr class="memdesc:ad0c26bcf64137533f38f2cda9abd75af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the layout for <code>t</code> is compatible with strided semantics.  <a href="namespacemlir.html#ad0c26bcf64137533f38f2cda9abd75af">More...</a><br /></td></tr>
<tr class="separator:ad0c26bcf64137533f38f2cda9abd75af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72e36349258a6b2baeae78188a74550"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae72e36349258a6b2baeae78188a74550">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1DiagnosticArgument.html">DiagnosticArgument</a> &amp;arg)</td></tr>
<tr class="separator:ae72e36349258a6b2baeae78188a74550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b9a8e647d5e73b7e107b0669ec9e29"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a85b9a8e647d5e73b7e107b0669ec9e29">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;<a class="el" href="ModuleImport_8cpp.html#a0ba25d7b0573f8dd5fd669095441a61e">diag</a>)</td></tr>
<tr class="separator:a85b9a8e647d5e73b7e107b0669ec9e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e96b0c437652eb5a4890734bb6bcee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a4e96b0c437652eb5a4890734bb6bcee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to emit an error message using this location.  <a href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">More...</a><br /></td></tr>
<tr class="separator:a4e96b0c437652eb5a4890734bb6bcee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc4e9418ff63ebea20c7f709ebcb0f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2dc4e9418ff63ebea20c7f709ebcb0f8">emitError</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message)</td></tr>
<tr class="separator:a2dc4e9418ff63ebea20c7f709ebcb0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0768c8a572dc71b0b00d57414b56b60d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0768c8a572dc71b0b00d57414b56b60d">emitWarning</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a0768c8a572dc71b0b00d57414b56b60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to emit a warning message using this location.  <a href="namespacemlir.html#a0768c8a572dc71b0b00d57414b56b60d">More...</a><br /></td></tr>
<tr class="separator:a0768c8a572dc71b0b00d57414b56b60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e96e5ea091fb5bea539cef6ea7c5624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5e96e5ea091fb5bea539cef6ea7c5624">emitWarning</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message)</td></tr>
<tr class="separator:a5e96e5ea091fb5bea539cef6ea7c5624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9ca6fe9d5aab498bf090db3e878c87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8a9ca6fe9d5aab498bf090db3e878c87">emitRemark</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a8a9ca6fe9d5aab498bf090db3e878c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to emit a remark message using this location.  <a href="namespacemlir.html#a8a9ca6fe9d5aab498bf090db3e878c87">More...</a><br /></td></tr>
<tr class="separator:a8a9ca6fe9d5aab498bf090db3e878c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391c4b4ea9dc95fbcfbfdab8a49547a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a391c4b4ea9dc95fbcfbfdab8a49547a3">emitRemark</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message)</td></tr>
<tr class="separator:a391c4b4ea9dc95fbcfbfdab8a49547a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45deee4eed2b998fbde1d3573325bc6e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a45deee4eed2b998fbde1d3573325bc6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a45deee4eed2b998fbde1d3573325bc6e">emitOptionalError</a> (std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; loc, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a45deee4eed2b998fbde1d3573325bc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads of the above emission functions that take an optionally null location.  <a href="namespacemlir.html#a45deee4eed2b998fbde1d3573325bc6e">More...</a><br /></td></tr>
<tr class="separator:a45deee4eed2b998fbde1d3573325bc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03c4337fa32d3045568e4dc6eef60ca"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac03c4337fa32d3045568e4dc6eef60ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac03c4337fa32d3045568e4dc6eef60ca">emitOptionalWarning</a> (std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; loc, Args &amp;&amp;...args)</td></tr>
<tr class="separator:ac03c4337fa32d3045568e4dc6eef60ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5cd384eee5c5c8a7125233ade78eea"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a3f5cd384eee5c5c8a7125233ade78eea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3f5cd384eee5c5c8a7125233ade78eea">emitOptionalRemark</a> (std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; loc, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a3f5cd384eee5c5c8a7125233ade78eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655bb0e17a21ea2c35194f7c822c9ca5"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a655bb0e17a21ea2c35194f7c822c9ca5">hash_value</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> arg)</td></tr>
<tr class="separator:a655bb0e17a21ea2c35194f7c822c9ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab097ddf5971ea2a3956fc814005f459f"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab097ddf5971ea2a3956fc814005f459f">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;loc)</td></tr>
<tr class="separator:ab097ddf5971ea2a3956fc814005f459f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6261878bc5197cfcc003e5b3fa735ea"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa6261878bc5197cfcc003e5b3fa735ea">hash_value</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> arg)</td></tr>
<tr class="separator:aa6261878bc5197cfcc003e5b3fa735ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad402a86ee4c9000c6fa1fceaddab560b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__op__matcher.html">detail::constant_op_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad402a86ee4c9000c6fa1fceaddab560b">m_Constant</a> ()</td></tr>
<tr class="memdesc:ad402a86ee4c9000c6fa1fceaddab560b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant foldable operation.  <a href="namespacemlir.html#ad402a86ee4c9000c6fa1fceaddab560b">More...</a><br /></td></tr>
<tr class="separator:ad402a86ee4c9000c6fa1fceaddab560b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d87ea3290be975b746704e58465017"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1AttrOpMatcher.html">detail::AttrOpMatcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a18d87ea3290be975b746704e58465017">m_Attr</a> (StringRef attrName)</td></tr>
<tr class="memdesc:a18d87ea3290be975b746704e58465017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a named attribute operation.  <a href="namespacemlir.html#a18d87ea3290be975b746704e58465017">More...</a><br /></td></tr>
<tr class="separator:a18d87ea3290be975b746704e58465017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b52f968271c9a4da1bc766ee083a9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1NameOpMatcher.html">detail::NameOpMatcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a69b52f968271c9a4da1bc766ee083a9c">m_Op</a> (StringRef opName)</td></tr>
<tr class="memdesc:a69b52f968271c9a4da1bc766ee083a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a named operation.  <a href="namespacemlir.html#a69b52f968271c9a4da1bc766ee083a9c">More...</a><br /></td></tr>
<tr class="separator:a69b52f968271c9a4da1bc766ee083a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b6da5781fbe1b019fcb64dcd6921dd"><td class="memTemplParams" colspan="2">template&lt;typename AttrT &gt; </td></tr>
<tr class="memitem:a10b6da5781fbe1b019fcb64dcd6921dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__op__binder.html">detail::constant_op_binder</a>&lt; AttrT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a10b6da5781fbe1b019fcb64dcd6921dd">m_Constant</a> (AttrT *bind_value)</td></tr>
<tr class="memdesc:a10b6da5781fbe1b019fcb64dcd6921dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a value from a constant foldable operation and writes the value to bind_value.  <a href="namespacemlir.html#a10b6da5781fbe1b019fcb64dcd6921dd">More...</a><br /></td></tr>
<tr class="separator:a10b6da5781fbe1b019fcb64dcd6921dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3132b68de242f1e938904d71be736db8"><td class="memTemplParams" colspan="2">template&lt;typename AttrT &gt; </td></tr>
<tr class="memitem:a3132b68de242f1e938904d71be736db8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1AttrOpBinder.html">detail::AttrOpBinder</a>&lt; AttrT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3132b68de242f1e938904d71be736db8">m_Attr</a> (StringRef attrName, AttrT *bindValue)</td></tr>
<tr class="memdesc:a3132b68de242f1e938904d71be736db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a named attribute operation and writes the value to bind_value.  <a href="namespacemlir.html#a3132b68de242f1e938904d71be736db8">More...</a><br /></td></tr>
<tr class="separator:a3132b68de242f1e938904d71be736db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea33aa665368d4f2108eb2d41c85111"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8ea33aa665368d4f2108eb2d41c85111">m_AnyZeroFloat</a> ()</td></tr>
<tr class="memdesc:a8ea33aa665368d4f2108eb2d41c85111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float (both positive and negative) zero.  <a href="namespacemlir.html#a8ea33aa665368d4f2108eb2d41c85111">More...</a><br /></td></tr>
<tr class="separator:a8ea33aa665368d4f2108eb2d41c85111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774a1ae971f4ef00eb57389293dfe617"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a774a1ae971f4ef00eb57389293dfe617">m_PosZeroFloat</a> ()</td></tr>
<tr class="memdesc:a774a1ae971f4ef00eb57389293dfe617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float positive zero.  <a href="namespacemlir.html#a774a1ae971f4ef00eb57389293dfe617">More...</a><br /></td></tr>
<tr class="separator:a774a1ae971f4ef00eb57389293dfe617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9eba8d1292854c0da6c062988ecac9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa9eba8d1292854c0da6c062988ecac9b">m_NegZeroFloat</a> ()</td></tr>
<tr class="memdesc:aa9eba8d1292854c0da6c062988ecac9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float negative zero.  <a href="namespacemlir.html#aa9eba8d1292854c0da6c062988ecac9b">More...</a><br /></td></tr>
<tr class="separator:aa9eba8d1292854c0da6c062988ecac9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0495d84f34cf3238a7741fa6974a485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af0495d84f34cf3238a7741fa6974a485">m_OneFloat</a> ()</td></tr>
<tr class="memdesc:af0495d84f34cf3238a7741fa6974a485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float ones.  <a href="namespacemlir.html#af0495d84f34cf3238a7741fa6974a485">More...</a><br /></td></tr>
<tr class="separator:af0495d84f34cf3238a7741fa6974a485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc93dfeaa35bda23b16591c462c335f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adc93dfeaa35bda23b16591c462c335f6">m_PosInfFloat</a> ()</td></tr>
<tr class="memdesc:adc93dfeaa35bda23b16591c462c335f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float positive infinity.  <a href="namespacemlir.html#adc93dfeaa35bda23b16591c462c335f6">More...</a><br /></td></tr>
<tr class="separator:adc93dfeaa35bda23b16591c462c335f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e89b015211525b010832d2d2c37650b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9e89b015211525b010832d2d2c37650b">m_NegInfFloat</a> ()</td></tr>
<tr class="memdesc:a9e89b015211525b010832d2d2c37650b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float negative infinity.  <a href="namespacemlir.html#a9e89b015211525b010832d2d2c37650b">More...</a><br /></td></tr>
<tr class="separator:a9e89b015211525b010832d2d2c37650b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5d8af15bd8994b1a7abeaaacfe1b06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7f5d8af15bd8994b1a7abeaaacfe1b06">m_Zero</a> ()</td></tr>
<tr class="memdesc:a7f5d8af15bd8994b1a7abeaaacfe1b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer zero.  <a href="namespacemlir.html#a7f5d8af15bd8994b1a7abeaaacfe1b06">More...</a><br /></td></tr>
<tr class="separator:a7f5d8af15bd8994b1a7abeaaacfe1b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bb42600b9be680591776fdc14a53cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a94bb42600b9be680591776fdc14a53cd">m_NonZero</a> ()</td></tr>
<tr class="memdesc:a94bb42600b9be680591776fdc14a53cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer that is any non-zero value.  <a href="namespacemlir.html#a94bb42600b9be680591776fdc14a53cd">More...</a><br /></td></tr>
<tr class="separator:a94bb42600b9be680591776fdc14a53cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907f415a4c803b15ef57db37cc732f39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a907f415a4c803b15ef57db37cc732f39">m_One</a> ()</td></tr>
<tr class="memdesc:a907f415a4c803b15ef57db37cc732f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer one.  <a href="namespacemlir.html#a907f415a4c803b15ef57db37cc732f39">More...</a><br /></td></tr>
<tr class="separator:a907f415a4c803b15ef57db37cc732f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2418532386147bec2ca5aadf5414406"><td class="memTemplParams" colspan="2">template&lt;typename OpClass &gt; </td></tr>
<tr class="memitem:ac2418532386147bec2ca5aadf5414406"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">detail::op_matcher</a>&lt; OpClass &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac2418532386147bec2ca5aadf5414406">m_Op</a> ()</td></tr>
<tr class="memdesc:ac2418532386147bec2ca5aadf5414406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the given OpClass.  <a href="namespacemlir.html#ac2418532386147bec2ca5aadf5414406">More...</a><br /></td></tr>
<tr class="separator:ac2418532386147bec2ca5aadf5414406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0190228b09e7b51a4bc1e013c01d404c"><td class="memTemplParams" colspan="2">template&lt;typename Pattern &gt; </td></tr>
<tr class="memitem:a0190228b09e7b51a4bc1e013c01d404c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0190228b09e7b51a4bc1e013c01d404c">matchPattern</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="memdesc:a0190228b09e7b51a4bc1e013c01d404c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for matching a pattern over a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="namespacemlir.html#a0190228b09e7b51a4bc1e013c01d404c">More...</a><br /></td></tr>
<tr class="separator:a0190228b09e7b51a4bc1e013c01d404c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="memTemplParams" colspan="2">template&lt;typename Pattern &gt; </td></tr>
<tr class="memitem:a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1b97d57dcd6c08b495fbd3ef22aeda6f">matchPattern</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="memdesc:a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for matching a pattern over an <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>.  <a href="namespacemlir.html#a1b97d57dcd6c08b495fbd3ef22aeda6f">More...</a><br /></td></tr>
<tr class="separator:a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f267f37c147c72f6ca26a41ff9f7bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__op__binder.html">detail::constant_float_op_binder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a41f267f37c147c72f6ca26a41ff9f7bb">m_ConstantFloat</a> (FloatAttr::ValueType *bind_value)</td></tr>
<tr class="memdesc:a41f267f37c147c72f6ca26a41ff9f7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant holding a scalar/vector/tensor float (splat) and writes the float value to bind_value.  <a href="namespacemlir.html#a41f267f37c147c72f6ca26a41ff9f7bb">More...</a><br /></td></tr>
<tr class="separator:a41f267f37c147c72f6ca26a41ff9f7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930dbe1d176d999aec049a4581838974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__op__binder.html">detail::constant_int_op_binder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a930dbe1d176d999aec049a4581838974">m_ConstantInt</a> (IntegerAttr::ValueType *bind_value)</td></tr>
<tr class="memdesc:a930dbe1d176d999aec049a4581838974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant holding a scalar/vector/tensor integer (splat) and writes the integer value to bind_value.  <a href="namespacemlir.html#a930dbe1d176d999aec049a4581838974">More...</a><br /></td></tr>
<tr class="separator:a930dbe1d176d999aec049a4581838974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecde76b07cd295bae0d6ef10d1c45d8"><td class="memTemplParams" colspan="2">template&lt;typename OpType , typename... Matchers&gt; </td></tr>
<tr class="memitem:a7ecde76b07cd295bae0d6ef10d1c45d8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7ecde76b07cd295bae0d6ef10d1c45d8">m_Op</a> (Matchers... matchers)</td></tr>
<tr class="separator:a7ecde76b07cd295bae0d6ef10d1c45d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5254079fbbd31a78a3430bff18df2d7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5254079fbbd31a78a3430bff18df2d7c">registerMLIRContextCLOptions</a> ()</td></tr>
<tr class="memdesc:a5254079fbbd31a78a3430bff18df2d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of useful command-line options that can be used to configure various flags within the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a>.  <a href="namespacemlir.html#a5254079fbbd31a78a3430bff18df2d7c">More...</a><br /></td></tr>
<tr class="separator:a5254079fbbd31a78a3430bff18df2d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68cec5ae244b132b00ea85983874b59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab68cec5ae244b132b00ea85983874b59">convertFromAttribute</a> (int64_t &amp;storage, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> *<a class="el" href="ModuleImport_8cpp.html#a0ba25d7b0573f8dd5fd669095441a61e">diag</a>)</td></tr>
<tr class="memdesc:ab68cec5ae244b132b00ea85983874b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an IntegerAttr attribute to an int64_t, or return an error if the attribute isn't an IntegerAttr.  <a href="namespacemlir.html#ab68cec5ae244b132b00ea85983874b59">More...</a><br /></td></tr>
<tr class="separator:ab68cec5ae244b132b00ea85983874b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81e61402439e0b78cd25dc4ad7eb591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab81e61402439e0b78cd25dc4ad7eb591">convertToAttribute</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, int64_t storage)</td></tr>
<tr class="memdesc:ab81e61402439e0b78cd25dc4ad7eb591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the provided int64_t to an IntegerAttr attribute.  <a href="namespacemlir.html#ab81e61402439e0b78cd25dc4ad7eb591">More...</a><br /></td></tr>
<tr class="separator:ab81e61402439e0b78cd25dc4ad7eb591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36180c3614ba72f2955215b016bfc171"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a36180c3614ba72f2955215b016bfc171">convertFromAttribute</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; int64_t &gt; storage, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> *<a class="el" href="ModuleImport_8cpp.html#a0ba25d7b0573f8dd5fd669095441a61e">diag</a>)</td></tr>
<tr class="memdesc:a36180c3614ba72f2955215b016bfc171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a DenseI64ArrayAttr to the provided storage.  <a href="namespacemlir.html#a36180c3614ba72f2955215b016bfc171">More...</a><br /></td></tr>
<tr class="separator:a36180c3614ba72f2955215b016bfc171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5c480f463f3ed7b6369caae8c8d366"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abd5c480f463f3ed7b6369caae8c8d366">convertToAttribute</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; storage)</td></tr>
<tr class="memdesc:abd5c480f463f3ed7b6369caae8c8d366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the provided <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;int64_t&gt;</a> to a DenseI64ArrayAttr attribute.  <a href="namespacemlir.html#abd5c480f463f3ed7b6369caae8c8d366">More...</a><br /></td></tr>
<tr class="separator:abd5c480f463f3ed7b6369caae8c8d366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4f129dda2c412845b5ec66a77325a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abc4f129dda2c412845b5ec66a77325a3">operator==</a> (<a class="el" href="classmlir_1_1OpState.html">OpState</a> lhs, <a class="el" href="classmlir_1_1OpState.html">OpState</a> rhs)</td></tr>
<tr class="separator:abc4f129dda2c412845b5ec66a77325a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee326f96469cd288efb48265e173295e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aee326f96469cd288efb48265e173295e">operator!=</a> (<a class="el" href="classmlir_1_1OpState.html">OpState</a> lhs, <a class="el" href="classmlir_1_1OpState.html">OpState</a> rhs)</td></tr>
<tr class="separator:aee326f96469cd288efb48265e173295e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c357b30f2e56803678fe5f7b75e80a1"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8c357b30f2e56803678fe5f7b75e80a1">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr)</td></tr>
<tr class="memdesc:a8c357b30f2e56803678fe5f7b75e80a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow printing to a stream.  <a href="namespacemlir.html#a8c357b30f2e56803678fe5f7b75e80a1">More...</a><br /></td></tr>
<tr class="separator:a8c357b30f2e56803678fe5f7b75e80a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07e7b01e09b3da975cc984b4e1c506d"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af07e7b01e09b3da975cc984b4e1c506d">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1OpState.html">OpState</a> op)</td></tr>
<tr class="memdesc:af07e7b01e09b3da975cc984b4e1c506d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow printing to a stream.  <a href="namespacemlir.html#af07e7b01e09b3da975cc984b4e1c506d">More...</a><br /></td></tr>
<tr class="separator:af07e7b01e09b3da975cc984b4e1c506d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dd71f700f3e4336e89a94f69ff28de"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab0dd71f700f3e4336e89a94f69ff28de">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op)</td></tr>
<tr class="separator:ab0dd71f700f3e4336e89a94f69ff28de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dade5c2740697bc36ceb8d6554ee00"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a45dade5c2740697bc36ceb8d6554ee00">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1OperationName.html">OperationName</a> info)</td></tr>
<tr class="separator:a45dade5c2740697bc36ceb8d6554ee00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93109842c1b05424c5052d9bd9a4394"><td class="memItemLeft" align="right" valign="top">llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad93109842c1b05424c5052d9bd9a4394">hash_value</a> (<a class="el" href="classmlir_1_1OperationName.html">OperationName</a> arg)</td></tr>
<tr class="separator:ad93109842c1b05424c5052d9bd9a4394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af912da94236cff04e9076f6e052676b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af912da94236cff04e9076f6e052676b1">LLVM_ENABLE_BITMASK_ENUMS_IN_NAMESPACE</a> ()</td></tr>
<tr class="memdesc:af912da94236cff04e9076f6e052676b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Bitmask enums for <a class="el" href="structmlir_1_1OperationEquivalence.html#a292ebf6a0885a07fd4c94f9750587dfe">OperationEquivalence::Flags</a>.  <a href="namespacemlir.html#af912da94236cff04e9076f6e052676b1">More...</a><br /></td></tr>
<tr class="separator:af912da94236cff04e9076f6e052676b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac18c17aca8d8a8549fef55a52af5393"><td class="memItemLeft" align="right" valign="top">llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aac18c17aca8d8a8549fef55a52af5393">hash_value</a> (const <a class="el" href="classmlir_1_1AsmDialectResourceHandle.html">AsmDialectResourceHandle</a> &amp;param)</td></tr>
<tr class="separator:aac18c17aca8d8a8549fef55a52af5393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97986a4859106d3c96b089e726e26c7c"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT &gt; </td></tr>
<tr class="memitem:a97986a4859106d3c96b089e726e26c7c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a97986a4859106d3c96b089e726e26c7c">operator&lt;&lt;</a> (AsmPrinterT &amp;p, <a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="separator:a97986a4859106d3c96b089e726e26c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69273e2629a0b7e18af99582f687692"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT &gt; </td></tr>
<tr class="memitem:ab69273e2629a0b7e18af99582f687692"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab69273e2629a0b7e18af99582f687692">operator&lt;&lt;</a> (AsmPrinterT &amp;p, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="separator:ab69273e2629a0b7e18af99582f687692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424d21ac06bbb37dee5c29f22e9d261a"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT &gt; </td></tr>
<tr class="memitem:a424d21ac06bbb37dee5c29f22e9d261a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a424d21ac06bbb37dee5c29f22e9d261a">operator&lt;&lt;</a> (AsmPrinterT &amp;p, const APFloat &amp;value)</td></tr>
<tr class="separator:a424d21ac06bbb37dee5c29f22e9d261a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31efc2a6e3489b511bf1640b6e3b9eb"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT &gt; </td></tr>
<tr class="memitem:ac31efc2a6e3489b511bf1640b6e3b9eb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac31efc2a6e3489b511bf1640b6e3b9eb">operator&lt;&lt;</a> (AsmPrinterT &amp;p, float value)</td></tr>
<tr class="separator:ac31efc2a6e3489b511bf1640b6e3b9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad013c3d87cad19d6a7fa6ce16eb6bd58"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT &gt; </td></tr>
<tr class="memitem:ad013c3d87cad19d6a7fa6ce16eb6bd58"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad013c3d87cad19d6a7fa6ce16eb6bd58">operator&lt;&lt;</a> (AsmPrinterT &amp;p, double value)</td></tr>
<tr class="separator:ad013c3d87cad19d6a7fa6ce16eb6bd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462d4f34f404bcc705506899944185f6"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT , typename T , std::enable_if_t&lt;!std::is_convertible&lt; T &amp;, Value &amp; &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Type &amp; &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Attribute &amp; &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, ValueRange &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, APFloat &amp; &gt;::value &amp;&amp;!llvm::is_one_of&lt; T, bool, float, double &gt;::value, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a462d4f34f404bcc705506899944185f6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a462d4f34f404bcc705506899944185f6">operator&lt;&lt;</a> (AsmPrinterT &amp;p, const T &amp;other)</td></tr>
<tr class="separator:a462d4f34f404bcc705506899944185f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627aa7e5b958743b9a67a4ccbe1418c9"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT &gt; </td></tr>
<tr class="memitem:a627aa7e5b958743b9a67a4ccbe1418c9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a627aa7e5b958743b9a67a4ccbe1418c9">operator&lt;&lt;</a> (AsmPrinterT &amp;p, bool value)</td></tr>
<tr class="separator:a627aa7e5b958743b9a67a4ccbe1418c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ecef972faf3b5c78d8415d69a86728"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT , typename ValueRangeT &gt; </td></tr>
<tr class="memitem:a26ecef972faf3b5c78d8415d69a86728"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a26ecef972faf3b5c78d8415d69a86728">operator&lt;&lt;</a> (AsmPrinterT &amp;p, const <a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a>&lt; ValueRangeT &gt; &amp;types)</td></tr>
<tr class="separator:a26ecef972faf3b5c78d8415d69a86728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d69cef9b50344549afeaaa734f8172d"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT &gt; </td></tr>
<tr class="memitem:a4d69cef9b50344549afeaaa734f8172d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4d69cef9b50344549afeaaa734f8172d">operator&lt;&lt;</a> (AsmPrinterT &amp;p, const <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> &amp;types)</td></tr>
<tr class="separator:a4d69cef9b50344549afeaaa734f8172d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970e10cc4cef6e2f2dd48772041b4773"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT , typename T &gt; </td></tr>
<tr class="memitem:a970e10cc4cef6e2f2dd48772041b4773"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value &amp;&amp;std::is_convertible&lt; T &amp;, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a970e10cc4cef6e2f2dd48772041b4773">operator&lt;&lt;</a> (AsmPrinterT &amp;p, const T &amp;other)=delete</td></tr>
<tr class="separator:a970e10cc4cef6e2f2dd48772041b4773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d315bdf3396a4c2cac6ead94cfc0e26"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT , typename ElementT &gt; </td></tr>
<tr class="memitem:a6d315bdf3396a4c2cac6ead94cfc0e26"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6d315bdf3396a4c2cac6ead94cfc0e26">operator&lt;&lt;</a> (AsmPrinterT &amp;p, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; ElementT &gt; types)</td></tr>
<tr class="separator:a6d315bdf3396a4c2cac6ead94cfc0e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabdc4e9d44aae13942c9ea9b41b9a33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acabdc4e9d44aae13942c9ea9b41b9a33">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="separator:acabdc4e9d44aae13942c9ea9b41b9a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c02ebe7d299d1683ae658ea4e9352c"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; std::is_convertible&lt; T &amp;, ValueRange &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Value &amp; &gt;::value, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a58c02ebe7d299d1683ae658ea4e9352c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a58c02ebe7d299d1683ae658ea4e9352c">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, const T &amp;values)</td></tr>
<tr class="separator:a58c02ebe7d299d1683ae658ea4e9352c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad554d3204bdbdc4a87d291ed94c1e575"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad554d3204bdbdc4a87d291ed94c1e575">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Block.html">Block</a> *value)</td></tr>
<tr class="separator:ad554d3204bdbdc4a87d291ed94c1e575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee66a47ca548fabe02261ad8b96eea5"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acee66a47ca548fabe02261ad8b96eea5">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a> value)</td></tr>
<tr class="separator:acee66a47ca548fabe02261ad8b96eea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778366ed204055f8c0ae4e113220a5bd"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a778366ed204055f8c0ae4e113220a5bd">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1PDLValue.html#aa5a98d42f4638805a23d5390ddb28ac0">PDLValue::Kind</a> kind)</td></tr>
<tr class="separator:a778366ed204055f8c0ae4e113220a5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed40bd15766a7dff96f3d30577d8f87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5ed40bd15766a7dff96f3d30577d8f87">mayHaveSSADominance</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:a5ed40bd15766a7dff96f3d30577d8f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if the given region may have SSA dominance.  <a href="namespacemlir.html#a5ed40bd15766a7dff96f3d30577d8f87">More...</a><br /></td></tr>
<tr class="separator:a5ed40bd15766a7dff96f3d30577d8f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78425f2c879f5b708f5c58af03931e9f"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a78425f2c879f5b708f5c58af03931e9f">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1SymbolTable.html#a4f1a6f39b93a08abe4e80a5c15fe32b8">SymbolTable::Visibility</a> visibility)</td></tr>
<tr class="separator:a78425f2c879f5b708f5c58af03931e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3083728e72d361c987c5e5a0e8d2f39a"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename FuncT &gt; </td></tr>
<tr class="memitem:a3083728e72d361c987c5e5a0e8d2f39a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3083728e72d361c987c5e5a0e8d2f39a">failableParallelForEach</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, IteratorT begin, IteratorT end, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:a3083728e72d361c987c5e5a0e8d2f39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements between [begin, end) asynchronously.  <a href="namespacemlir.html#a3083728e72d361c987c5e5a0e8d2f39a">More...</a><br /></td></tr>
<tr class="separator:a3083728e72d361c987c5e5a0e8d2f39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98aa0f01173a481075d9d5a2ca50d8ab"><td class="memTemplParams" colspan="2">template&lt;typename RangeT , typename FuncT &gt; </td></tr>
<tr class="memitem:a98aa0f01173a481075d9d5a2ca50d8ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a98aa0f01173a481075d9d5a2ca50d8ab">failableParallelForEach</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, RangeT &amp;&amp;range, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:a98aa0f01173a481075d9d5a2ca50d8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements in the provided range asynchronously.  <a href="namespacemlir.html#a98aa0f01173a481075d9d5a2ca50d8ab">More...</a><br /></td></tr>
<tr class="separator:a98aa0f01173a481075d9d5a2ca50d8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5aa5179ec6f13db4eaa8fa255bde665"><td class="memTemplParams" colspan="2">template&lt;typename FuncT &gt; </td></tr>
<tr class="memitem:af5aa5179ec6f13db4eaa8fa255bde665"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af5aa5179ec6f13db4eaa8fa255bde665">failableParallelForEachN</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, size_t begin, size_t end, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:af5aa5179ec6f13db4eaa8fa255bde665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements between [begin, end) asynchronously.  <a href="namespacemlir.html#af5aa5179ec6f13db4eaa8fa255bde665">More...</a><br /></td></tr>
<tr class="separator:af5aa5179ec6f13db4eaa8fa255bde665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acf0c58d63da562112dd8f6a81b49e3"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename FuncT &gt; </td></tr>
<tr class="memitem:a7acf0c58d63da562112dd8f6a81b49e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7acf0c58d63da562112dd8f6a81b49e3">parallelForEach</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, IteratorT begin, IteratorT end, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:a7acf0c58d63da562112dd8f6a81b49e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements between [begin, end) asynchronously.  <a href="namespacemlir.html#a7acf0c58d63da562112dd8f6a81b49e3">More...</a><br /></td></tr>
<tr class="separator:a7acf0c58d63da562112dd8f6a81b49e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1232c5821e793866aa3cf2234e1ba93"><td class="memTemplParams" colspan="2">template&lt;typename RangeT , typename FuncT &gt; </td></tr>
<tr class="memitem:af1232c5821e793866aa3cf2234e1ba93"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af1232c5821e793866aa3cf2234e1ba93">parallelForEach</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, RangeT &amp;&amp;range, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:af1232c5821e793866aa3cf2234e1ba93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements in the provided range asynchronously.  <a href="namespacemlir.html#af1232c5821e793866aa3cf2234e1ba93">More...</a><br /></td></tr>
<tr class="separator:af1232c5821e793866aa3cf2234e1ba93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02ff92115796118c612bc82db603b7e"><td class="memTemplParams" colspan="2">template&lt;typename FuncT &gt; </td></tr>
<tr class="memitem:ad02ff92115796118c612bc82db603b7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad02ff92115796118c612bc82db603b7e">parallelFor</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, size_t begin, size_t end, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:ad02ff92115796118c612bc82db603b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements between [begin, end) asynchronously.  <a href="namespacemlir.html#ad02ff92115796118c612bc82db603b7e">More...</a><br /></td></tr>
<tr class="separator:ad02ff92115796118c612bc82db603b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb322b17530b4289c3e3ec1f4ad2ecce"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abb322b17530b4289c3e3ec1f4ad2ecce">hash_value</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> arg)</td></tr>
<tr class="memdesc:abb322b17530b4289c3e3ec1f4ad2ecce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="classmlir_1_1TypeRange.html" title="This class provides an abstraction over the various different ranges of value types.">TypeRange</a> hashable.  <a href="namespacemlir.html#abb322b17530b4289c3e3ec1f4ad2ecce">More...</a><br /></td></tr>
<tr class="separator:abb322b17530b4289c3e3ec1f4ad2ecce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e22b31f6f0d59955e0e73f0d387613"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a40e22b31f6f0d59955e0e73f0d387613">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> &amp;types)</td></tr>
<tr class="memdesc:a40e22b31f6f0d59955e0e73f0d387613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a type range to the given output stream.  <a href="namespacemlir.html#a40e22b31f6f0d59955e0e73f0d387613">More...</a><br /></td></tr>
<tr class="separator:a40e22b31f6f0d59955e0e73f0d387613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc3d1f66f267d9111234fac1effdfce"><td class="memTemplParams" colspan="2">template&lt;typename RangeT &gt; </td></tr>
<tr class="memitem:a8fc3d1f66f267d9111234fac1effdfce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8fc3d1f66f267d9111234fac1effdfce">operator==</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; lhs, const <a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a>&lt; RangeT &gt; &amp;rhs)</td></tr>
<tr class="separator:a8fc3d1f66f267d9111234fac1effdfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5bfd80339235fbb32a685ff75f4e16"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acd5bfd80339235fbb32a685ff75f4e16">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="separator:acd5bfd80339235fbb32a685ff75f4e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31eede9183d3fdae566e18d94a5ef51b"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a31eede9183d3fdae566e18d94a5ef51b">hash_value</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> arg)</td></tr>
<tr class="separator:a31eede9183d3fdae566e18d94a5ef51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82686ceb29eb0f78b59e29021f1b2cdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a82686ceb29eb0f78b59e29021f1b2cdd">getElementTypeOrSelf</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memdesc:a82686ceb29eb0f78b59e29021f1b2cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element type or return the type itself.  <a href="namespacemlir.html#a82686ceb29eb0f78b59e29021f1b2cdd">More...</a><br /></td></tr>
<tr class="separator:a82686ceb29eb0f78b59e29021f1b2cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252aee27751e05d584d0b1a8e793ecf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a252aee27751e05d584d0b1a8e793ecf0">getElementTypeOrSelf</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:a252aee27751e05d584d0b1a8e793ecf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element type or return the type itself.  <a href="namespacemlir.html#a252aee27751e05d584d0b1a8e793ecf0">More...</a><br /></td></tr>
<tr class="separator:a252aee27751e05d584d0b1a8e793ecf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81d443c449b61825fb2c2ec6aa90d35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae81d443c449b61825fb2c2ec6aa90d35">getElementTypeOrSelf</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="separator:ae81d443c449b61825fb2c2ec6aa90d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bbb7497276c5ea7e8ed4ad1315bf40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, 10 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a46bbb7497276c5ea7e8ed4ad1315bf40">getFlattenedTypes</a> (TupleType t)</td></tr>
<tr class="memdesc:a46bbb7497276c5ea7e8ed4ad1315bf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the types within a nested Tuple.  <a href="namespacemlir.html#a46bbb7497276c5ea7e8ed4ad1315bf40">More...</a><br /></td></tr>
<tr class="separator:a46bbb7497276c5ea7e8ed4ad1315bf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd6b581b08699ce79d3e9f820c1ade9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4bd6b581b08699ce79d3e9f820c1ade9">isOpaqueTypeWithName</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, StringRef dialect, StringRef typeData)</td></tr>
<tr class="memdesc:a4bd6b581b08699ce79d3e9f820c1ade9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified type is an opaque type with the specified dialect and typeData.  <a href="namespacemlir.html#a4bd6b581b08699ce79d3e9f820c1ade9">More...</a><br /></td></tr>
<tr class="separator:a4bd6b581b08699ce79d3e9f820c1ade9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb414ad1d507c2ab841305c273f4deb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acb414ad1d507c2ab841305c273f4deb8">verifyCompatibleShape</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape1, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape2)</td></tr>
<tr class="memdesc:acb414ad1d507c2ab841305c273f4deb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if the given two shapes are compatible.  <a href="namespacemlir.html#acb414ad1d507c2ab841305c273f4deb8">More...</a><br /></td></tr>
<tr class="separator:acb414ad1d507c2ab841305c273f4deb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54e5e6c31f51ef648f7c03652a29ce6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac54e5e6c31f51ef648f7c03652a29ce6">verifyCompatibleShape</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type1, <a class="el" href="classmlir_1_1Type.html">Type</a> type2)</td></tr>
<tr class="memdesc:ac54e5e6c31f51ef648f7c03652a29ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if the given two types have compatible shape.  <a href="namespacemlir.html#ac54e5e6c31f51ef648f7c03652a29ce6">More...</a><br /></td></tr>
<tr class="separator:ac54e5e6c31f51ef648f7c03652a29ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2801a1733326688cf0c9bee8d633f234"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2801a1733326688cf0c9bee8d633f234">verifyCompatibleShapes</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types1, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types2)</td></tr>
<tr class="memdesc:a2801a1733326688cf0c9bee8d633f234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if the given two arrays have the same number of elements and each pair wise entries have compatible shape.  <a href="namespacemlir.html#a2801a1733326688cf0c9bee8d633f234">More...</a><br /></td></tr>
<tr class="separator:a2801a1733326688cf0c9bee8d633f234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132fff065736d8e977fe8179f2e7086c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a132fff065736d8e977fe8179f2e7086c">verifyCompatibleShapes</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types)</td></tr>
<tr class="memdesc:a132fff065736d8e977fe8179f2e7086c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if all given types have compatible shapes.  <a href="namespacemlir.html#a132fff065736d8e977fe8179f2e7086c">More...</a><br /></td></tr>
<tr class="separator:a132fff065736d8e977fe8179f2e7086c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961cf9926486f7d6e7160efa8f846d64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a961cf9926486f7d6e7160efa8f846d64">verifyCompatibleDims</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; dims)</td></tr>
<tr class="memdesc:a961cf9926486f7d6e7160efa8f846d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimensions are compatible if all non-dynamic dims are equal.  <a href="namespacemlir.html#a961cf9926486f7d6e7160efa8f846d64">More...</a><br /></td></tr>
<tr class="separator:a961cf9926486f7d6e7160efa8f846d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279adec3f964e12de632fa76060d2669"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a279adec3f964e12de632fa76060d2669">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1IRUnit.html">IRUnit</a> &amp;unit)</td></tr>
<tr class="separator:a279adec3f964e12de632fa76060d2669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df16c49c963cdc57cf6f9e7c3e9f822"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3df16c49c963cdc57cf6f9e7c3e9f822">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="separator:a3df16c49c963cdc57cf6f9e7c3e9f822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab710b1f6f21f3f35197575b609aae4b4"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab710b1f6f21f3f35197575b609aae4b4">hash_value</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> arg)</td></tr>
<tr class="memdesc:ab710b1f6f21f3f35197575b609aae4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> hashable.  <a href="namespacemlir.html#ab710b1f6f21f3f35197575b609aae4b4">More...</a><br /></td></tr>
<tr class="separator:ab710b1f6f21f3f35197575b609aae4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b1ba650fd43b50351e92bbb75bd4c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae4b1ba650fd43b50351e92bbb75bd4c0">verify</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, bool verifyRecursively=true)</td></tr>
<tr class="memdesc:ae4b1ba650fd43b50351e92bbb75bd4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform (potentially expensive) checks of invariants, used to detect compiler bugs, on this operation and any nested operations.  <a href="namespacemlir.html#ae4b1ba650fd43b50351e92bbb75bd4c0">More...</a><br /></td></tr>
<tr class="separator:ae4b1ba650fd43b50351e92bbb75bd4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f975095772c8ece0dbda8bf7f455eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab0f975095772c8ece0dbda8bf7f455eb">parseSourceFile</a> (const llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=nullptr)</td></tr>
<tr class="memdesc:ab0f975095772c8ece0dbda8bf7f455eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated SourceMgr and appends parsed operations to the given block.  <a href="namespacemlir.html#ab0f975095772c8ece0dbda8bf7f455eb">More...</a><br /></td></tr>
<tr class="separator:ab0f975095772c8ece0dbda8bf7f455eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537a80c31d8487a710f53cd9a38e390a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a537a80c31d8487a710f53cd9a38e390a">parseSourceFile</a> (const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=nullptr)</td></tr>
<tr class="memdesc:a537a80c31d8487a710f53cd9a38e390a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR).  <a href="namespacemlir.html#a537a80c31d8487a710f53cd9a38e390a">More...</a><br /></td></tr>
<tr class="separator:a537a80c31d8487a710f53cd9a38e390a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006a32917056b7f14d65e9ea5cc08392"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a006a32917056b7f14d65e9ea5cc08392">parseSourceFile</a> (llvm::StringRef filename, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=nullptr)</td></tr>
<tr class="memdesc:a006a32917056b7f14d65e9ea5cc08392"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename and appends parsed operations to the given block.  <a href="namespacemlir.html#a006a32917056b7f14d65e9ea5cc08392">More...</a><br /></td></tr>
<tr class="separator:a006a32917056b7f14d65e9ea5cc08392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ad011b0b3c1635c410fe60bfd557c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a13ad011b0b3c1635c410fe60bfd557c2">parseSourceFile</a> (llvm::StringRef filename, llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=nullptr)</td></tr>
<tr class="memdesc:a13ad011b0b3c1635c410fe60bfd557c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename using the provided SourceMgr and appends parsed operations to the given block.  <a href="namespacemlir.html#a13ad011b0b3c1635c410fe60bfd557c2">More...</a><br /></td></tr>
<tr class="separator:a13ad011b0b3c1635c410fe60bfd557c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54875232f3a58ed939964dc275d1e36f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a54875232f3a58ed939964dc275d1e36f">parseSourceFile</a> (llvm::StringRef filename, const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=nullptr)</td></tr>
<tr class="memdesc:a54875232f3a58ed939964dc275d1e36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR).  <a href="namespacemlir.html#a54875232f3a58ed939964dc275d1e36f">More...</a><br /></td></tr>
<tr class="separator:a54875232f3a58ed939964dc275d1e36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80178c9e23c4fd7db357124cbe19651a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a80178c9e23c4fd7db357124cbe19651a">parseSourceString</a> (llvm::StringRef sourceStr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config, StringRef sourceName=&quot;&quot;, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=nullptr)</td></tr>
<tr class="memdesc:a80178c9e23c4fd7db357124cbe19651a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the IR string and appends parsed operations to the given block.  <a href="namespacemlir.html#a80178c9e23c4fd7db357124cbe19651a">More...</a><br /></td></tr>
<tr class="separator:a80178c9e23c4fd7db357124cbe19651a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8735a3d1b2704c1497e7c4b8173e8d99"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT  = Operation *&gt; </td></tr>
<tr class="memitem:a8735a3d1b2704c1497e7c4b8173e8d99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8735a3d1b2704c1497e7c4b8173e8d99">parseSourceFile</a> (const llvm::SourceMgr &amp;sourceMgr, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config)</td></tr>
<tr class="memdesc:a8735a3d1b2704c1497e7c4b8173e8d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated SourceMgr.  <a href="namespacemlir.html#a8735a3d1b2704c1497e7c4b8173e8d99">More...</a><br /></td></tr>
<tr class="separator:a8735a3d1b2704c1497e7c4b8173e8d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9ed7461f16d832b9a3d5c1c444ff7e"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT  = Operation *&gt; </td></tr>
<tr class="memitem:a2b9ed7461f16d832b9a3d5c1c444ff7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2b9ed7461f16d832b9a3d5c1c444ff7e">parseSourceFile</a> (const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config)</td></tr>
<tr class="memdesc:a2b9ed7461f16d832b9a3d5c1c444ff7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR).  <a href="namespacemlir.html#a2b9ed7461f16d832b9a3d5c1c444ff7e">More...</a><br /></td></tr>
<tr class="separator:a2b9ed7461f16d832b9a3d5c1c444ff7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731c3e653fe7b19e18f2ca619aa763fa"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT  = Operation *&gt; </td></tr>
<tr class="memitem:a731c3e653fe7b19e18f2ca619aa763fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a731c3e653fe7b19e18f2ca619aa763fa">parseSourceFile</a> (StringRef filename, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config)</td></tr>
<tr class="memdesc:a731c3e653fe7b19e18f2ca619aa763fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename.  <a href="namespacemlir.html#a731c3e653fe7b19e18f2ca619aa763fa">More...</a><br /></td></tr>
<tr class="separator:a731c3e653fe7b19e18f2ca619aa763fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f46d0b9658a27fa31f7ce98851ca7fe"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT  = Operation *&gt; </td></tr>
<tr class="memitem:a3f46d0b9658a27fa31f7ce98851ca7fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3f46d0b9658a27fa31f7ce98851ca7fe">parseSourceFile</a> (llvm::StringRef filename, llvm::SourceMgr &amp;sourceMgr, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config)</td></tr>
<tr class="memdesc:a3f46d0b9658a27fa31f7ce98851ca7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename using the provided SourceMgr.  <a href="namespacemlir.html#a3f46d0b9658a27fa31f7ce98851ca7fe">More...</a><br /></td></tr>
<tr class="separator:a3f46d0b9658a27fa31f7ce98851ca7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e06cd142a5019f145069349181e2e0"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT  = Operation *&gt; </td></tr>
<tr class="memitem:af9e06cd142a5019f145069349181e2e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af9e06cd142a5019f145069349181e2e0">parseSourceFile</a> (llvm::StringRef filename, const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config)</td></tr>
<tr class="memdesc:af9e06cd142a5019f145069349181e2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR).  <a href="namespacemlir.html#af9e06cd142a5019f145069349181e2e0">More...</a><br /></td></tr>
<tr class="separator:af9e06cd142a5019f145069349181e2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfecc94be370f449013ec1f80818da8"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT  = Operation *&gt; </td></tr>
<tr class="memitem:a1bfecc94be370f449013ec1f80818da8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1bfecc94be370f449013ec1f80818da8">parseSourceString</a> (llvm::StringRef sourceStr, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config, StringRef sourceName=&quot;&quot;)</td></tr>
<tr class="memdesc:a1bfecc94be370f449013ec1f80818da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the provided string containing MLIR.  <a href="namespacemlir.html#a1bfecc94be370f449013ec1f80818da8">More...</a><br /></td></tr>
<tr class="separator:a1bfecc94be370f449013ec1f80818da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c4edce10b597637635af55bb162477"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa5c4edce10b597637635af55bb162477">registerPassManagerCLOptions</a> ()</td></tr>
<tr class="memdesc:aa5c4edce10b597637635af55bb162477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of useful command-line options that can be used to configure a pass manager.  <a href="namespacemlir.html#aa5c4edce10b597637635af55bb162477">More...</a><br /></td></tr>
<tr class="separator:aa5c4edce10b597637635af55bb162477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133398d008de5837d6df9b322b62f5f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a133398d008de5837d6df9b322b62f5f6">applyPassManagerCLOptions</a> (<a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;pm)</td></tr>
<tr class="memdesc:a133398d008de5837d6df9b322b62f5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply any values provided to the pass manager options that were registered with 'registerPassManagerOptions'.  <a href="namespacemlir.html#a133398d008de5837d6df9b322b62f5f6">More...</a><br /></td></tr>
<tr class="separator:a133398d008de5837d6df9b322b62f5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd78ebb9f95cfe7ea3856d9f9c46d030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acd78ebb9f95cfe7ea3856d9f9c46d030">applyDefaultTimingPassManagerCLOptions</a> (<a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;pm)</td></tr>
<tr class="memdesc:acd78ebb9f95cfe7ea3856d9f9c46d030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply any values provided to the timing manager options that were registered with <code>registerDefaultTimingManagerOptions</code>.  <a href="namespacemlir.html#acd78ebb9f95cfe7ea3856d9f9c46d030">More...</a><br /></td></tr>
<tr class="separator:acd78ebb9f95cfe7ea3856d9f9c46d030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83965c855ad737422194336251348893"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a83965c855ad737422194336251348893">registerPassPipeline</a> (StringRef arg, StringRef description, const <a class="el" href="namespacemlir.html#af4ccb1e7accf2ec0c57b1aea967ccd02">PassRegistryFunction</a> &amp;function, std::function&lt; void(<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(const <a class="el" href="classmlir_1_1detail_1_1PassOptions.html">detail::PassOptions</a> &amp;)&gt;)&gt; optHandler)</td></tr>
<tr class="memdesc:a83965c855ad737422194336251348893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a specific dialect pipeline registry function with the system, typically used through the <a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> template.  <a href="namespacemlir.html#a83965c855ad737422194336251348893">More...</a><br /></td></tr>
<tr class="separator:a83965c855ad737422194336251348893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4626059212aef6f3aa5fa7088ce667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5a4626059212aef6f3aa5fa7088ce667">registerPass</a> (const <a class="el" href="namespacemlir.html#a48db7fd5d49bfa7ca8c81e5a6a058683">PassAllocatorFunction</a> &amp;function)</td></tr>
<tr class="memdesc:a5a4626059212aef6f3aa5fa7088ce667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a specific dialect pass allocator function with the system, typically used through the <a class="el" href="structmlir_1_1PassRegistration.html" title="PassRegistration provides a global initializer that registers a Pass allocation routine for a concret...">PassRegistration</a> template.  <a href="namespacemlir.html#a5a4626059212aef6f3aa5fa7088ce667">More...</a><br /></td></tr>
<tr class="separator:a5a4626059212aef6f3aa5fa7088ce667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d10077c7edf58c1152a1170257d739"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad8d10077c7edf58c1152a1170257d739">parsePassPipeline</a> (StringRef pipeline, <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;pm, raw_ostream &amp;errorStream=llvm::errs())</td></tr>
<tr class="memdesc:ad8d10077c7edf58c1152a1170257d739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the textual representation of a pass pipeline, adding the result to 'pm' on success.  <a href="namespacemlir.html#ad8d10077c7edf58c1152a1170257d739">More...</a><br /></td></tr>
<tr class="separator:ad8d10077c7edf58c1152a1170257d739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5abaea7950d9dc385a018dbbb40d0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aef5abaea7950d9dc385a018dbbb40d0b">parsePassPipeline</a> (StringRef pipeline, raw_ostream &amp;errorStream=llvm::errs())</td></tr>
<tr class="memdesc:aef5abaea7950d9dc385a018dbbb40d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the given textual representation of a pass pipeline, and return the parsed pipeline on success.  <a href="namespacemlir.html#aef5abaea7950d9dc385a018dbbb40d0b">More...</a><br /></td></tr>
<tr class="separator:aef5abaea7950d9dc385a018dbbb40d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed5140e30c6e204e8bdc35d08d0eb08"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4ed5140e30c6e204e8bdc35d08d0eb08">createReductionTreePass</a> ()</td></tr>
<tr class="separator:a4ed5140e30c6e204e8bdc35d08d0eb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87060fc8d3ef747e189053c6bd556a5a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a87060fc8d3ef747e189053c6bd556a5a">createOptReductionPass</a> ()</td></tr>
<tr class="separator:a87060fc8d3ef747e189053c6bd556a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54881321f630a119cdee5af076de868d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a54881321f630a119cdee5af076de868d"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a54881321f630a119cdee5af076de868d">debugString</a> (T &amp;&amp;op)</td></tr>
<tr class="separator:a54881321f630a119cdee5af076de868d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2eb0b34f6d7e90435b0a6ce3d8ffaf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::MemoryBuffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">openInputFile</a> (llvm::StringRef inputFilename, std::string *errorMessage=nullptr)</td></tr>
<tr class="memdesc:a0c2eb0b34f6d7e90435b0a6ce3d8ffaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the file specified by its name for reading.  <a href="namespacemlir.html#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">More...</a><br /></td></tr>
<tr class="separator:a0c2eb0b34f6d7e90435b0a6ce3d8ffaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec63c3f9b9b50f77b7cc8b92f506204"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::MemoryBuffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4ec63c3f9b9b50f77b7cc8b92f506204">openInputFile</a> (llvm::StringRef inputFilename, llvm::Align alignment, std::string *errorMessage=nullptr)</td></tr>
<tr class="memdesc:a4ec63c3f9b9b50f77b7cc8b92f506204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the file specified by its name for reading, with the given buffer alignment constraint.  <a href="namespacemlir.html#a4ec63c3f9b9b50f77b7cc8b92f506204">More...</a><br /></td></tr>
<tr class="separator:a4ec63c3f9b9b50f77b7cc8b92f506204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8c9750d9c8efdbcc7542f3b1564d8d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::ToolOutputFile &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4c8c9750d9c8efdbcc7542f3b1564d8d">openOutputFile</a> (llvm::StringRef outputFilename, std::string *errorMessage=nullptr)</td></tr>
<tr class="memdesc:a4c8c9750d9c8efdbcc7542f3b1564d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the file specified by its name for writing.  <a href="namespacemlir.html#a4c8c9750d9c8efdbcc7542f3b1564d8d">More...</a><br /></td></tr>
<tr class="separator:a4c8c9750d9c8efdbcc7542f3b1564d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f55c06c7c4aeace3f6824dd68f8b1ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a> (bool isSuccess=true)</td></tr>
<tr class="memdesc:a5f55c06c7c4aeace3f6824dd68f8b1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to generate a <a class="el" href="structmlir_1_1LogicalResult.html" title="This class represents an efficient way to signal success or failure.">LogicalResult</a>.  <a href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">More...</a><br /></td></tr>
<tr class="separator:a5f55c06c7c4aeace3f6824dd68f8b1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07367c8c4a3d4a47a32bc2b9b7d8a3f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a> (bool isFailure=true)</td></tr>
<tr class="memdesc:a07367c8c4a3d4a47a32bc2b9b7d8a3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to generate a <a class="el" href="structmlir_1_1LogicalResult.html" title="This class represents an efficient way to signal success or failure.">LogicalResult</a>.  <a href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">More...</a><br /></td></tr>
<tr class="separator:a07367c8c4a3d4a47a32bc2b9b7d8a3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a1cb2e1046f84d6328600b92c99e52"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a57a1cb2e1046f84d6328600b92c99e52">succeeded</a> (<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> result)</td></tr>
<tr class="memdesc:a57a1cb2e1046f84d6328600b92c99e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that returns true if the provided <a class="el" href="structmlir_1_1LogicalResult.html" title="This class represents an efficient way to signal success or failure.">LogicalResult</a> corresponds to a success value.  <a href="namespacemlir.html#a57a1cb2e1046f84d6328600b92c99e52">More...</a><br /></td></tr>
<tr class="separator:a57a1cb2e1046f84d6328600b92c99e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec13ab4fb753865cdfd2699aa01c23b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a> (<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> result)</td></tr>
<tr class="memdesc:aeec13ab4fb753865cdfd2699aa01c23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that returns true if the provided <a class="el" href="structmlir_1_1LogicalResult.html" title="This class represents an efficient way to signal success or failure.">LogicalResult</a> corresponds to a failure value.  <a href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">More...</a><br /></td></tr>
<tr class="separator:aeec13ab4fb753865cdfd2699aa01c23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ccf1eabcff0cf5b0ca167316f18822"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = std::enable_if_t&lt;!std::is_convertible_v&lt;T, bool&gt;&gt;&gt; </td></tr>
<tr class="memitem:a41ccf1eabcff0cf5b0ca167316f18822"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a41ccf1eabcff0cf5b0ca167316f18822">success</a> (T &amp;&amp;t)</td></tr>
<tr class="memdesc:a41ccf1eabcff0cf5b0ca167316f18822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a value on the success path in a <a class="el" href="classmlir_1_1FailureOr.html" title="This class provides support for representing a failure result, or a valid value of type T.">FailureOr</a> of the same value type.  <a href="namespacemlir.html#a41ccf1eabcff0cf5b0ca167316f18822">More...</a><br /></td></tr>
<tr class="separator:a41ccf1eabcff0cf5b0ca167316f18822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a3d17c70f67aa2d18203667acaf114"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a46a3d17c70f67aa2d18203667acaf114">ceilDiv</a> (int64_t lhs, int64_t rhs)</td></tr>
<tr class="memdesc:a46a3d17c70f67aa2d18203667acaf114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of MLIR's ceildiv operation on constants.  <a href="namespacemlir.html#a46a3d17c70f67aa2d18203667acaf114">More...</a><br /></td></tr>
<tr class="separator:a46a3d17c70f67aa2d18203667acaf114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3983eab6c9a05efd28747c0e79dd9d44"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3983eab6c9a05efd28747c0e79dd9d44">floorDiv</a> (int64_t lhs, int64_t rhs)</td></tr>
<tr class="memdesc:a3983eab6c9a05efd28747c0e79dd9d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of MLIR's floordiv operation on constants.  <a href="namespacemlir.html#a3983eab6c9a05efd28747c0e79dd9d44">More...</a><br /></td></tr>
<tr class="separator:a3983eab6c9a05efd28747c0e79dd9d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca33cad5b0cd935568ea0fc0a439abd"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afca33cad5b0cd935568ea0fc0a439abd">mod</a> (int64_t lhs, int64_t rhs)</td></tr>
<tr class="memdesc:afca33cad5b0cd935568ea0fc0a439abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns MLIR's mod operation on constants.  <a href="namespacemlir.html#afca33cad5b0cd935568ea0fc0a439abd">More...</a><br /></td></tr>
<tr class="separator:afca33cad5b0cd935568ea0fc0a439abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da5a75b8bc3193908b0e222a6da1d85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1da5a75b8bc3193908b0e222a6da1d85">registerDefaultTimingManagerCLOptions</a> ()</td></tr>
<tr class="memdesc:a1da5a75b8bc3193908b0e222a6da1d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of useful command-line options that can be used to configure a <code><a class="el" href="classmlir_1_1DefaultTimingManager.html" title="Facilities for time measurement and report printing to an output stream.">DefaultTimingManager</a></code>.  <a href="namespacemlir.html#a1da5a75b8bc3193908b0e222a6da1d85">More...</a><br /></td></tr>
<tr class="separator:a1da5a75b8bc3193908b0e222a6da1d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41920e66a206248f862766a705125d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab41920e66a206248f862766a705125d1">applyDefaultTimingManagerCLOptions</a> (<a class="el" href="classmlir_1_1DefaultTimingManager.html">DefaultTimingManager</a> &amp;tm)</td></tr>
<tr class="memdesc:ab41920e66a206248f862766a705125d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply any values that were registered with 'registerDefaultTimingManagerOptions' to a <code><a class="el" href="classmlir_1_1DefaultTimingManager.html" title="Facilities for time measurement and report printing to an output stream.">DefaultTimingManager</a></code>.  <a href="namespacemlir.html#ab41920e66a206248f862766a705125d1">More...</a><br /></td></tr>
<tr class="separator:ab41920e66a206248f862766a705125d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f624e2b686a5cf9b36bf1289e3a143"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad0f624e2b686a5cf9b36bf1289e3a143">splitAndProcessBuffer</a> (std::unique_ptr&lt; llvm::MemoryBuffer &gt; originalBuffer, <a class="el" href="namespacemlir.html#aafb0c2458571cd80ebb876d979e24346">ChunkBufferHandler</a> processChunkBuffer, raw_ostream &amp;os, bool enableSplitting=true, bool insertMarkerInOutput=false)</td></tr>
<tr class="memdesc:ad0f624e2b686a5cf9b36bf1289e3a143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the specified buffer on a marker (<code>// -----</code>), processes each chunk independently according to the normal <code>processChunkBuffer</code> logic, and writes all results to <code>os</code>.  <a href="namespacemlir.html#ad0f624e2b686a5cf9b36bf1289e3a143">More...</a><br /></td></tr>
<tr class="separator:ad0f624e2b686a5cf9b36bf1289e3a143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb3bcc9d23b2cfd1367b84f5b00b7c1"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aafb3bcc9d23b2cfd1367b84f5b00b7c1">hash_value</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id)</td></tr>
<tr class="memdesc:aafb3bcc9d23b2cfd1367b84f5b00b7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable hashing <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a>.  <a href="namespacemlir.html#aafb3bcc9d23b2cfd1367b84f5b00b7c1">More...</a><br /></td></tr>
<tr class="separator:aafb3bcc9d23b2cfd1367b84f5b00b7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e68be8ebf61b3be9572769e19bc467"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad1e68be8ebf61b3be9572769e19bc467">registerAllToLLVMIRTranslations</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ad1e68be8ebf61b3be9572769e19bc467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers all dialects that can be translated to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR and the corresponding translation interfaces.  <a href="namespacemlir.html#ad1e68be8ebf61b3be9572769e19bc467">More...</a><br /></td></tr>
<tr class="separator:ad1e68be8ebf61b3be9572769e19bc467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b51fcb4b20988958223a34812c119a3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5b51fcb4b20988958223a34812c119a3">registerAllFromLLVMIRTranslations</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a5b51fcb4b20988958223a34812c119a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers all dialects that can be translated from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR and the corresponding translation interfaces.  <a href="namespacemlir.html#a5b51fcb4b20988958223a34812c119a3">More...</a><br /></td></tr>
<tr class="separator:a5b51fcb4b20988958223a34812c119a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0465249a74e23df5fdc548001933239c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0465249a74e23df5fdc548001933239c">registerAMXDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a0465249a74e23df5fdc548001933239c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the AMX dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#a0465249a74e23df5fdc548001933239c">More...</a><br /></td></tr>
<tr class="separator:a0465249a74e23df5fdc548001933239c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a637ec7428727c66f27117b9892f1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa4a637ec7428727c66f27117b9892f1e">registerAMXDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:aa4a637ec7428727c66f27117b9892f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the AMX dialect and the translation from it in the registry associated with the given context.  <a href="namespacemlir.html#aa4a637ec7428727c66f27117b9892f1e">More...</a><br /></td></tr>
<tr class="separator:aa4a637ec7428727c66f27117b9892f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad">registerArmNeonDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ArmNeon dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad">More...</a><br /></td></tr>
<tr class="separator:ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559f20bb41c97729f2d089e6f7a72e4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a559f20bb41c97729f2d089e6f7a72e4e">registerArmNeonDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a559f20bb41c97729f2d089e6f7a72e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ArmNeon dialect and the translation from it in the registry associated with the given context.  <a href="namespacemlir.html#a559f20bb41c97729f2d089e6f7a72e4e">More...</a><br /></td></tr>
<tr class="separator:a559f20bb41c97729f2d089e6f7a72e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53be2d34e1d4e96ea100bbf93af35a2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a53be2d34e1d4e96ea100bbf93af35a2c">registerArmSVEDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a53be2d34e1d4e96ea100bbf93af35a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ArmSVE dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#a53be2d34e1d4e96ea100bbf93af35a2c">More...</a><br /></td></tr>
<tr class="separator:a53be2d34e1d4e96ea100bbf93af35a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9c160fac7074517c6f013864acee68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afc9c160fac7074517c6f013864acee68">registerArmSVEDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:afc9c160fac7074517c6f013864acee68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ArmSVE dialect and the translation from it in the registry associated with the given context.  <a href="namespacemlir.html#afc9c160fac7074517c6f013864acee68">More...</a><br /></td></tr>
<tr class="separator:afc9c160fac7074517c6f013864acee68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857314125d33fcc46a38cd3aca4d1d12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a857314125d33fcc46a38cd3aca4d1d12">registerBuiltinDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a857314125d33fcc46a38cd3aca4d1d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the translation from the builtin dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry.  <a href="namespacemlir.html#a857314125d33fcc46a38cd3aca4d1d12">More...</a><br /></td></tr>
<tr class="separator:a857314125d33fcc46a38cd3aca4d1d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af1c7f18bef740745581f7130c8c46e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1af1c7f18bef740745581f7130c8c46e">registerBuiltinDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a1af1c7f18bef740745581f7130c8c46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the translation from the builtin dialect in the registry associated with the given context.  <a href="namespacemlir.html#a1af1c7f18bef740745581f7130c8c46e">More...</a><br /></td></tr>
<tr class="separator:a1af1c7f18bef740745581f7130c8c46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9427230420827cff7cd15f78924cdb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa9427230420827cff7cd15f78924cdb4">registerGPUDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:aa9427230420827cff7cd15f78924cdb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the GPU dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#aa9427230420827cff7cd15f78924cdb4">More...</a><br /></td></tr>
<tr class="separator:aa9427230420827cff7cd15f78924cdb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe90c6efbbc0e7e7469f14619fd7445b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afe90c6efbbc0e7e7469f14619fd7445b">registerGPUDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:afe90c6efbbc0e7e7469f14619fd7445b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the GPU dialect and the translation from it in the registry associated with the given context.  <a href="namespacemlir.html#afe90c6efbbc0e7e7469f14619fd7445b">More...</a><br /></td></tr>
<tr class="separator:afe90c6efbbc0e7e7469f14619fd7445b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01617995d72a114db65ee711b2422d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab01617995d72a114db65ee711b2422d5">registerLLVMDialectImport</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ab01617995d72a114db65ee711b2422d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and its import from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry.  <a href="namespacemlir.html#ab01617995d72a114db65ee711b2422d5">More...</a><br /></td></tr>
<tr class="separator:ab01617995d72a114db65ee711b2422d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0110d23914c27f0140d63a8bb934d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4a0110d23914c27f0140d63a8bb934d4">registerLLVMDialectImport</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a4a0110d23914c27f0140d63a8bb934d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and its import from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR with the given context.  <a href="namespacemlir.html#a4a0110d23914c27f0140d63a8bb934d4">More...</a><br /></td></tr>
<tr class="separator:a4a0110d23914c27f0140d63a8bb934d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9759ca57d83ec47b341d58d966b9e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8b9759ca57d83ec47b341d58d966b9e8">registerLLVMDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a8b9759ca57d83ec47b341d58d966b9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#a8b9759ca57d83ec47b341d58d966b9e8">More...</a><br /></td></tr>
<tr class="separator:a8b9759ca57d83ec47b341d58d966b9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74024a3b8ec9af8d50db598772774a96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a74024a3b8ec9af8d50db598772774a96">registerLLVMDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a74024a3b8ec9af8d50db598772774a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and the translation from it in the registry associated with the given context.  <a href="namespacemlir.html#a74024a3b8ec9af8d50db598772774a96">More...</a><br /></td></tr>
<tr class="separator:a74024a3b8ec9af8d50db598772774a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2989267e0da323d644b3316b85b3942f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2989267e0da323d644b3316b85b3942f">registerNVVMDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a2989267e0da323d644b3316b85b3942f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#a2989267e0da323d644b3316b85b3942f">More...</a><br /></td></tr>
<tr class="separator:a2989267e0da323d644b3316b85b3942f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d03cc4e706acdb35969f4d4e78142a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a00d03cc4e706acdb35969f4d4e78142a">registerNVVMDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a00d03cc4e706acdb35969f4d4e78142a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and the translation from it in the registry associated with the given context.  <a href="namespacemlir.html#a00d03cc4e706acdb35969f4d4e78142a">More...</a><br /></td></tr>
<tr class="separator:a00d03cc4e706acdb35969f4d4e78142a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bc345c5d25bda3847f7ddf6cebe9bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae9bc345c5d25bda3847f7ddf6cebe9bc">registerOpenACCDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ae9bc345c5d25bda3847f7ddf6cebe9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the OpenACC dialect and the translation to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#ae9bc345c5d25bda3847f7ddf6cebe9bc">More...</a><br /></td></tr>
<tr class="separator:ae9bc345c5d25bda3847f7ddf6cebe9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889d8518a5c67b981e76d27c9a256d86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a889d8518a5c67b981e76d27c9a256d86">registerOpenACCDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a889d8518a5c67b981e76d27c9a256d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the OpenACC dialect and the translation in the registry associated with the given context.  <a href="namespacemlir.html#a889d8518a5c67b981e76d27c9a256d86">More...</a><br /></td></tr>
<tr class="separator:a889d8518a5c67b981e76d27c9a256d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea20d97a32efd36c02468e54db4b2e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6ea20d97a32efd36c02468e54db4b2e7">registerOpenMPDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a6ea20d97a32efd36c02468e54db4b2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the OpenMP dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#a6ea20d97a32efd36c02468e54db4b2e7">More...</a><br /></td></tr>
<tr class="separator:a6ea20d97a32efd36c02468e54db4b2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa35b353841b70d090e1ead360536308"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aaa35b353841b70d090e1ead360536308">registerOpenMPDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:aaa35b353841b70d090e1ead360536308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the OpenMP dialect and the translation from it in the registry associated with the given context.  <a href="namespacemlir.html#aaa35b353841b70d090e1ead360536308">More...</a><br /></td></tr>
<tr class="separator:aaa35b353841b70d090e1ead360536308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab895c88d57833ccee805eb3233c04ca6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab895c88d57833ccee805eb3233c04ca6">registerROCDLDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ab895c88d57833ccee805eb3233c04ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ROCDL dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#ab895c88d57833ccee805eb3233c04ca6">More...</a><br /></td></tr>
<tr class="separator:ab895c88d57833ccee805eb3233c04ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e522221c6652cb1450a6a3803125534"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4e522221c6652cb1450a6a3803125534">registerROCDLDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a4e522221c6652cb1450a6a3803125534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ROCDL dialect and the translation from it in the registry associated with the given context.  <a href="namespacemlir.html#a4e522221c6652cb1450a6a3803125534">More...</a><br /></td></tr>
<tr class="separator:a4e522221c6652cb1450a6a3803125534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a06304b237de21b74a8c5b3251ac35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a06a06304b237de21b74a8c5b3251ac35">registerX86VectorDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a06a06304b237de21b74a8c5b3251ac35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the X86Vector dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#a06a06304b237de21b74a8c5b3251ac35">More...</a><br /></td></tr>
<tr class="separator:a06a06304b237de21b74a8c5b3251ac35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087d9cf09c9d93a0bf0f287509afc5b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a087d9cf09c9d93a0bf0f287509afc5b4">registerX86VectorDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a087d9cf09c9d93a0bf0f287509afc5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the X86Vector dialect and the translation from it in the registry associated with the given context.  <a href="namespacemlir.html#a087d9cf09c9d93a0bf0f287509afc5b4">More...</a><br /></td></tr>
<tr class="separator:a087d9cf09c9d93a0bf0f287509afc5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc149979459c3123124db882fb765dba"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adc149979459c3123124db882fb765dba">translateModuleToLLVMIR</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *module, llvm::LLVMContext &amp;llvmContext, llvm::StringRef name=&quot;LLVMDialectModule&quot;)</td></tr>
<tr class="memdesc:adc149979459c3123124db882fb765dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate operation that satisfies <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect module requirements into an <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR module living in the given context.  <a href="namespacemlir.html#adc149979459c3123124db882fb765dba">More...</a><br /></td></tr>
<tr class="separator:adc149979459c3123124db882fb765dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1f3b8cc0f16fa8f9165cce0e5a875b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afc1f3b8cc0f16fa8f9165cce0e5a875b">translateLLVMIRToModule</a> (std::unique_ptr&lt; llvm::Module &gt; llvmModule, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:afc1f3b8cc0f16fa8f9165cce0e5a875b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> module into an MLIR module living in the given context.  <a href="namespacemlir.html#afc1f3b8cc0f16fa8f9165cce0e5a875b">More...</a><br /></td></tr>
<tr class="separator:afc1f3b8cc0f16fa8f9165cce0e5a875b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f93379e5dbb5551bbe57170230a1d92"><td class="memItemLeft" align="right" valign="top">DataLayoutSpecInterface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2f93379e5dbb5551bbe57170230a1d92">translateDataLayout</a> (const llvm::DataLayout &amp;dataLayout, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a2f93379e5dbb5551bbe57170230a1d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate the given <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> data layout into an MLIR equivalent using the DLTI dialect.  <a href="namespacemlir.html#a2f93379e5dbb5551bbe57170230a1d92">More...</a><br /></td></tr>
<tr class="separator:a2f93379e5dbb5551bbe57170230a1d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ad163144fafb93cf9814b2235ccf59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af3ad163144fafb93cf9814b2235ccf59">MlirLspServerMain</a> (int argc, char **argv, <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:af3ad163144fafb93cf9814b2235ccf59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for tools like <code>mlir-lsp-server</code>.  <a href="namespacemlir.html#af3ad163144fafb93cf9814b2235ccf59">More...</a><br /></td></tr>
<tr class="separator:af3ad163144fafb93cf9814b2235ccf59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440508357b9fe36f36010043c99e2f22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a440508357b9fe36f36010043c99e2f22">MlirOptMain</a> (llvm::raw_ostream &amp;outputStream, std::unique_ptr&lt; llvm::MemoryBuffer &gt; buffer, <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry, const <a class="el" href="classmlir_1_1MlirOptMainConfig.html">MlirOptMainConfig</a> &amp;config)</td></tr>
<tr class="memdesc:a440508357b9fe36f36010043c99e2f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the core processing behind <code>mlir-opt</code>.  <a href="namespacemlir.html#a440508357b9fe36f36010043c99e2f22">More...</a><br /></td></tr>
<tr class="separator:a440508357b9fe36f36010043c99e2f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6b96254b4e476bf34403287c27825a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1f6b96254b4e476bf34403287c27825a">MlirOptMain</a> (int argc, char **argv, llvm::StringRef toolName, <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a1f6b96254b4e476bf34403287c27825a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for tools like <code>mlir-opt</code>.  <a href="namespacemlir.html#a1f6b96254b4e476bf34403287c27825a">More...</a><br /></td></tr>
<tr class="separator:a1f6b96254b4e476bf34403287c27825a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1168f4877a1008569deabfdab07fbb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3d1168f4877a1008569deabfdab07fbb">asMainReturnCode</a> (<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> r)</td></tr>
<tr class="memdesc:a3d1168f4877a1008569deabfdab07fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper wrapper to return the result of MlirOptMain directly from main.  <a href="namespacemlir.html#a3d1168f4877a1008569deabfdab07fbb">More...</a><br /></td></tr>
<tr class="separator:a3d1168f4877a1008569deabfdab07fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf1fa346908020b9dbc2009bb3630ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afcf1fa346908020b9dbc2009bb3630ce">MlirPdllLspServerMain</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:afcf1fa346908020b9dbc2009bb3630ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for tools like <code>mlir-pdll-lsp-server</code>.  <a href="namespacemlir.html#afcf1fa346908020b9dbc2009bb3630ce">More...</a><br /></td></tr>
<tr class="separator:afcf1fa346908020b9dbc2009bb3630ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab515fd3b6aebea7df681f094b42d9e71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab515fd3b6aebea7df681f094b42d9e71">mlirReduceMain</a> (int argc, char **argv, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="separator:ab515fd3b6aebea7df681f094b42d9e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4175a8043cece857c2779663ef3ba91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad4175a8043cece857c2779663ef3ba91">MlirTblgenMain</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:ad4175a8043cece857c2779663ef3ba91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main Program for tools like 'mlir-tblgen' with custom backends.  <a href="namespacemlir.html#ad4175a8043cece857c2779663ef3ba91">More...</a><br /></td></tr>
<tr class="separator:ad4175a8043cece857c2779663ef3ba91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab673e648679ec83d87417b04baf281dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab673e648679ec83d87417b04baf281dd">mlirTranslateMain</a> (int argc, char **argv, StringRef toolName)</td></tr>
<tr class="memdesc:ab673e648679ec83d87417b04baf281dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate to/from an MLIR module from/to an external representation (e.g.  <a href="namespacemlir.html#ab673e648679ec83d87417b04baf281dd">More...</a><br /></td></tr>
<tr class="separator:ab673e648679ec83d87417b04baf281dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a41d372a37300e7b09f82fbd8b2d425"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3a41d372a37300e7b09f82fbd8b2d425">registerTranslationCLOptions</a> ()</td></tr>
<tr class="memdesc:a3a41d372a37300e7b09f82fbd8b2d425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register command-line options used by the translation registry.  <a href="namespacemlir.html#a3a41d372a37300e7b09f82fbd8b2d425">More...</a><br /></td></tr>
<tr class="separator:a3a41d372a37300e7b09f82fbd8b2d425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718d37dc4122f9a0851238684eb13a39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a718d37dc4122f9a0851238684eb13a39">parseSourceFileForTool</a> (const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config, bool insertImplicitModule)</td></tr>
<tr class="memdesc:a718d37dc4122f9a0851238684eb13a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated SourceMgr.  <a href="namespacemlir.html#a718d37dc4122f9a0851238684eb13a39">More...</a><br /></td></tr>
<tr class="separator:a718d37dc4122f9a0851238684eb13a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71592b6a57d95558cc2094b140ec445"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae71592b6a57d95558cc2094b140ec445">TableGenLspServerMain</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:ae71592b6a57d95558cc2094b140ec445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for tools like <code>tblgen-lsp-server</code>.  <a href="namespacemlir.html#ae71592b6a57d95558cc2094b140ec445">More...</a><br /></td></tr>
<tr class="separator:ae71592b6a57d95558cc2094b140ec445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6657dab425bc62dafe146c813979dc2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6657dab425bc62dafe146c813979dc2b">populateCommutativityUtilsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a6657dab425bc62dafe146c813979dc2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the commutativity utility patterns.  <a href="namespacemlir.html#a6657dab425bc62dafe146c813979dc2b">More...</a><br /></td></tr>
<tr class="separator:a6657dab425bc62dafe146c813979dc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e826b7dff0a2629197a20d859cd4c7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac6e826b7dff0a2629197a20d859cd4c7">controlFlowSink</a> (<a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a> regions, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; shouldMoveIntoRegion, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; moveIntoRegion)</td></tr>
<tr class="memdesc:ac6e826b7dff0a2629197a20d859cd4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of regions, perform control flow sinking on them.  <a href="namespacemlir.html#ac6e826b7dff0a2629197a20d859cd4c7">More...</a><br /></td></tr>
<tr class="separator:ac6e826b7dff0a2629197a20d859cd4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03521cb5a2e00b91574ef1df705310bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a03521cb5a2e00b91574ef1df705310bd">getSinglyExecutedRegionsToSink</a> (RegionBranchOpInterface branch, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> * &gt; &amp;regions)</td></tr>
<tr class="memdesc:a03521cb5a2e00b91574ef1df705310bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>regions</code> with regions of the provided region branch op that are executed at most once at that are reachable given the current operands of the op.  <a href="namespacemlir.html#a03521cb5a2e00b91574ef1df705310bd">More...</a><br /></td></tr>
<tr class="separator:a03521cb5a2e00b91574ef1df705310bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12287a4adc9d89ce2ed49712b091c5fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a12287a4adc9d89ce2ed49712b091c5fa">populateFunctionOpInterfaceTypeConversionPattern</a> (StringRef functionLikeOpName, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="memdesc:a12287a4adc9d89ce2ed49712b091c5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pattern to the given pattern list to convert the signature of a FunctionOpInterface op with the given type converter.  <a href="namespacemlir.html#a12287a4adc9d89ce2ed49712b091c5fa">More...</a><br /></td></tr>
<tr class="separator:a12287a4adc9d89ce2ed49712b091c5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab8b50117bb49a7ce3d85628dd374b8"><td class="memTemplParams" colspan="2">template&lt;typename FuncOpT &gt; </td></tr>
<tr class="memitem:a1ab8b50117bb49a7ce3d85628dd374b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1ab8b50117bb49a7ce3d85628dd374b8">populateFunctionOpInterfaceTypeConversionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="separator:a1ab8b50117bb49a7ce3d85628dd374b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d377212fbb36b5d552063fab3c054e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab5d377212fbb36b5d552063fab3c054e">populateAnyFunctionOpInterfaceTypeConversionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="separator:ab5d377212fbb36b5d552063fab3c054e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53cd627dc538a8da5a61d8ba621e603"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae53cd627dc538a8da5a61d8ba621e603">registerConversionPDLFunctions</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ae53cd627dc538a8da5a61d8ba621e603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the dialect conversion PDL functions with the given pattern set.  <a href="namespacemlir.html#ae53cd627dc538a8da5a61d8ba621e603">More...</a><br /></td></tr>
<tr class="separator:ae53cd627dc538a8da5a61d8ba621e603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239d533c4f17a4d6e0c3fa5a3e362692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a239d533c4f17a4d6e0c3fa5a3e362692">applyPartialConversion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; ops, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *unconvertedOps=nullptr)</td></tr>
<tr class="memdesc:a239d533c4f17a4d6e0c3fa5a3e362692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Below we define several entry points for operation conversion.  <a href="namespacemlir.html#a239d533c4f17a4d6e0c3fa5a3e362692">More...</a><br /></td></tr>
<tr class="separator:a239d533c4f17a4d6e0c3fa5a3e362692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6bdfc70c056bdf02a5d1470b926eab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acc6bdfc70c056bdf02a5d1470b926eab">applyPartialConversion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *unconvertedOps=nullptr)</td></tr>
<tr class="separator:acc6bdfc70c056bdf02a5d1470b926eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7512bc48b1a360b7881bd8e8edf74e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aaa7512bc48b1a360b7881bd8e8edf74e">applyFullConversion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; ops, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aaa7512bc48b1a360b7881bd8e8edf74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a complete conversion on the given operations, and all nested operations.  <a href="namespacemlir.html#aaa7512bc48b1a360b7881bd8e8edf74e">More...</a><br /></td></tr>
<tr class="separator:aaa7512bc48b1a360b7881bd8e8edf74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da50bb4604fb05010c585eb301e2789"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1da50bb4604fb05010c585eb301e2789">applyFullConversion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a1da50bb4604fb05010c585eb301e2789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab585c34c7b24e9436fd19b4eeda434"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afab585c34c7b24e9436fd19b4eeda434">applyAnalysisConversion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; ops, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;convertedOps, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;)&gt; notifyCallback=nullptr)</td></tr>
<tr class="memdesc:afab585c34c7b24e9436fd19b4eeda434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an analysis conversion on the given operations, and all nested operations.  <a href="namespacemlir.html#afab585c34c7b24e9436fd19b4eeda434">More...</a><br /></td></tr>
<tr class="separator:afab585c34c7b24e9436fd19b4eeda434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8c56a3b48cf2fac3d26eb11e76a2f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ade8c56a3b48cf2fac3d26eb11e76a2f4">applyAnalysisConversion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;convertedOps, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;)&gt; notifyCallback=nullptr)</td></tr>
<tr class="separator:ade8c56a3b48cf2fac3d26eb11e76a2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cb09dc0d8e54bce84bd4ad60f155f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a13cb09dc0d8e54bce84bd4ad60f155f0">applyPatternsAndFoldGreedily</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> config=<a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>())</td></tr>
<tr class="memdesc:a13cb09dc0d8e54bce84bd4ad60f155f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite ops in the given region, which must be isolated from above, by repeatedly applying the highest benefit patterns in a greedy work-list driven manner.  <a href="namespacemlir.html#a13cb09dc0d8e54bce84bd4ad60f155f0">More...</a><br /></td></tr>
<tr class="separator:a13cb09dc0d8e54bce84bd4ad60f155f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218fc6e0abad6c66d8c518853b50f084"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a218fc6e0abad6c66d8c518853b50f084">applyPatternsAndFoldGreedily</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> config=<a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>())</td></tr>
<tr class="memdesc:a218fc6e0abad6c66d8c518853b50f084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite ops in all regions of the given op, which must be isolated from above.  <a href="namespacemlir.html#a218fc6e0abad6c66d8c518853b50f084">More...</a><br /></td></tr>
<tr class="separator:a218fc6e0abad6c66d8c518853b50f084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b86ede77ff793a77a2f26ac8755313"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a10b86ede77ff793a77a2f26ac8755313">applyOpPatternsAndFold</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; ops, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> config=<a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>(), bool *changed=nullptr, bool *allErased=nullptr)</td></tr>
<tr class="memdesc:a10b86ede77ff793a77a2f26ac8755313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the specified rewrite patterns on <code>ops</code> while also trying to fold these ops.  <a href="namespacemlir.html#a10b86ede77ff793a77a2f26ac8755313">More...</a><br /></td></tr>
<tr class="separator:a10b86ede77ff793a77a2f26ac8755313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754f32a9d62efdcb48e4e0a2f3da1576"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a754f32a9d62efdcb48e4e0a2f3da1576">inlineRegion</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *inlinePoint, <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;mapper, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> resultsToReplace, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> regionResultTypes, std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; inlineLoc=std::nullopt, bool shouldCloneInlinedRegion=true)</td></tr>
<tr class="memdesc:a754f32a9d62efdcb48e4e0a2f3da1576"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inlines a region, 'src', into another.  <a href="namespacemlir.html#a754f32a9d62efdcb48e4e0a2f3da1576">More...</a><br /></td></tr>
<tr class="separator:a754f32a9d62efdcb48e4e0a2f3da1576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1236e68e2c467729ae0f0c6189e3d55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad1236e68e2c467729ae0f0c6189e3d55">inlineRegion</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Block.html">Block</a> *inlineBlock, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> inlinePoint, <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;mapper, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> resultsToReplace, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> regionResultTypes, std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; inlineLoc=std::nullopt, bool shouldCloneInlinedRegion=true)</td></tr>
<tr class="separator:ad1236e68e2c467729ae0f0c6189e3d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16442f718030c48c28c7ae986fa39acf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a16442f718030c48c28c7ae986fa39acf">inlineRegion</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *inlinePoint, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inlinedOperands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> resultsToReplace, std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; inlineLoc=std::nullopt, bool shouldCloneInlinedRegion=true)</td></tr>
<tr class="memdesc:a16442f718030c48c28c7ae986fa39acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is an overload of the above 'inlineRegion' that allows for providing the set of operands ('inlinedOperands') that should be used in-favor of the region arguments when inlining.  <a href="namespacemlir.html#a16442f718030c48c28c7ae986fa39acf">More...</a><br /></td></tr>
<tr class="separator:a16442f718030c48c28c7ae986fa39acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1be5dbac3676f88a7f87669ec0f2484"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad1be5dbac3676f88a7f87669ec0f2484">inlineRegion</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Block.html">Block</a> *inlineBlock, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> inlinePoint, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inlinedOperands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> resultsToReplace, std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; inlineLoc=std::nullopt, bool shouldCloneInlinedRegion=true)</td></tr>
<tr class="separator:ad1be5dbac3676f88a7f87669ec0f2484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa82b2f82348c0eacc76f1c4a862a796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afa82b2f82348c0eacc76f1c4a862a796">inlineCall</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, CallOpInterface call, CallableOpInterface callable, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, bool shouldCloneInlinedRegion=true)</td></tr>
<tr class="memdesc:afa82b2f82348c0eacc76f1c4a862a796"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inlines a given region, 'src', of a callable operation, 'callable', into the location defined by the given call operation.  <a href="namespacemlir.html#afa82b2f82348c0eacc76f1c4a862a796">More...</a><br /></td></tr>
<tr class="separator:afa82b2f82348c0eacc76f1c4a862a796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3bd1afbf84ef9cca6c336a104d7280"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2d3bd1afbf84ef9cca6c336a104d7280">generateLocationsFromIR</a> (raw_ostream &amp;os, StringRef fileName, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags)</td></tr>
<tr class="memdesc:a2d3bd1afbf84ef9cca6c336a104d7280"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates new locations from the given IR by snapshotting the IR to the given stream, and using the printed locations within that stream.  <a href="namespacemlir.html#a2d3bd1afbf84ef9cca6c336a104d7280">More...</a><br /></td></tr>
<tr class="separator:a2d3bd1afbf84ef9cca6c336a104d7280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16c6823f94d6ce99fa7da7547658345"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af16c6823f94d6ce99fa7da7547658345">generateLocationsFromIR</a> (StringRef fileName, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags)</td></tr>
<tr class="memdesc:af16c6823f94d6ce99fa7da7547658345"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates new locations from the given IR by snapshotting the IR to the given file, and using the printed locations within that file.  <a href="namespacemlir.html#af16c6823f94d6ce99fa7da7547658345">More...</a><br /></td></tr>
<tr class="separator:af16c6823f94d6ce99fa7da7547658345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e9bde94caabba0feba96a044a09afc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a94e9bde94caabba0feba96a044a09afc">generateLocationsFromIR</a> (raw_ostream &amp;os, StringRef fileName, StringRef tag, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags)</td></tr>
<tr class="memdesc:a94e9bde94caabba0feba96a044a09afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates new locations from the given IR by snapshotting the IR to the given stream, and using the printed locations within that stream.  <a href="namespacemlir.html#a94e9bde94caabba0feba96a044a09afc">More...</a><br /></td></tr>
<tr class="separator:a94e9bde94caabba0feba96a044a09afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab170389f5f17475f89037e332018b4f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab170389f5f17475f89037e332018b4f8">generateLocationsFromIR</a> (StringRef fileName, StringRef tag, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags)</td></tr>
<tr class="memdesc:ab170389f5f17475f89037e332018b4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates new locations from the given IR by snapshotting the IR to the given file, and using the printed locations within that file.  <a href="namespacemlir.html#ab170389f5f17475f89037e332018b4f8">More...</a><br /></td></tr>
<tr class="separator:ab170389f5f17475f89037e332018b4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415fbf6253902c584461fa6a43a59ad5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a415fbf6253902c584461fa6a43a59ad5">createLocationSnapshotPass</a> (<a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags, StringRef fileName=&quot;&quot;, StringRef tag=&quot;&quot;)</td></tr>
<tr class="memdesc:a415fbf6253902c584461fa6a43a59ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to generate new locations by snapshotting the IR to the given file, and using the printed locations within that file.  <a href="namespacemlir.html#a415fbf6253902c584461fa6a43a59ad5">More...</a><br /></td></tr>
<tr class="separator:a415fbf6253902c584461fa6a43a59ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0bdadbeb0d7f5b8cef57668447640b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abb0bdadbeb0d7f5b8cef57668447640b">createLocationSnapshotPass</a> ()</td></tr>
<tr class="memdesc:abb0bdadbeb0d7f5b8cef57668447640b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload utilizing pass options for initialization.  <a href="namespacemlir.html#abb0bdadbeb0d7f5b8cef57668447640b">More...</a><br /></td></tr>
<tr class="separator:abb0bdadbeb0d7f5b8cef57668447640b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7770d05a67ea19ac133fde220298b3c7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7770d05a67ea19ac133fde220298b3c7">moveLoopInvariantCode</a> (<a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a> regions, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; isDefinedOutsideRegion, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; shouldMoveOutOfRegion, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; moveOutOfRegion)</td></tr>
<tr class="memdesc:a7770d05a67ea19ac133fde220298b3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of regions, perform loop-invariant code motion.  <a href="namespacemlir.html#a7770d05a67ea19ac133fde220298b3c7">More...</a><br /></td></tr>
<tr class="separator:a7770d05a67ea19ac133fde220298b3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b9f2d2e0330c53880b673633907ac6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a56b9f2d2e0330c53880b673633907ac6">moveLoopInvariantCode</a> (LoopLikeOpInterface loopLike)</td></tr>
<tr class="memdesc:a56b9f2d2e0330c53880b673633907ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move side-effect free loop invariant code out of a loop-like op using methods provided by the interface.  <a href="namespacemlir.html#a56b9f2d2e0330c53880b673633907ac6">More...</a><br /></td></tr>
<tr class="separator:a56b9f2d2e0330c53880b673633907ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a711d749b7adf4b8d57219d55753c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af6a711d749b7adf4b8d57219d55753c3">tryToPromoteMemorySlots</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; PromotableAllocationOpInterface &gt; allocators, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;dominance)</td></tr>
<tr class="memdesc:af6a711d749b7adf4b8d57219d55753c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to promote the memory slots of the provided allocators.  <a href="namespacemlir.html#af6a711d749b7adf4b8d57219d55753c3">More...</a><br /></td></tr>
<tr class="separator:af6a711d749b7adf4b8d57219d55753c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32067eb3e1b98572873f7cce08848080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a32067eb3e1b98572873f7cce08848080">applyPartialOneToNConversion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OneToNTypeConverter.html">OneToNTypeConverter</a> &amp;typeConverter, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a32067eb3e1b98572873f7cce08848080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given set of patterns recursively on the given op and adds user materializations where necessary.  <a href="namespacemlir.html#a32067eb3e1b98572873f7cce08848080">More...</a><br /></td></tr>
<tr class="separator:a32067eb3e1b98572873f7cce08848080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0069355214b578476e81bc909f7f13"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aab0069355214b578476e81bc909f7f13">createCanonicalizerPass</a> ()</td></tr>
<tr class="memdesc:aab0069355214b578476e81bc909f7f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the Canonicalizer pass, configured with default settings (which can be overridden by pass options on the command line).  <a href="namespacemlir.html#aab0069355214b578476e81bc909f7f13">More...</a><br /></td></tr>
<tr class="separator:aab0069355214b578476e81bc909f7f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c145cb37ca2bf4e90ceaff2231652f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a93c145cb37ca2bf4e90ceaff2231652f">createCanonicalizerPass</a> (const <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> &amp;config, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt; disabledPatterns=std::nullopt, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt; enabledPatterns=std::nullopt)</td></tr>
<tr class="memdesc:a93c145cb37ca2bf4e90ceaff2231652f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the Canonicalizer pass with the specified config.  <a href="namespacemlir.html#a93c145cb37ca2bf4e90ceaff2231652f">More...</a><br /></td></tr>
<tr class="separator:a93c145cb37ca2bf4e90ceaff2231652f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f1d125e949d2172433639f2f31d3e6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac1f1d125e949d2172433639f2f31d3e6">createControlFlowSinkPass</a> ()</td></tr>
<tr class="memdesc:ac1f1d125e949d2172433639f2f31d3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to perform control-flow sinking.  <a href="namespacemlir.html#ac1f1d125e949d2172433639f2f31d3e6">More...</a><br /></td></tr>
<tr class="separator:ac1f1d125e949d2172433639f2f31d3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14895da9723acd9c7f910c2694ff9f65"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a14895da9723acd9c7f910c2694ff9f65">createCSEPass</a> ()</td></tr>
<tr class="memdesc:a14895da9723acd9c7f910c2694ff9f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to perform common sub expression elimination.  <a href="namespacemlir.html#a14895da9723acd9c7f910c2694ff9f65">More...</a><br /></td></tr>
<tr class="separator:a14895da9723acd9c7f910c2694ff9f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a84c3fae02e7540b0db48350b738be1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0a84c3fae02e7540b0db48350b738be1">createPrintIRPass</a> (const PrintIRPassOptions &amp;={})</td></tr>
<tr class="memdesc:a0a84c3fae02e7540b0db48350b738be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to print IR on the debug stream.  <a href="namespacemlir.html#a0a84c3fae02e7540b0db48350b738be1">More...</a><br /></td></tr>
<tr class="separator:a0a84c3fae02e7540b0db48350b738be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdd2528f381177f9ded6de5eba9900b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6fdd2528f381177f9ded6de5eba9900b">createGenerateRuntimeVerificationPass</a> ()</td></tr>
<tr class="memdesc:a6fdd2528f381177f9ded6de5eba9900b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that generates IR to verify ops at runtime.  <a href="namespacemlir.html#a6fdd2528f381177f9ded6de5eba9900b">More...</a><br /></td></tr>
<tr class="separator:a6fdd2528f381177f9ded6de5eba9900b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319fde65e573dbc3a947d58196cb2b3a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a319fde65e573dbc3a947d58196cb2b3a">createLoopInvariantCodeMotionPass</a> ()</td></tr>
<tr class="memdesc:a319fde65e573dbc3a947d58196cb2b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop invariant code motion pass that hoists loop invariant instructions out of the loop.  <a href="namespacemlir.html#a319fde65e573dbc3a947d58196cb2b3a">More...</a><br /></td></tr>
<tr class="separator:a319fde65e573dbc3a947d58196cb2b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b152134b4d44a148dac8bfc24070dcd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3b152134b4d44a148dac8bfc24070dcd">createStripDebugInfoPass</a> ()</td></tr>
<tr class="memdesc:a3b152134b4d44a148dac8bfc24070dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to strip debug information from a function.  <a href="namespacemlir.html#a3b152134b4d44a148dac8bfc24070dcd">More...</a><br /></td></tr>
<tr class="separator:a3b152134b4d44a148dac8bfc24070dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56d49b89c1f203d6fa20f126bf4d900"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab56d49b89c1f203d6fa20f126bf4d900">createPrintOpStatsPass</a> (raw_ostream &amp;os=llvm::errs())</td></tr>
<tr class="memdesc:ab56d49b89c1f203d6fa20f126bf4d900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which prints the list of ops and the number of occurrences in the module.  <a href="namespacemlir.html#ab56d49b89c1f203d6fa20f126bf4d900">More...</a><br /></td></tr>
<tr class="separator:ab56d49b89c1f203d6fa20f126bf4d900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738190b0f29ddc52ba6847cb310eb60d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a738190b0f29ddc52ba6847cb310eb60d">createPrintOpStatsPass</a> (raw_ostream &amp;os, bool printAsJSON)</td></tr>
<tr class="memdesc:a738190b0f29ddc52ba6847cb310eb60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which prints the list of ops and the number of occurrences in the module with the output format option.  <a href="namespacemlir.html#a738190b0f29ddc52ba6847cb310eb60d">More...</a><br /></td></tr>
<tr class="separator:a738190b0f29ddc52ba6847cb310eb60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6ad0644a283c257d1fbc15be6adc18"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6c6ad0644a283c257d1fbc15be6adc18">createInlinerPass</a> ()</td></tr>
<tr class="memdesc:a6c6ad0644a283c257d1fbc15be6adc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which inlines calls and callable operations as defined by the <a class="el" href="classmlir_1_1CallGraph.html">CallGraph</a>.  <a href="namespacemlir.html#a6c6ad0644a283c257d1fbc15be6adc18">More...</a><br /></td></tr>
<tr class="separator:a6c6ad0644a283c257d1fbc15be6adc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1372ce1294d9b98b652930aa6baf1386"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1372ce1294d9b98b652930aa6baf1386">createInlinerPass</a> (llvm::StringMap&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt; opPipelines)</td></tr>
<tr class="memdesc:a1372ce1294d9b98b652930aa6baf1386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the inliner pass, and use the provided pass managers when optimizing callable operations with names matching the key type.  <a href="namespacemlir.html#a1372ce1294d9b98b652930aa6baf1386">More...</a><br /></td></tr>
<tr class="separator:a1372ce1294d9b98b652930aa6baf1386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282d4666d1a10f4c41e6b114bf5e6a7f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a282d4666d1a10f4c41e6b114bf5e6a7f">createInlinerPass</a> (llvm::StringMap&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt; opPipelines, std::function&lt; void(<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;)&gt; defaultPipelineBuilder)</td></tr>
<tr class="memdesc:a282d4666d1a10f4c41e6b114bf5e6a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the inliner pass, and use the provided pass managers when optimizing callable operations with names matching the key type.  <a href="namespacemlir.html#a282d4666d1a10f4c41e6b114bf5e6a7f">More...</a><br /></td></tr>
<tr class="separator:a282d4666d1a10f4c41e6b114bf5e6a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6119493f8c83de427f34658e5e39cbfe"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6119493f8c83de427f34658e5e39cbfe">createSCCPPass</a> ()</td></tr>
<tr class="memdesc:a6119493f8c83de427f34658e5e39cbfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which performs sparse conditional constant propagation over nested operations.  <a href="namespacemlir.html#a6119493f8c83de427f34658e5e39cbfe">More...</a><br /></td></tr>
<tr class="separator:a6119493f8c83de427f34658e5e39cbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69605e45210627de9b7fde4644fa50c1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a69605e45210627de9b7fde4644fa50c1">createSymbolDCEPass</a> ()</td></tr>
<tr class="memdesc:a69605e45210627de9b7fde4644fa50c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which delete symbol operations that are unreachable.  <a href="namespacemlir.html#a69605e45210627de9b7fde4644fa50c1">More...</a><br /></td></tr>
<tr class="separator:a69605e45210627de9b7fde4644fa50c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b0f8a089ed821a240c7dd4e5573573"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae0b0f8a089ed821a240c7dd4e5573573">createSymbolPrivatizePass</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt; excludeSymbols={})</td></tr>
<tr class="memdesc:ae0b0f8a089ed821a240c7dd4e5573573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which marks top-level symbol operations as <code>private</code> unless listed in <code>excludeSymbols</code>.  <a href="namespacemlir.html#ae0b0f8a089ed821a240c7dd4e5573573">More...</a><br /></td></tr>
<tr class="separator:ae0b0f8a089ed821a240c7dd4e5573573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4480ae6dd145482f88ec81d28df3bca8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4480ae6dd145482f88ec81d28df3bca8">createTopologicalSortPass</a> ()</td></tr>
<tr class="memdesc:a4480ae6dd145482f88ec81d28df3bca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that recursively sorts nested regions without SSA dominance topologically such that, as much as possible, users of values appear after their producers.  <a href="namespacemlir.html#a4480ae6dd145482f88ec81d28df3bca8">More...</a><br /></td></tr>
<tr class="separator:a4480ae6dd145482f88ec81d28df3bca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac680df79552c596c048cd9cb27638c5f"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:ac680df79552c596c048cd9cb27638c5f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac680df79552c596c048cd9cb27638c5f">areValuesDefinedAbove</a> (<a class="el" href="structmlir_1_1Range.html">Range</a> values, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;limit)</td></tr>
<tr class="memdesc:ac680df79552c596c048cd9cb27638c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all values in the provided range are defined above the <code>limit</code> region.  <a href="namespacemlir.html#ac680df79552c596c048cd9cb27638c5f">More...</a><br /></td></tr>
<tr class="separator:ac680df79552c596c048cd9cb27638c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a5d204dd78ac563241168e6b2e40eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a15a5d204dd78ac563241168e6b2e40eb">replaceAllUsesInRegionWith</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> orig, <a class="el" href="classmlir_1_1Value.html">Value</a> replacement, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:a15a5d204dd78ac563241168e6b2e40eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all uses of <code>orig</code> within the given region with <code>replacement</code>.  <a href="namespacemlir.html#a15a5d204dd78ac563241168e6b2e40eb">More...</a><br /></td></tr>
<tr class="separator:a15a5d204dd78ac563241168e6b2e40eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae644ec0854505ef60f12c23b96de595b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae644ec0854505ef60f12c23b96de595b">visitUsedValuesDefinedAbove</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;limit, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt; callback)</td></tr>
<tr class="memdesc:ae644ec0854505ef60f12c23b96de595b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>callback</code> for each use of a value within <code>region</code> or its descendants that was defined at the ancestors of the <code>limit</code>.  <a href="namespacemlir.html#ae644ec0854505ef60f12c23b96de595b">More...</a><br /></td></tr>
<tr class="separator:ae644ec0854505ef60f12c23b96de595b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036e7ce3c7c3bf73fc0a653cd98bb7c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a036e7ce3c7c3bf73fc0a653cd98bb7c0">visitUsedValuesDefinedAbove</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt; callback)</td></tr>
<tr class="memdesc:a036e7ce3c7c3bf73fc0a653cd98bb7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>callback</code> for each use of a value within any of the regions provided that was defined in one of the ancestors.  <a href="namespacemlir.html#a036e7ce3c7c3bf73fc0a653cd98bb7c0">More...</a><br /></td></tr>
<tr class="separator:a036e7ce3c7c3bf73fc0a653cd98bb7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f08e970a346cd42559db87f97f0b91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a98f08e970a346cd42559db87f97f0b91">getUsedValuesDefinedAbove</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;limit, <a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:a98f08e970a346cd42559db87f97f0b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill <code>values</code> with a list of values defined at the ancestors of the <code>limit</code> region and used within <code>region</code> or its descendants.  <a href="namespacemlir.html#a98f08e970a346cd42559db87f97f0b91">More...</a><br /></td></tr>
<tr class="separator:a98f08e970a346cd42559db87f97f0b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c45b388f069e9396c50660f41a7eacf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2c45b388f069e9396c50660f41a7eacf">getUsedValuesDefinedAbove</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions, <a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:a2c45b388f069e9396c50660f41a7eacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill <code>values</code> with a list of values used within any of the regions provided but defined in one of the ancestors.  <a href="namespacemlir.html#a2c45b388f069e9396c50660f41a7eacf">More...</a><br /></td></tr>
<tr class="separator:a2c45b388f069e9396c50660f41a7eacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d806144c2d33e56f341109c75c3d277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7d806144c2d33e56f341109c75c3d277">makeRegionIsolatedFromAbove</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; cloneOperationIntoRegion=[](<a class="el" href="classmlir_1_1Operation.html">Operation</a> *) { return false;})</td></tr>
<tr class="memdesc:a7d806144c2d33e56f341109c75c3d277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a region isolated from above.  <a href="namespacemlir.html#a7d806144c2d33e56f341109c75c3d277">More...</a><br /></td></tr>
<tr class="separator:a7d806144c2d33e56f341109c75c3d277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c016066a116564e82772ece3edd84c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a50c016066a116564e82772ece3edd84c">simplifyRegions</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions)</td></tr>
<tr class="memdesc:a50c016066a116564e82772ece3edd84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a set of structural simplifications over the given regions.  <a href="namespacemlir.html#a50c016066a116564e82772ece3edd84c">More...</a><br /></td></tr>
<tr class="separator:a50c016066a116564e82772ece3edd84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab9585c8607c12142232e0f58ebcc8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6ab9585c8607c12142232e0f58ebcc8b">eraseUnreachableBlocks</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions)</td></tr>
<tr class="memdesc:a6ab9585c8607c12142232e0f58ebcc8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the unreachable blocks within the provided regions.  <a href="namespacemlir.html#a6ab9585c8607c12142232e0f58ebcc8b">More...</a><br /></td></tr>
<tr class="separator:a6ab9585c8607c12142232e0f58ebcc8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb183dcb73d44f0e0aedb09b73c7fd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9eb183dcb73d44f0e0aedb09b73c7fd7">runRegionDCE</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions)</td></tr>
<tr class="memdesc:a9eb183dcb73d44f0e0aedb09b73c7fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns success if any operations or arguments were deleted, failure otherwise.  <a href="namespacemlir.html#a9eb183dcb73d44f0e0aedb09b73c7fd7">More...</a><br /></td></tr>
<tr class="separator:a9eb183dcb73d44f0e0aedb09b73c7fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb95f9dc749d6a604340f83fd16b19f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adb95f9dc749d6a604340f83fd16b19f9">sortTopologically</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> &gt; ops, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; isOperandReady=nullptr)</td></tr>
<tr class="memdesc:adb95f9dc749d6a604340f83fd16b19f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a block, sort a range operations in said block in topological order.  <a href="namespacemlir.html#adb95f9dc749d6a604340f83fd16b19f9">More...</a><br /></td></tr>
<tr class="separator:adb95f9dc749d6a604340f83fd16b19f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35009cf90a73229f64f9090d4e5aa2b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a35009cf90a73229f64f9090d4e5aa2b7">sortTopologically</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; isOperandReady=nullptr)</td></tr>
<tr class="memdesc:a35009cf90a73229f64f9090d4e5aa2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a block, sort its operations in topological order, excluding its terminator if it has one.  <a href="namespacemlir.html#a35009cf90a73229f64f9090d4e5aa2b7">More...</a><br /></td></tr>
<tr class="separator:a35009cf90a73229f64f9090d4e5aa2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28129a93d39ade2d40077f25a09eb389"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a28129a93d39ade2d40077f25a09eb389">computeTopologicalSorting</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; ops, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; isOperandReady=nullptr)</td></tr>
<tr class="memdesc:a28129a93d39ade2d40077f25a09eb389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a topological ordering of the given ops.  <a href="namespacemlir.html#a28129a93d39ade2d40077f25a09eb389">More...</a><br /></td></tr>
<tr class="separator:a28129a93d39ade2d40077f25a09eb389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045e1f32a8d90260d292aad61149c0ef"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a045e1f32a8d90260d292aad61149c0ef">createPrintOpGraphPass</a> (raw_ostream &amp;os=llvm::errs())</td></tr>
<tr class="memdesc:a045e1f32a8d90260d292aad61149c0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to print op graphs.  <a href="namespacemlir.html#a045e1f32a8d90260d292aad61149c0ef">More...</a><br /></td></tr>
<tr class="separator:a045e1f32a8d90260d292aad61149c0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a64af4be39c0a24e5cf7dd18d7f619f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9a64af4be39c0a24e5cf7dd18d7f619f">populateGpuMemorySpaceAttributeConversions</a> (<a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, const <a class="el" href="namespacemlir.html#ae70a1dffc17ef544b387b99ba05784d2">MemorySpaceMapping</a> &amp;mapping)</td></tr>
<tr class="memdesc:a9a64af4be39c0a24e5cf7dd18d7f619f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates memory space attribute conversion rules for lowering gpu.address_space to integer values.  <a href="namespacemlir.html#a9a64af4be39c0a24e5cf7dd18d7f619f">More...</a><br /></td></tr>
<tr class="separator:a9a64af4be39c0a24e5cf7dd18d7f619f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9994bf5e77db2932598481cf8e46fb"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:aaf9994bf5e77db2932598481cf8e46fb"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aaf9994bf5e77db2932598481cf8e46fb">getValuesSortedByKeyImpl</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; K &gt; keys, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; V &gt; values, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(K, K)&gt; compare)</td></tr>
<tr class="memdesc:aaf9994bf5e77db2932598481cf8e46fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to sort <code>values</code> according to matching <code>keys</code>.  <a href="namespacemlir.html#aaf9994bf5e77db2932598481cf8e46fb">More...</a><br /></td></tr>
<tr class="separator:aaf9994bf5e77db2932598481cf8e46fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b336390b16983a364b2d95bd2a64a2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2b336390b16983a364b2d95bd2a64a2f">registerTestRoundtripSPIRV</a> ()</td></tr>
<tr class="separator:a2b336390b16983a364b2d95bd2a64a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed913befc935e3b4b3e622838655b30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9ed913befc935e3b4b3e622838655b30">registerTestRoundtripDebugSPIRV</a> ()</td></tr>
<tr class="separator:a9ed913befc935e3b4b3e622838655b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2887883f00b094c5ca61c631d7b093a0"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2887883f00b094c5ca61c631d7b093a0">kDeriveIndexBitwidthFromDataLayout</a> = 0</td></tr>
<tr class="memdesc:a2887883f00b094c5ca61c631d7b093a0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> to pass as bitwidth for the index type when the converter is expected to derive the bitwidth from the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> data layout.  <a href="namespacemlir.html#a2887883f00b094c5ca61c631d7b093a0">More...</a><br /></td></tr>
<tr class="separator:a2887883f00b094c5ca61c631d7b093a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89827c63faec642164c91b4f8eb0bbbb"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a89827c63faec642164c91b4f8eb0bbbb">kPtrBasePosInDataDescriptor</a> = 0</td></tr>
<tr class="separator:a89827c63faec642164c91b4f8eb0bbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b10e5f178951c728a16e10de4d038c0"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5b10e5f178951c728a16e10de4d038c0">kPtrPosInDataDescriptor</a> = 1</td></tr>
<tr class="separator:a5b10e5f178951c728a16e10de4d038c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d7fcc466ac5f8bdada62aa526a821e"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a17d7fcc466ac5f8bdada62aa526a821e">kSizePosInDataDescriptor</a> = 2</td></tr>
<tr class="separator:a17d7fcc466ac5f8bdada62aa526a821e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f52f0c5e268decd5b4ff95c42ea054"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a52f52f0c5e268decd5b4ff95c42ea054"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a52f52f0c5e268decd5b4ff95c42ea054">has_sub_attr_or_type_v</a></td></tr>
<tr class="separator:a52f52f0c5e268decd5b4ff95c42ea054"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This header declares functions that assit transformations in the MemRef dialect. </p>
<p>The pass expands memref operations that modify the metadata of a memref (sizes, offset, strides) into a sequence of easier to analyze constructs.</p>
<p>Include the generated interface declarations.</p>
<p>In particular, this pass transforms operations into explicit sequence of operations that model the effect of this operation on the different metadata. This pass uses affine constructs to materialize these effects. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ac9afb3b6f82b256aea9f20e913e8afd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9afb3b6f82b256aea9f20e913e8afd5">&#9670;&nbsp;</a></span>AllocFunType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ac9afb3b6f82b256aea9f20e913e8afd5">mlir::AllocFunType</a> = typedef <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;void *(size_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00037">37</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

</div>
</div>
<a id="aad8f5011648c4f698028afb8a96b31ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8f5011648c4f698028afb8a96b31ce">&#9670;&nbsp;</a></span>AttributeStorageAllocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aad8f5011648c4f698028afb8a96b31ce">mlir::AttributeStorageAllocator</a> = typedef <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttributeSupport_8h_source.html#l00193">193</a> of file <a class="el" href="AttributeSupport_8h_source.html">AttributeSupport.h</a>.</p>

</div>
</div>
<a id="a16ea1893e6ad27965d15e12d6f545008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ea1893e6ad27965d15e12d6f545008">&#9670;&nbsp;</a></span>AttrSubElementReplacements</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a16ea1893e6ad27965d15e12d6f545008">mlir::AttrSubElementReplacements</a> = typedef <a class="el" href="classmlir_1_1AttrTypeSubElementReplacements.html">AttrTypeSubElementReplacements</a>&lt;<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00273">273</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

</div>
</div>
<a id="af5aaca5fea0016501841c1e98a14e7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5aaca5fea0016501841c1e98a14e7ab">&#9670;&nbsp;</a></span>BlobGenerator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#af5aaca5fea0016501841c1e98a14e7ab">mlir::BlobGenerator</a> = typedef std::function&lt;<a class="el" href="namespacemlir.html#afd0d8f38577d05b87e540d717a7ba9c5">OwnedBlob</a>(const std::string &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, StringRef)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GPUCommonPass_8h_source.html#l00045">45</a> of file <a class="el" href="GPUCommonPass_8h_source.html">GPUCommonPass.h</a>.</p>

</div>
</div>
<a id="aafb0c2458571cd80ebb876d979e24346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb0c2458571cd80ebb876d979e24346">&#9670;&nbsp;</a></span>ChunkBufferHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aafb0c2458571cd80ebb876d979e24346">mlir::ChunkBufferHandler</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>( std::unique_ptr&lt;llvm::MemoryBuffer&gt; chunkBuffer, raw_ostream &amp;os)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ToolUtilities_8h_source.html#l00027">27</a> of file <a class="el" href="ToolUtilities_8h_source.html">ToolUtilities.h</a>.</p>

</div>
</div>
<a id="a33732a3813b186ef51131421fac26f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33732a3813b186ef51131421fac26f4a">&#9670;&nbsp;</a></span>DataLayoutEntryKey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a33732a3813b186ef51131421fac26f4a">mlir::DataLayoutEntryKey</a> = typedef <a class="el" href="classllvm_1_1PointerUnion.html">llvm::PointerUnion</a>&lt;<a class="el" href="classmlir_1_1Type.html">Type</a>, StringAttr&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8h_source.html#l00025">25</a> of file <a class="el" href="DataLayoutInterfaces_8h_source.html">DataLayoutInterfaces.h</a>.</p>

</div>
</div>
<a id="a72a4f77607d05cf551b24ceb9362c034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a4f77607d05cf551b24ceb9362c034">&#9670;&nbsp;</a></span>DataLayoutEntryList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a72a4f77607d05cf551b24ceb9362c034">mlir::DataLayoutEntryList</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">llvm::SmallVector</a>&lt;DataLayoutEntryInterface, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8h_source.html#l00028">28</a> of file <a class="el" href="DataLayoutInterfaces_8h_source.html">DataLayoutInterfaces.h</a>.</p>

</div>
</div>
<a id="a577834e9b93afb653df29d66a6975ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577834e9b93afb653df29d66a6975ecf">&#9670;&nbsp;</a></span>DataLayoutEntryListRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">mlir::DataLayoutEntryListRef</a> = typedef <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt;DataLayoutEntryInterface&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8h_source.html#l00029">29</a> of file <a class="el" href="DataLayoutInterfaces_8h_source.html">DataLayoutInterfaces.h</a>.</p>

</div>
</div>
<a id="a759bdae349015b16ce375bdd46c1e16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759bdae349015b16ce375bdd46c1e16c">&#9670;&nbsp;</a></span>DefaultAttributeStorage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a759bdae349015b16ce375bdd46c1e16c">mlir::DefaultAttributeStorage</a> = typedef <a class="el" href="classmlir_1_1AttributeStorage.html">AttributeStorage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default storage type for attributes that require no additional initialization or storage. </p>

<p class="definition">Definition at line <a class="el" href="AttributeSupport_8h_source.html#l00185">185</a> of file <a class="el" href="AttributeSupport_8h_source.html">AttributeSupport.h</a>.</p>

</div>
</div>
<a id="a8b36f0e85767ed4e793d86f40bd8fe55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b36f0e85767ed4e793d86f40bd8fe55">&#9670;&nbsp;</a></span>DefaultTypeStorage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a8b36f0e85767ed4e793d86f40bd8fe55">mlir::DefaultTypeStorage</a> = typedef <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default storage type for types that require no additional initialization or storage. </p>

<p class="definition">Definition at line <a class="el" href="TypeSupport_8h_source.html#l00181">181</a> of file <a class="el" href="TypeSupport_8h_source.html">TypeSupport.h</a>.</p>

</div>
</div>
<a id="a7dffb2feeebaff96012a0f11534ecb42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dffb2feeebaff96012a0f11534ecb42">&#9670;&nbsp;</a></span>DenseBoolArrayAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a7dffb2feeebaff96012a0f11534ecb42">mlir::DenseBoolArrayAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;bool&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00759">759</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a1691413cd0a4f426cddf9c9ec13c0523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1691413cd0a4f426cddf9c9ec13c0523">&#9670;&nbsp;</a></span>DenseBoolResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a1691413cd0a4f426cddf9c9ec13c0523">mlir::DenseBoolResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;bool&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00809">809</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a057c3db4d18f7bc0ebd0e5943ab4f6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057c3db4d18f7bc0ebd0e5943ab4f6f8">&#9670;&nbsp;</a></span>DenseF32ArrayAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a057c3db4d18f7bc0ebd0e5943ab4f6f8">mlir::DenseF32ArrayAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00764">764</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="af658dc01559125b6634401cc7a8128d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af658dc01559125b6634401cc7a8128d1">&#9670;&nbsp;</a></span>DenseF32ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#af658dc01559125b6634401cc7a8128d1">mlir::DenseF32ResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00827">827</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="accd8e5d82c207ff36cbbf5abad9ca288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd8e5d82c207ff36cbbf5abad9ca288">&#9670;&nbsp;</a></span>DenseF64ArrayAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#accd8e5d82c207ff36cbbf5abad9ca288">mlir::DenseF64ArrayAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00765">765</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="af761c00f33889d6ec2a2247517748327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af761c00f33889d6ec2a2247517748327">&#9670;&nbsp;</a></span>DenseF64ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#af761c00f33889d6ec2a2247517748327">mlir::DenseF64ResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00829">829</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a684fa3991fcdc7c970ec8a74aa461a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684fa3991fcdc7c970ec8a74aa461a77">&#9670;&nbsp;</a></span>DenseI16ArrayAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a684fa3991fcdc7c970ec8a74aa461a77">mlir::DenseI16ArrayAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;int16_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00761">761</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a313e0d370789a4ea8efc263c0212e445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313e0d370789a4ea8efc263c0212e445">&#9670;&nbsp;</a></span>DenseI16ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a313e0d370789a4ea8efc263c0212e445">mlir::DenseI16ResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;int16_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00813">813</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="ace9107ae5cb34fa1aa00e0fd1377ad89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9107ae5cb34fa1aa00e0fd1377ad89">&#9670;&nbsp;</a></span>DenseI32ArrayAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ace9107ae5cb34fa1aa00e0fd1377ad89">mlir::DenseI32ArrayAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;int32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00762">762</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a82486c15d0b4b7a7c6aeaf299655cae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82486c15d0b4b7a7c6aeaf299655cae4">&#9670;&nbsp;</a></span>DenseI32ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a82486c15d0b4b7a7c6aeaf299655cae4">mlir::DenseI32ResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;int32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00815">815</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a50858f49b4d3e313809688de651162e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50858f49b4d3e313809688de651162e3">&#9670;&nbsp;</a></span>DenseI64ArrayAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">mlir::DenseI64ArrayAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;int64_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00763">763</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a702b9fea87b463a5d46d215e2a41b434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a702b9fea87b463a5d46d215e2a41b434">&#9670;&nbsp;</a></span>DenseI64ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a702b9fea87b463a5d46d215e2a41b434">mlir::DenseI64ResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;int64_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00817">817</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="ab90796fd9f1813081632c1402c9ab0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90796fd9f1813081632c1402c9ab0f5">&#9670;&nbsp;</a></span>DenseI8ArrayAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ab90796fd9f1813081632c1402c9ab0f5">mlir::DenseI8ArrayAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;int8_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00760">760</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a80c8652ae83dca72bfa8476f790a779e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c8652ae83dca72bfa8476f790a779e">&#9670;&nbsp;</a></span>DenseI8ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a80c8652ae83dca72bfa8476f790a779e">mlir::DenseI8ResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;int8_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00811">811</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="ad7f731697783a754f6f0e3821d1264b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f731697783a754f6f0e3821d1264b2">&#9670;&nbsp;</a></span>DenseMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename KeyInfoT  = DenseMapInfo&lt;KeyT&gt;, typename BucketT  = llvm::detail::DenseMapPair&lt;KeyT, ValueT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">mlir::DenseMap</a> = typedef <a class="el" href="classllvm_1_1DenseMap.html">llvm::DenseMap</a>&lt;KeyT, ValueT, KeyInfoT, BucketT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00124">124</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a087da824f0d25f4e19913ab4f2688c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087da824f0d25f4e19913ab4f2688c7b">&#9670;&nbsp;</a></span>DenseMapInfo</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Enable  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a087da824f0d25f4e19913ab4f2688c7b">DenseMapInfo</a>&lt; <a class="el" href="classmlir_1_1RegisteredOperationName.html">mlir::RegisteredOperationName</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00120">120</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a6841368c88bd98143c5b7fc3174fc663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6841368c88bd98143c5b7fc3174fc663">&#9670;&nbsp;</a></span>DenseResourceElementsHandle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a6841368c88bd98143c5b7fc3174fc663">mlir::DenseResourceElementsHandle</a> = typedef <a class="el" href="structmlir_1_1DialectResourceBlobHandle.html">DialectResourceBlobHandle</a>&lt;BuiltinDialect&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00696">696</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a59d6aae8a616cd9d13c8b1edb1095948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d6aae8a616cd9d13c8b1edb1095948">&#9670;&nbsp;</a></span>DenseSet</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , typename ValueInfoT  = DenseMapInfo&lt;ValueT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">mlir::DenseSet</a> = typedef <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt;ValueT, ValueInfoT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00126">126</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a9d38dcceb11bdea46ed3a87eae2c0e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d38dcceb11bdea46ed3a87eae2c0e4e">&#9670;&nbsp;</a></span>DenseUI16ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a9d38dcceb11bdea46ed3a87eae2c0e4e">mlir::DenseUI16ResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;uint16_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00821">821</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="ad62ce2fff3156992f2755bc853f1f85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62ce2fff3156992f2755bc853f1f85f">&#9670;&nbsp;</a></span>DenseUI32ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ad62ce2fff3156992f2755bc853f1f85f">mlir::DenseUI32ResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;uint32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00823">823</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="aac2b788b2acc9e11d299d1bdfc6ab941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2b788b2acc9e11d299d1bdfc6ab941">&#9670;&nbsp;</a></span>DenseUI64ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aac2b788b2acc9e11d299d1bdfc6ab941">mlir::DenseUI64ResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;uint64_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00825">825</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a0be9cf4f237c5eb1d4ae5ceedca018e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be9cf4f237c5eb1d4ae5ceedca018e8">&#9670;&nbsp;</a></span>DenseUI8ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a0be9cf4f237c5eb1d4ae5ceedca018e8">mlir::DenseUI8ResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;uint8_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00819">819</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a2e943fa4f63d44d69d846e504c16d5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e943fa4f63d44d69d846e504c16d5f6">&#9670;&nbsp;</a></span>DialectAllocatorFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a2e943fa4f63d44d69d846e504c16d5f6">mlir::DialectAllocatorFunction</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1Dialect.html">Dialect</a> *(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectRegistry_8h_source.html#l00027">27</a> of file <a class="el" href="DialectRegistry_8h_source.html">DialectRegistry.h</a>.</p>

</div>
</div>
<a id="a6ffd752ab3a9dd88587958c328e34e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffd752ab3a9dd88587958c328e34e70">&#9670;&nbsp;</a></span>DialectAllocatorFunctionRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a6ffd752ab3a9dd88587958c328e34e70">mlir::DialectAllocatorFunctionRef</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;<a class="el" href="classmlir_1_1Dialect.html">Dialect</a> *(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectRegistry_8h_source.html#l00028">28</a> of file <a class="el" href="DialectRegistry_8h_source.html">DialectRegistry.h</a>.</p>

</div>
</div>
<a id="a4308db4537fab4bd6031bf3ba2206525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4308db4537fab4bd6031bf3ba2206525">&#9670;&nbsp;</a></span>DialectRegistrationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a4308db4537fab4bd6031bf3ba2206525">mlir::DialectRegistrationFunction</a> = typedef std::function&lt;void(<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that adds all dialects and dialect extensions used for the translation to the given <a class="el" href="classmlir_1_1DialectRegistry.html" title="The DialectRegistry maps a dialect namespace to a constructor for the matching dialect.">DialectRegistry</a>. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00057">57</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="aedbc3d0362a57c5175f05dd95fb59641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedbc3d0362a57c5175f05dd95fb59641">&#9670;&nbsp;</a></span>DominanceInfoNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aedbc3d0362a57c5175f05dd95fb59641">mlir::DominanceInfoNode</a> = typedef llvm::DomTreeNodeBase&lt;<a class="el" href="classmlir_1_1Block.html">Block</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dominance_8h_source.html#l00030">30</a> of file <a class="el" href="Dominance_8h_source.html">Dominance.h</a>.</p>

</div>
</div>
<a id="a226a6f936696eac398cee8be0368046b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226a6f936696eac398cee8be0368046b">&#9670;&nbsp;</a></span>DynamicDialectPopulationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a226a6f936696eac398cee8be0368046b">mlir::DynamicDialectPopulationFunction</a> = typedef std::function&lt;void(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *, <a class="el" href="classmlir_1_1DynamicDialect.html">DynamicDialect</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectRegistry_8h_source.html#l00029">29</a> of file <a class="el" href="DialectRegistry_8h_source.html">DialectRegistry.h</a>.</p>

</div>
</div>
<a id="ae076c6e0e79ca32d89266007db06f358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae076c6e0e79ca32d89266007db06f358">&#9670;&nbsp;</a></span>ElementWiseVisitor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ae076c6e0e79ca32d89266007db06f358">mlir::ElementWiseVisitor</a> = typedef <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;void(T &amp;ptr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;int64_t&gt;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient callback to "visit" a memref element by element. </p>
<p>This takes a reference to an individual element as well as the coordinates. It can be used in conjuction with a <a class="el" href="classStridedMemrefIterator.html" title="Iterate over all elements in a strided memref.">StridedMemrefIterator</a>. </p>

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00130">130</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

</div>
</div>
<a id="a0bff6226b7c81b6134b8c1130403a172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bff6226b7c81b6134b8c1130403a172">&#9670;&nbsp;</a></span>function_ref</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">mlir::function_ref</a> = typedef <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;Fn&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00150">150</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a4ddb6704fdaa06a1d6d81b12d73eac94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddb6704fdaa06a1d6d81b12d73eac94">&#9670;&nbsp;</a></span>GenFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a4ddb6704fdaa06a1d6d81b12d73eac94">mlir::GenFunction</a> = typedef std::function&lt;bool(const llvm::RecordKeeper &amp;recordKeeper, raw_ostream &amp;os)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generator function to invoke. </p>

<p class="definition">Definition at line <a class="el" href="GenInfo_8h_source.html#l00024">24</a> of file <a class="el" href="GenInfo_8h_source.html">GenInfo.h</a>.</p>

</div>
</div>
<a id="ad5c8735b67af7a64e4deff16477a06eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c8735b67af7a64e4deff16477a06eb">&#9670;&nbsp;</a></span>Loops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">mlir::Loops</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;scf::ForOp, 8&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile a nest of standard for loops rooted at <code>rootForOp</code> by finding such parametric tile sizes that the outer loops have a fixed number of iterations as defined in <code>sizes</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html#l00159">159</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a594a45ae9aa1ccffd960f369da94d156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594a45ae9aa1ccffd960f369da94d156">&#9670;&nbsp;</a></span>LoweringCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a594a45ae9aa1ccffd960f369da94d156">mlir::LoweringCallback</a> = typedef std::function&lt;std::unique_ptr&lt;llvm::Module&gt;( <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, llvm::LLVMContext &amp;, StringRef)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GPUCommonPass_8h_source.html#l00047">47</a> of file <a class="el" href="GPUCommonPass_8h_source.html">GPUCommonPass.h</a>.</p>

</div>
</div>
<a id="ae70a1dffc17ef544b387b99ba05784d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70a1dffc17ef544b387b99ba05784d2">&#9670;&nbsp;</a></span>MemorySpaceMapping</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ae70a1dffc17ef544b387b99ba05784d2">mlir::MemorySpaceMapping</a> = typedef std::function&lt;unsigned(gpu::AddressSpace gpuAddressSpace)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that maps a MemorySpace enum to a target-specific integer value. </p>

<p class="definition">Definition at line <a class="el" href="GPUOpsLowering_8h_source.html#l00116">116</a> of file <a class="el" href="GPUOpsLowering_8h_source.html">GPUOpsLowering.h</a>.</p>

</div>
</div>
<a id="ae809ff18bf496d00671a691c71795f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae809ff18bf496d00671a691c71795f68">&#9670;&nbsp;</a></span>NewYieldValueFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ae809ff18bf496d00671a691c71795f68">mlir::NewYieldValueFn</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;( <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a>&gt; newBBArgs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the <code>loop</code> with <code>newIterOperands</code> added as new initialization values. </p>
<p><code>newYieldValuesFn</code> is a callback that can be used to specify the additional values to be yielded by the loop. The number of values returned by the callback should match the number of new initialization values. This function</p><ul>
<li>Moves (i.e. doesnt clone) operations from the <code>loop</code> to the newly created loop</li>
<li>Replaces the uses of <code>loop</code> with the new loop.</li>
<li><code>loop</code> isnt erased, but is left in a "no-op" state where the body of the loop just yields the basic block arguments that correspond to the initialization values of a loop. The loop is dead after this method.</li>
<li>If <code>replaceIterOperandsUsesInLoop</code> is true, all uses of the <code>newIterOperands</code> within the generated new loop are replaced with the corresponding <code><a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a></code> in the loop body. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html#l00051">51</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="af2d45da2e2b2d5f705d618b778e36d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d45da2e2b2d5f705d618b778e36d52">&#9670;&nbsp;</a></span>OpAsmSetBlockNameFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#af2d45da2e2b2d5f705d618b778e36d52">mlir::OpAsmSetBlockNameFn</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;void(<a class="el" href="classmlir_1_1Block.html">Block</a> *, StringRef)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A functor used to set the name of blocks in regions directly nested under an operation. </p>

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l01574">1574</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="ab0887111bf825d1f766ef9e0911394d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0887111bf825d1f766ef9e0911394d5">&#9670;&nbsp;</a></span>OpAsmSetValueNameFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ab0887111bf825d1f766ef9e0911394d5">mlir::OpAsmSetValueNameFn</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;void(<a class="el" href="classmlir_1_1Value.html">Value</a>, StringRef)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A functor used to set the name of the start of a result group of an operation. </p>
<p>See 'getAsmResultNames' below for more details. </p>

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l01570">1570</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a3789e28c54bcaf5d2c3baf5f99eb615f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3789e28c54bcaf5d2c3baf5f99eb615f">&#9670;&nbsp;</a></span>OperandElementTypeRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a3789e28c54bcaf5d2c3baf5f99eb615f">mlir::OperandElementTypeRange</a> = typedef <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="classmlir_1_1OperandElementTypeIterator.html">OperandElementTypeIterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8h_source.html#l00085">85</a> of file <a class="el" href="TypeUtilities_8h_source.html">TypeUtilities.h</a>.</p>

</div>
</div>
<a id="afd0d8f38577d05b87e540d717a7ba9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0d8f38577d05b87e540d717a7ba9c5">&#9670;&nbsp;</a></span>OwnedBlob</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#afd0d8f38577d05b87e540d717a7ba9c5">mlir::OwnedBlob</a> = typedef std::unique_ptr&lt;std::vector&lt;char&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GPUCommonPass_8h_source.html#l00044">44</a> of file <a class="el" href="GPUCommonPass_8h_source.html">GPUCommonPass.h</a>.</p>

</div>
</div>
<a id="a48db7fd5d49bfa7ca8c81e5a6a058683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48db7fd5d49bfa7ca8c81e5a6a058683">&#9670;&nbsp;</a></span>PassAllocatorFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a48db7fd5d49bfa7ca8c81e5a6a058683">mlir::PassAllocatorFunction</a> = typedef std::function&lt;std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">Pass</a>&gt;()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PassRegistry_8h_source.html#l00041">41</a> of file <a class="el" href="PassRegistry_8h_source.html">PassRegistry.h</a>.</p>

</div>
</div>
<a id="aa22124ccf5219095aee552486366ccc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22124ccf5219095aee552486366ccc0">&#9670;&nbsp;</a></span>PassPipelineFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aa22124ccf5219095aee552486366ccc0">mlir::PassPipelineFn</a> = typedef <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;pm)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This defines the function type used to setup the pass manager. </p>
<p>This can be used to pass in a callback to setup a default pass pipeline to be applied on the loaded IR. </p>

<p class="definition">Definition at line <a class="el" href="MlirOptMain_8h_source.html#l00220">220</a> of file <a class="el" href="MlirOptMain_8h_source.html">MlirOptMain.h</a>.</p>

</div>
</div>
<a id="af4ccb1e7accf2ec0c57b1aea967ccd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ccb1e7accf2ec0c57b1aea967ccd02">&#9670;&nbsp;</a></span>PassRegistryFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#af4ccb1e7accf2ec0c57b1aea967ccd02">mlir::PassRegistryFunction</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>( <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;, StringRef <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(const Twine &amp;)&gt; errorHandler)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A registry function that adds passes to the given pass manager. </p>
<p>This should also parse options and return <a class="el" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed" title="Utility function to generate a LogicalResult.">success()</a> if parsing succeeded. <code>errorHandler</code> is a functor used to emit errors during parsing. parameter corresponds to the raw location within the pipeline string. This should always return failure. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8h_source.html#l00038">38</a> of file <a class="el" href="PassRegistry_8h_source.html">PassRegistry.h</a>.</p>

</div>
</div>
<a id="ac8e9dd2cd47f4932caf7412344a0d902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e9dd2cd47f4932caf7412344a0d902">&#9670;&nbsp;</a></span>PDLConstraintFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ac8e9dd2cd47f4932caf7412344a0d902">mlir::PDLConstraintFunction</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a>&gt;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic PDL pattern constraint function. </p>
<p>This function applies a constraint to a given set of opaque <a class="el" href="classmlir_1_1PDLValue.html" title="Storage type of byte-code interpreter values.">PDLValue</a> entities. Returns success if the constraint successfully held, failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00981">981</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

</div>
</div>
<a id="af1dbc894e93a039d9b57063dd5efa569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1dbc894e93a039d9b57063dd5efa569">&#9670;&nbsp;</a></span>PDLRewriteFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#af1dbc894e93a039d9b57063dd5efa569">mlir::PDLRewriteFunction</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>( <a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;, <a class="el" href="classmlir_1_1PDLResultList.html">PDLResultList</a> &amp;, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a>&gt;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A native PDL rewrite function. </p>
<p>This function performs a rewrite on the given set of values. Any results from this rewrite that should be passed back to PDL should be added to the provided result list. This method is only invoked when the corresponding match was successful. Returns failure if an invariant of the rewrite was broken (certain rewriters may recover from partial pattern application). </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00989">989</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

</div>
</div>
<a id="ae5cf0e24a954fa30fb469105d4ca5dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5cf0e24a954fa30fb469105d4ca5dd8">&#9670;&nbsp;</a></span>ReassociationExprs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ae5cf0e24a954fa30fb469105d4ca5dd8">mlir::ReassociationExprs</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00028">28</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

</div>
</div>
<a id="ab973fb931221b9539fe0ffd408e261ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab973fb931221b9539fe0ffd408e261ff">&#9670;&nbsp;</a></span>ReassociationIndices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">mlir::ReassociationIndices</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00026">26</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

</div>
</div>
<a id="a7ed845b40509fa999492a04654211321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed845b40509fa999492a04654211321">&#9670;&nbsp;</a></span>ReassociationIndicesRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a7ed845b40509fa999492a04654211321">mlir::ReassociationIndicesRef</a> = typedef <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;int64_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00027">27</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

</div>
</div>
<a id="a0a5ee68dc80640e6ac9c4a6011d18bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5ee68dc80640e6ac9c4a6011d18bc1">&#9670;&nbsp;</a></span>ReifiedRankedShapedTypeDims</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a0a5ee68dc80640e6ac9c4a6011d18bc1">mlir::ReifiedRankedShapedTypeDims</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InferTypeOpInterface_8h_source.html#l00029">29</a> of file <a class="el" href="InferTypeOpInterface_8h_source.html">InferTypeOpInterface.h</a>.</p>

</div>
</div>
<a id="a253b95ef2aaf79bdc612ae40fddc0732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253b95ef2aaf79bdc612ae40fddc0732">&#9670;&nbsp;</a></span>ResultElementTypeRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a253b95ef2aaf79bdc612ae40fddc0732">mlir::ResultElementTypeRange</a> = typedef <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="classmlir_1_1ResultElementTypeIterator.html">ResultElementTypeIterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8h_source.html#l00098">98</a> of file <a class="el" href="TypeUtilities_8h_source.html">TypeUtilities.h</a>.</p>

</div>
</div>
<a id="a408db684234b50da0ac6888331842065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408db684234b50da0ac6888331842065">&#9670;&nbsp;</a></span>SetIntRangeFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a408db684234b50da0ac6888331842065">mlir::SetIntRangeFn</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;void(<a class="el" href="classmlir_1_1Value.html">Value</a>, const <a class="el" href="classmlir_1_1ConstantIntRanges.html">ConstantIntRanges</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the <code>setResultRanges</code> callback provided to ops implementing InferIntRangeInterface. </p>
<p>It should be called once for each integer result value and be passed the <a class="el" href="classmlir_1_1ConstantIntRanges.html" title="A set of arbitrary-precision integers representing bounds on a given integer value.">ConstantIntRanges</a> corresponding to that value. </p>

<p class="definition">Definition at line <a class="el" href="InferIntRangeInterface_8h_source.html#l00109">109</a> of file <a class="el" href="InferIntRangeInterface_8h_source.html">InferIntRangeInterface.h</a>.</p>

</div>
</div>
<a id="a637916a3aeba97d795fa40975fbd7bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637916a3aeba97d795fa40975fbd7bd6">&#9670;&nbsp;</a></span>SetVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Vector  = std::vector&lt;T&gt;, typename Set  = DenseSet&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">mlir::SetVector</a> = typedef <a class="el" href="classllvm_1_1SetVector.html">llvm::SetVector</a>&lt;T, <a class="el" href="structVector.html">Vector</a>, Set&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00129">129</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="ac2b3592ab67f8512cb18e62375d7ff4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b3592ab67f8512cb18e62375d7ff4b">&#9670;&nbsp;</a></span>StringSet</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorTy  = llvm::MallocAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ac2b3592ab67f8512cb18e62375d7ff4b">mlir::StringSet</a> = typedef <a class="el" href="classllvm_1_1StringSet.html">llvm::StringSet</a>&lt;AllocatorTy&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00131">131</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="ac474b9f30a56412e090d9919e4dd8b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac474b9f30a56412e090d9919e4dd8b34">&#9670;&nbsp;</a></span>StringSwitch</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ac474b9f30a56412e090d9919e4dd8b34">mlir::StringSwitch</a> = typedef <a class="el" href="classllvm_1_1StringSwitch.html">llvm::StringSwitch</a>&lt;T, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00140">140</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a3f0d45d0562d47acc2c42934ccbfea19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0d45d0562d47acc2c42934ccbfea19">&#9670;&nbsp;</a></span>TileLoops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a3f0d45d0562d47acc2c42934ccbfea19">mlir::TileLoops</a> = typedef std::pair&lt;<a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>, <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html#l00160">160</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a611e5b4f126ef025a241fda803748304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611e5b4f126ef025a241fda803748304">&#9670;&nbsp;</a></span>TransitiveFilter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">mlir::TransitiveFilter</a> = typedef <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> of the condition to limit the propagation of transitive use-defs. </p>
<p>This can be used in particular to limit the propagation to a given Scope or to avoid passing through certain types of operation in a configurable manner. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8h_source.html#l00028">28</a> of file <a class="el" href="SliceAnalysis_8h_source.html">SliceAnalysis.h</a>.</p>

</div>
</div>
<a id="a86f6096a57734eed0290d2ab34ad5e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f6096a57734eed0290d2ab34ad5e79">&#9670;&nbsp;</a></span>TranslateFromMLIRFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a86f6096a57734eed0290d2ab34ad5e79">mlir::TranslateFromMLIRFunction</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, llvm::raw_ostream &amp;output)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that translates MLIR to a different format and outputs the result to a stream. </p>
<p>It is allowed to modify the operation. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00043">43</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="a0a36971a2ce3497d801451c71cabd7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a36971a2ce3497d801451c71cabd7f0">&#9670;&nbsp;</a></span>TranslateFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a0a36971a2ce3497d801451c71cabd7f0">mlir::TranslateFunction</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>( const std::shared_ptr&lt;llvm::SourceMgr&gt; &amp;sourceMgr, llvm::raw_ostream &amp;output, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that performs file-to-file translation involving MLIR. </p>
<p>The input file is held in the given MemoryBuffer; the output file should be written to the given raw_ostream. The implementation should create all MLIR constructs needed during the process inside the given context. This can be used for round-tripping external formats through the MLIR system. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00051">51</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="a2e66fd933b3c9e825ff92ccea2450120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e66fd933b3c9e825ff92ccea2450120">&#9670;&nbsp;</a></span>TranslateRawSourceMgrToMLIRFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a2e66fd933b3c9e825ff92ccea2450120">mlir::TranslateRawSourceMgrToMLIRFunction</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;(llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00030">30</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="ab2fc3e0eaaa708d4f579d33d914aafb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2fc3e0eaaa708d4f579d33d914aafb4">&#9670;&nbsp;</a></span>TranslateSourceMgrToMLIRFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ab2fc3e0eaaa708d4f579d33d914aafb4">mlir::TranslateSourceMgrToMLIRFunction</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;( const std::shared_ptr&lt;llvm::SourceMgr&gt; &amp;sourceMgr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that translates the sources managed by <code>sourceMgr</code> to MLIR. </p>
<p>The source manager has at least one buffer. The implementation should create a new MLIR <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> in the given context and return a pointer to it, or a nullptr in case of any error. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00028">28</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="a9e7afe9f2206cbd31d4c274a8a496fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7afe9f2206cbd31d4c274a8a496fcc">&#9670;&nbsp;</a></span>TranslateStringRefToMLIRFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a9e7afe9f2206cbd31d4c274a8a496fcc">mlir::TranslateStringRefToMLIRFunction</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;(llvm::StringRef, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that translates the given string to MLIR. </p>
<p>The implementation should create a new MLIR <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> in the given context. If source-related error reporting is required from within the function, use TranslateSourceMgrToMLIRFunction instead. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00038">38</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="a39768b5816332d4970911da09de5cec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39768b5816332d4970911da09de5cec4">&#9670;&nbsp;</a></span>TypedValue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ty , typename Value  = mlir::Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a39768b5816332d4970911da09de5cec4">mlir::TypedValue</a> = typedef std::conditional_t&lt;std::is_same_v&lt;Ty, <a class="el" href="classmlir_1_1Type.html">mlir::Type</a>&gt;, <a class="el" href="classmlir_1_1Value.html">mlir::Value</a>, <a class="el" href="structmlir_1_1detail_1_1TypedValue.html">detail::TypedValue</a>&lt;Ty&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If Ty is <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">mlir::Type</a> this will select <code><a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a></code> instead of having a wrapper around it. </p>
<p>This helps resolve ambiguous conversion issues. </p>

<p class="definition">Definition at line <a class="el" href="Value_8h_source.html#l00482">482</a> of file <a class="el" href="Value_8h_source.html">Value.h</a>.</p>

</div>
</div>
<a id="a3bff85dd5cf397b62e521086d55e2d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bff85dd5cf397b62e521086d55e2d37">&#9670;&nbsp;</a></span>TypeRangeRangeIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a3bff85dd5cf397b62e521086d55e2d37">mlir::TypeRangeRangeIterator</a> = typedef llvm::mapped_iterator&lt;llvm::iota_range&lt;unsigned&gt;::iterator, std::function&lt;<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>(unsigned)&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeRange_8h_source.html#l00085">85</a> of file <a class="el" href="TypeRange_8h_source.html">TypeRange.h</a>.</p>

</div>
</div>
<a id="a01e9069ef9040ccc727d541c02d49ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e9069ef9040ccc727d541c02d49ecd">&#9670;&nbsp;</a></span>TypeStorageAllocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a01e9069ef9040ccc727d541c02d49ecd">mlir::TypeStorageAllocator</a> = typedef <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a utility allocator used to allocate memory for instances of derived Types. </p>

<p class="definition">Definition at line <a class="el" href="TypeSupport_8h_source.html#l00189">189</a> of file <a class="el" href="TypeSupport_8h_source.html">TypeSupport.h</a>.</p>

</div>
</div>
<a id="a9cdd84a4516a711493014c535e027b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdd84a4516a711493014c535e027b86">&#9670;&nbsp;</a></span>TypeSubElementReplacements</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a9cdd84a4516a711493014c535e027b86">mlir::TypeSubElementReplacements</a> = typedef <a class="el" href="classmlir_1_1AttrTypeSubElementReplacements.html">AttrTypeSubElementReplacements</a>&lt;<a class="el" href="classmlir_1_1Type.html">Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00274">274</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

</div>
</div>
<a id="abcf44d03780c99376ac0c1dd1caed0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf44d03780c99376ac0c1dd1caed0f4">&#9670;&nbsp;</a></span>TypeSwitch</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ResultT  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#abcf44d03780c99376ac0c1dd1caed0f4">mlir::TypeSwitch</a> = typedef <a class="el" href="classllvm_1_1TypeSwitch.html">llvm::TypeSwitch</a>&lt;T, ResultT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00143">143</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a9c852d22f676b319b260b86ad21499ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c852d22f676b319b260b86ad21499ac">&#9670;&nbsp;</a></span>ValueDimList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a9c852d22f676b319b260b86ad21499ac">mlir::ValueDimList</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;std::pair&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, std::optional&lt;int64_t&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00023">23</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a6d3b7fd763c24274db6c115579084133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3b7fd763c24274db6c115579084133">&#9670;&nbsp;</a></span>AffineExprKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">mlir::AffineExprKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133aec211f7c20af43e742bf2570c3cb84f9"></a>Add&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a62b6d55816cf737bfc6f42e60df1a3f2"></a>Mul&#160;</td><td class="fielddoc"><p>RHS of mul is always a constant or a symbolic expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a7aeb0277500c86e4aa6bd23f9a737942"></a>Mod&#160;</td><td class="fielddoc"><p>RHS of mod is always a constant or a symbolic expression with a positive value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133abaa422535e7ce48b442cc07089e64e7a"></a>FloorDiv&#160;</td><td class="fielddoc"><p>RHS of floordiv is always a constant or a symbolic expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a30c212eb3184a5ed41f01a25c8124e8a"></a>CeilDiv&#160;</td><td class="fielddoc"><p>RHS of ceildiv is always a constant or a symbolic expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a4be6ccd8c4af006587a76a5fd3e7dc24"></a>LAST_AFFINE_BINARY_OP&#160;</td><td class="fielddoc"><p>This is a marker for the last affine binary op. </p>
<p>The range of binary op's is expected to be this element and earlier. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255"></a>Constant&#160;</td><td class="fielddoc"><p>Constant integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133ab49b848e4bb608f4d5650e4b2817c641"></a>DimId&#160;</td><td class="fielddoc"><p>Dimensional identifier. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133aea00d3c6059a4ff11d351696747fc7ff"></a>SymbolId&#160;</td><td class="fielddoc"><p>Symbolic identifier. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00040">40</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

</div>
</div>
<a id="ac84871bcca0aaa0176d43dbdbffe9a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84871bcca0aaa0176d43dbdbffe9a6c">&#9670;&nbsp;</a></span>AsmResourceEntryKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#ac84871bcca0aaa0176d43dbdbffe9a6c">mlir::AsmResourceEntryKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This enum represents the different kinds of resource values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac84871bcca0aaa0176d43dbdbffe9a6cae8016c85ada38bdc5fac616ec1318047"></a>Blob&#160;</td><td class="fielddoc"><p>A blob of data with an accompanying alignment. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac84871bcca0aaa0176d43dbdbffe9a6cac26f15e86e3de4c398a8273272aba034"></a>Bool&#160;</td><td class="fielddoc"><p>A boolean value. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac84871bcca0aaa0176d43dbdbffe9a6ca27118326006d3829667a400ad23d5d98"></a>String&#160;</td><td class="fielddoc"><p>A string value. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="AsmState_8h_source.html#l00270">270</a> of file <a class="el" href="AsmState_8h_source.html">AsmState.h</a>.</p>

</div>
</div>
<a id="a2c02a386e5ba59c4c88f83ac471f999d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c02a386e5ba59c4c88f83ac471f999d">&#9670;&nbsp;</a></span>ChangeResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">mlir::ChangeResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A result type used to indicate if a change happened. </p>
<p>Boolean operations on ChangeResult behave as though <code>Change</code> is truthy. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2c02a386e5ba59c4c88f83ac471f999da4bac8cdf0a968472b519b3b295d0d48b"></a>NoChange&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2c02a386e5ba59c4c88f83ac471f999daf4ec5f57bd4d31b803312d873be40da9"></a>Change&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="DataFlowFramework_8h_source.html#l00033">33</a> of file <a class="el" href="DataFlowFramework_8h_source.html">DataFlowFramework.h</a>.</p>

</div>
</div>
<a id="a98b49fcd2b613b6c30ffc13f35b8675c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b49fcd2b613b6c30ffc13f35b8675c">&#9670;&nbsp;</a></span>DeletionKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a98b49fcd2b613b6c30ffc13f35b8675c">mlir::DeletionKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returned by operation promotion logic requesting the deletion of an operation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a98b49fcd2b613b6c30ffc13f35b8675ca02bce93bff905887ad2233110bf9c49e"></a>Keep&#160;</td><td class="fielddoc"><p>Keep the operation after promotion. </p>
</td></tr>
<tr><td class="fieldname"><a id="a98b49fcd2b613b6c30ffc13f35b8675caf2a6c498fb90ee345d997f888fce3b18"></a>Delete&#160;</td><td class="fielddoc"><p>Delete the operation after promotion. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Mem2RegInterfaces_8h_source.html#l00028">28</a> of file <a class="el" href="Mem2RegInterfaces_8h_source.html">Mem2RegInterfaces.h</a>.</p>

</div>
</div>
<a id="a247bc9a6d1f1577f2d876cb55e2ea752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247bc9a6d1f1577f2d876cb55e2ea752">&#9670;&nbsp;</a></span>DiagnosticSeverity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752">mlir::DiagnosticSeverity</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the different supported severity of a diagnostic. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a3b0649c72650c313a357338dcdfb64ec"></a>Note&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a0eaadb4fcb48a0a0ed7bc9868be9fbaa"></a>Warning&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd"></a>Error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a91921ada405fd6ba65dff028df047cb6"></a>Remark&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html#l00041">41</a> of file <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

</div>
</div>
<a id="acbb0dcd5ae75936e3c6f177223c9d5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb0dcd5ae75936e3c6f177223c9d5eb">&#9670;&nbsp;</a></span>GreedyRewriteStrictness</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#acbb0dcd5ae75936e3c6f177223c9d5eb">mlir::GreedyRewriteStrictness</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This enum controls which ops are put on the worklist during a greedy pattern rewrite. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acbb0dcd5ae75936e3c6f177223c9d5eba97d3def284d4e3d3bef99205c339fceb"></a>AnyOp&#160;</td><td class="fielddoc"><p>No restrictions wrt. which ops are processed. </p>
</td></tr>
<tr><td class="fieldname"><a id="acbb0dcd5ae75936e3c6f177223c9d5eba8fc95fc7cfbd316cce7d887ab38f6120"></a>ExistingAndNewOps&#160;</td><td class="fielddoc"><p>Only pre-existing and newly created ops are processed. </p>
</td></tr>
<tr><td class="fieldname"><a id="acbb0dcd5ae75936e3c6f177223c9d5eba475f4ba4004dc37c3764009114b6e69b"></a>ExistingOps&#160;</td><td class="fielddoc"><p>Only pre-existing ops are processed. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00023">23</a> of file <a class="el" href="GreedyPatternRewriteDriver_8h_source.html">GreedyPatternRewriteDriver.h</a>.</p>

</div>
</div>
<a id="ab64460ede39d8480e398fd2e6810d95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64460ede39d8480e398fd2e6810d95b">&#9670;&nbsp;</a></span>PassDisplayMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95b">mlir::PassDisplayMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enum describing the different display modes for the information within the pass manager. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab64460ede39d8480e398fd2e6810d95ba4ee29ca12c7d126654bd0e5275de6135"></a>List&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab64460ede39d8480e398fd2e6810d95baaeaeaec51b4e6b88122f10ad96a8de72"></a>Pipeline&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="PassManager_8h_source.html#l00195">195</a> of file <a class="el" href="PassManager_8h_source.html">PassManager.h</a>.</p>

</div>
</div>
<a id="abeb30aa1b062bf437bf3ea2b843a2ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb30aa1b062bf437bf3ea2b843a2ae1">&#9670;&nbsp;</a></span>RegionKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#abeb30aa1b062bf437bf3ea2b843a2ae1">mlir::RegionKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The kinds of regions contained in an operation. </p>
<p>SSACFG regions require the SSA-Dominance property to hold. Graph regions do not require SSA-Dominance. If a registered operation does not implement RegionKindInterface, then any regions it contains are assumed to be SSACFG regions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abeb30aa1b062bf437bf3ea2b843a2ae1abfd486e5c2cad6a0ba13ec4e1951815b"></a>SSACFG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abeb30aa1b062bf437bf3ea2b843a2ae1a4cdbd2bafa8193091ba09509cedf94fd"></a>Graph&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="RegionKindInterface_8h_source.html#l00026">26</a> of file <a class="el" href="RegionKindInterface_8h_source.html">RegionKindInterface.h</a>.</p>

</div>
</div>
<a id="a11353e6611651b85531ad95629c57d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11353e6611651b85531ad95629c57d75">&#9670;&nbsp;</a></span>SliceVerificationResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">mlir::SliceVerificationResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum that captures information related to verifier error conditions on slice insert/extract type of ops. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a505a83f220c02df2f85c3810cd9ceb38"></a>Success&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a780dd32ee9af184442cea3f2a2a75271"></a>RankTooLarge&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a87c69361ccd090c9c844e19d08432a26"></a>SizeMismatch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a6341e1bfc09d56fa49bb1b9400459d8e"></a>ElemTypeMismatch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a36a2220daadd84aaba239b031cf4cd23"></a>MemSpaceMismatch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a36297823a9892f9936fba1805a1c52ca"></a>LayoutMismatch&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00348">348</a> of file <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html">BuiltinTypes.h</a>.</p>

</div>
</div>
<a id="a781474aef998ccce168b69ae973cd832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781474aef998ccce168b69ae973cd832">&#9670;&nbsp;</a></span>SparseParallelizationStrategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832">mlir::SparseParallelizationStrategy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a parallelization strategy. </p>
<p>Any independent loop is a candidate for parallelization. The loop is made parallel if (1) allowed by the strategy (e.g., AnyStorageOuterLoop considers either a dense or sparse outermost loop only), and (2) the generated code is an actual for-loop (and not a co-iterating while-loop). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a781474aef998ccce168b69ae973cd832a35c3ace1970663a16e5c65baa5941b13"></a>kNone&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a781474aef998ccce168b69ae973cd832a09e4a3d1c3e70c9426528f102480e6e7"></a>kDenseOuterLoop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a781474aef998ccce168b69ae973cd832afe3590ad05890d8754eef93504f9b7af"></a>kAnyStorageOuterLoop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a781474aef998ccce168b69ae973cd832a0d7778373362fd80feddcb9b38a354b8"></a>kDenseAnyLoop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a781474aef998ccce168b69ae973cd832a3b1257bf6747bc07f90c215e9aafd4a7"></a>kAnyStorageAnyLoop&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l00038">38</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ad6dfcab9b0dbfb18cf218eef50ba36ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6dfcab9b0dbfb18cf218eef50ba36ca">&#9670;&nbsp;</a></span>SparseToSparseConversionStrategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36ca">mlir::SparseToSparseConversionStrategy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a strategy for implementing sparse-to-sparse conversion. </p>
<p><code>kAuto</code> leaves it up to the compiler to automatically determine the method used. <code>kViaCOO</code> converts the source tensor to COO and then converts the COO to the target format. <code>kDirect</code> converts directly via the algorithm in <a href="https://arxiv.org/abs/2001.02609">https://arxiv.org/abs/2001.02609</a>; however, beware that there are many formats not supported by this conversion method.</p>
<p>The presence of the <code>kAuto</code> option violates our usual goal of keeping policy completely separated from mechanism. The reason it exists is because (at present) this strategy can only be specified on a per-file basis. To see why this is a problem, note that <code>kDirect</code> cannot support certain conversions; so if there is no <code>kAuto</code> setting, then whenever a file contains a single non-<code>kDirect</code>-able conversion the user would be forced to use <code>kViaCOO</code> for all conversions in that file! In the future, instead of using this enum as a <code><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a></code> option, we could instead move it to being an attribute on the conversion op; at which point <code>kAuto</code> would no longer be necessary. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad6dfcab9b0dbfb18cf218eef50ba36caaa8c857c2f1b000c92f9794ebf53888d7"></a>kAuto&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad6dfcab9b0dbfb18cf218eef50ba36caad0d3b7e52553c0a403cfe727b3ce47b3"></a>kViaCOO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad6dfcab9b0dbfb18cf218eef50ba36caaa9a2bb1cd77c7a81a96b73f10722040e"></a>kDirect&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l00097">97</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a9e4d5a3d224089fd8a2ebc3e933d08b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4d5a3d224089fd8a2ebc3e933d08b5">&#9670;&nbsp;</a></span>TraversalMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5">mlir::TraversalMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the traversal method options to be used in the reduction tree traversal. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9e4d5a3d224089fd8a2ebc3e933d08b5ab8166871d66f03feaa6948b3f5727c96"></a>SinglePath&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9e4d5a3d224089fd8a2ebc3e933d08b5ad4f6ed581fb2f9d06c062711e30c13e1"></a>Backtrack&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9e4d5a3d224089fd8a2ebc3e933d08b5a9addc7d66f740728689b7f9abde66593"></a>MultiPath&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ReductionNode_8h_source.html#l00037">37</a> of file <a class="el" href="ReductionNode_8h_source.html">ReductionNode.h</a>.</p>

</div>
</div>
<a id="a59fa9dd53c74f1ca73aa7ef263c94adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59fa9dd53c74f1ca73aa7ef263c94adc">&#9670;&nbsp;</a></span>WalkOrder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">mlir::WalkOrder</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traversal order for region, block and operation walk utilities. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc"></a>PreOrder&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163"></a>PostOrder&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00063">63</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5bcc9dc786aa8f64a60f1d51cdad3361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bcc9dc786aa8f64a60f1d51cdad3361">&#9670;&nbsp;</a></span>alignAffineMapWithValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::alignAffineMapWithValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>syms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>newSyms</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-indexes the dimensions and symbols of an affine map with given <code>operands</code> values to align with <code>dims</code> and <code>syms</code> values. </p>
<p>Each dimension/symbol of the map, bound to an operand <code>o</code>, is replaced with dimension <code>i</code>, where <code>i</code> is the position of <code>o</code> within <code>dims</code>. If <code>o</code> is not in <code>dims</code>, replace it with symbol <code>i</code>, where <code>i</code> is the position of <code>o</code> within <code>syms</code>. If <code>o</code> is not in <code>syms</code> either, replace it with a new symbol.</p>
<p>Note: If a value appears multiple times as a dimension/symbol (or both), all corresponding dim/sym expressions are replaced with the first dimension bound to that value (or first symbol if no such dimension exists).</p>
<p>The resulting affine map has <code>dims.size()</code> many dimensions and at least <code>syms.size()</code> many symbols.</p>
<p>The SSA values of the symbols of the resulting map are optionally returned via <code>newSyms</code>. This is a concatenation of <code>syms</code> with the SSA values of the newly added symbols.</p>
<p>Note: As part of this re-indexing, dimensions may turn into symbols, or vice versa. </p>

<p class="definition">Definition at line <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01272">1272</a> of file <a class="el" href="FlatLinearValueConstraints_8cpp_source.html">FlatLinearValueConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>, <a class="el" href="Builders_8cpp_source.html#l00339">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00343">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00271">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00324">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00333">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00328">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00426">mlir::AffineMap::replaceDimsAndSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01878">alignAndAddBound()</a>, and <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01112">mlir::FlatLinearValueConstraints::computeAlignedMap()</a>.</p>

</div>
</div>
<a id="afab585c34c7b24e9436fd19b4eeda434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab585c34c7b24e9436fd19b4eeda434">&#9670;&nbsp;</a></span>applyAnalysisConversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyAnalysisConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>convertedOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>notifyCallback</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply an analysis conversion on the given operations, and all nested operations. </p>
<p>This method analyzes which operations would be successfully converted to the target if a conversion was applied. All operations that were found to be legalizable to the given 'target' are placed within the provided 'convertedOps' set; note that no actual rewrites are applied to the operations on success and only pre-existing operations are added to the set. This method only returns failure if there are unreachable blocks in any of the regions nested within 'ops'. There's an additional argument <code>notifyCallback</code> which is used for collecting match failure diagnostics generated during the conversion. Diagnostics are only reported to this callback may only be available in debug mode. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03396">3396</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

</div>
</div>
<a id="ade8c56a3b48cf2fac3d26eb11e76a2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8c56a3b48cf2fac3d26eb11e76a2f4">&#9670;&nbsp;</a></span>applyAnalysisConversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyAnalysisConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>convertedOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>notifyCallback</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03406">3406</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

</div>
</div>
<a id="ab41920e66a206248f862766a705125d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41920e66a206248f862766a705125d1">&#9670;&nbsp;</a></span>applyDefaultTimingManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::applyDefaultTimingManagerCLOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DefaultTimingManager.html">DefaultTimingManager</a> &amp;&#160;</td>
          <td class="paramname"><em>tm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply any values that were registered with 'registerDefaultTimingManagerOptions' to a <code><a class="el" href="classmlir_1_1DefaultTimingManager.html" title="Facilities for time measurement and report printing to an output stream.">DefaultTimingManager</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="Timing_8cpp_source.html#l00562">562</a> of file <a class="el" href="Timing_8cpp_source.html">Timing.cpp</a>.</p>

<p class="reference">References <a class="el" href="Timing_8cpp_source.html#l00555">options</a>, <a class="el" href="Timing_8cpp_source.html#l00462">mlir::DefaultTimingManager::setDisplayMode()</a>, and <a class="el" href="Timing_8cpp_source.html#l00456">mlir::DefaultTimingManager::setEnabled()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassManagerOptions_8cpp_source.html#l00158">applyDefaultTimingPassManagerCLOptions()</a>, and <a class="el" href="MlirOptMain_8cpp_source.html#l00223">performActions()</a>.</p>

</div>
</div>
<a id="acd78ebb9f95cfe7ea3856d9f9c46d030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd78ebb9f95cfe7ea3856d9f9c46d030">&#9670;&nbsp;</a></span>applyDefaultTimingPassManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::applyDefaultTimingPassManagerCLOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply any values provided to the timing manager options that were registered with <code>registerDefaultTimingManagerOptions</code>. </p>
<p>This is a handy helper function if you do not want to bother creating your own timing manager and passing it to the pass manager. </p>

<p class="definition">Definition at line <a class="el" href="PassManagerOptions_8cpp_source.html#l00158">158</a> of file <a class="el" href="PassManagerOptions_8cpp_source.html">PassManagerOptions.cpp</a>.</p>

<p class="reference">References <a class="el" href="Timing_8cpp_source.html#l00562">applyDefaultTimingManagerCLOptions()</a>, and <a class="el" href="PassTiming_8cpp_source.html#l00148">mlir::PassManager::enableTiming()</a>.</p>

</div>
</div>
<a id="aaa7512bc48b1a360b7881bd8e8edf74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7512bc48b1a360b7881bd8e8edf74e">&#9670;&nbsp;</a></span>applyFullConversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyFullConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a complete conversion on the given operations, and all nested operations. </p>
<p>This method returns failure if the conversion of any operation fails, or if there are unreachable blocks in any of the regions nested within 'ops'. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03381">3381</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

</div>
</div>
<a id="a1da50bb4604fb05010c585eb301e2789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da50bb4604fb05010c585eb301e2789">&#9670;&nbsp;</a></span>applyFullConversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyFullConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03387">3387</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

</div>
</div>
<a id="a10b86ede77ff793a77a2f26ac8755313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b86ede77ff793a77a2f26ac8755313">&#9670;&nbsp;</a></span>applyOpPatternsAndFold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyOpPatternsAndFold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>changed</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>allErased</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the specified rewrite patterns on <code>ops</code> while also trying to fold these ops. </p>
<p>Newly created ops and other pre-existing ops that use results of rewritten ops or supply operands to such ops are simplified, unless such ops are excluded via <code>config.strictMode</code>. Any other ops remain unmodified (i.e., regardless of <code>strictMode</code>).</p>
<p>In addition to strictness, a region scope can be specified. Only ops within the scope are simplified. This is similar to <code>applyPatternsAndFoldGreedily</code>, where only ops within the given regions are simplified. If no scope is specified, it is assumed to be the first common enclosing region of the given ops.</p>
<p>Note that ops in <code>ops</code> could be erased as result of folding, becoming dead, or via pattern rewrites. If more far reaching simplification is desired, applyPatternsAndFoldGreedily should be used.</p>
<p>Returns success if the iterative process converged and no more patterns can be matched. <code>changed</code> is set to true if the IR was modified at all. <code>allOpsErased</code> is set to true if all ops in <code>ops</code> were erased. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00607">607</a> of file <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html">GreedyPatternRewriteDriver.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00582">findCommonAncestor()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00066">mlir::GreedyRewriteConfig::scope</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00405">mlir::affine::hoistAffineIfOp()</a>.</p>

</div>
</div>
<a id="a239d533c4f17a4d6e0c3fa5a3e362692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239d533c4f17a4d6e0c3fa5a3e362692">&#9670;&nbsp;</a></span>applyPartialConversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyPartialConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *&#160;</td>
          <td class="paramname"><em>unconvertedOps</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Below we define several entry points for operation conversion. </p>
<p>It is important to note that the patterns provided to the conversion framework may have additional constraints. See the <code><a class="el" href="classmlir_1_1PatternRewriter.html" title="A special type of RewriterBase that coordinates the application of a rewrite pattern on the current I...">PatternRewriter</a> Hooks</code> section of the <a class="el" href="classmlir_1_1ConversionPatternRewriter.html" title="This class implements a pattern rewriter for use with ConversionPatterns.">ConversionPatternRewriter</a>, to see what additional constraints are imposed on the use of the <a class="el" href="classmlir_1_1PatternRewriter.html" title="A special type of RewriterBase that coordinates the application of a rewrite pattern on the current I...">PatternRewriter</a>. Apply a partial conversion on the given operations and all nested operations. This method converts as many operations to the target as possible, ignoring operations that failed to legalize. This method only returns failure if there ops explicitly marked as illegal. If an <code>unconvertedOps</code> set is provided, all operations that are found not to be legalizable to the given <code>target</code> are placed within that set. (Note that if there is an op explicitly marked as illegal, the conversion terminates and the <code>unconvertedOps</code> set will not necessarily be complete.) </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03361">3361</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

</div>
</div>
<a id="acc6bdfc70c056bdf02a5d1470b926eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6bdfc70c056bdf02a5d1470b926eab">&#9670;&nbsp;</a></span>applyPartialConversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyPartialConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *&#160;</td>
          <td class="paramname"><em>unconvertedOps</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03370">3370</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

</div>
</div>
<a id="a32067eb3e1b98572873f7cce08848080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32067eb3e1b98572873f7cce08848080">&#9670;&nbsp;</a></span>applyPartialOneToNConversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyPartialOneToNConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OneToNTypeConverter.html">OneToNTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given set of patterns recursively on the given op and adds user materializations where necessary. </p>
<p>The patterns are expected to be <code><a class="el" href="classmlir_1_1OneToNConversionPattern.html" title="Base class for patterns with 1:N type conversions.">OneToNConversionPattern</a></code>, which help converting the types of the operands and results of the matched ops. The provided type converter is used to convert the operands of matched ops from their original types to operands with different types. Unlike in <code>DialectConversion</code>, this supports 1:N type conversions. Those conversions at the "boundary" of the pattern application, where converted results are not consumed by replaced ops that expect the converted operands or vice versa, the function inserts user materializations from the type converter. Also unlike <code>DialectConversion</code>, there are no legal or illegal types; the function simply applies the given patterns and does not fail if some ops or types remain unconverted (i.e., the conversion is only "partial"). </p>

<p class="definition">Definition at line <a class="el" href="Transforms_2Utils_2OneToNTypeConversion_8cpp_source.html#l00311">311</a> of file <a class="el" href="Transforms_2Utils_2OneToNTypeConversion_8cpp_source.html">OneToNTypeConversion.cpp</a>.</p>

</div>
</div>
<a id="a133398d008de5837d6df9b322b62f5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133398d008de5837d6df9b322b62f5f6">&#9670;&nbsp;</a></span>applyPassManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyPassManagerCLOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply any values provided to the pass manager options that were registered with 'registerPassManagerOptions'. </p>

<p class="definition">Definition at line <a class="el" href="PassManagerOptions_8cpp_source.html#l00133">133</a> of file <a class="el" href="PassManagerOptions_8cpp_source.html">PassManagerOptions.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">emitError()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00421">mlir::PassManager::enableCrashReproducerGeneration()</a>, <a class="el" href="PassStatistics_8cpp_source.html#l00250">mlir::PassManager::enableStatistics()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">get()</a>, <a class="el" href="PassManager_8h_source.html#l00232">mlir::PassManager::getContext()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00563">mlir::MLIRContext::isMultithreadingEnabled()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="a218fc6e0abad6c66d8c518853b50f084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218fc6e0abad6c66d8c518853b50f084">&#9670;&nbsp;</a></span>applyPatternsAndFoldGreedily() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyPatternsAndFoldGreedily </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rewrite ops in all regions of the given op, which must be isolated from above. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00110">110</a> of file <a class="el" href="GreedyPatternRewriteDriver_8h_source.html">GreedyPatternRewriteDriver.h</a>.</p>

</div>
</div>
<a id="a13cb09dc0d8e54bce84bd4ad60f155f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13cb09dc0d8e54bce84bd4ad60f155f0">&#9670;&nbsp;</a></span>applyPatternsAndFoldGreedily() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyPatternsAndFoldGreedily </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite ops in the given region, which must be isolated from above, by repeatedly applying the highest benefit patterns in a greedy work-list driven manner. </p>
<p>This variant may stop after a predefined number of iterations, see the alternative below to provide a specific number of iterations before stopping in absence of convergence.</p>
<p>Return success if the iterative process converged and no more patterns can be matched in the result operation regions.</p>
<p>Note: This does not apply patterns to the top-level operation itself. These methods also perform folding and simple dead-code elimination before attempting to match any of the provided patterns.</p>
<p>You may configure several aspects of this with <a class="el" href="classmlir_1_1GreedyRewriteConfig.html" title="This class allows control over how the GreedyPatternRewriteDriver works.">GreedyRewriteConfig</a>. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00495">495</a> of file <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html">GreedyPatternRewriteDriver.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00024">mlir::Region::getContext()</a>, <a class="el" href="IR_2Region_8h_source.html#l00200">mlir::Region::getParentOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00690">mlir::Operation::hasTrait()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00055">mlir::GreedyRewriteConfig::maxIterations</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00066">mlir::GreedyRewriteConfig::scope</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00405">mlir::affine::hoistAffineIfOp()</a>, and <a class="el" href="TransformInterfaces_8cpp_source.html#l01376">mlir::transform::detail::transformWithPatternsApply()</a>.</p>

</div>
</div>
<a id="a2b76f177cd65bd4fd394f9dc65d20be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b76f177cd65bd4fd394f9dc65d20be2">&#9670;&nbsp;</a></span>applyPermutationMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;T&gt; mlir::applyPermutationMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a permutation from <code>map</code> to <code>source</code> and return the result. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00609">609</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00333">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00332">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00337">mlir::AffineMap::getResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00521">mlir::AffineMap::isProjectedPermutation()</a>.</p>

</div>
</div>
<a id="adbcff71555e8c1965e508f324f43a55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcff71555e8c1965e508f324f43a55a">&#9670;&nbsp;</a></span>applyPermutationToVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::applyPermutationToVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>inVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the permutation defined by <code>permutation</code> to <code>inVec</code>. </p>
<p>Element <code>i</code> in <code>inVec</code> is mapped to location <code>j = permutation[i]</code>. E.g.: for an input vector &lsquo;inVec = ['a&rsquo;, 'b', 'c']<code>and a permutation vector</code>permutation = [2, 0, 1]<code>, this function leaves</code>inVec = ['c', 'a', 'b']`. </p>

<p class="definition">Definition at line <a class="el" href="Utils_2IndexingUtils_8h_source.html#l00187">187</a> of file <a class="el" href="Utils_2IndexingUtils_8h_source.html">IndexingUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l03437">commonPermutationOfPackAndUnPackOp()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00087">mlir::tensor::computeTransposedType()</a>, <a class="el" href="TensorOps_8cpp_source.html#l03574">getPackOpResultTypeShape()</a>, <a class="el" href="Interchange_8cpp_source.html#l00050">mlir::linalg::interchangeGenericOp()</a>, <a class="el" href="Transforms_8cpp_source.html#l00480">mlir::linalg::lowerPack()</a>, <a class="el" href="Transforms_8cpp_source.html#l00610">mlir::linalg::lowerUnPack()</a>, and <a class="el" href="Transforms_8cpp_source.html#l00859">permuteShape()</a>.</p>

</div>
</div>
<a id="ac680df79552c596c048cd9cb27638c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac680df79552c596c048cd9cb27638c5f">&#9670;&nbsp;</a></span>areValuesDefinedAbove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::areValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Range.html">Range</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if all values in the provided range are defined above the <code>limit</code> region. </p>
<p>That is, if they are defined in a region that is a proper ancestor of <code>limit</code>. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8h_source.html#l00024">24</a> of file <a class="el" href="RegionUtils_8h_source.html">RegionUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToGPU_8cpp_source.html#l00110">checkAffineLoopNestMappableImpl()</a>.</p>

</div>
</div>
<a id="a3d1168f4877a1008569deabfdab07fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1168f4877a1008569deabfdab07fbb">&#9670;&nbsp;</a></span>asMainReturnCode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mlir::asMainReturnCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper wrapper to return the result of MlirOptMain directly from main. </p>
<p>Example: </p><pre class="fragment">int main(int argc, char **argv) {
  // ...
  return mlir::asMainReturnCode(mlir::MlirOptMain(
      argc, argv, /* ... *&amp;zwj;/);
}
</pre> 
<p class="definition">Definition at line <a class="el" href="MlirOptMain_8h_source.html#l00248">248</a> of file <a class="el" href="MlirOptMain_8h_source.html">MlirOptMain.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00041">mlir::LogicalResult::succeeded()</a>.</p>

</div>
</div>
<a id="a173d145c5b783b4fe092fc78fd6879ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173d145c5b783b4fe092fc78fd6879ec">&#9670;&nbsp;</a></span>barePtrFuncArgTypeConverter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::barePtrFuncArgTypeConverter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to convert function argument types. </p>
<p>It converts MemRef function arguments to bare pointers to the MemRef element type. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00629">629</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00476">mlir::LLVMTypeConverter::convertCallingConventionType()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00223">mlir::LLVMTypeConverter::convertFunctionSignature()</a>.</p>

</div>
</div>
<a id="a3d147ba82716614172eb7e9b5209d3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d147ba82716614172eb7e9b5209d3eb">&#9670;&nbsp;</a></span>bindDims()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... AffineExprTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bindDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy &amp;...&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a list of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> references to DimExpr at positions: [0 . </p>
<p>. sizeof...(exprs)] </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00329">329</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00453">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="Tiling_8cpp_source.html#l00247">calculateTileOffsetsAndSizes()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00683">mlir::linalg::computeSliceParameters()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00077">contractSupportsMMAMatrixType()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00023">mlir::tensor::createPadHighOp()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00188">createSubViewIntersection()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00086">getBoundedTileSize()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01853">mlir::affine::getDivMod()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00173">mlir::nvgpu::getLaneIdAndValueIdToOperandCoord()</a>, <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00055">invertSliceIndexing()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00099">mlir::memref::multiBuffer()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00936">mlir::linalg::offsetIndices()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l01087">packMatmulGreedily()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00076">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00468">mlir::linalg::updateBoundsForCyclicDistribution()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00692">updateExpandedGenericOpRegion()</a>.</p>

</div>
</div>
<a id="a2c870d90073423151a32e2c0f2afa506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c870d90073423151a32e2c0f2afa506">&#9670;&nbsp;</a></span>bindDimsList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AffineExprTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bindDimsList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineExprTy &gt;&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00334">334</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00502">getAffineDimExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00062">resolveSourceIndicesExpandShape()</a>.</p>

</div>
</div>
<a id="a8df39b3ef750e258dbe3dfe5b251cea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df39b3ef750e258dbe3dfe5b251cea5">&#9670;&nbsp;</a></span>bindSymbols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... AffineExprTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bindSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy &amp;...&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a list of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> references to SymbolExpr at positions: [0 . </p>
<p>. sizeof...(exprs)] </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00343">343</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00247">calculateTileOffsetsAndSizes()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00086">getBoundedTileSize()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00066">mlir::linalg::getConvolvedIndex()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01866">getIndexProduct()</a>, <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00055">invertSliceIndexing()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01762">mlir::affine::mapLoopToProcessorIds()</a>, <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00017">mlir::affine::mergeOffsetsSizesAndStrides()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l01087">packMatmulGreedily()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00119">peelForLoop()</a>, and <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00081">mlir::affine::resolveIndicesIntoOpWithOffsetsAndStrides()</a>.</p>

</div>
</div>
<a id="af523defc0429b26ab3f85b7023748822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af523defc0429b26ab3f85b7023748822">&#9670;&nbsp;</a></span>bindSymbolsList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AffineExprTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bindSymbolsList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineExprTy &gt;&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00348">348</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00512">getAffineSymbolExpr()</a>.</p>

</div>
</div>
<a id="a80dcfbd64b4c5038926d874e46edeea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80dcfbd64b4c5038926d874e46edeea2">&#9670;&nbsp;</a></span>canonicalizeStridedLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MemRefType mlir::canonicalizeStridedLayout </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a version of <code>t</code> with identity layout if it can be determined statically that the layout is the canonical contiguous strided layout. </p>
<p>Otherwise pass <code>t</code>'s layout into <code>simplifyAffineMap</code> and return a copy of <code>t</code> with simplified layout.</p>
<p>Otherwise pass <code>t</code>'s layout into <code>simplifyAffineMap</code> and return a copy of <code>t</code> with simplified layout. If <code>t</code> has multiple layout maps or a multi-result layout, just return <code>t</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00856">856</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01135">mlir::AffineMap::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00324">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00332">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00328">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00341">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00273">mlir::AffineMap::isIdentity()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00894">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00189">mlir::MemRefType::Builder::setLayout()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01407">simplifyAffineExpr()</a>.</p>

</div>
</div>
<a id="a46a3d17c70f67aa2d18203667acaf114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a3d17c70f67aa2d18203667acaf114">&#9670;&nbsp;</a></span>ceilDiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::ceilDiv </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of MLIR's ceildiv operation on constants. </p>
<p>The RHS is expected to be non-zero. </p>

<p class="definition">Definition at line <a class="el" href="MathExtras_8h_source.html#l00023">23</a> of file <a class="el" href="MathExtras_8h_source.html">MathExtras.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefBuilder_8cpp_source.html#l00365">mlir::UnrankedMemRefDescriptor::computeSizes()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00234">constantTripCount()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00712">getBoundForExpr()</a>, <a class="el" href="TensorOps_8cpp_source.html#l03574">getPackOpResultTypeShape()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00038">mlir::affine::getTripCountMapAndOperands()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00460">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00565">setInterTileBoundsParametric()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00791">simplifyCeilDiv()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00840">simplifyExprAndOperands()</a>.</p>

</div>
</div>
<a id="ab07dda6e0df087e91b18fdb2b8bfe5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07dda6e0df087e91b18fdb2b8bfe5aa">&#9670;&nbsp;</a></span>clone() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>newResultTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newOperands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00099">99</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00113">fuse()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00129">getTiledProducer()</a>, <a class="el" href="Transforms_8cpp_source.html#l00184">mlir::linalg::rewriteAsPaddedOp()</a>, and <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00519">mlir::vector::splitFullAndPartialTransfer()</a>.</p>

</div>
</div>
<a id="aa75b562b2c25a3d66295d10efde0b996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75b562b2c25a3d66295d10efde0b996">&#9670;&nbsp;</a></span>clone() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpT mlir::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OpT&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>newResultTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newOperands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00119">119</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

</div>
</div>
<a id="a49429f945b2bca0efdd4c315bb68505b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49429f945b2bca0efdd4c315bb68505b">&#9670;&nbsp;</a></span>cloneWithoutRegions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::cloneWithoutRegions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>newResultTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newOperands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00109">109</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

</div>
</div>
<a id="ad6d3795f1b83fc9e56398102edb81bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d3795f1b83fc9e56398102edb81bd4">&#9670;&nbsp;</a></span>coalesceLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::coalesceLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a perfect nest of "for" loops with a single linearized loop. </p>
<p>Assumes <code>loops</code> contains a list of perfectly nested loops with bounds and steps independent of any loop induction variable involved in the nest. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00653">653</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00583">normalizeLoop()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00028">replaceAllUsesInRegionWith()</a>, <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="a225e1cd29fad1b00f569d9567bc6cb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225e1cd29fad1b00f569d9567bc6cb2e">&#9670;&nbsp;</a></span>collapseParallelLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::collapseParallelLoops </td>
          <td>(</td>
          <td class="paramtype">scf::ParallelOp&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::vector&lt; unsigned &gt;&gt;&#160;</td>
          <td class="paramname"><em>combinedDimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take the ParallelLoop and for each set of dimension indices, combine them into a single dimension. </p>
<p>combinedDimensions must contain each index into loops exactly once. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00710">710</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00234">mlir::OpBuilder::atBlockBegin()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00520">mlir::Operation::erase()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00583">normalizeLoop()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00028">replaceAllUsesInRegionWith()</a>.</p>

</div>
</div>
<a id="aab965622bbf0ccdfcb51384517fd3117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab965622bbf0ccdfcb51384517fd3117">&#9670;&nbsp;</a></span>composeReassociationIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; &gt; mlir::composeReassociationIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>producerReassociations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>consumerReassociations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose reassociation maps that are used in pair of reshape ops where one is a producer and other is the consumer. </p>
<p>Only valid to use this method when both the producer and consumer are collapsing dimensions or both are expanding dimensions.</p>
<p>For example, producerReassociation = [[0, 1], [2], [3, 4]] consumerReassociation = [[0, 1], [2]]</p>
<p>is folded into</p>
<p>result = [[0, 1, 2], [3, 4]]. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00097">97</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ReshapeOpsUtils_8h_source.html#l00175">mlir::ComposeReassociativeReshapeOps&lt; ReshapeOpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ab05caafff59182b2191e4645cdceb5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05caafff59182b2191e4645cdceb5d5">&#9670;&nbsp;</a></span>compressDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::compressDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>unusedDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the dims that are listed in <code>unusedDims</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00620">620</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00780">projectDims()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00625">compressUnusedDims()</a>.</p>

</div>
</div>
<a id="a6de5b9ec7c351db7ed870d0df7248342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de5b9ec7c351db7ed870d0df7248342">&#9670;&nbsp;</a></span>compressSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::compressSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>unusedSymbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the symbols that are listed in <code>unusedSymbols</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00634">634</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00787">projectSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00639">compressUnusedSymbols()</a>.</p>

</div>
</div>
<a id="a99f84d2ce14eec6c85a20251582e5cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f84d2ce14eec6c85a20251582e5cc1">&#9670;&nbsp;</a></span>compressUnusedDims() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::compressUnusedDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the dims that are not used. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00625">625</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00620">compressDims()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00804">getUnusedDimsBitVector()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00629">compressUnusedDims()</a>, <a class="el" href="VectorOps_8cpp_source.html#l03466">inferTransferOpMaskType()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00424">reindexIndexingMap()</a>.</p>

</div>
</div>
<a id="ae2a3cbce4381f83b710fe6cfc9a867c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a3cbce4381f83b710fe6cfc9a867c9">&#9670;&nbsp;</a></span>compressUnusedDims() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; mlir::compressUnusedDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the dims that are not used by any of the individual maps in <code>maps</code>. </p>
<p>Asserts that all maps in <code>maps</code> are normalized to the same number of dims and symbols. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00629">629</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00625">compressUnusedDims()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00590">compressUnusedListImpl()</a>.</p>

</div>
</div>
<a id="ae4c401a074fdcc1cb0efb7e5369b2ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c401a074fdcc1cb0efb7e5369b2ef3">&#9670;&nbsp;</a></span>compressUnusedSymbols() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::compressUnusedSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the symbols that are not used. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00639">639</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00634">compressSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00816">getUnusedSymbolsBitVector()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00643">compressUnusedSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00794">getProjectedMap()</a>, and <a class="el" href="CAPI_2IR_2AffineMap_8cpp_source.html#l00150">mlirAffineMapCompressUnusedSymbols()</a>.</p>

</div>
</div>
<a id="a4a26d1a643586acb4362f535168be129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a26d1a643586acb4362f535168be129">&#9670;&nbsp;</a></span>compressUnusedSymbols() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; mlir::compressUnusedSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the symbols that are not used by any of the individual maps in <code>maps</code>. </p>
<p>Asserts that all maps in <code>maps</code> are normalized to the same number of dims and symbols. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00643">643</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00590">compressUnusedListImpl()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00639">compressUnusedSymbols()</a>.</p>

</div>
</div>
<a id="ad0f77472da918076c9d2a222a501823f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f77472da918076c9d2a222a501823f">&#9670;&nbsp;</a></span>computeElementwiseMul() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; mlir::computeElementwiseMul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector containing llvm::zip_equal(v1, v2) multiplied elementwise. </p>
<p>It is the caller's responsibility to pass proper <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> kind that result in valid <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> (i.e. cannot multiply 2 <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> or divide by an <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a>).</p>
<p>Return an empty vector if <code>v1</code> and <code>v2</code> are empty. </p>

<p class="definition">Definition at line <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00147">147</a> of file <a class="el" href="Utils_2IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00034">computeElementwiseMulImpl()</a>.</p>

</div>
</div>
<a id="a1c7ccdb269314ad17ee4550b4bcb608a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7ccdb269314ad17ee4550b4bcb608a">&#9670;&nbsp;</a></span>computeElementwiseMul() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; mlir::computeElementwiseMul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector containing llvm::zip_equal(v1, v2) multiplied elementwise. </p>
<p>Return an empty vector if <code>v1</code> and <code>v2</code> are empty. </p>

<p class="definition">Definition at line <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00079">79</a> of file <a class="el" href="Utils_2IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00034">computeElementwiseMulImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorUnroll_8cpp_source.html#l00031">getVectorOffset()</a>.</p>

</div>
</div>
<a id="a9c157bd2c9cf4949b45235593f6ef994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c157bd2c9cf4949b45235593f6ef994">&#9670;&nbsp;</a></span>computeMaxLinearIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::computeMaxLinearIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>basis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of elements of basis (i.e. </p>
<p>the max linear index). Return <code>0</code> if <code>basis</code> is empty.</p>
<p><code>basis</code> elements are asserted to be non-negative.</p>
<p>Return <code>0</code> if <code>basis</code> is empty. </p>

<p class="definition">Definition at line <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00084">84</a> of file <a class="el" href="Utils_2IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="PolynomialApproximation_8cpp_source.html#l00089">handleMultidimensionalVectors()</a>.</p>

</div>
</div>
<a id="ac2248838afeb293df08c1731f2d12fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2248838afeb293df08c1731f2d12fc2">&#9670;&nbsp;</a></span>computeMaxLinearIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::computeMaxLinearIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of elements of basis (i.e. </p>
<p>the max linear index). Return <code>0</code> if <code>basis</code> is empty.</p>
<p>It is the caller's responsibility to pass proper <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> kind that result in valid <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> (i.e. cannot multiply 2 <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> or divide by an <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a>).</p>
<p><code>basis</code> elements are expected to bind to non-negative values.</p>
<p>Return the <code>0</code> <a class="el" href="classmlir_1_1AffineConstantExpr.html" title="An integer constant appearing in affine expression.">AffineConstantExpr</a> if <code>basis</code> is empty. </p>

<p class="definition">Definition at line <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00152">152</a> of file <a class="el" href="Utils_2IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00527">getAffineConstantExpr()</a>.</p>

</div>
</div>
<a id="a6eab61c26bfef3d7aaf3db051d58230b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eab61c26bfef3d7aaf3db051d58230b">&#9670;&nbsp;</a></span>computePermutationVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; mlir::computePermutationVector </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>permSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>desiredPositions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a permutation vector of size permSize that would result in moving positions into desiredPositions. </p>
<p>For example, permSize == 5, positions = {2, 4}, desiredPositions = {1, 0} would result in a {4, 2, 0, 1, 3} permutation vector. </p>

<p class="definition">Definition at line <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00217">217</a> of file <a class="el" href="Utils_2IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transforms_8cpp_source.html#l00480">mlir::linalg::lowerPack()</a>, <a class="el" href="Transforms_8cpp_source.html#l00610">mlir::linalg::lowerUnPack()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l01087">packMatmulGreedily()</a>.</p>

</div>
</div>
<a id="aa9f62cebc6176c66cb358ddbc17e3df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f62cebc6176c66cb358ddbc17e3df7">&#9670;&nbsp;</a></span>computeRankReductionMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; llvm::SmallDenseSet&lt; unsigned &gt; &gt; mlir::computeRankReductionMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>originalShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>reducedShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an <code>originalShape</code> and a <code>reducedShape</code> assumed to be a subset of <code>originalShape</code> with some <code>1</code> entries erased, return the set of indices that specifies which of the entries of <code>originalShape</code> are dropped to obtain <code>reducedShape</code>. </p>
<p>The returned mask can be applied as a projection to <code>originalShape</code> to obtain the <code>reducedShape</code>. This mask is useful to track which dimensions must be kept when e.g. compute MemRef strides under rank-reducing operations. Return std::nullopt if reducedShape cannot be obtained by dropping only <code>1</code> entries in <code>originalShape</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00398">398</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00424">isRankReducedType()</a>.</p>

</div>
</div>
<a id="ad1c2ae63c247a9ba4509c8d1181127b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c2ae63c247a9ba4509c8d1181127b0">&#9670;&nbsp;</a></span>computeShapeRatio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; &gt; mlir::computeShapeRatio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>subShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the multi-dimensional integral ratio of <code>subShape</code> to the trailing dimensions of <code>shape</code>. </p>
<p>This represents how many times <code>subShape</code> fits within <code>shape</code>. If integral division is not possible, return std::nullopt. The trailing <code>subShape.size()</code> entries of both shapes are assumed (and enforced) to only contain non-negative values.</p>
<p>Examples:</p><ul>
<li>shapeRatio({3, 5, 8}, {2, 5, 2}) returns {3, 2, 1}.</li>
<li>shapeRatio({3, 8}, {2, 5, 2}) returns std::nullopt (subshape has higher rank).</li>
<li>shapeRatio({42, 2, 10, 32}, {2, 5, 2}) returns {42, 1, 2, 16} which is derived as {42(leading shape dim), 2/2, 10/5, 32/2}.</li>
<li>shapeRatio({42, 2, 11, 32}, {2, 5, 2}) returns std::nullopt which is derived as {42(leading shape dim), 2/2, 11/5(not divisible), 32/2}. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00109">109</a> of file <a class="el" href="Utils_2IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00071">copy()</a>.</p>

</div>
</div>
<a id="a53b9af9c7621d308e75814d488a9f6d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b9af9c7621d308e75814d488a9f6d7">&#9670;&nbsp;</a></span>computeStrides() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&gt; mlir::computeStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Utils_2IndexingUtils_8h_source.html#l00119">119</a> of file <a class="el" href="Utils_2IndexingUtils_8h_source.html">IndexingUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00072">computeSuffixProduct()</a>.</p>

</div>
</div>
<a id="a41f80386c0deb6ec32cbf4c8f3b929c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f80386c0deb6ec32cbf4c8f3b929c3">&#9670;&nbsp;</a></span>computeStrides() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t&gt; mlir::computeStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Utils_2IndexingUtils_8h_source.html#l00045">45</a> of file <a class="el" href="Utils_2IndexingUtils_8h_source.html">IndexingUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00072">computeSuffixProduct()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PolynomialApproximation_8cpp_source.html#l00089">handleMultidimensionalVectors()</a>.</p>

</div>
</div>
<a id="a530d6a928389d2f4c0234b059442a03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530d6a928389d2f4c0234b059442a03a">&#9670;&nbsp;</a></span>computeSuffixProduct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; mlir::computeSuffixProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of sizes, return the suffix product. </p>
<p>When applied to slicing, this is the calculation needed to derive the strides (i.e. the number of linear indices to skip along the (k-1) most minor dimensions to get the next k-slice).</p>
<p>This is the basis to linearize an n-D offset confined to <code>[0 ... sizes]</code>.</p>
<p>Assuming <code>sizes</code> is <code>[s0, .. sn]</code>, return the vector&lt;AffineExpr&gt; <code>[s1 * ... * sn, s2 * ... * sn, ..., sn, 1]</code>.</p>
<p>It is the caller's responsibility to pass proper <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> kind that result in valid <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> (i.e. cannot multiply 2 <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> or divide by an <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a>).</p>
<p><code>sizes</code> elements are expected to bind to non-negative values.</p>
<p>Return an empty vector if <code>sizes</code> is empty. </p>

<p class="definition">Definition at line <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00140">140</a> of file <a class="el" href="Utils_2IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00023">computeSuffixProductImpl()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00527">getAffineConstantExpr()</a>.</p>

</div>
</div>
<a id="a93db6f545964ed23f06b57618f09b33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93db6f545964ed23f06b57618f09b33a">&#9670;&nbsp;</a></span>computeSuffixProduct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; mlir::computeSuffixProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of sizes, return the suffix product. </p>
<p>When applied to slicing, this is the calculation needed to derive the strides (i.e. the number of linear indices to skip along the (k-1) most minor dimensions to get the next k-slice).</p>
<p>This is the basis to linearize an n-D offset confined to <code>[0 ... sizes]</code>.</p>
<p>Assuming <code>sizes</code> is <code>[s0, .. sn]</code>, return the vector&lt;int64_t&gt; <code>[s1 * ... * sn, s2 * ... * sn, ..., sn, 1]</code>.</p>
<p><code>sizes</code> elements are asserted to be non-negative.</p>
<p>Return an empty vector if <code>sizes</code> is empty. </p>

<p class="definition">Definition at line <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00072">72</a> of file <a class="el" href="Utils_2IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00023">computeSuffixProductImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Utils_2IndexingUtils_8h_source.html#l00045">computeStrides()</a>, <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00113">resolveSourceIndicesCollapseShape()</a>, and <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00062">resolveSourceIndicesExpandShape()</a>.</p>

</div>
</div>
<a id="a28129a93d39ade2d40077f25a09eb389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28129a93d39ade2d40077f25a09eb389">&#9670;&nbsp;</a></span>computeTopologicalSorting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::computeTopologicalSorting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>isOperandReady</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a topological ordering of the given ops. </p>
<p>This sort is not stable.</p>
<p>Note: If the specified ops contain incomplete/interrupted SSA use-def chains, the result may not actually be a topological sorting with respect to the entire program. </p>

<p class="definition">Definition at line <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00107">107</a> of file <a class="el" href="TopologicalSortUtils_8cpp_source.html">TopologicalSortUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8cpp_source.html#l00080">makeRegionIsolatedFromAbove()</a>.</p>

</div>
</div>
<a id="a6d24d64d6db077b8d5c88316b0d6c717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d24d64d6db077b8d5c88316b0d6c717">&#9670;&nbsp;</a></span>concatAffineMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::concatAffineMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates a list of <code>maps</code> into a single <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a>, stepping over potentially empty maps. </p>
<p>Assumes each of the underlying map has 0 symbols. The resulting map has a number of dims equal to the max of <code>maps</code>' dims and the concatenated results as its results. Returns an empty map if all input <code>maps</code> are empty.</p>
<p>Example: When applied to the following list of 3 affine maps,</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  (i, j, k) -&gt; (i, k),</div>
<div class="line">  (i, j, k) -&gt; (k, j),</div>
<div class="line">  (i, j, k) -&gt; (i, j)</div>
<div class="line">}</div>
</div><!-- fragment --><p>Returns the map:</p>
<div class="fragment"><div class="line">(i, j, k) -&gt; (i, k, k, j, i, j)</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00712">712</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01135">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00332">mlir::AffineMap::getNumResults()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00199">max()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00031">mlir::linalg::detail::canOpOperandsBeDroppedImpl()</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00113">replaceUnitDims()</a>.</p>

</div>
</div>
<a id="acc3c1de7f45b21ef1f9deddb22b03655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3c1de7f45b21ef1f9deddb22b03655">&#9670;&nbsp;</a></span>configureAMXLegalizeForExportTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::configureAMXLegalizeForExportTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the target to support lowering AMX ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00220">220</a> of file <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00856">mlir::ConversionTarget::addIllegalOp()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00817">mlir::ConversionTarget::addLegalOp()</a>.</p>

</div>
</div>
<a id="a026c18765c0bc2d44d9ab120174d36ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026c18765c0bc2d44d9ab120174d36ae">&#9670;&nbsp;</a></span>configureArmSVELegalizeForExportTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::configureArmSVELegalizeForExportTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the target to support lowering ArmSVE ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="ArmSVE_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00095">95</a> of file <a class="el" href="ArmSVE_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00856">mlir::ConversionTarget::addIllegalOp()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00817">mlir::ConversionTarget::addLegalOp()</a>.</p>

</div>
</div>
<a id="a7fa896c9229c786edc4a7970b960b208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa896c9229c786edc4a7970b960b208">&#9670;&nbsp;</a></span>configureGpuToNVVMConversionLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::configureGpuToNVVMConversionLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure target to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00288">288</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00934">mlir::ConversionTarget::addIllegalDialect()</a>, <a class="el" href="DialectConversion_8h_source.html#l00856">mlir::ConversionTarget::addIllegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00899">mlir::ConversionTarget::addLegalDialect()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00817">mlir::ConversionTarget::addLegalOp()</a>.</p>

</div>
</div>
<a id="a65c490624b02da7c5cb78aa071e0aa2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c490624b02da7c5cb78aa071e0aa2a">&#9670;&nbsp;</a></span>configureGpuToROCDLConversionLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::configureGpuToROCDLConversionLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure target to convert from the GPU dialect to ROCDL. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00191">191</a> of file <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html">LowerGpuOpsToROCDLOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00934">mlir::ConversionTarget::addIllegalDialect()</a>, <a class="el" href="DialectConversion_8h_source.html#l00856">mlir::ConversionTarget::addIllegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00899">mlir::ConversionTarget::addLegalDialect()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00817">mlir::ConversionTarget::addLegalOp()</a>.</p>

</div>
</div>
<a id="a732e2b51952bf0b2c474784272e790b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732e2b51952bf0b2c474784272e790b4">&#9670;&nbsp;</a></span>configureOpenMPToLLVMConversionLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::configureOpenMPToLLVMConversionLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure dynamic conversion legality of regionless operations from OpenMP to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00180">180</a> of file <a class="el" href="OpenMPToLLVM_8cpp_source.html">OpenMPToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00832">mlir::ConversionTarget::addDynamicallyLegalOp()</a>.</p>

</div>
</div>
<a id="af01d59b73ef695a82338e96055101c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01d59b73ef695a82338e96055101c16">&#9670;&nbsp;</a></span>configureParallelLoopToGPULegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::configureParallelLoopToGPULegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the rewrite target such that only <code>scf.parallel</code> operations that are not rewritten by the provided patterns are legal. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPU_8cpp_source.html#l00685">685</a> of file <a class="el" href="SCFToGPU_8cpp_source.html">SCFToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00832">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00899">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="ParallelLoopMapper_8cpp_source.html#l00031">mlir::gpu::getMappingAttrName()</a>, and <a class="el" href="SCFToGPU_8cpp_source.html#l00058">kVisitedAttrName</a>.</p>

</div>
</div>
<a id="afa8013cee2241cd53aa923b23e4e3575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8013cee2241cd53aa923b23e4e3575">&#9670;&nbsp;</a></span>configureX86VectorLegalizeForExportTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::configureX86VectorLegalizeForExportTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the target to support lowering X86Vector ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="X86Vector_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00168">168</a> of file <a class="el" href="X86Vector_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00856">mlir::ConversionTarget::addIllegalOp()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00817">mlir::ConversionTarget::addLegalOp()</a>.</p>

</div>
</div>
<a id="a694b6ad2c919c4bcef792aca11deda42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a694b6ad2c919c4bcef792aca11deda42">&#9670;&nbsp;</a></span>constantTripCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; int64_t &gt; mlir::constantTripCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of iterations for a loop with a lower bound <code>lb</code>, upper bound <code>ub</code> and step <code>step</code>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00234">234</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MathExtras_8h_source.html#l00023">ceilDiv()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00117">getConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00541">mlir::scf::promoteIfSingleIteration()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00383">promoteIfSingleIteration()</a>.</p>

</div>
</div>
<a id="a5d3b3bbe9e749975af2eb5358df6f5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3b3bbe9e749975af2eb5358df6f5fe">&#9670;&nbsp;</a></span>constFoldBinaryOp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class CalculationT  = function_ref&lt;ElementValueT(ElementValueT, ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldBinaryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CalculationT &amp;&#160;</td>
          <td class="paramname"><em>calculate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00140">140</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

</div>
</div>
<a id="aeded9a4bf948b50af55435652f46e4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeded9a4bf948b50af55435652f46e4ff">&#9670;&nbsp;</a></span>constFoldBinaryOp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class CalculationT  = function_ref&lt;ElementValueT(ElementValueT, ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldBinaryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>resultType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CalculationT &amp;&#160;</td>
          <td class="paramname"><em>calculate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00127">127</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

</div>
</div>
<a id="ae516571eecf95b88edc5de8b3133936b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae516571eecf95b88edc5de8b3133936b">&#9670;&nbsp;</a></span>constFoldBinaryOpConditional() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class CalculationT  = function_ref&lt;              std::optional&lt;ElementValueT&gt;(ElementValueT, ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldBinaryOpConditional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CalculationT &amp;&#160;</td>
          <td class="paramname"><em>calculate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs constant folding <code>calculate</code> with element-wise behavior on the two attributes in <code>operands</code> and returns the result if possible. </p>
<p>Uses the operand element type for the element type of the returned attribute. </p>

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00102">102</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

<p class="reference">References <a class="el" href="CommonFolders_8h_source.html#l00032">constFoldBinaryOpConditional()</a>.</p>

</div>
</div>
<a id="a94dbd0711a153c12e79337d0d141ec37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94dbd0711a153c12e79337d0d141ec37">&#9670;&nbsp;</a></span>constFoldBinaryOpConditional() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class CalculationT  = function_ref&lt;              std::optional&lt;ElementValueT&gt;(ElementValueT, ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldBinaryOpConditional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>resultType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CalculationT &amp;&#160;</td>
          <td class="paramname"><em>calculate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs constant folding <code>calculate</code> with element-wise behavior on the two attributes in <code>operands</code> and returns the result if possible. </p>
<p>Uses <code>resultType</code> for the type of the returned attribute. </p>

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00032">32</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00368">get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00890">mlir::DenseElementsAttr::get()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00382">mlir::DenseElementsAttr::getSplatValue()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01258">mlir::DenseElementsAttr::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CommonFolders_8h_source.html#l00102">constFoldBinaryOpConditional()</a>.</p>

</div>
</div>
<a id="ac450f976e30737567db650586c193a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac450f976e30737567db650586c193a92">&#9670;&nbsp;</a></span>constFoldCastOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT , class TargetAttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class TargetElementValueT  = typename TargetAttrElementT::ValueType, class CalculationT  = function_ref&lt;TargetElementValueT(ElementValueT, bool)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldCastOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>resType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CalculationT &amp;&#160;</td>
          <td class="paramname"><em>calculate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00213">213</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

</div>
</div>
<a id="a8fb2ddb434a672f458f2ae6ab2a11570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb2ddb434a672f458f2ae6ab2a11570">&#9670;&nbsp;</a></span>constFoldUnaryOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class CalculationT  = function_ref&lt;ElementValueT(ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldUnaryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CalculationT &amp;&amp;&#160;</td>
          <td class="paramname"><em>calculate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00200">200</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

</div>
</div>
<a id="ae4426b1d36447ba782a881c857b05b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4426b1d36447ba782a881c857b05b00">&#9670;&nbsp;</a></span>constFoldUnaryOpConditional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class CalculationT  = function_ref&lt;std::optional&lt;ElementValueT&gt;(ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldUnaryOpConditional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CalculationT &amp;&amp;&#160;</td>
          <td class="paramname"><em>calculate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs constant folding <code>calculate</code> with element-wise behavior on the one attributes in <code>operands</code> and returns the result if possible. </p>

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00155">155</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

</div>
</div>
<a id="ac6e826b7dff0a2629197a20d859cd4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e826b7dff0a2629197a20d859cd4c7">&#9670;&nbsp;</a></span>controlFlowSink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mlir::controlFlowSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a>&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>domInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>shouldMoveIntoRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>moveIntoRegion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of regions, perform control flow sinking on them. </p>
<p>For each region, control-flow sinking moves operations that dominate the region but whose only users are in the region into the regions so that they aren't executed on paths where their results are not needed.</p>
<p>TODO: For the moment, this is a <em>simple</em> control-flow sink, i.e., no duplicating of ops. It should be made to accept a cost model to determine whether duplicating a particular op is profitable.</p>
<p>Example:</p>
<div class="fragment"><div class="line">%0 = arith.addi %arg0, %arg1</div>
<div class="line">scf.if %cond {</div>
<div class="line">  scf.yield %0</div>
<div class="line">} else {</div>
<div class="line">  scf.yield %arg2</div>
<div class="line">}</div>
</div><!-- fragment --><p>After control-flow sink:</p>
<div class="fragment"><div class="line">scf.if %cond {</div>
<div class="line">  %0 = arith.addi %arg0, %arg1</div>
<div class="line">  scf.yield %0</div>
<div class="line">} else {</div>
<div class="line">  scf.yield %arg2</div>
<div class="line">}</div>
</div><!-- fragment --><p>Users must supply a callback <code>shouldMoveIntoRegion</code> that determines whether the given operation that only has users in the given operation should be moved into that region. If this returns true, <code>moveIntoRegion</code> is called on the same operation and region.</p>
<p><code>moveIntoRegion</code> must move the operation into the region such that dominance of the operation is preserved; for example, by moving the operation to the start of the entry block. This ensures the preservation of SSA dominance of the operation's results.</p>
<p>Returns the number of operations sunk. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowSinkUtils_8cpp_source.html#l00127">127</a> of file <a class="el" href="ControlFlowSinkUtils_8cpp_source.html">ControlFlowSinkUtils.cpp</a>.</p>

</div>
</div>
<a id="a4e36f1b7aaec9319e5ba11077079aa4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e36f1b7aaec9319e5ba11077079aa4e">&#9670;&nbsp;</a></span>convertAffineLoopNestToGPULaunch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::convertAffineLoopNestToGPULaunch </td>
          <td>(</td>
          <td class="paramtype">affine::AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numBlockDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numThreadDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a perfect affine loop nest with the outermost loop identified by <code>forOp</code> into a gpu::Launch operation. </p>
<p>Map <code>numBlockDims</code> outer loops to GPU blocks and <code>numThreadDims</code> to GPU threads. The bounds of the loops that are mapped should be independent of the induction variables of the other mapped loops.</p>
<p>No check on the size of the block or grid, or on the validity of parallelization is performed, it is under the responsibility of the caller to strip-mine the loops and to perform the dependence analysis before calling the conversion. </p>

</div>
</div>
<a id="ab68cec5ae244b132b00ea85983874b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68cec5ae244b132b00ea85983874b59">&#9670;&nbsp;</a></span>convertFromAttribute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::convertFromAttribute </td>
          <td>(</td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> *&#160;</td>
          <td class="paramname"><em>diag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an IntegerAttr attribute to an int64_t, or return an error if the attribute isn't an IntegerAttr. </p>
<p>If the optional diagnostic is provided an error message is also emitted. </p>

</div>
</div>
<a id="a36180c3614ba72f2955215b016bfc171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36180c3614ba72f2955215b016bfc171">&#9670;&nbsp;</a></span>convertFromAttribute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::convertFromAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> *&#160;</td>
          <td class="paramname"><em>diag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a DenseI64ArrayAttr to the provided storage. </p>
<p>It is expected that the storage has the same size as the array. An error is returned if the attribute isn't a DenseI64ArrayAttr or it does not have the same size. If the optional diagnostic is provided an error message is also emitted. </p>

</div>
</div>
<a id="a23560b6de94f046854c32398b275f8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23560b6de94f046854c32398b275f8b6">&#9670;&nbsp;</a></span>convertMMAToLLVMType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVM::LLVMStructType</a> mlir::convertMMAToLLVMType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1gpu_1_1MMAMatrixType.html">gpu::MMAMatrixType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the LLVMStructureType corresponding to the MMAMatrixType <code>type</code>. </p>

<p class="definition">Definition at line <a class="el" href="WmmaOpsToNvvm_8cpp_source.html#l00380">380</a> of file <a class="el" href="WmmaOpsToNvvm_8cpp_source.html">WmmaOpsToNvvm.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVOps_8cpp_source.html#l00698">getElementType()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00447">mlir::LLVM::LLVMStructType::getLiteral()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00086">mlir::gpu::MMAMatrixType::getOperand()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00080">mlir::gpu::MMAMatrixType::getShape()</a>, and <a class="el" href="namespacemlir_1_1NVVM.html#af89f820490ad44f10442793c0f8f2258">mlir::NVVM::inferMMAType()</a>.</p>

</div>
</div>
<a id="aaa20dcaf31535f42f49b54af6cb7a890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa20dcaf31535f42f49b54af6cb7a890">&#9670;&nbsp;</a></span>convertMMAToSPIRVType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1spirv_1_1CooperativeMatrixNVType.html">mlir::spirv::CooperativeMatrixNVType</a> mlir::convertMMAToSPIRVType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1gpu_1_1MMAMatrixType.html">gpu::MMAMatrixType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the LLVMStructureType corresponding to the MMAMatrixType <code>type</code>. </p>

<p class="definition">Definition at line <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html#l00250">250</a> of file <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html">WmmaOpsToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVTypes_8cpp_source.html#l00231">mlir::spirv::CooperativeMatrixNVType::get()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00084">mlir::gpu::MMAMatrixType::getElementType()</a>, and <a class="el" href="GPUDialect_8cpp_source.html#l00080">mlir::gpu::MMAMatrixType::getShape()</a>.</p>

</div>
</div>
<a id="a9b2799e8f52860dadc460b88a8f2df32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2799e8f52860dadc460b88a8f2df32">&#9670;&nbsp;</a></span>convertReassociationIndicesToExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2 &gt;, 2 &gt; mlir::convertReassociationIndicesToExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociationIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert reassociation indices to affine expressions. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00133">133</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00502">getAffineDimExpr()</a>.</p>

</div>
</div>
<a id="af3ef18cead6fd6974a5031544f3c46cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ef18cead6fd6974a5031544f3c46cb">&#9670;&nbsp;</a></span>convertReassociationMapsToIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a>, 2 &gt; mlir::convertReassociationMapsToIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ae5cf0e24a954fa30fb469105d4ca5dd8">ReassociationExprs</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociationExprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert Array&lt;Array&lt;AffineExpr&gt;&gt; to Array&lt;Array&lt;int64_t&gt;&gt;. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00170">170</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00325">mlir::AffineDimExpr::getPosition()</a>.</p>

</div>
</div>
<a id="a10d383da63b1370b9cf5c13c252b391d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d383da63b1370b9cf5c13c252b391d">&#9670;&nbsp;</a></span>convertScalarToDtype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::convertScalarToDtype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>toType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isUnsignedCast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a scalar value <code>operand</code> to type <code>toType</code>. </p>
<p>If the value doesn't convert, a warning will be issued and the operand is returned as is (which will presumably yield a verification issue downstream). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00087">87</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Types_8h_source.html#l00311">mlir::Type::dyn_cast()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00334">emitWarning()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8h_source.html#l00301">mlir::Type::isa()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00049">mlir::Type::isIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00038">mlir::linalg::createMul()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00201">mlir::sparse_tensor::genCast()</a>.</p>

</div>
</div>
<a id="abd5c480f463f3ed7b6369caae8c8d366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5c480f463f3ed7b6369caae8c8d366">&#9670;&nbsp;</a></span>convertToAttribute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::convertToAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the provided <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;int64_t&gt;</a> to a DenseI64ArrayAttr attribute. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00054">54</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00852">mlir::detail::DenseArrayAttrImpl&lt; T &gt;::get()</a>.</p>

</div>
</div>
<a id="ab81e61402439e0b78cd25dc4ad7eb591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81e61402439e0b78cd25dc4ad7eb591">&#9670;&nbsp;</a></span>convertToAttribute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::convertToAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the provided int64_t to an IntegerAttr attribute. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00033">33</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00368">get()</a>.</p>

</div>
</div>
<a id="af7d71d5f26ac7f264365e6fb7a6aadff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d71d5f26ac7f264365e6fb7a6aadff">&#9670;&nbsp;</a></span>convertVectorToMMAOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::convertVectorToMMAOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>rootOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert vector ops to MMA matrix operations nested under <code>rootOp</code>. </p>
<p>This will convert slice of operations that can be legally converted to MMA operations. The rest of the vector operations are left untouched. </p>

<p class="definition">Definition at line <a class="el" href="VectorToGPU_8cpp_source.html#l01218">1218</a> of file <a class="el" href="VectorToGPU_8cpp_source.html">VectorToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorToGPU_8cpp_source.html#l00343">getOpToConvert()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00030">mlir::LogicalResult::success()</a>.</p>

</div>
</div>
<a id="a8d66f364335bd7ca0a98bb53f82f0a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d66f364335bd7ca0a98bb53f82f0a77">&#9670;&nbsp;</a></span>convertVectorToNVVMCompatibleMMASync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::convertVectorToNVVMCompatibleMMASync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>rootOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert vector ops ops nested under <code>rootOp</code> to vector and GPU operaitons compatible with the <code>nvvm.mma.sync</code> lowering path. </p>
<p>This will convert a slice of operations that can be legally lowered on this path while the rest of the vector operations are left untouched. </p>

<p class="definition">Definition at line <a class="el" href="VectorToGPU_8cpp_source.html#l01251">1251</a> of file <a class="el" href="VectorToGPU_8cpp_source.html">VectorToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorToGPU_8cpp_source.html#l00343">getOpToConvert()</a>.</p>

</div>
</div>
<a id="aec305cc3472323a62580de136ce81cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec305cc3472323a62580de136ce81cc3">&#9670;&nbsp;</a></span>createAffineForToGPUPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a>&lt; FunctionOpInterface &gt; &gt; mlir::createAffineForToGPUPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCFToGPUPass_8cpp_source.html#l00076">76</a> of file <a class="el" href="SCFToGPUPass_8cpp_source.html">SCFToGPUPass.cpp</a>.</p>

</div>
</div>
<a id="a0ec40c7aecb333928b9b4e9e409f0670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec40c7aecb333928b9b4e9e409f0670">&#9670;&nbsp;</a></span>createAffineForToGPUPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a>&lt; FunctionOpInterface &gt; &gt; mlir::createAffineForToGPUPass </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numBlockDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numThreadDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that converts loop nests into GPU kernels. </p>
<p>It considers top-level affine.for operations as roots of loop nests and converts them to the gpu.launch operations if possible.</p>
<p>No check on the size of the block or grid, or on the validity of parallelization is performed, it is under the responsibility of the caller to strip-mine the loops and to perform the dependence analysis before calling the conversion. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPUPass_8cpp_source.html#l00072">72</a> of file <a class="el" href="SCFToGPUPass_8cpp_source.html">SCFToGPUPass.cpp</a>.</p>

</div>
</div>
<a id="aef286aa7b84037b9a4b9b638c57d20c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef286aa7b84037b9a4b9b638c57d20c1">&#9670;&nbsp;</a></span>createAsyncFuncToAsyncRuntimePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createAsyncFuncToAsyncRuntimePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00879">879</a> of file <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html">AsyncToAsyncRuntime.cpp</a>.</p>

</div>
</div>
<a id="a4239fe8f68fb32a8788127f7a6850950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4239fe8f68fb32a8788127f7a6850950">&#9670;&nbsp;</a></span>createAsyncParallelForPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createAsyncParallelForPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncParallelFor_8cpp_source.html#l00943">943</a> of file <a class="el" href="AsyncParallelFor_8cpp_source.html">AsyncParallelFor.cpp</a>.</p>

</div>
</div>
<a id="a755ae56707350858331f8a2d72036f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755ae56707350858331f8a2d72036f86">&#9670;&nbsp;</a></span>createAsyncParallelForPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createAsyncParallelForPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>asyncDispatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>numWorkerThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>minTaskSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncParallelFor_8cpp_source.html#l00947">947</a> of file <a class="el" href="AsyncParallelFor_8cpp_source.html">AsyncParallelFor.cpp</a>.</p>

</div>
</div>
<a id="a89c5cda96fda85b96d4c5786f58680bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c5cda96fda85b96d4c5786f58680bd">&#9670;&nbsp;</a></span>createAsyncRuntimePolicyBasedRefCountingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createAsyncRuntimePolicyBasedRefCountingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html#l00563">563</a> of file <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html">AsyncRuntimeRefCounting.cpp</a>.</p>

</div>
</div>
<a id="ac29ec7fe477dccf07bddf61bec9c3ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29ec7fe477dccf07bddf61bec9c3ac7">&#9670;&nbsp;</a></span>createAsyncRuntimeRefCountingOptPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createAsyncRuntimeRefCountingOptPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncRuntimeRefCountingOpt_8cpp_source.html#l00234">234</a> of file <a class="el" href="AsyncRuntimeRefCountingOpt_8cpp_source.html">AsyncRuntimeRefCountingOpt.cpp</a>.</p>

</div>
</div>
<a id="ac74b480a928c4e1972270a410dd3e214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74b480a928c4e1972270a410dd3e214">&#9670;&nbsp;</a></span>createAsyncRuntimeRefCountingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createAsyncRuntimeRefCountingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html#l00559">559</a> of file <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html">AsyncRuntimeRefCounting.cpp</a>.</p>

</div>
</div>
<a id="acda37b3719dc71d8caddd1d39ca215db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda37b3719dc71d8caddd1d39ca215db">&#9670;&nbsp;</a></span>createAsyncToAsyncRuntimePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createAsyncToAsyncRuntimePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00874">874</a> of file <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html">AsyncToAsyncRuntime.cpp</a>.</p>

</div>
</div>
<a id="ae01b05ed73bc512e7ae40bc6d37ae1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01b05ed73bc512e7ae40bc6d37ae1a0">&#9670;&nbsp;</a></span>createBufferizationToMemRefPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createBufferizationToMemRefPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BufferizationToMemRef_8cpp_source.html#l00110">110</a> of file <a class="el" href="BufferizationToMemRef_8cpp_source.html">BufferizationToMemRef.cpp</a>.</p>

</div>
</div>
<a id="aab0069355214b578476e81bc909f7f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0069355214b578476e81bc909f7f13">&#9670;&nbsp;</a></span>createCanonicalizerPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createCanonicalizerPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the Canonicalizer pass, configured with default settings (which can be overridden by pass options on the command line). </p>
<p>Create a Canonicalizer pass. </p>

<p class="definition">Definition at line <a class="el" href="Canonicalizer_8cpp_source.html#l00072">72</a> of file <a class="el" href="Canonicalizer_8cpp_source.html">Canonicalizer.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TosaToLinalgPass_8cpp_source.html#l00077">mlir::tosa::addTosaToLinalgPasses()</a>, <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00057">mlir::sparse_tensor::buildSparseCompiler()</a>, and <a class="el" href="Inliner_8cpp_source.html#l00038">defaultInlinerOptPipeline()</a>.</p>

</div>
</div>
<a id="a93c145cb37ca2bf4e90ceaff2231652f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c145cb37ca2bf4e90ceaff2231652f">&#9670;&nbsp;</a></span>createCanonicalizerPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createCanonicalizerPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>disabledPatterns</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>enabledPatterns</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the Canonicalizer pass with the specified config. </p>
<p><code>disabledPatterns</code> is a set of labels used to filter out input patterns with a debug label or debug name in this set. <code>enabledPatterns</code> is a set of labels used to filter out input patterns that do not have one of the labels in this set. Debug labels must be set explicitly on patterns or when adding them with <code><a class="el" href="classmlir_1_1RewritePatternSet.html#acfa4cea1d588753d077a407ef5681391" title="An overload of the above add method that allows for attaching a set of debug labels to the attached p...">RewritePatternSet::addWithLabel</a></code>. Debug names may be empty, but patterns created with <code><a class="el" href="classmlir_1_1RewritePattern.html#a2df499b22dc244d6c265e372a16db01b" title="This method provides a convenient interface for creating and initializing derived rewrite patterns of...">RewritePattern::create</a></code> have their default debug name set to their type name. </p>

<p class="definition">Definition at line <a class="el" href="Canonicalizer_8cpp_source.html#l00078">78</a> of file <a class="el" href="Canonicalizer_8cpp_source.html">Canonicalizer.cpp</a>.</p>

</div>
</div>
<a id="ac1f1d125e949d2172433639f2f31d3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f1d125e949d2172433639f2f31d3e6">&#9670;&nbsp;</a></span>createControlFlowSinkPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createControlFlowSinkPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to perform control-flow sinking. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowSink_8cpp_source.html#l00056">56</a> of file <a class="el" href="ControlFlowSink_8cpp_source.html">ControlFlowSink.cpp</a>.</p>

</div>
</div>
<a id="a4e1b32f0e812af513c57185c972dc0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1b32f0e812af513c57185c972dc0ae">&#9670;&nbsp;</a></span>createConvertAMDGPUToROCDLPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertAMDGPUToROCDLPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00563">563</a> of file <a class="el" href="AMDGPUToROCDL_8cpp_source.html">AMDGPUToROCDL.cpp</a>.</p>

</div>
</div>
<a id="a4655b459042808cdaf22b54faf67aaf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4655b459042808cdaf22b54faf67aaf6">&#9670;&nbsp;</a></span>createConvertArmNeon2dToIntrPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertArmNeon2dToIntrPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to lower Arm NEON 2D ops to intrinsics, i.e. </p>
<p>equivalent ops operating on flattened 1D vectors and mapping more directly to the corresponding Arm NEON instruction. </p>

<p class="definition">Definition at line <a class="el" href="ArmNeon2dToIntr_8cpp_source.html#l00074">74</a> of file <a class="el" href="ArmNeon2dToIntr_8cpp_source.html">ArmNeon2dToIntr.cpp</a>.</p>

</div>
</div>
<a id="a1c3204f9ba36eb541a03f8bf0ed4a9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3204f9ba36eb541a03f8bf0ed4a9a7">&#9670;&nbsp;</a></span>createConvertComplexToLibmPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertComplexToLibmPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Complex operations to libm calls. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToLibm_8cpp_source.html#l00147">147</a> of file <a class="el" href="ComplexToLibm_8cpp_source.html">ComplexToLibm.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00057">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="ad891730d98fe42a400b188049ff923f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad891730d98fe42a400b188049ff923f2">&#9670;&nbsp;</a></span>createConvertComplexToStandardPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertComplexToStandardPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Complex operations to the Standard dialect. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToStandard_8cpp_source.html#l01106">1106</a> of file <a class="el" href="ComplexToStandard_8cpp_source.html">ComplexToStandard.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00057">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a3d0b6795b3be074dc19b6445f2cc687a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0b6795b3be074dc19b6445f2cc687a">&#9670;&nbsp;</a></span>createConvertControlFlowToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt; mlir::createConvertControlFlowToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert ControlFlow ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowToSPIRVPass_8cpp_source.html#l00054">54</a> of file <a class="el" href="ControlFlowToSPIRVPass_8cpp_source.html">ControlFlowToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="abc492b94e5d0848e7244b2682da91021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc492b94e5d0848e7244b2682da91021">&#9670;&nbsp;</a></span>createConvertElementwiseToLinalgPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertElementwiseToLinalgPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00148">148</a> of file <a class="el" href="ElementwiseToLinalg_8cpp_source.html">ElementwiseToLinalg.cpp</a>.</p>

</div>
</div>
<a id="a1face754eadd25641ccf594efd52ba7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1face754eadd25641ccf594efd52ba7b">&#9670;&nbsp;</a></span>createConvertFuncToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt; mlir::createConvertFuncToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert Func ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="FuncToSPIRVPass_8cpp_source.html#l00054">54</a> of file <a class="el" href="FuncToSPIRVPass_8cpp_source.html">FuncToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="ad39c9d3321b2f5f4aee088b02b535f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39c9d3321b2f5f4aee088b02b535f9b">&#9670;&nbsp;</a></span>createConvertGpuLaunchFuncToVulkanLaunchFuncPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::ModuleOp &gt; &gt; mlir::createConvertGpuLaunchFuncToVulkanLaunchFuncPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertGPULaunchFuncToVulkanLaunchFunc_8cpp_source.html#l00209">209</a> of file <a class="el" href="ConvertGPULaunchFuncToVulkanLaunchFunc_8cpp_source.html">ConvertGPULaunchFuncToVulkanLaunchFunc.cpp</a>.</p>

</div>
</div>
<a id="a112698688acfebc3284b59e6ffa4d155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112698688acfebc3284b59e6ffa4d155">&#9670;&nbsp;</a></span>createConvertGPUToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertGPUToSPIRVPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mapMemorySpace</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert GPU kernel ops to corresponding SPIR-V ops. </p>
<p>For a gpu.func to be converted, it should have a spirv.entry_point_abi attribute. If <code>mapMemorySpace</code> is true, performs MemRef memory space to SPIR-V mapping according to default Vulkan rules first. </p>

<p class="definition">Definition at line <a class="el" href="GPUToSPIRVPass_8cpp_source.html#l00109">109</a> of file <a class="el" href="GPUToSPIRVPass_8cpp_source.html">GPUToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a49b8d9d8ebc6d954a9bb1d61ff789bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b8d9d8ebc6d954a9bb1d61ff789bc0">&#9670;&nbsp;</a></span>createConvertLinalgToAffineLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createConvertLinalgToAffineLoopsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations to affine.for loops and affine_load/affine_store accesses. </p>
<p>Placeholder for now, this is NYI. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00366">366</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

</div>
</div>
<a id="a048ca3f94f0e3472846128d08e1db05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048ca3f94f0e3472846128d08e1db05f">&#9670;&nbsp;</a></span>createConvertLinalgToLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createConvertLinalgToLoopsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations to scf.for loops and memref.load/memref.store accesses. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00356">356</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00057">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="ac2eb8ccd7e77282559488dfb6408a632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2eb8ccd7e77282559488dfb6408a632">&#9670;&nbsp;</a></span>createConvertLinalgToParallelLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createConvertLinalgToParallelLoopsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations to scf.parallel loops and memref.load/memref.store accesses. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00361">361</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

</div>
</div>
<a id="aefb33f39a4ad0d4d52396f132bee84cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb33f39a4ad0d4d52396f132bee84cf">&#9670;&nbsp;</a></span>createConvertLinalgToStandardPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertLinalgToStandardPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations to the Standard dialect. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToStandard_8cpp_source.html#l00155">155</a> of file <a class="el" href="LinalgToStandard_8cpp_source.html">LinalgToStandard.cpp</a>.</p>

</div>
</div>
<a id="aa0be8ab8e597910498a4a64215faa2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0be8ab8e597910498a4a64215faa2fb">&#9670;&nbsp;</a></span>createConvertMathToLibmPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertMathToLibmPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Math operations to libm calls. </p>

<p class="definition">Definition at line <a class="el" href="MathToLibm_8cpp_source.html#l00204">204</a> of file <a class="el" href="MathToLibm_8cpp_source.html">MathToLibm.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00057">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a10c8995bd3756d7b1e15813d96b2b2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c8995bd3756d7b1e15813d96b2b2ad">&#9670;&nbsp;</a></span>createConvertMathToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt; mlir::createConvertMathToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert Math ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="MathToSPIRVPass_8cpp_source.html#l00063">63</a> of file <a class="el" href="MathToSPIRVPass_8cpp_source.html">MathToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a3bec430062ec4285c83eccbab6ebbe29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bec430062ec4285c83eccbab6ebbe29">&#9670;&nbsp;</a></span>createConvertMemRefToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt; mlir::createConvertMemRefToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert MemRef ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="MemRefToSPIRVPass_8cpp_source.html#l00064">64</a> of file <a class="el" href="MemRefToSPIRVPass_8cpp_source.html">MemRefToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a3c1dc4bc47a3830e063b709a36e0ab91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1dc4bc47a3830e063b709a36e0ab91">&#9670;&nbsp;</a></span>createConvertOpenACCToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertOpenACCToSCFPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert the OpenACC dialect into the LLVMIR dialect. </p>

<p class="definition">Definition at line <a class="el" href="OpenACCToSCF_8cpp_source.html#l00100">100</a> of file <a class="el" href="OpenACCToSCF_8cpp_source.html">OpenACCToSCF.cpp</a>.</p>

</div>
</div>
<a id="a877c34cdb063f52ff5ea4efd82807621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877c34cdb063f52ff5ea4efd82807621">&#9670;&nbsp;</a></span>createConvertSCFToCFPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertSCFToCFPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert SCF operations to CFG branch-based operation in the ControlFlow dialect. </p>

<p class="definition">Definition at line <a class="el" href="SCFToControlFlow_8cpp_source.html#l00705">705</a> of file <a class="el" href="SCFToControlFlow_8cpp_source.html">SCFToControlFlow.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00057">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a74c87a4d7e914dda62d03a97cf7e8963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c87a4d7e914dda62d03a97cf7e8963">&#9670;&nbsp;</a></span>createConvertSCFToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt; mlir::createConvertSCFToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert SCF ops into SPIR-V ops. </p>

</div>
</div>
<a id="ac85b8b89468b7fc2b347d361b512e8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85b8b89468b7fc2b347d361b512e8d3">&#9670;&nbsp;</a></span>createConvertShapeConstraintsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertShapeConstraintsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertShapeConstraints_8cpp_source.html#l00071">71</a> of file <a class="el" href="ConvertShapeConstraints_8cpp_source.html">ConvertShapeConstraints.cpp</a>.</p>

</div>
</div>
<a id="abc9ecc9afba558cb026032d0453a7c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9ecc9afba558cb026032d0453a7c95">&#9670;&nbsp;</a></span>createConvertShapeToStandardPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertShapeToStandardPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ShapeToStandard_8cpp_source.html#l00736">736</a> of file <a class="el" href="ShapeToStandard_8cpp_source.html">ShapeToStandard.cpp</a>.</p>

</div>
</div>
<a id="a2ff30b5a742e19dd8d8fea41d953fbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff30b5a742e19dd8d8fea41d953fbe4">&#9670;&nbsp;</a></span>createConvertTensorToLinalgPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertTensorToLinalgPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert Tensor ops to Linalg ops. </p>

<p class="definition">Definition at line <a class="el" href="TensorToLinalgPass_8cpp_source.html#l00050">50</a> of file <a class="el" href="TensorToLinalgPass_8cpp_source.html">TensorToLinalgPass.cpp</a>.</p>

</div>
</div>
<a id="a81d3655f76a6db563fa528a741573691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d3655f76a6db563fa528a741573691">&#9670;&nbsp;</a></span>createConvertTensorToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt; mlir::createConvertTensorToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert Tensor ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="TensorToSPIRVPass_8cpp_source.html#l00057">57</a> of file <a class="el" href="TensorToSPIRVPass_8cpp_source.html">TensorToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="ad3e64d4460362ea3cdb2edc8b746396c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e64d4460362ea3cdb2edc8b746396c">&#9670;&nbsp;</a></span>createConvertVectorToGPUPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertVectorToGPUPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useNvGpu</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert from vector to GPU ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorToGPU_8cpp_source.html#l01320">1320</a> of file <a class="el" href="VectorToGPU_8cpp_source.html">VectorToGPU.cpp</a>.</p>

</div>
</div>
<a id="ac5c71e471d7d8cdda288a27d1ae75642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c71e471d7d8cdda288a27d1ae75642">&#9670;&nbsp;</a></span>createConvertVectorToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertVectorToSCFPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert a subset of vector ops to SCF. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSCF_8cpp_source.html#l01324">1324</a> of file <a class="el" href="VectorToSCF_8cpp_source.html">VectorToSCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00057">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a8113c1109f8cc9f8d47492fce5d7723f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8113c1109f8cc9f8d47492fce5d7723f">&#9670;&nbsp;</a></span>createConvertVectorToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt; mlir::createConvertVectorToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert <a class="el" href="structVector.html">Vector</a> Ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSPIRVPass_8cpp_source.html#l00063">63</a> of file <a class="el" href="VectorToSPIRVPass_8cpp_source.html">VectorToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a14895da9723acd9c7f910c2694ff9f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14895da9723acd9c7f910c2694ff9f65">&#9670;&nbsp;</a></span>createCSEPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createCSEPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to perform common sub expression elimination. </p>

<p class="definition">Definition at line <a class="el" href="CSE_8cpp_source.html#l00350">350</a> of file <a class="el" href="CSE_8cpp_source.html">CSE.cpp</a>.</p>

</div>
</div>
<a id="a0fcdb1d516a9d3198ae11daf05637b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fcdb1d516a9d3198ae11daf05637b05">&#9670;&nbsp;</a></span>createFoldReshapeOpsByLinearizationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">Pass</a>&gt; mlir::createFoldReshapeOpsByLinearizationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7acfeadb8fff74a53be77ccf540be99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acfeadb8fff74a53be77ccf540be99b">&#9670;&nbsp;</a></span>createForLoopPeelingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createForLoopPeelingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that peels for loops at their upper bounds for better vectorization. </p>

<p class="definition">Definition at line <a class="el" href="LoopSpecialization_8cpp_source.html#l00286">286</a> of file <a class="el" href="LoopSpecialization_8cpp_source.html">LoopSpecialization.cpp</a>.</p>

</div>
</div>
<a id="a2a6597022fdb6de5a99b895b2bfc9e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6597022fdb6de5a99b895b2bfc9e0a">&#9670;&nbsp;</a></span>createForLoopRangeFoldingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createForLoopRangeFoldingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which folds arith ops on induction variable into loop range. </p>

<p class="definition">Definition at line <a class="el" href="LoopRangeFolding_8cpp_source.html#l00089">89</a> of file <a class="el" href="LoopRangeFolding_8cpp_source.html">LoopRangeFolding.cpp</a>.</p>

</div>
</div>
<a id="a1d49e4ae28aeaaa552466850cc5e04ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d49e4ae28aeaaa552466850cc5e04ec">&#9670;&nbsp;</a></span>createForLoopSpecializationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createForLoopSpecializationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that specializes for loop for unrolling and vectorization. </p>

<p class="definition">Definition at line <a class="el" href="LoopSpecialization_8cpp_source.html#l00282">282</a> of file <a class="el" href="LoopSpecialization_8cpp_source.html">LoopSpecialization.cpp</a>.</p>

</div>
</div>
<a id="a76018eef454fd668d103ea3cc6afc52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76018eef454fd668d103ea3cc6afc52a">&#9670;&nbsp;</a></span>createForToWhileLoopPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createForToWhileLoopPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ForToWhile_8cpp_source.html#l00120">120</a> of file <a class="el" href="ForToWhile_8cpp_source.html">ForToWhile.cpp</a>.</p>

</div>
</div>
<a id="a6fdd2528f381177f9ded6de5eba9900b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fdd2528f381177f9ded6de5eba9900b">&#9670;&nbsp;</a></span>createGenerateRuntimeVerificationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createGenerateRuntimeVerificationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that generates IR to verify ops at runtime. </p>

<p class="definition">Definition at line <a class="el" href="GenerateRuntimeVerification_8cpp_source.html#l00038">38</a> of file <a class="el" href="GenerateRuntimeVerification_8cpp_source.html">GenerateRuntimeVerification.cpp</a>.</p>

</div>
</div>
<a id="a8bd2637570ab4c74519de8ed73747b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd2637570ab4c74519de8ed73747b5f">&#9670;&nbsp;</a></span>createGpuAsyncRegionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createGpuAsyncRegionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrites a function region so that GPU ops execute asynchronously. </p>

<p class="definition">Definition at line <a class="el" href="AsyncRegionRewriter_8cpp_source.html#l00352">352</a> of file <a class="el" href="AsyncRegionRewriter_8cpp_source.html">AsyncRegionRewriter.cpp</a>.</p>

</div>
</div>
<a id="ae628f55b8a69b490ef848ceb63d234b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae628f55b8a69b490ef848ceb63d234b9">&#9670;&nbsp;</a></span>createGpuKernelOutliningPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createGpuKernelOutliningPass </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>dataLayoutStr</em> = <code>StringRef()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces <code>gpu.launch</code> with <code>gpu.launch_func</code> by moving the region into a separate kernel function. </p>

<p class="definition">Definition at line <a class="el" href="KernelOutlining_8cpp_source.html#l00443">443</a> of file <a class="el" href="KernelOutlining_8cpp_source.html">KernelOutlining.cpp</a>.</p>

</div>
</div>
<a id="a66200178a198c2f8aae15e94882f0788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66200178a198c2f8aae15e94882f0788">&#9670;&nbsp;</a></span>createGpuLauchSinkIndexComputationsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createGpuLauchSinkIndexComputationsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> that moves ops which are likely an index computation into gpu.launch body. </p>

<p class="definition">Definition at line <a class="el" href="KernelOutlining_8cpp_source.html#l00438">438</a> of file <a class="el" href="KernelOutlining_8cpp_source.html">KernelOutlining.cpp</a>.</p>

</div>
</div>
<a id="acc65540e2fcc88965c99cf18236192b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc65540e2fcc88965c99cf18236192b4">&#9670;&nbsp;</a></span>createGpuMapParallelLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::func::FuncOp &gt; &gt; mlir::createGpuMapParallelLoopsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps the parallel loops found in the given function to workgroups. </p>
<p>The first loop encountered will be mapped to the global workgroup and the second loop encountered to the local workgroup. Within each mapping, the first three dimensions are mapped to x/y/z hardware ids and all following dimensions are mapped to sequential loops. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopMapper_8cpp_source.html#l00150">150</a> of file <a class="el" href="ParallelLoopMapper_8cpp_source.html">ParallelLoopMapper.cpp</a>.</p>

</div>
</div>
<a id="ac94e0df03210ed9f9748882cd5a70a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94e0df03210ed9f9748882cd5a70a47">&#9670;&nbsp;</a></span>createGpuSerializeToCubinPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">Pass</a>&gt; mlir::createGpuSerializeToCubinPass </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>chip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>features</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an instance of the GPU kernel function to CUBIN binary serialization pass. </p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00057">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a67c464614f40cbae1452d716d1a35636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c464614f40cbae1452d716d1a35636">&#9670;&nbsp;</a></span>createGpuSerializeToHsacoPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">Pass</a>&gt; mlir::createGpuSerializeToHsacoPass </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>arch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an instance of the GPU kernel function to HSAco binary serialization pass. </p>

</div>
</div>
<a id="a6c6ad0644a283c257d1fbc15be6adc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6ad0644a283c257d1fbc15be6adc18">&#9670;&nbsp;</a></span>createInlinerPass() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createInlinerPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which inlines calls and callable operations as defined by the <a class="el" href="classmlir_1_1CallGraph.html">CallGraph</a>. </p>

<p class="definition">Definition at line <a class="el" href="Inliner_8cpp_source.html#l00824">824</a> of file <a class="el" href="Inliner_8cpp_source.html">Inliner.cpp</a>.</p>

</div>
</div>
<a id="a1372ce1294d9b98b652930aa6baf1386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1372ce1294d9b98b652930aa6baf1386">&#9670;&nbsp;</a></span>createInlinerPass() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createInlinerPass </td>
          <td>(</td>
          <td class="paramtype">llvm::StringMap&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt;&#160;</td>
          <td class="paramname"><em>opPipelines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the inliner pass, and use the provided pass managers when optimizing callable operations with names matching the key type. </p>
<p>Callable operations with a name not within the provided map will use the default inliner pipeline during optimization. </p>

<p class="definition">Definition at line <a class="el" href="Inliner_8cpp_source.html#l00828">828</a> of file <a class="el" href="Inliner_8cpp_source.html">Inliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="Inliner_8cpp_source.html#l00038">defaultInlinerOptPipeline()</a>.</p>

</div>
</div>
<a id="a282d4666d1a10f4c41e6b114bf5e6a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282d4666d1a10f4c41e6b114bf5e6a7f">&#9670;&nbsp;</a></span>createInlinerPass() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createInlinerPass </td>
          <td>(</td>
          <td class="paramtype">llvm::StringMap&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt;&#160;</td>
          <td class="paramname"><em>opPipelines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>defaultPipelineBuilder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the inliner pass, and use the provided pass managers when optimizing callable operations with names matching the key type. </p>
<p>Callable operations with a name not within the provided map will use the provided default pipeline builder. </p>

<p class="definition">Definition at line <a class="el" href="Inliner_8cpp_source.html#l00832">832</a> of file <a class="el" href="Inliner_8cpp_source.html">Inliner.cpp</a>.</p>

</div>
</div>
<a id="aacc6c56dc4a5f06f5a3dbff9a70f2126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc6c56dc4a5f06f5a3dbff9a70f2126">&#9670;&nbsp;</a></span>createLinalgBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createLinalgBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations which work on tensors to use buffers instead. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Bufferize_8cpp_source.html#l00052">52</a> of file <a class="el" href="Linalg_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

</div>
</div>
<a id="a888e0ad22e8609a0c5042ccecdb7adc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888e0ad22e8609a0c5042ccecdb7adc7">&#9670;&nbsp;</a></span>createLinalgDetensorizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLinalgDetensorizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations to equivalent operations that work on primitive types, if possible. </p>

<p class="definition">Definition at line <a class="el" href="Detensorize_8cpp_source.html#l00580">580</a> of file <a class="el" href="Detensorize_8cpp_source.html">Detensorize.cpp</a>.</p>

</div>
</div>
<a id="aa174a4f487204b0e8221ed0ab2dfb737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa174a4f487204b0e8221ed0ab2dfb737">&#9670;&nbsp;</a></span>createLinalgElementwiseOpFusionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLinalgElementwiseOpFusionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01893">1893</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

</div>
</div>
<a id="aa750e27e8b520efa98466e75aece0f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa750e27e8b520efa98466e75aece0f7b">&#9670;&nbsp;</a></span>createLinalgFoldUnitExtentDimsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLinalgFoldUnitExtentDimsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DropUnitDims_8cpp_source.html#l00724">724</a> of file <a class="el" href="DropUnitDims_8cpp_source.html">DropUnitDims.cpp</a>.</p>

</div>
</div>
<a id="abbac2762b3662cb64525cf03fbf69f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbac2762b3662cb64525cf03fbf69f83">&#9670;&nbsp;</a></span>createLinalgGeneralizationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createLinalgGeneralizationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert named Linalg operations to Linalg generic operations. </p>

<p class="definition">Definition at line <a class="el" href="Generalization_8cpp_source.html#l00097">97</a> of file <a class="el" href="Generalization_8cpp_source.html">Generalization.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00057">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="ae1086a21637aa5a39c59574052b80c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1086a21637aa5a39c59574052b80c17">&#9670;&nbsp;</a></span>createLinalgInlineScalarOperandsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createLinalgInlineScalarOperandsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InlineScalarOperands_8cpp_source.html#l00117">117</a> of file <a class="el" href="InlineScalarOperands_8cpp_source.html">InlineScalarOperands.cpp</a>.</p>

</div>
</div>
<a id="ad448648b1ff12e114f53247cbad44e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad448648b1ff12e114f53247cbad44e5c">&#9670;&nbsp;</a></span>createLinalgNamedOpConversionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLinalgNamedOpConversionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NamedOpConversions_8cpp_source.html#l00166">166</a> of file <a class="el" href="NamedOpConversions_8cpp_source.html">NamedOpConversions.cpp</a>.</p>

</div>
</div>
<a id="abb0bdadbeb0d7f5b8cef57668447640b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0bdadbeb0d7f5b8cef57668447640b">&#9670;&nbsp;</a></span>createLocationSnapshotPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLocationSnapshotPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload utilizing pass options for initialization. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00157">157</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

</div>
</div>
<a id="a415fbf6253902c584461fa6a43a59ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415fbf6253902c584461fa6a43a59ad5">&#9670;&nbsp;</a></span>createLocationSnapshotPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLocationSnapshotPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>fileName</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>tag</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to generate new locations by snapshotting the IR to the given file, and using the printed locations within that file. </p>
<p>If <code>filename</code> is empty, a temporary file is generated instead. If a 'tag' is non-empty, the generated locations are represented as a NameLoc with the given tag as the name, and then fused with the existing locations. Otherwise, the existing locations are replaced. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00152">152</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

</div>
</div>
<a id="a319fde65e573dbc3a947d58196cb2b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319fde65e573dbc3a947d58196cb2b3a">&#9670;&nbsp;</a></span>createLoopInvariantCodeMotionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLoopInvariantCodeMotionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop invariant code motion pass that hoists loop invariant instructions out of the loop. </p>

<p class="definition">Definition at line <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html#l00042">42</a> of file <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html">LoopInvariantCodeMotion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00104">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="ae09ce34232ab009ce688d7cdc63695a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09ce34232ab009ce688d7cdc63695a8">&#9670;&nbsp;</a></span>createLowerAffinePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLowerAffinePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lowers affine control flow operations (ForStmt, IfStmt and AffineApplyOp) to equivalent lower-level constructs (flow of basic blocks and arithmetic primitives). </p>
<p>Lowers If and For operations within a function into their lower level CFG equivalent blocks. </p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00569">569</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00057">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="abf4e20598665a8f48288a9f03ddc8772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4e20598665a8f48288a9f03ddc8772">&#9670;&nbsp;</a></span>createLowerGpuOpsToNVVMOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; gpu::GPUModuleOp &gt; &gt; mlir::createLowerGpuOpsToNVVMOpsPass </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>indexBitwidth</em> = <code><a class="el" href="namespacemlir.html#a2887883f00b094c5ca61c631d7b093a0">kDeriveIndexBitwidthFromDataLayout</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hasRedux</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that lowers GPU dialect operations to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> counterparts. </p>
<p>The index bitwidth used for the lowering of the device side index computations is configurable. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00378">378</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00057">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a6cb6ab100d4d15861d7ed00e702ff0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb6ab100d4d15861d7ed00e702ff0ed">&#9670;&nbsp;</a></span>createLowerGpuOpsToROCDLOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; gpu::GPUModuleOp &gt; &gt; mlir::createLowerGpuOpsToROCDLOpsPass </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>chipset</em> = <code>&quot;gfx900&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>indexBitwidth</em> = <code><a class="el" href="namespacemlir.html#a2887883f00b094c5ca61c631d7b093a0">kDeriveIndexBitwidthFromDataLayout</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBarePtrCallConv</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1gpu_1_1amd.html#a8637afbd01b984be30dbd1cdb78ae45f">gpu::amd::Runtime</a>&#160;</td>
          <td class="paramname"><em>runtime</em> = <code>gpu::amd::Runtime::Unknown</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that lowers GPU dialect operations to ROCDL counterparts. </p>
<p>The index bitwidth used for the lowering of the device side index computations is configurable. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00287">287</a> of file <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html">LowerGpuOpsToROCDLOps.cpp</a>.</p>

</div>
</div>
<a id="a0c5b68602e237b1c1c3209ae71184cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5b68602e237b1c1c3209ae71184cd2">&#9670;&nbsp;</a></span>createMapMemRefStorageClassPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt; mlir::createMapMemRefStorageClassPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to map numeric MemRef memory spaces to symbolic SPIR-V storage classes. </p>
<p>The mapping is read from the command-line option. </p>

<p class="definition">Definition at line <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00364">364</a> of file <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html">MapMemRefStorageClassPass.cpp</a>.</p>

</div>
</div>
<a id="a87060fc8d3ef747e189053c6bd556a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87060fc8d3ef747e189053c6bd556a5a">&#9670;&nbsp;</a></span>createOptReductionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createOptReductionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OptReductionPass_8cpp_source.html#l00090">90</a> of file <a class="el" href="OptReductionPass_8cpp_source.html">OptReductionPass.cpp</a>.</p>

</div>
</div>
<a id="a4bb4bec758f757740b983d352319eccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb4bec758f757740b983d352319eccb">&#9670;&nbsp;</a></span>createOutlineShapeComputationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createOutlineShapeComputationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outline the shape computation part by adding shape.func and populate conrresponding mapping infomation into ShapeMappingAnalysis. </p>

<p class="definition">Definition at line <a class="el" href="OutlineShapeComputation_8cpp_source.html#l00331">331</a> of file <a class="el" href="OutlineShapeComputation_8cpp_source.html">OutlineShapeComputation.cpp</a>.</p>

</div>
</div>
<a id="ad00701d01638289dd08ec9e255076f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00701d01638289dd08ec9e255076f50">&#9670;&nbsp;</a></span>createParallelLoopFusionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createParallelLoopFusionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop fusion pass which fuses parallel loops. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00179">179</a> of file <a class="el" href="ParallelLoopFusion_8cpp_source.html">ParallelLoopFusion.cpp</a>.</p>

</div>
</div>
<a id="a16b9f8678ec66eed9c66536834540184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b9f8678ec66eed9c66536834540184">&#9670;&nbsp;</a></span>createParallelLoopSpecializationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createParallelLoopSpecializationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that specializes parallel loop for unrolling and vectorization. </p>

<p class="definition">Definition at line <a class="el" href="LoopSpecialization_8cpp_source.html#l00278">278</a> of file <a class="el" href="LoopSpecialization_8cpp_source.html">LoopSpecialization.cpp</a>.</p>

</div>
</div>
<a id="a213571bc56b32e75bc35cf02098982a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213571bc56b32e75bc35cf02098982a1">&#9670;&nbsp;</a></span>createParallelLoopTilingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createParallelLoopTilingPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>tileSize</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noMinMaxBounds</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which tiles innermost parallel loops. </p>
<p>If noMinMaxBounds, the upper bound of the inner loop will be a same value among different outter loop iterations, and an additional inbound check will be emitted inside the internal loops. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopTiling_8cpp_source.html#l00211">211</a> of file <a class="el" href="ParallelLoopTiling_8cpp_source.html">ParallelLoopTiling.cpp</a>.</p>

</div>
</div>
<a id="aa2f36107d7ffc6c1f873c746385d9de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f36107d7ffc6c1f873c746385d9de0">&#9670;&nbsp;</a></span>createParallelLoopToGpuPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createParallelLoopToGpuPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that converts scf.parallel operations into a gpu.launch operation. </p>
<p>The mapping of loop dimensions to launch dimensions is derived from mapping attributes. See ParallelToGpuLaunchLowering::matchAndRewrite for a description of the used attributes. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPUPass_8cpp_source.html#l00080">80</a> of file <a class="el" href="SCFToGPUPass_8cpp_source.html">SCFToGPUPass.cpp</a>.</p>

</div>
</div>
<a id="af882e712b4e426905d73c1c74bd0f353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af882e712b4e426905d73c1c74bd0f353">&#9670;&nbsp;</a></span>createPDLToPDLInterpPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createPDLToPDLInterpPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a pass to convert PDL ops to PDL interpreter ops. </p>

<p class="definition">Definition at line <a class="el" href="PDLToPDLInterp_8cpp_source.html#l00994">994</a> of file <a class="el" href="PDLToPDLInterp_8cpp_source.html">PDLToPDLInterp.cpp</a>.</p>

</div>
</div>
<a id="ae7b51cc369e6be47cad63fe35c030ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b51cc369e6be47cad63fe35c030ca3">&#9670;&nbsp;</a></span>createPDLToPDLInterpPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createPDLToPDLInterpPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1PDLPatternConfigSet.html">PDLPatternConfigSet</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>configMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a pass to convert PDL ops to PDL interpreter ops. </p>
<p><code>configMap</code> holds a map of the configurations for each pattern being compiled. </p>

<p class="definition">Definition at line <a class="el" href="PDLToPDLInterp_8cpp_source.html#l00997">997</a> of file <a class="el" href="PDLToPDLInterp_8cpp_source.html">PDLToPDLInterp.cpp</a>.</p>

</div>
</div>
<a id="af0453f43fae9c5d6de063d3b2076bbeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0453f43fae9c5d6de063d3b2076bbeb">&#9670;&nbsp;</a></span>createPostSparsificationRewritePass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createPostSparsificationRewritePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00374">374</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00104">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a9c396e4212b7c922cfacb6f0509316b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c396e4212b7c922cfacb6f0509316b5">&#9670;&nbsp;</a></span>createPostSparsificationRewritePass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createPostSparsificationRewritePass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableRT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableForeach</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableConvert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00379">379</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

</div>
</div>
<a id="aa6abc74515648dc477ae4f5af8cbf310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6abc74515648dc477ae4f5af8cbf310">&#9670;&nbsp;</a></span>createPreSparsificationRewritePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createPreSparsificationRewritePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00361">361</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00104">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a0a84c3fae02e7540b0db48350b738be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a84c3fae02e7540b0db48350b738be1">&#9670;&nbsp;</a></span>createPrintIRPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createPrintIRPass </td>
          <td>(</td>
          <td class="paramtype">const PrintIRPassOptions &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to print IR on the debug stream. </p>

<p class="definition">Definition at line <a class="el" href="PrintIR_8cpp_source.html#l00033">33</a> of file <a class="el" href="PrintIR_8cpp_source.html">PrintIR.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="a045e1f32a8d90260d292aad61149c0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045e1f32a8d90260d292aad61149c0ef">&#9670;&nbsp;</a></span>createPrintOpGraphPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createPrintOpGraphPass </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>llvm::errs()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to print op graphs. </p>

<p class="definition">Definition at line <a class="el" href="ViewOpGraph_8cpp_source.html#l00326">326</a> of file <a class="el" href="ViewOpGraph_8cpp_source.html">ViewOpGraph.cpp</a>.</p>

</div>
</div>
<a id="a738190b0f29ddc52ba6847cb310eb60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a738190b0f29ddc52ba6847cb310eb60d">&#9670;&nbsp;</a></span>createPrintOpStatsPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createPrintOpStatsPass </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>printAsJSON</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which prints the list of ops and the number of occurrences in the module with the output format option. </p>

<p class="definition">Definition at line <a class="el" href="OpStats_8cpp_source.html#l00119">119</a> of file <a class="el" href="OpStats_8cpp_source.html">OpStats.cpp</a>.</p>

</div>
</div>
<a id="ab56d49b89c1f203d6fa20f126bf4d900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56d49b89c1f203d6fa20f126bf4d900">&#9670;&nbsp;</a></span>createPrintOpStatsPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createPrintOpStatsPass </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>llvm::errs()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which prints the list of ops and the number of occurrences in the module. </p>

<p class="definition">Definition at line <a class="el" href="OpStats_8cpp_source.html#l00115">115</a> of file <a class="el" href="OpStats_8cpp_source.html">OpStats.cpp</a>.</p>

</div>
</div>
<a id="aab06609d5a7ea6d475070dcc8d271725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab06609d5a7ea6d475070dcc8d271725">&#9670;&nbsp;</a></span>createReconcileUnrealizedCastsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createReconcileUnrealizedCastsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that eliminates noop <code>unrealized_conversion_cast</code> operation sequences. </p>

<p class="definition">Definition at line <a class="el" href="ReconcileUnrealizedCasts_8cpp_source.html#l00132">132</a> of file <a class="el" href="ReconcileUnrealizedCasts_8cpp_source.html">ReconcileUnrealizedCasts.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00057">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a4ed5140e30c6e204e8bdc35d08d0eb08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed5140e30c6e204e8bdc35d08d0eb08">&#9670;&nbsp;</a></span>createReductionTreePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createReductionTreePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReductionTreePass_8cpp_source.html#l00259">259</a> of file <a class="el" href="ReductionTreePass_8cpp_source.html">ReductionTreePass.cpp</a>.</p>

</div>
</div>
<a id="ad79c79f5d3c3fd8668be6d76e33bad9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79c79f5d3c3fd8668be6d76e33bad9a">&#9670;&nbsp;</a></span>createRemoveShapeConstraintsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createRemoveShapeConstraintsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RemoveShapeConstraints_8cpp_source.html#l00070">70</a> of file <a class="el" href="RemoveShapeConstraints_8cpp_source.html">RemoveShapeConstraints.cpp</a>.</p>

</div>
</div>
<a id="a6119493f8c83de427f34658e5e39cbfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6119493f8c83de427f34658e5e39cbfe">&#9670;&nbsp;</a></span>createSCCPPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSCCPPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which performs sparse conditional constant propagation over nested operations. </p>

<p class="definition">Definition at line <a class="el" href="SCCP_8cpp_source.html#l00133">133</a> of file <a class="el" href="SCCP_8cpp_source.html">SCCP.cpp</a>.</p>

</div>
</div>
<a id="a8c2a7464fefab1d85cec445e487f0d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2a7464fefab1d85cec445e487f0d0c">&#9670;&nbsp;</a></span>createSCFBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSCFBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that bufferizes the SCF dialect. </p>

<p class="definition">Definition at line <a class="el" href="SCF_2Transforms_2Bufferize_8cpp_source.html#l00045">45</a> of file <a class="el" href="SCF_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

</div>
</div>
<a id="ac7f8ebf7a2133d1c68cea6e20fba0ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f8ebf7a2133d1c68cea6e20fba0ea8">&#9670;&nbsp;</a></span>createSCFForLoopCanonicalizationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSCFForLoopCanonicalizationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that canonicalizes affine.min and affine.max operations inside of scf.for loops with known lower and upper bounds. </p>

<p class="definition">Definition at line <a class="el" href="LoopCanonicalization_8cpp_source.html#l00189">189</a> of file <a class="el" href="LoopCanonicalization_8cpp_source.html">LoopCanonicalization.cpp</a>.</p>

</div>
</div>
<a id="a801d4bb16485795a758c5c60d8413c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a801d4bb16485795a758c5c60d8413c6f">&#9670;&nbsp;</a></span>createShapeBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createShapeBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Shape_2Transforms_2Bufferize_8cpp_source.html#l00047">47</a> of file <a class="el" href="Shape_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

</div>
</div>
<a id="a050e7653e9cef5f155370ca0425994e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050e7653e9cef5f155370ca0425994e9">&#9670;&nbsp;</a></span>createShapeToShapeLowering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createShapeToShapeLowering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the ShapeToShapeLowering pass that legalizes Shape dialect to be convertible to Arith. </p>
<p>For example, <code>shape.num_elements</code> get transformed to <code>shape.reduce</code>, which can be lowered to SCF and Arith. </p>

<p class="definition">Definition at line <a class="el" href="ShapeToShapeLowering_8cpp_source.html#l00085">85</a> of file <a class="el" href="ShapeToShapeLowering_8cpp_source.html">ShapeToShapeLowering.cpp</a>.</p>

</div>
</div>
<a id="a52922b4f9a9b71d07318a65565e1d95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52922b4f9a9b71d07318a65565e1d95d">&#9670;&nbsp;</a></span>createSparseBufferRewritePass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseBufferRewritePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00405">405</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00104">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="aa9c5d254155d499befa419181f2539ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c5d254155d499befa419181f2539ea">&#9670;&nbsp;</a></span>createSparseBufferRewritePass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseBufferRewritePass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableBufferInitialization</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00410">410</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

</div>
</div>
<a id="a2fa7d8a0754783f37e6e38a77c7e8116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa7d8a0754783f37e6e38a77c7e8116">&#9670;&nbsp;</a></span>createSparseGPUCodegenPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseGPUCodegenPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00426">426</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00057">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a145b51940ed730f152b315db4e82cae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145b51940ed730f152b315db4e82cae5">&#9670;&nbsp;</a></span>createSparseGPUCodegenPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseGPUCodegenPass </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numThreads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00430">430</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

</div>
</div>
<a id="a1444af92cb6556316a97dbd17dc10ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1444af92cb6556316a97dbd17dc10ea4">&#9670;&nbsp;</a></span>createSparseTensorCodegenPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseTensorCodegenPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00394">394</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00104">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="ad11d8839f833db69a07242adf6894472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11d8839f833db69a07242adf6894472">&#9670;&nbsp;</a></span>createSparseTensorCodegenPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseTensorCodegenPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createSparseDeallocs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableBufferInitialization</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00399">399</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

</div>
</div>
<a id="a50fe6af993ee7df395f88312234f0dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50fe6af993ee7df395f88312234f0dc0">&#9670;&nbsp;</a></span>createSparseTensorConversionPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseTensorConversionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00385">385</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00104">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="aa8654e2dbbf377b3df5383b90c7f9b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8654e2dbbf377b3df5383b90c7f9b2c">&#9670;&nbsp;</a></span>createSparseTensorConversionPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseTensorConversionPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1SparseTensorConversionOptions.html">SparseTensorConversionOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00389">389</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="a06a9ca41ccfad286cda8688e8d66f588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a9ca41ccfad286cda8688e8d66f588">&#9670;&nbsp;</a></span>createSparseVectorizationPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseVectorizationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00414">414</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00104">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a3399bec16625e6af75488bb739d48d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3399bec16625e6af75488bb739d48d4c">&#9670;&nbsp;</a></span>createSparseVectorizationPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseVectorizationPass </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>vectorLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableVLAVectorization</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableSIMDIndex32</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00419">419</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

</div>
</div>
<a id="a4218327a76c03ad88d87dee6df15c634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4218327a76c03ad88d87dee6df15c634">&#9670;&nbsp;</a></span>createSparsificationAndBufferizationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparsificationAndBufferizationPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">bufferization::OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>bufferizationOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsificationOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1SparseTensorConversionOptions.html">SparseTensorConversionOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>sparseTensorConversionOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createSparseDeallocs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableRuntimeLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableBufferInitialization</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>vectorLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableVLAVectorization</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableSIMDIndex32</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00180">180</a> of file <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html">SparsificationAndBufferizationPass.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00057">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="ae0be4f778219bfb3917a2c7d3e7e1bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0be4f778219bfb3917a2c7d3e7e1bd0">&#9670;&nbsp;</a></span>createSparsificationPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparsificationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00365">365</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00104">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a11b0dcc4a707e4e560a7a2f69a95a7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b0dcc4a707e4e560a7a2f69a95a7c9">&#9670;&nbsp;</a></span>createSparsificationPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparsificationPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00370">370</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="aa52fe837d33ee51beba517a1d44dbea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52fe837d33ee51beba517a1d44dbea3">&#9670;&nbsp;</a></span>createStorageSpecifierToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createStorageSpecifierToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00434">434</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00104">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a3b152134b4d44a148dac8bfc24070dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b152134b4d44a148dac8bfc24070dcd">&#9670;&nbsp;</a></span>createStripDebugInfoPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createStripDebugInfoPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to strip debug information from a function. </p>

<p class="definition">Definition at line <a class="el" href="StripDebugInfo_8cpp_source.html#l00046">46</a> of file <a class="el" href="StripDebugInfo_8cpp_source.html">StripDebugInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00057">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a69605e45210627de9b7fde4644fa50c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69605e45210627de9b7fde4644fa50c1">&#9670;&nbsp;</a></span>createSymbolDCEPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSymbolDCEPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which delete symbol operations that are unreachable. </p>
<p>This pass may <em>only</em> be scheduled on an operation that defines a <a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a>. </p>

<p class="definition">Definition at line <a class="el" href="SymbolDCE_8cpp_source.html#l00149">149</a> of file <a class="el" href="SymbolDCE_8cpp_source.html">SymbolDCE.cpp</a>.</p>

</div>
</div>
<a id="ae0b0f8a089ed821a240c7dd4e5573573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b0f8a089ed821a240c7dd4e5573573">&#9670;&nbsp;</a></span>createSymbolPrivatizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSymbolPrivatizePass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>excludeSymbols</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which marks top-level symbol operations as <code>private</code> unless listed in <code>excludeSymbols</code>. </p>

<p class="definition">Definition at line <a class="el" href="SymbolPrivatize_8cpp_source.html#l00061">61</a> of file <a class="el" href="SymbolPrivatize_8cpp_source.html">SymbolPrivatize.cpp</a>.</p>

</div>
</div>
<a id="ab03de4687b73fcc63bfde7e0dda6b741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03de4687b73fcc63bfde7e0dda6b741">&#9670;&nbsp;</a></span>createTestSCFParallelLoopCollapsingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createTestSCFParallelLoopCollapsingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that transforms a single ParallelLoop over N induction variables into another ParallelLoop over less than N induction variables. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopCollapsing_8cpp_source.html#l00106">106</a> of file <a class="el" href="ParallelLoopCollapsing_8cpp_source.html">ParallelLoopCollapsing.cpp</a>.</p>

</div>
</div>
<a id="a4480ae6dd145482f88ec81d28df3bca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4480ae6dd145482f88ec81d28df3bca8">&#9670;&nbsp;</a></span>createTopologicalSortPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createTopologicalSortPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that recursively sorts nested regions without SSA dominance topologically such that, as much as possible, users of values appear after their producers. </p>

<p class="definition">Definition at line <a class="el" href="TopologicalSort_8cpp_source.html#l00038">38</a> of file <a class="el" href="TopologicalSort_8cpp_source.html">TopologicalSort.cpp</a>.</p>

</div>
</div>
<a id="a54881321f630a119cdee5af076de868d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54881321f630a119cdee5af076de868d">&#9670;&nbsp;</a></span>debugString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string mlir::debugString </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DebugStringHelper_8h_source.html#l00028">28</a> of file <a class="el" href="DebugStringHelper_8h_source.html">DebugStringHelper.h</a>.</p>

</div>
</div>
<a id="a7485a65ba54d86caa67a0639e38504d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7485a65ba54d86caa67a0639e38504d3">&#9670;&nbsp;</a></span>decomposeMixedValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; ArrayAttr, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt; mlir::decomposeMixedValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mixedValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompose a vector of mixed static or dynamic values into the corresponding pair of arrays. </p>
<p>This is the inverse function of <code>getMixedValues</code>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00181">181</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Attributes_8h_source.html#l00176">mlir::Attribute::cast()</a>, and <a class="el" href="Builders_8cpp_source.html#l00274">mlir::Builder::getI64ArrayAttr()</a>.</p>

</div>
</div>
<a id="a1041856e784cdbf7811cd10bc5a5ffd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1041856e784cdbf7811cd10bc5a5ffd6">&#9670;&nbsp;</a></span>delinearize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; mlir::delinearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>linearIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>strides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the strides together with a linear index in the dimension space, return the vector-space offsets in each dimension for a de-linearized index. </p>
<p>Let <code>li = linearIndex</code>, assuming <code>strides</code> are <code>[s0, .. sn]</code>, return the vector of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> <code>[li % s0, (li / s0) % s1, ..., (li / s0 / .. / sn-1) % sn]</code></p>
<p>It is the caller's responsibility to pass proper <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> kind that result in valid <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> (i.e. cannot multiply 2 <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> or divide by an <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a>).</p>
<p><code>strides</code> elements are expected to bind to non-negative values. </p>

<p class="definition">Definition at line <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00174">174</a> of file <a class="el" href="Utils_2IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00056">delinearizeImpl()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00778">mlir::AffineExpr::floorDiv()</a>.</p>

</div>
</div>
<a id="a2830e5f60c269c339ef24c33d8f7fbf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2830e5f60c269c339ef24c33d8f7fbf0">&#9670;&nbsp;</a></span>delinearize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; mlir::delinearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>linearIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>strides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00181">181</a> of file <a class="el" href="Utils_2IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00100">delinearize()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00527">getAffineConstantExpr()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00025">mlir::AffineExpr::getContext()</a>.</p>

</div>
</div>
<a id="a448d2cc69bc47c1304f4f1608937c3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448d2cc69bc47c1304f4f1608937c3c4">&#9670;&nbsp;</a></span>delinearize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; mlir::delinearize </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>linearIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>strides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the strides together with a linear index in the dimension space, return the vector-space offsets in each dimension for a de-linearized index. </p>
<p><code>strides</code> elements are asserted to be non-negative.</p>
<p>Let <code>li = linearIndex</code>, assuming <code>strides</code> are <code>[s0, .. sn]</code>, return the vector of int64_t <code>[li % s0, (li / s0) % s1, ..., (li / s0 / .. / sn-1) % sn]</code> </p>

<p class="definition">Definition at line <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00100">100</a> of file <a class="el" href="Utils_2IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00056">delinearizeImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00181">delinearize()</a>, <a class="el" href="VectorUnroll_8cpp_source.html#l00031">getVectorOffset()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00089">handleMultidimensionalVectors()</a>, and <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00113">resolveSourceIndicesCollapseShape()</a>.</p>

</div>
</div>
<a id="abf9a8d86f0213b02a553c01aea31e6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9a8d86f0213b02a553c01aea31e6e4">&#9670;&nbsp;</a></span>dispatchIndexOpFoldResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::dispatchIndexOpFoldResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dynamicVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>staticVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to dispatch an <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> into <code>staticVec</code> if: a) it is an IntegerAttr In other cases, the <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> is dispached to the <code>dynamicVec</code>. </p>
<p>In such dynamic cases, ShapedType::kDynamic is also pushed to <code>staticVec</code>. This is useful to extract mixed static and dynamic entries that come from an AttrSizedOperandSegments trait.</p>
<p>In such dynamic cases, a copy of the <code>sentinel</code> value is also pushed to <code>staticVec</code>. This is useful to extract mixed static and dynamic entries that come from an AttrSizedOperandSegments trait. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00051">51</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="StaticValueUtils_8cpp_source.html#l00064">dispatchIndexOpFoldResults()</a>.</p>

</div>
</div>
<a id="a923d05c8f39df57cf19f1ec709bbe5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923d05c8f39df57cf19f1ec709bbe5a5">&#9670;&nbsp;</a></span>dispatchIndexOpFoldResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::dispatchIndexOpFoldResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>ofrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dynamicVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>staticVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to dispatch multiple OpFoldResults according to the behavior of <code>dispatchIndexOpFoldResult(<a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> ofr</code> for a single <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00064">64</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00051">dispatchIndexOpFoldResult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00453">mlir::tensor::bubbleUpPadSlice()</a>.</p>

</div>
</div>
<a id="a7739fe988f31077f0005b73f457eb373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7739fe988f31077f0005b73f457eb373">&#9670;&nbsp;</a></span>emitDefiniteFailure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DiagnosedDefiniteFailure.html">DiagnosedDefiniteFailure</a> mlir::emitDefiniteFailure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emits a definite failure with the given message. </p>
<p>The returned object allows for last-minute modification to the error message, such as attaching notes and completing the message. It will be reported when the object is destructed or converted. </p>

<p class="definition">Definition at line <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00243">243</a> of file <a class="el" href="DiagnosedSilenceableFailure_8h_source.html">DiagnosedSilenceableFailure.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="MatchInterfaces_8h_source.html#l00053">mlir::transform::SingleOpMatcherOpTrait&lt; OpTy &gt;::apply()</a>, <a class="el" href="MatchInterfaces_8h_source.html#l00093">mlir::transform::SingleValueMatcherOpTrait&lt; OpTy &gt;::apply()</a>, <a class="el" href="GPUTransformOps_8cpp_source.html#l00243">definiteFailureHelper()</a>, and <a class="el" href="TransformInterfaces_8cpp_source.html#l01376">mlir::transform::detail::transformWithPatternsApply()</a>.</p>

</div>
</div>
<a id="a1f82005038ea404596c74643db0d564f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f82005038ea404596c74643db0d564f">&#9670;&nbsp;</a></span>emitDefiniteFailure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DiagnosedDefiniteFailure.html">DiagnosedDefiniteFailure</a> mlir::emitDefiniteFailure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00247">247</a> of file <a class="el" href="DiagnosedSilenceableFailure_8h_source.html">DiagnosedSilenceableFailure.h</a>.</p>

</div>
</div>
<a id="a4e96b0c437652eb5a4890734bb6bcee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e96b0c437652eb5a4890734bb6bcee7">&#9670;&nbsp;</a></span>emitError() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to emit an error message using this location. </p>
<p>Emit an error message using this location. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">328</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassManagerOptions_8cpp_source.html#l00133">applyPassManagerCLOptions()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00172">buildSequentialConstant()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01110">mlir::transform::detail::checkApplyToOne()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00296">checkTensorElementType()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00615">mlir::LLVM::ModuleTranslation::convertBlock()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00561">mlir::LLVM::ModuleImport::convertDataLayout()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00543">mlir::LLVM::ModuleImport::convertGlobals()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00601">convertOmpSections()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01058">mlir::LLVM::ModuleImport::convertValue()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00040">deserializeModule()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00456">mlir::spirv::Deserializer::processOp&lt; spirv::CopyMemoryOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00332">mlir::spirv::Deserializer::processOp&lt; spirv::EntryPointOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00381">mlir::spirv::Deserializer::processOp&lt; spirv::ExecutionModeOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00414">mlir::spirv::Deserializer::processOp&lt; spirv::FunctionCallOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00527">mlir::spirv::Deserializer::processOp&lt; spirv::GenericCastToPtrExplicitOp &gt;()</a>, <a class="el" href="ImplicitLocOpBuilder_8h_source.html#l00094">mlir::ImplicitLocOpBuilder::emitError()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00265">mlir::Operation::emitError()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l00167">mlir::detail::Parser::emitError()</a>, <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html#l00491">emitOptionalError()</a>, <a class="el" href="FakeQuantSupport_8cpp_source.html#l00108">mlir::quant::fakeQuantAttrsToType()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00231">mlir::detail::PassCrashReproducerGenerator::finalize()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00214">mlir::detail::OpPassManagerImpl::finalizePassList()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00827">forwardPassthroughAttributes()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00128">mlir::DynamicType::get()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00071">mlir::gpu::MMAMatrixType::getChecked()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00253">mlir::DynamicAttr::getChecked()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00138">mlir::DynamicType::getChecked()</a>, <a class="el" href="DLTI_8cpp_source.html#l00142">mlir::DataLayoutSpecAttr::getChecked()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01174">mlir::spirv::MatrixType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00375">mlir::quant::CalibratedQuantizedType::getChecked()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00808">mlir::spirv::SampledImageType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00313">mlir::quant::UniformQuantizedPerAxisType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00261">mlir::quant::UniformQuantizedType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00225">mlir::quant::AnyQuantizedType::getChecked()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01182">mlir::detail::getDefaultDiagnosticEmitFn()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01012">getElementPtrType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00749">getElementType()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00424">mlir::LLVM::LLVMStructType::getIdentifiedChecked()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01352">getInsertExtractValueElementType()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00453">mlir::LLVM::LLVMStructType::getLiteralChecked()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00323">mlir::LLVM::detail::getLLVMConstant()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00464">mlir::LLVM::LLVMStructType::getOpaqueChecked()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00649">getOrInsertBuiltinVariable()</a>, <a class="el" href="CLOptionsSetup_8cpp_source.html#l00072">mlir::tracing::InstallDebugHandler::Impl::Impl()</a>, <a class="el" href="IR_8cpp_source.html#l00319">inferOperationTypes()</a>, <a class="el" href="LLVMImportInterface_8h_source.html#l00088">mlir::LLVMImportInterface::initializeImport()</a>, <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00373">mlir::transform::detail::interpreterBaseRunOnOperationImpl()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00289">loadIRDLDialects()</a>, <a class="el" href="CAPI_2IR_2Diagnostics_8cpp_source.html#l00078">mlirEmitError()</a>, <a class="el" href="MlirReduceMain_8cpp_source.html#l00049">mlirReduceMain()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l04686">parsePtrAccessChainOpImpl()</a>, <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00056">parseTransformModuleFromFile()</a>, <a class="el" href="BytecodeReader_8cpp_source.html#l01839">readBytecodeFileImpl()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00027">registerFromLLVMIRTranslation()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00227">reshapeLikeShapesAreCompatible()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00184">mlir::MlirOptMainConfig::setPassPipelineParser()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00062">translateDataLayout()</a>, <a class="el" href="ExtensibleDialect_8h_source.html#l00086">mlir::DynamicAttrDefinition::verify()</a>, <a class="el" href="ExtensibleDialect_8h_source.html#l00242">mlir::DynamicTypeDefinition::verify()</a>, <a class="el" href="DLTI_8cpp_source.html#l00149">mlir::DataLayoutSpecAttr::verify()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00095">mlir::gpu::MMAMatrixType::verify()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00495">mlir::LLVM::LLVMStructType::verify()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00163">mlir::spirv::InterfaceVarABIAttr::verify()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00259">mlir::spirv::VerCapExtAttr::verify()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01180">mlir::spirv::MatrixType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00383">mlir::quant::CalibratedQuantizedType::verify()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00816">mlir::spirv::SampledImageType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00323">mlir::quant::UniformQuantizedPerAxisType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00270">mlir::quant::UniformQuantizedType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00032">mlir::quant::QuantizedType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00235">mlir::quant::AnyQuantizedType::verify()</a>, <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00077">mlir::detail::verifyAffineMapAsLayout()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00531">mlir::detail::verifyDataLayoutSpec()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00616">mlir::LLVM::LLVMStructType::verifyEntries()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00959">verifyRegionAttribute()</a>, and <a class="el" href="LLVMTypes_8cpp_source.html#l00653">verifyVectorConstructionInvariants()</a>.</p>

</div>
</div>
<a id="a2dc4e9418ff63ebea20c7f709ebcb0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc4e9418ff63ebea20c7f709ebcb0f8">&#9670;&nbsp;</a></span>emitError() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00329">329</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00306">emitDiag()</a>, and <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">Error</a>.</p>

</div>
</div>
<a id="a45deee4eed2b998fbde1d3573325bc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45deee4eed2b998fbde1d3573325bc6e">&#9670;&nbsp;</a></span>emitOptionalError()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::emitOptionalError </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads of the above emission functions that take an optionally null location. </p>
<p>If the location is null, no diagnostic is emitted and a failure is returned. Given that the provided location may be null, these methods take the diagnostic arguments directly instead of relying on the returned <a class="el" href="classmlir_1_1InFlightDiagnostic.html" title="This class represents a diagnostic that is inflight and set to be reported.">InFlightDiagnostic</a>. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html#l00491">491</a> of file <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html#l00334">mlir::InFlightDiagnostic::append()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">emitError()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>.</p>

</div>
</div>
<a id="a3f5cd384eee5c5c8a7125233ade78eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5cd384eee5c5c8a7125233ade78eea">&#9670;&nbsp;</a></span>emitOptionalRemark()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::emitOptionalRemark </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html#l00503">503</a> of file <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html#l00334">mlir::InFlightDiagnostic::append()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00342">emitRemark()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>.</p>

</div>
</div>
<a id="ac03c4337fa32d3045568e4dc6eef60ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03c4337fa32d3045568e4dc6eef60ca">&#9670;&nbsp;</a></span>emitOptionalWarning()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::emitOptionalWarning </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html#l00497">497</a> of file <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html#l00334">mlir::InFlightDiagnostic::append()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00334">emitWarning()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>.</p>

</div>
</div>
<a id="a8a9ca6fe9d5aab498bf090db3e878c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9ca6fe9d5aab498bf090db3e878c87">&#9670;&nbsp;</a></span>emitRemark() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitRemark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to emit a remark message using this location. </p>
<p>Emit a remark message using this location. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00342">342</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html#l00503">emitOptionalRemark()</a>, <a class="el" href="ImplicitLocOpBuilder_8h_source.html#l00102">mlir::ImplicitLocOpBuilder::emitRemark()</a>, and <a class="el" href="IR_2Operation_8cpp_source.html#l00286">mlir::Operation::emitRemark()</a>.</p>

</div>
</div>
<a id="a391c4b4ea9dc95fbcfbfdab8a49547a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391c4b4ea9dc95fbcfbfdab8a49547a3">&#9670;&nbsp;</a></span>emitRemark() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitRemark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00345">345</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00306">emitDiag()</a>, and <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a91921ada405fd6ba65dff028df047cb6">Remark</a>.</p>

</div>
</div>
<a id="a428b91d18eabd5b259a3ed6e0f27f60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428b91d18eabd5b259a3ed6e0f27f60c">&#9670;&nbsp;</a></span>emitSilenceableFailure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a> mlir::emitSilenceableFailure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emits a silenceable failure with the given message. </p>
<p>A silenceable failure must be either suppressed or converted into a definite failure and reported to the user. </p>

<p class="definition">Definition at line <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00256">256</a> of file <a class="el" href="DiagnosedSilenceableFailure_8h_source.html">DiagnosedSilenceableFailure.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgMatchOps_8cpp_source.html#l00208">containsAll()</a>, <a class="el" href="LinalgMatchOps_8cpp_source.html#l00236">expandTargetSpecification()</a>, and <a class="el" href="GPUTransformOps_8cpp_source.html#l00730">mlir::transform::gpu::mapOneForallToThreadsImpl()</a>.</p>

</div>
</div>
<a id="a078c07e9f16a6122a56bae420ce94308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078c07e9f16a6122a56bae420ce94308">&#9670;&nbsp;</a></span>emitSilenceableFailure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a> mlir::emitSilenceableFailure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00262">262</a> of file <a class="el" href="DiagnosedSilenceableFailure_8h_source.html">DiagnosedSilenceableFailure.h</a>.</p>

</div>
</div>
<a id="a0768c8a572dc71b0b00d57414b56b60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0768c8a572dc71b0b00d57414b56b60d">&#9670;&nbsp;</a></span>emitWarning() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitWarning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to emit a warning message using this location. </p>
<p>Emit a warning message using this location. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00334">334</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleImport_8cpp_source.html#l00561">mlir::LLVM::ModuleImport::convertDataLayout()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00087">convertScalarToDtype()</a>, <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html#l00497">emitOptionalWarning()</a>, <a class="el" href="ImplicitLocOpBuilder_8h_source.html#l00098">mlir::ImplicitLocOpBuilder::emitWarning()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00277">mlir::Operation::emitWarning()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01557">mlir::LLVM::ModuleImport::processFunction()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01459">processPassthroughAttrs()</a>, and <a class="el" href="LoopAnnotationImporter_8cpp_source.html#l00460">mlir::LLVM::detail::LoopAnnotationImporter::translateAccessGroup()</a>.</p>

</div>
</div>
<a id="a5e96e5ea091fb5bea539cef6ea7c5624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e96e5ea091fb5bea539cef6ea7c5624">&#9670;&nbsp;</a></span>emitWarning() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitWarning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00337">337</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00306">emitDiag()</a>, and <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a0eaadb4fcb48a0a0ed7bc9868be9fbaa">Warning</a>.</p>

</div>
</div>
<a id="ab8075944125730fed529e3b93dcfed5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8075944125730fed529e3b93dcfed5b">&#9670;&nbsp;</a></span>encodeBindAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::encodeBindAttribute </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes global variable's descriptor set and binding into its name if they both exist. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01617">1617</a> of file <a class="el" href="SPIRVToLLVM_8cpp_source.html">SPIRVToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a6ab9585c8607c12142232e0f58ebcc8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab9585c8607c12142232e0f58ebcc8b">&#9670;&nbsp;</a></span>eraseUnreachableBlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::eraseUnreachableBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase the unreachable blocks within the provided regions. </p>
<p>Returns success if any blocks were erased, failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00179">179</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00055">mlir::Region::begin()</a>, <a class="el" href="IR_2Region_8h_source.html#l00060">mlir::Region::empty()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00056">mlir::Region::end()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8cpp_source.html#l00830">simplifyRegions()</a>.</p>

</div>
</div>
<a id="a0bbb3252a45b5feab49c0bac2a68779c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbb3252a45b5feab49c0bac2a68779c">&#9670;&nbsp;</a></span>expandDimsToRank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::expandDimsToRank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>projectedDimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand <code>map</code> to operate on <code>rank</code> dims while projecting out the dims in <code>projectedDimensions</code>. </p>
<p>This amounts to composing <code>map</code> with <code>id(rank).dropResults(projectedDimensions)</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00829">829</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00482">mlir::AffineMap::compose()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00258">mlir::AffineMap::dropResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00271">mlir::AffineMap::getContext()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00262">mlir::AffineMap::getMultiDimIdentityMap()</a>.</p>

</div>
</div>
<a id="aecdaa20d0acb7aec0f05cb700b1e09df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdaa20d0acb7aec0f05cb700b1e09df">&#9670;&nbsp;</a></span>extractFixedOuterLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a3f0d45d0562d47acc2c42934ccbfea19">TileLoops</a> mlir::extractFixedOuterLoops </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>rootFOrOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00967">967</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00339">ceilDivPositive()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00862">getPerfectlyNestedLoopsImpl()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00927">tile()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00840">tryIsolateBands()</a>.</p>

</div>
</div>
<a id="a48355da3ce92decf18a91c2148e3d4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48355da3ce92decf18a91c2148e3d4c6">&#9670;&nbsp;</a></span>extractFromI64ArrayAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; mlir::extractFromI64ArrayAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract int64_t values from the assumed ArrayAttr of IntegerAttr. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00072">72</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Attributes_8h_source.html#l00176">mlir::Attribute::cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgTransformOps_8cpp_source.html#l00268">parseTileLikeOp()</a>.</p>

</div>
</div>
<a id="a3083728e72d361c987c5e5a0e8d2f39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3083728e72d361c987c5e5a0e8d2f39a">&#9670;&nbsp;</a></span>failableParallelForEach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename FuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::failableParallelForEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements between [begin, end) asynchronously. </p>
<p>If the given function returns a failure when processing any of the elements, execution is stopped and a failure is returned from this function. This means that in the case of failure, not all elements of the range will be processed. Diagnostics emitted during processing are ordered relative to the element's position within [begin, end). If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00036">36</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l01035">mlir::ParallelDiagnosticHandler::eraseOrderIDForThread()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00621">mlir::MLIRContext::getThreadPool()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00563">mlir::MLIRContext::isMultithreadingEnabled()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00192">min()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l01029">mlir::ParallelDiagnosticHandler::setOrderIDForThread()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Threading_8h_source.html#l00090">failableParallelForEach()</a>, <a class="el" href="Threading_8h_source.html#l00105">failableParallelForEachN()</a>, and <a class="el" href="Threading_8h_source.html#l00117">parallelForEach()</a>.</p>

</div>
</div>
<a id="a98aa0f01173a481075d9d5a2ca50d8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98aa0f01173a481075d9d5a2ca50d8ab">&#9670;&nbsp;</a></span>failableParallelForEach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT , typename FuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::failableParallelForEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeT &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements in the provided range asynchronously. </p>
<p>If the given function returns a failure when processing any of the elements, execution is stopped and a failure is returned from this function. This means that in the case of failure, not all elements of the range will be processed. Diagnostics emitted during processing are ordered relative to the element's position within the range. If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00090">90</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="Threading_8h_source.html#l00036">failableParallelForEach()</a>.</p>

</div>
</div>
<a id="af5aa5179ec6f13db4eaa8fa255bde665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5aa5179ec6f13db4eaa8fa255bde665">&#9670;&nbsp;</a></span>failableParallelForEachN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::failableParallelForEachN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements between [begin, end) asynchronously. </p>
<p>If the given function returns a failure when processing any of the elements, execution is stopped and a failure is returned from this function. This means that in the case of failure, not all elements of the range will be processed. Diagnostics emitted during processing are ordered relative to the element's position within [begin, end). If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00105">105</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="Threading_8h_source.html#l00036">failableParallelForEach()</a>.</p>

</div>
</div>
<a id="aeec13ab4fb753865cdfd2699aa01c23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec13ab4fb753865cdfd2699aa01c23b">&#9670;&nbsp;</a></span>failed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::failed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that returns true if the provided <a class="el" href="structmlir_1_1LogicalResult.html" title="This class represents an efficient way to signal success or failure.">LogicalResult</a> corresponds to a failure value. </p>

<p class="definition">Definition at line <a class="el" href="LogicalResult_8h_source.html#l00072">72</a> of file <a class="el" href="LogicalResult_8h_source.html">LogicalResult.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00044">mlir::LogicalResult::failed()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00069">mlir::affine::FlatAffineValueConstraints::addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00120">mlir::affine::FlatAffineValueConstraints::addAffineParallelOpDomain()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00062">mlir::ValueBoundsConstraintSet::addBound()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00652">mlir::FlatLinearConstraints::addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00149">mlir::affine::FlatAffineValueConstraints::addDomainFromSliceMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00038">mlir::affine::FlatAffineValueConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Simplex_8cpp_source.html#l01091">mlir::presburger::Simplex::addInequality()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01241">addMissingLoopIVBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00239">mlir::affine::FlatAffineValueConstraints::addSliceBounds()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00932">mlir::PassPipelineCLParser::addToPipeline()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02306">mlir::affine::affineDataCopyGenerate()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01063">mlir::affine::affineScalarReplace()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00118">mlir::bufferization::allocateTensorForShapedValue()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00358">mlir::bufferization::analyzeModuleOp()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00658">analyzeProfitability()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01797">appendMangledType()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00484">mlir::PassReproducerOptions::apply()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00495">applyPatternsAndFoldGreedily()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00211">applyTilingToAll()</a>, <a class="el" href="lsp-server-support_2Protocol_8cpp_source.html#l00518">mlir::lsp::TextDocumentContentChangeEvent::applyTo()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l00690">mlir::transform::TransformState::applyTransform()</a>, <a class="el" href="TransformInterfaces_8h_source.html#l01074">mlir::transform::detail::applyTransformToEach()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00409">mlir::bufferization::bufferizeModuleOp()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00052">mlir::bufferization::BufferizeTypeConverter::BufferizeTypeConverter()</a>, <a class="el" href="PatternMatch_8h_source.html#l01387">mlir::detail::pdl_function_builder::buildConstraintFn()</a>, <a class="el" href="Tensor_2Transforms_2IndependenceTransforms_8cpp_source.html#l00036">mlir::tensor::buildIndependentOp()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00673">buildPackingLoopNestImpl()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00414">mlir::LLVMTypeConverter::canConvertToBarePtr()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00028">mlir::bufferization::castOrReallocMemRefValue()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00368">checkIfHyperRectangular()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00598">mlir::affine::checkMemrefAccessDependence()</a>, <a class="el" href="MLIRGen_8cpp_source.html#l00620">mlir::pdll::codegenPDLLToMLIR()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01418">mlir::linalg::collapseGenericOpIterationDims()</a>, <a class="el" href="DLTI_8cpp_source.html#l00249">mlir::DataLayoutSpecAttr::combineWith()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00158">mlir::FlatLinearConstraints::composeMatchingMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02306">computeCollapsedLayoutMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02190">computeExpandedLayoutMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00965">computeMemRefRankReductionMask()</a>, <a class="el" href="Analysis_2Presburger_2Utils_8cpp_source.html#l00223">mlir::presburger::computeSingleVarRepr()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01289">mlir::affine::computeSliceUnion()</a>, <a class="el" href="Simplex_8cpp_source.html#l00518">mlir::presburger::SymbolicLexSimplex::computeSymbolicIntegerLexMin()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01374">mlir::presburger::IntegerRelation::constantFoldVarRange()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00287">convertAffineLoopNestToGPULaunch()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03005">mlir::TypeConverter::convertBlockSignature()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01285">mlir::detail::ConversionPatternRewriterImpl::convertBlockSignature()</a>, <a class="el" href="MLIRServer_8cpp_source.html#l01286">mlir::lsp::MLIRServer::convertFromBytecode()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03065">convertFuncOpTypes()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00576">mlir::LLVM::ModuleImport::convertFunctions()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00223">mlir::LLVMTypeConverter::convertFunctionSignature()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00543">mlir::LLVM::ModuleImport::convertGlobals()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00514">mlir::LLVM::ModuleImport::convertMetadata()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01325">mlir::detail::ConversionPatternRewriterImpl::convertNonEntryRegionTypes()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01186">convertOmpAtomicCapture()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01117">convertOmpAtomicUpdate()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00127">convertOmpOpRegions()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01280">convertOmpReductionOp()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00952">convertOmpSimdLoop()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00758">convertOmpWsLoop()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01310">mlir::detail::ConversionPatternRewriterImpl::convertRegionTypes()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02972">mlir::TypeConverter::convertSignatureArg()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02987">mlir::TypeConverter::convertSignatureArgs()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02939">mlir::TypeConverter::convertType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02949">mlir::TypeConverter::convertTypes()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01098">mlir::LLVM::ModuleImport::convertValues()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00228">mlir::ConvertToLLVMPattern::copyUnrankedDescriptors()</a>, <a class="el" href="PassOptions_8h_source.html#l00333">mlir::PassPipelineOptions&lt; T &gt;::createFromString()</a>, <a class="el" href="LoopAnnotationImporter_8cpp_source.html#l00270">createIfNonNull()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01879">mlir::affine::delinearizeIndex()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00063">mlir::spirv::Deserializer::deserialize()</a>, <a class="el" href="Deserialization_8cpp_source.html#l00015">mlir::spirv::deserialize()</a>, <a class="el" href="Simplex_8cpp_source.html#l01408">mlir::presburger::Simplex::detectRedundant()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00077">doubleBuffer()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00128">encodeKernelName()</a>, <a class="el" href="Threading_8h_source.html#l00036">failableParallelForEach()</a>, <a class="el" href="LogicalResult_8h_source.html#l00082">mlir::FailureOr&lt; T &gt;::FailureOr()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00214">mlir::detail::OpPassManagerImpl::finalizePassList()</a>, <a class="el" href="Simplex_8cpp_source.html#l00288">mlir::presburger::LexSimplex::findIntegerLexMin()</a>, <a class="el" href="ReductionTreePass_8cpp_source.html#l00086">findOptimal()</a>, <a class="el" href="Simplex_8cpp_source.html#l00217">mlir::presburger::LexSimplex::findRationalLexMin()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00800">mlir::FlatLinearValueConstraints::FlatLinearValueConstraints()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00628">mlir::FlatLinearConstraints::flattenAlignedMapAndMergeLocals()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02276">foldLoopBounds()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00088">mlir::bufferization::foldToMemrefToTensorPair()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00827">forwardPassthroughAttributes()</a>, <a class="el" href="FrozenRewritePatternSet_8cpp_source.html#l00059">mlir::FrozenRewritePatternSet::FrozenRewritePatternSet()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00734">fuseWithReshapeByExpansion()</a>, <a class="el" href="Generalization_8cpp_source.html#l00051">mlir::linalg::generalizeNamedOp()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02503">mlir::affine::generateCopyForMemRegion()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00458">mlir::affine::MemRefAccess::getAccessRelation()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00552">mlir::affine::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00742">mlir::FlatLinearConstraints::getAsIntegerSet()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00668">mlir::bufferization::getBuffer()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00156">getCastCompatibleMemRefType()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00253">mlir::DynamicAttr::getChecked()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00138">mlir::DynamicType::getChecked()</a>, <a class="el" href="StorageUniquerSupport_8h_source.html#l00191">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::getChecked()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00203">getConstantOffset()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00216">getConstantStrides()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00112">mlir::ConvertToLLVMPattern::getElementPtrType()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01055">mlir::spirv::StructType::getEmpty()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00850">mlir::FlatLinearValueConstraints::getHyperrectangular()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00312">mlir::affine::FlatAffineValueConstraints::getIneqAsAffineValueMap()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00173">mlir::nvgpu::getLaneIdAndValueIdToOperandCoord()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01781">getMemoryFootprintBytes()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00125">getMemrefConstantHorizontalStride()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00430">mlir::LLVM::LLVMStructType::getNewIdentified()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00842">mlir::spirv::getOpenCLElementPtr()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00064">mlir::tensor::getOrCreateDestination()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00493">mlir::affine::getRelationFromMap()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01516">mlir::ConversionPatternRewriter::getRemappedValue()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00537">mlir::affine::ComputationSliceState::getSourceAsConstraints()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00727">getStridesAndOffset()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00785">getStridesAndOffset()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00140">getTypeNumBytes()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00811">mlir::spirv::getVulkanElementPtr()</a>, <a class="el" href="PassOptions_8h_source.html#l00230">mlir::detail::PassOptions::ListOption&lt; DataType, OptionParser &gt;::handleOccurrence()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00026">hasFullyDynamicLayoutMap()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00937">mlir::linalg::hoistPaddingOnTensors()</a>, <a class="el" href="SubsetHoisting_8cpp_source.html#l00462">mlir::linalg::hoistRedundantSubsetExtractInsert()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00219">mlir::detail::inferReturnTensorTypes()</a>, <a class="el" href="DataFlowFramework_8cpp_source.html#l00065">mlir::DataFlowSolver::initializeAndRun()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00270">VectorizationState::initState()</a>, <a class="el" href="Inliner_8cpp_source.html#l00464">inlineCallsInSCC()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00423">inlineConvertOmpRegions()</a>, <a class="el" href="Interchange_8cpp_source.html#l00050">mlir::linalg::interchangeGenericOp()</a>, <a class="el" href="TranslateToCpp_8cpp_source.html#l00040">interleaveWithError()</a>, <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00455">mlir::transform::detail::interpreterBaseInitializeImpl()</a>, <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00373">mlir::transform::detail::interpreterBaseRunOnOperationImpl()</a>, <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00080">mlir::DiagnosedSilenceableFailure::isDefiniteFailure()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00760">mlir::OperationEquivalence::isEquivalentTo()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00568">isFusionProfitable()</a>, <a class="el" href="Tester_8cpp_source.html#l00027">mlir::Tester::isInteresting()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l01497">isLastMemrefDimUnitStride()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00760">mlir::affine::ComputationSliceState::isMaximal()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00099">isMemRefTypeSupported()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00690">mlir::affine::ComputationSliceState::isSliceValid()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00353">JitRunnerMain()</a>, <a class="el" href="OpImplementation_8h_source.html#l00724">mlir::AsmParser::KeywordSwitch&lt; ResultT &gt;::KeywordSwitch()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00024">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00330">mlir::SymbolTable::lookupSymbolIn()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00875">mlir::SymbolTableCollection::lookupSymbolIn()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00934">mlir::LockedSymbolTableCollection::lookupSymbolIn()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01015">mlir::affine::loopUnrollByFactor()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00460">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01133">mlir::affine::loopUnrollJamByFactor()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00225">lowerAsEntryFunction()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00118">lowerEntryPointABIAttr()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00509">makeAtomicReductionGen()</a>, <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00021">makeIndependent()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00479">makeReductionGen()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00020">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03613">CanonicalizeAffineMinMaxOpExprAndTermOrder&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="Transforms_8cpp_source.html#l01179">mlir::linalg::ExtractSliceOfPadTensorSwapPattern::matchAndRewrite()</a>, <a class="el" href="CAPI_2Interfaces_2Interfaces_8cpp_source.html#l00041">mlirInferTypeOpInterfaceInferReturnTypes()</a>, <a class="el" href="IR_8cpp_source.html#l00351">mlirOperationCreate()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00398">MlirOptMain()</a>, <a class="el" href="MlirReduceMain_8cpp_source.html#l00049">mlirReduceMain()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00987">NAryInferReturnTypes()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01714">mlir::affine::normalizeMemRef()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01772">mlir::affine::normalizeMemRefType()</a>, <a class="el" href="LogicalResult_8h_source.html#l00126">mlir::ParseResult::operator bool()</a>, <a class="el" href="OptimizeSharedMemory_8cpp_source.html#l00181">mlir::nvgpu::optimizeSharedMemoryReadsAndWrites()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00291">outlineIfOp()</a>, <a class="el" href="Transforms_8cpp_source.html#l00736">mlir::linalg::pack()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l01087">packMatmulGreedily()</a>, <a class="el" href="Transforms_8cpp_source.html#l00285">mlir::linalg::padAndHoistLinalgOp()</a>, <a class="el" href="Transforms_8cpp_source.html#l00056">padOperandToSmallestStaticBoundingBox()</a>, <a class="el" href="DLTI_8cpp_source.html#l00068">mlir::DataLayoutEntryAttr::parse()</a>, <a class="el" href="DLTI_8cpp_source.html#l00295">mlir::DataLayoutSpecAttr::parse()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00156">mlir::FieldParser&lt; ContainerT, std::enable_if_t&lt; llvm::is_detected&lt; detail::has_push_back_t, ContainerT &gt;::value, ContainerT &gt; &gt;::parse()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00174">mlir::FieldParser&lt; AffineMap &gt;::parse()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00269">mlir::DynamicAttr::parse()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00156">mlir::DynamicType::parse()</a>, <a class="el" href="PassOptions_8h_source.html#l00364">llvm::cl::detail::VectorParserBase&lt; VectorT, ElementT &gt;::parse()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00248">parseAlignedClause()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00285">parseArrayType()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00559">mlir::DynamicDialect::parseAttribute()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00051">mlir::detail::Parser::parseAttribute()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00344">parseAttributions()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02031">parseBound()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00151">mlir::detail::pass_options::parseCommaSeparatedList()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00103">parseCreateOperationOpResults()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00405">mlir::detail::Parser::parseDecOrHexAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l01004">mlir::detail::Parser::parseDenseResourceElementsAttr()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00491">parseDependVarList()</a>, <a class="el" href="BytecodeReader_8cpp_source.html#l00469">parseDialectGrouping()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00054">mlir::detail::Parser::parseDialectSymbolBody()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00524">mlir::detail::Parser::parseDimensionListRanked()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00961">parseDstStyleOp()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00123">parseDynamicIndexList()</a>, <a class="el" href="BytecodeReader_8cpp_source.html#l00330">parseEntry()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00094">parseExpressedTypeAndRange()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00273">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseFloat()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00164">mlir::function_interface_impl::parseFunctionOp()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00083">parseFunctionResultList()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00343">parseGangClause()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00569">parseGEPIndices()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00381">parseInterfaceVarABIAttr()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00357">parseKeywordList()</a>, <a class="el" href="OpImplementation_8h_source.html#l00812">mlir::AsmParser::parseKeywordOrString()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00882">parseMultitileSizesTypes()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00255">parseOptionalArrayStride()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00448">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalAttrDictWithKeyword()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01104">parseOptionalCallFuncPtr()</a>, <a class="el" href="OpImplementation_8h_source.html#l00653">mlir::AsmParser::parseOptionalInteger()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02349">parseOptionalInterchange()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00695">parsePassPipeline()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00082">parsePointer()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00162">parseQuantParams()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00409">parseReductionVarList()</a>, <a class="el" href="OpImplementation_8h_source.html#l01082">mlir::AsmParser::parseResourceHandle()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l00326">mlir::detail::Parser::parseResourceHandle()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00422">parseRuntimeArrayType()</a>, <a class="el" href="TransformOps_8cpp_source.html#l01619">parseSequenceOpOperands()</a>, <a class="el" href="IRDL_8cpp_source.html#l00050">parseSingleBlockRegion()</a>, <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00155">mlir::detail::parseSourceFile()</a>, <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00245">parseSourceString()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00063">parseStorageRange()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l01140">mlir::detail::Parser::parseStridedLayoutAttr()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00601">parseStructMemberDecorations()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00668">parseStructType()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00493">parseSwitchOpCases()</a>, <a class="el" href="OpImplementation_8h_source.html#l01044">mlir::AsmParser::parseSymbolName()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00554">parseSynchronizationHint()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00356">mlir::detail::Parser::parseTensorType()</a>, <a class="el" href="MLProgramOps_8cpp_source.html#l00029">parseTokenOrdering()</a>, <a class="el" href="OpImplementation_8h_source.html#l01405">mlir::OpAsmParser::parseTrailingOperandList()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00532">mlir::DynamicDialect::parseType()</a>, <a class="el" href="MLProgramOps_8cpp_source.html#l00084">parseTypedInitialValue()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00813">mlir::detail::DenseArrayAttrImpl&lt; T &gt;::parseWithoutBraces()</a>, <a class="el" href="PassRegistry_8h_source.html#l00168">mlir::PassPipelineRegistration&lt; Options &gt;::PassPipelineRegistration()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03302">pdllConvertValues()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l01296">prepareLLVMModule()</a>, <a class="el" href="TranslateToCpp_8cpp_source.html#l00185">printConstantOp()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01977">mlir::AsmPrinter::Impl::printLocation()</a>, <a class="el" href="TranslateToCpp_8cpp_source.html#l00315">printOperation()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00318">processBuffer()</a>, <a class="el" href="PatternMatch_8h_source.html#l01315">mlir::detail::pdl_function_builder::processResults()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00184">mlir::bufferization::promoteBufferResultsToOutParams()</a>, <a class="el" href="Promotion_8cpp_source.html#l00213">mlir::linalg::promoteSubviewAsNewBuffer()</a>, <a class="el" href="Promotion_8cpp_source.html#l00265">promoteSubViews()</a>, <a class="el" href="Promotion_8cpp_source.html#l00395">mlir::linalg::promoteSubViews()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00082">mlir::DialectBytecodeReader::readAttribute()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00047">mlir::DialectBytecodeReader::readList()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00111">mlir::DialectBytecodeReader::readResourceHandle()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00353">readResourceHandle()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00099">mlir::DialectBytecodeReader::readType()</a>, <a class="el" href="ReductionNode_8cpp_source.html#l00026">mlir::ReductionNode::ReductionNode()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03309">registerConversionPDLFunctions()</a>, <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00020">reifyValueBound()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01210">mlir::detail::ConversionPatternRewriterImpl::remapValues()</a>, <a class="el" href="SwapExtractSliceWithProducerPatterns_8cpp_source.html#l00023">mlir::tensor::replaceExtractSliceWithTiledProducer()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l00971">mlir::transform::TransformState::Extension::replacePayloadValue()</a>, <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00172">mlir::memref::replaceWithIndependentOp()</a>, <a class="el" href="TosaMakeBroadcastable_8cpp_source.html#l00081">reshapeLowerToHigher()</a>, <a class="el" href="AsmParserState_8cpp_source.html#l00070">mlir::AsmParserState::Impl::resolveSymbolUses()</a>, <a class="el" href="ByteCode_8cpp_source.html#l02290">mlir::detail::PDLByteCode::rewrite()</a>, <a class="el" href="Transforms_8cpp_source.html#l00184">mlir::linalg::rewriteAsPaddedOp()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00284">mlir::linalg::rewriteInDestinationPassingStyle()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00102">roundTripModule()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00446">mlir::bufferization::runOneShotModuleBufferize()</a>, <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00104">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>, <a class="el" href="Inliner_8cpp_source.html#l00293">runTransformOnCGSCCs()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02720">mlir::affine::separateFullTiles()</a>, <a class="el" href="Serializer_8cpp_source.html#l00089">mlir::spirv::Serializer::serialize()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00073">serializeModule()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00184">mlir::MlirOptMainConfig::setPassPipelineParser()</a>, <a class="el" href="ToolUtilities_8cpp_source.html#l00022">splitAndProcessBuffer()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00360">tileAndFuseFirstExtractUse()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00430">tileAndFuseFirstExtractUseThroughContainingOpBlockArgument()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00514">mlir::scf::tileAndFuseProducerOfSlice()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00645">mlir::scf::tileConsumerAndFuseProducerGreedilyUsingSCFForOp()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00778">mlir::affine::tilePerfectlyNested()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00821">mlir::affine::tilePerfectlyNestedParametric()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00275">mlir::linalg::TileLoopNest::tileRootOp()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02507">mlir::transform::tileToForallOpImpl()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01376">mlir::transform::detail::transformWithPatternsApply()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00062">translateDataLayout()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01670">translateLLVMIRToModule()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00398">mlir::DenseElementsAttr::try_value_begin()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00407">mlir::DenseElementsAttr::try_value_end()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00051">mlir::linalg::unrollIndex()</a>, <a class="el" href="PDLLServer_8cpp_source.html#l01722">mlir::lsp::PDLLServer::updateDocument()</a>, <a class="el" href="TableGenServer_8cpp_source.html#l00686">mlir::lsp::TableGenServer::updateDocument()</a>, <a class="el" href="AttrTypeSubElements_8cpp_source.html#l00140">updateSubElementImpl()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01475">mlir::linalg::vectorize()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01856">mlir::affine::vectorizeAffineLoopNest()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01315">mlir::linalg::vectorizeLinalgOpPrecondition()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01664">vectorizeLoops()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00323">mlir::quant::UniformQuantizedPerAxisType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00270">mlir::quant::UniformQuantizedType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00235">mlir::quant::AnyQuantizedType::verify()</a>, <a class="el" href="PatternMatch_8h_source.html#l01063">mlir::detail::pdl_function_builder::ProcessPDLValueBasedOn&lt; T, BaseT &gt;::verifyAsArg()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00096">verifyCompatibleShapes()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00531">mlir::detail::verifyDataLayoutSpec()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00958">verifyGroupNonUniformArithmeticOp()</a>, <a class="el" href="BufferDeallocation_8cpp_source.html#l00074">walkReturnOperations()</a>, and <a class="el" href="Arith_2Transforms_2EmulateWideInt_8cpp_source.html#l01094">mlir::arith::WideIntEmulationConverter::WideIntEmulationConverter()</a>.</p>

</div>
</div>
<a id="a07367c8c4a3d4a47a32bc2b9b7d8a3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">&#9670;&nbsp;</a></span>failure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::failure </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isFailure</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to generate a <a class="el" href="structmlir_1_1LogicalResult.html" title="This class represents an efficient way to signal success or failure.">LogicalResult</a>. </p>
<p>If isFailure is true a <code>failure</code> result is generated, otherwise a 'success' result is generated. </p>

<p class="definition">Definition at line <a class="el" href="LogicalResult_8h_source.html#l00062">62</a> of file <a class="el" href="LogicalResult_8h_source.html">LogicalResult.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00036">mlir::LogicalResult::failure()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00069">mlir::affine::FlatAffineValueConstraints::addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00120">mlir::affine::FlatAffineValueConstraints::addAffineParallelOpDomain()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00652">mlir::FlatLinearConstraints::addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00149">mlir::affine::FlatAffineValueConstraints::addDomainFromSliceMaps()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00079">mlir::scf::addLoopRangeConstraints()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01241">addMissingLoopIVBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00239">mlir::affine::FlatAffineValueConstraints::addSliceBounds()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00932">mlir::PassPipelineCLParser::addToPipeline()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02306">mlir::affine::affineDataCopyGenerate()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00346">mlir::affine::affineParallelize()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00118">mlir::bufferization::allocateTensorForShapedValue()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00358">mlir::bufferization::analyzeModuleOp()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00658">analyzeProfitability()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01797">appendMangledType()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00484">mlir::PassReproducerOptions::apply()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00133">applyPassManagerCLOptions()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00211">applyTilingToAll()</a>, <a class="el" href="lsp-server-support_2Protocol_8cpp_source.html#l00497">mlir::lsp::TextDocumentContentChangeEvent::applyTo()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00629">barePtrFuncArgTypeConverter()</a>, <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00453">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00409">mlir::bufferization::bufferizeModuleOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l01387">mlir::detail::pdl_function_builder::buildConstraintFn()</a>, <a class="el" href="Tensor_2Transforms_2IndependenceTransforms_8cpp_source.html#l00036">mlir::tensor::buildIndependentOp()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00718">mlir::linalg::detail::buildPackingLoopNest()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00673">buildPackingLoopNestImpl()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00392">canCollapseShapeBeSimplifiedByRankReducingSlice()</a>, <a class="el" href="AffineOps_8cpp_source.html#l04037">mlir::affine::AffineValueMap::canonicalize()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02322">canonicalizeLoopBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03558">canonicalizeMapExprAndTermOrder()</a>, <a class="el" href="VectorDropLeadUnitDim_8cpp_source.html#l00285">mlir::vector::castAwayContractionLeadingOneDim()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00028">mlir::bufferization::castOrReallocMemRefValue()</a>, <a class="el" href="DiagnosedSilenceableFailure_8cpp_source.html#l00019">mlir::DiagnosedSilenceableFailure::checkAndReport()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01110">mlir::transform::detail::checkApplyToOne()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00070">checkCapabilityRequirements()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00042">checkExtensionRequirements()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00368">checkIfHyperRectangular()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01648">mlir::affine::coalesceLoops()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00653">coalesceLoops()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l00368">mlir::detail::Parser::codeCompleteDialectName()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l00383">mlir::detail::Parser::codeCompleteDialectOrElidedOpName()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l00419">mlir::detail::Parser::codeCompleteExpectedTokens()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l00373">mlir::detail::Parser::codeCompleteOperationName()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l00423">mlir::detail::Parser::codeCompleteOptionalTokens()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l00406">mlir::detail::Parser::codeCompleteStringDialectOrOperationName()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00096">collapseBranch()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01418">mlir::linalg::collapseGenericOpIterationDims()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00040">collectValidReferencesFor()</a>, <a class="el" href="DLTI_8cpp_source.html#l00195">combineOneSpec()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00158">mlir::FlatLinearConstraints::composeMatchingMap()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00220">mlir::ValueBoundsConstraintSet::computeBound()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02306">computeCollapsedLayoutMap()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00405">mlir::ValueBoundsConstraintSet::computeConstantBound()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02190">computeExpandedLayoutMap()</a>, <a class="el" href="TosaMakeBroadcastable_8cpp_source.html#l00049">computeReshapeOutput()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00087">mlir::tensor::computeTransposedType()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00365">mlir::AffineMap::constantFold()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01361">mlir::presburger::IntegerRelation::constantFoldVar()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00287">convertAffineLoopNestToGPULaunch()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01285">mlir::detail::ConversionPatternRewriterImpl::convertBlockSignature()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03065">convertFuncOpTypes()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00576">mlir::LLVM::ModuleImport::convertFunctions()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00121">convertInstructionImpl()</a>, <a class="el" href="LLVMImportInterface_8h_source.html#l00050">mlir::LLVMImportDialectInterface::convertIntrinsic()</a>, <a class="el" href="LLVMImportInterface_8h_source.html#l00116">mlir::LLVMImportInterface::convertIntrinsic()</a>, <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html#l00055">convertIntrinsicImpl()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00514">mlir::LLVM::ModuleImport::convertMetadata()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01076">mlir::LLVM::ModuleImport::convertMetadataValue()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01325">mlir::detail::ConversionPatternRewriterImpl::convertNonEntryRegionTypes()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00127">convertOmpOpRegions()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00568">convertOmpOrderedRegion()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01280">convertOmpReductionOp()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00952">convertOmpSimdLoop()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01626">convertOmpTarget()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00758">convertOmpWsLoop()</a>, <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00140">convertOperationImpl()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01310">mlir::detail::ConversionPatternRewriterImpl::convertRegionTypes()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02972">mlir::TypeConverter::convertSignatureArg()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02987">mlir::TypeConverter::convertSignatureArgs()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02901">mlir::TypeConverter::convertType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02949">mlir::TypeConverter::convertTypes()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01098">mlir::LLVM::ModuleImport::convertValues()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00228">mlir::ConvertToLLVMPattern::copyUnrankedDescriptors()</a>, <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00087">mlir::tensor::ExtractSliceFromCollapseHelper::create()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00057">mlir::tensor::createDimValue()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02665">createFullTiles()</a>, <a class="el" href="OpImplementation_8h_source.html#l01617">mlir::OpAsmDialectInterface::declareResource()</a>, <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00054">mlir::DiagnosedSilenceableFailure::definiteFailure()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01879">mlir::affine::delinearizeIndex()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00063">mlir::spirv::Deserializer::deserialize()</a>, <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html#l00041">dropRefIfNoUses()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00593">mlir::detail::ExpectedDiag::emitError()</a>, <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html#l00491">emitOptionalError()</a>, <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html#l00503">emitOptionalRemark()</a>, <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html#l00497">emitOptionalWarning()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00128">encodeKernelName()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00670">extractStrides()</a>, <a class="el" href="Threading_8h_source.html#l00036">failableParallelForEach()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00214">mlir::detail::OpPassManagerImpl::finalizePassList()</a>, <a class="el" href="SubsetHoisting_8cpp_source.html#l00065">findHoistableMatchingExtractSlice()</a>, <a class="el" href="SubsetHoisting_8cpp_source.html#l00119">findHoistableMatchingTransferRead()</a>, <a class="el" href="ReductionTreePass_8cpp_source.html#l00151">findOptimal()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00628">mlir::FlatLinearConstraints::flattenAlignedMapAndMergeLocals()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00592">mlir::Operation::fold()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01210">foldExtractOpFromExtractChain()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00778">mlir::OperationName::UnregisteredOpModel::foldHook()</a>, <a class="el" href="TensorOps_8cpp_source.html#l02226">foldInsertAfterInsertSlice()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02276">foldLoopBounds()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00088">mlir::bufferization::foldToMemrefToTensorPair()</a>, <a class="el" href="OpDefinition_8h_source.html#l01576">mlir::op_definition_impl::foldTrait()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00827">forwardPassthroughAttributes()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00862">forwardStoreToLoad()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00327">mlir::linalg::TileLoopNest::fuseProducer()</a>, <a class="el" href="Fusion_8cpp_source.html#l00237">mlir::linalg::fuseProducerOfTensor()</a>, <a class="el" href="Generalization_8cpp_source.html#l00038">generalizeNamedOpPrecondition()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00980">generateCleanupLoopForUnroll()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01971">generateCopy()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02503">mlir::affine::generateCopyForMemRegion()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00733">mlir::OpState::genericParseProperties()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00458">mlir::affine::MemRefAccess::getAccessRelation()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00552">mlir::affine::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00668">mlir::bufferization::getBuffer()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00286">getDefaultABIAttrs()</a>, <a class="el" href="Analysis_2Presburger_2Utils_8cpp_source.html#l00096">getDivRepr()</a>, <a class="el" href="TargetAndABI_8cpp_source.html#l00225">mlir::spirv::getExecutionModel()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00072">getFlattenedAffineExprs()</a>, <a class="el" href="BufferUtils_8cpp_source.html#l00150">mlir::bufferization::getGlobalFor()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01866">getIndexProduct()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00082">getInterfaceVariables()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00094">getIntOrSplatIntValue()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00173">mlir::nvgpu::getLaneIdAndValueIdToOperandCoord()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00238">mlir::nvgpu::getLaneIdToLdMatrixMatrixCoord()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00209">mlir::nvgpu::getLdMatrixParams()</a>, <a class="el" href="TargetAndABI_8cpp_source.html#l00236">mlir::spirv::getMemoryModel()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00399">mlir::LLVMTypeConverter::getMemRefAddressSpace()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00084">getMemRefAlignment()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00100">mlir::nvgpu::getMmaSyncRegisterType()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01318">getMultiAffineFunctionFromMap()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00064">mlir::tensor::getOrCreateDestination()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00493">mlir::affine::getRelationFromMap()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00048">mlir::shape::getShapeVec()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00537">mlir::affine::ComputationSliceState::getSourceAsConstraints()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00727">getStridesAndOffset()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00785">getStridesAndOffset()</a>, <a class="el" href="IntRangeOptimizations_8cpp_source.html#l00034">handleEq()</a>, <a class="el" href="IntRangeOptimizations_8cpp_source.html#l00041">handleNe()</a>, <a class="el" href="IntRangeOptimizations_8cpp_source.html#l00058">handleSle()</a>, <a class="el" href="IntRangeOptimizations_8cpp_source.html#l00048">handleSlt()</a>, <a class="el" href="IntRangeOptimizations_8cpp_source.html#l00086">handleUle()</a>, <a class="el" href="IntRangeOptimizations_8cpp_source.html#l00076">handleUlt()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00405">mlir::affine::hoistAffineIfOp()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00937">mlir::linalg::hoistPaddingOnTensors()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00220">incSlicePosition()</a>, <a class="el" href="IR_8cpp_source.html#l00319">inferOperationTypes()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00219">mlir::detail::inferReturnTensorTypes()</a>, <a class="el" href="DataFlowFramework_8cpp_source.html#l00065">mlir::DataFlowSolver::initializeAndRun()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00270">VectorizationState::initState()</a>, <a class="el" href="CodegenEnv_8cpp_source.html#l00062">mlir::sparse_tensor::CodegenEnv::initTensorExp()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00429">inlineCall()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00423">inlineConvertOmpRegions()</a>, <a class="el" href="Interchange_8cpp_source.html#l00036">interchangeGenericOpPrecondition()</a>, <a class="el" href="TranslateToCpp_8cpp_source.html#l00040">interleaveWithError()</a>, <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00455">mlir::transform::detail::interpreterBaseInitializeImpl()</a>, <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00373">mlir::transform::detail::interpreterBaseRunOnOperationImpl()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00099">isMemRefTypeSupported()</a>, <a class="el" href="OpImplementation_8h_source.html#l00724">mlir::AsmParser::KeywordSwitch&lt; ResultT &gt;::KeywordSwitch()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00024">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00289">loadIRDLDialects()</a>, <a class="el" href="LoopAnnotationImporter_8cpp_source.html#l00495">mlir::LLVM::detail::LoopAnnotationImporter::lookupAccessGroupAttrs()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00501">mlir::LLVM::ModuleImport::lookupAliasScopeAttrs()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00340">lookupSymbolInImpl()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01015">mlir::affine::loopUnrollByFactor()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00460">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00892">mlir::affine::loopUnrollFull()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01133">mlir::affine::loopUnrollJamByFactor()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00118">lowerEntryPointABIAttr()</a>, <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00021">makeIndependent()</a>, <a class="el" href="NamedOpConversions_8cpp_source.html#l00036">matchAndReplaceDepthwiseConv()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01044">CanonicalizeContractAdd&lt; AddOpType &gt;::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00232">mlir::ComposeCollapseOfExpandOp&lt; CollapseOpTy, ExpandOpTy, CastOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00298">mlir::ComposeExpandOfCollapseOp&lt; ExpandOpTy, CollapseOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00020">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00154">InsertSliceOfInsertSliceFolder&lt; OpTy &gt;::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00175">mlir::ComposeReassociativeReshapeOps&lt; ReshapeOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03431">DeduplicateAffineMinMaxExpressions&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03474">MergeAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03613">CanonicalizeAffineMinMaxOpExprAndTermOrder&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03627">CanonicalizeSingleResultAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="SwapExtractSliceWithFillPatterns_8cpp_source.html#l00022">SwapExtractSliceOfFill::matchAndRewrite()</a>, <a class="el" href="Transforms_8cpp_source.html#l01179">mlir::linalg::ExtractSliceOfPadTensorSwapPattern::matchAndRewrite()</a>, <a class="el" href="Transforms_8cpp_source.html#l01038">mlir::linalg::PadOpTransformationPattern::matchAndRewrite()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00033">mlir::scf::matchForLikeLoop()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00752">mergeIdenticalBlocks()</a>, <a class="el" href="CAPI_2ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00075">mlirExecutionEngineInvokePacked()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00398">MlirOptMain()</a>, <a class="el" href="MlirReduceMain_8cpp_source.html#l00049">mlirReduceMain()</a>, <a class="el" href="Simplex_8cpp_source.html#l00758">mlir::presburger::LexSimplexBase::moveRowUnknownToColumn()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00099">mlir::memref::multiBuffer()</a>, <a class="el" href="Dialect_2LLVMIR_2IR_2TypeDetail_8h_source.html#l00243">mlir::LLVM::detail::LLVMStructTypeStorage::mutate()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00986">mlir::spirv::detail::StructTypeStorage::mutate()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01714">mlir::affine::normalizeMemRef()</a>, <a class="el" href="PatternMatch_8h_source.html#l00597">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PatternMatch_8h_source.html#l00424">mlir::RewriterBase::Listener::notifyMatchFailure()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01418">mlir::detail::ConversionPatternRewriterImpl::notifyMatchFailure()</a>, <a class="el" href="TransformOps_8cpp_source.html#l00197">mlir::transform::TrackingListener::notifyMatchFailure()</a>, <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html#l00271">mlir::Diagnostic::operator FailureOr&lt; T &gt;()</a>, <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html#l00373">mlir::InFlightDiagnostic::operator FailureOr&lt; T &gt;()</a>, <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00217">mlir::DiagnosedDefiniteFailure::operator LogicalResult()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00193">mlir::Diagnostic::operator LogicalResult()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00201">mlir::InFlightDiagnostic::operator LogicalResult()</a>, <a class="el" href="Diagnostic_8h_source.html#l00058">mlir::pdll::ast::Diagnostic::operator LogicalResult()</a>, <a class="el" href="Diagnostic_8h_source.html#l00110">mlir::pdll::ast::InFlightDiagnostic::operator LogicalResult()</a>, <a class="el" href="OptimizeSharedMemory_8cpp_source.html#l00181">mlir::nvgpu::optimizeSharedMemoryReadsAndWrites()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00291">outlineIfOp()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00187">outlineSingleBlockRegion()</a>, <a class="el" href="Transforms_8cpp_source.html#l00736">mlir::linalg::pack()</a>, <a class="el" href="Transforms_8cpp_source.html#l00409">packLinalgMetadataOnce()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00918">mlir::detail::ParallelDiagnosticHandlerImpl::ParallelDiagnosticHandlerImpl()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00065">mlir::FieldParser&lt; AttributeT, std::enable_if_t&lt; std::is_base_of&lt; Attribute, AttributeT &gt;::value, AttributeT &gt; &gt;::parse()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00077">mlir::FieldParser&lt; TypeT, std::enable_if_t&lt; std::is_base_of&lt; Type, TypeT &gt;::value, TypeT &gt; &gt;::parse()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00089">mlir::FieldParser&lt; IntT, std::enable_if_t&lt; std::is_integral&lt; IntT &gt;::value, IntT &gt; &gt;::parse()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00100">mlir::FieldParser&lt; std::string &gt;::parse()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00114">mlir::FieldParser&lt; std::optional&lt; AttributeT &gt;, std::enable_if_t&lt; std::is_base_of&lt; Attribute, AttributeT &gt;::value, std::optional&lt; AttributeT &gt; &gt; &gt;::parse()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00131">mlir::FieldParser&lt; std::optional&lt; IntT &gt;, std::enable_if_t&lt; std::is_integral&lt; IntT &gt;::value, std::optional&lt; IntT &gt; &gt; &gt;::parse()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00156">mlir::FieldParser&lt; ContainerT, std::enable_if_t&lt; llvm::is_detected&lt; detail::has_push_back_t, ContainerT &gt;::value, ContainerT &gt; &gt;::parse()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00174">mlir::FieldParser&lt; AffineMap &gt;::parse()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00269">mlir::DynamicAttr::parse()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00156">mlir::DynamicType::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01711">mlir::affine::AffineDmaStartOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01870">mlir::affine::AffineDmaWaitOp::parse()</a>, <a class="el" href="Chipset_8cpp_source.html#l00016">mlir::amdgpu::Chipset::parse()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00699">mlir::detail::Parser::parseAffineMapReference()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03372">parseAffineMinMaxOp()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00088">parseAllocateAndAllocator()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00785">parseArithmeticExtendedBinaryOp()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00518">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseArrowTypeList()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01185">parseAtomicCompareExchangeImpl()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00823">parseAtomicUpdateOp()</a>, <a class="el" href="OpImplementation_8h_source.html#l00892">mlir::AsmParser::parseAttribute()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00051">mlir::detail::Parser::parseAttribute()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00294">mlir::detail::Parser::parseAttributeDict()</a>, <a class="el" href="Dialect_2Async_2IR_2Async_8cpp_source.html#l00292">parseAwaitResultType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02031">parseBound()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00029">mlir::detail::Parser::parseCallSiteLocation()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01061">parseCallTypeAndResolveOperands()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00131">parseClauseAttr()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00122">parseCmpOp()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00533">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseColonType()</a>, <a class="el" href="OpImplementation_8h_source.html#l01192">mlir::AsmParser::parseColonType()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00539">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseColonTypeList()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l00050">mlir::detail::Parser::parseCommaSeparatedList()</a>, <a class="el" href="PassOptions_8h_source.html#l00038">mlir::detail::pass_options::parseCommaSeparatedList()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l00139">mlir::detail::Parser::parseCommaSeparatedListUntil()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00127">parseCommonStructuredOpParts()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00231">parseControlAttribute()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00067">parseCreateOperationOpAttributes()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00103">parseCreateOperationOpResults()</a>, <a class="el" href="OpImplementation_8h_source.html#l00923">mlir::AsmParser::parseCustomAttributeWithFallback()</a>, <a class="el" href="OpImplementation_8h_source.html#l01149">mlir::AsmParser::parseCustomTypeWithFallback()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01278">parseDenseI64ArrayAttr()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00491">parseDependVarList()</a>, <a class="el" href="BytecodeReader_8cpp_source.html#l00469">parseDialectGrouping()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00054">mlir::detail::Parser::parseDialectSymbolBody()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00452">mlir::affine::parseDimAndSymbolList()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00524">mlir::detail::Parser::parseDimensionListRanked()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00961">parseDstStyleOp()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00123">parseDynamicIndexList()</a>, <a class="el" href="BytecodeReader_8cpp_source.html#l00330">parseEntry()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00217">parseEnumKeywordAttr()</a>, <a class="el" href="ParserUtils_8h_source.html#l00027">parseEnumKeywordAttr()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00176">parseEnumStrAttr()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00273">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseFloat()</a>, <a class="el" href="TransformOps_8cpp_source.html#l00585">parseForeachMatchSymbols()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00272">mlir::detail::PassOptions::parseFromString()</a>, <a class="el" href="FileLineColLocBreakpointManager_8cpp_source.html#l00017">mlir::tracing::FileLineColLocBreakpoint::parseFromString()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00164">mlir::function_interface_impl::parseFunctionOp()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00083">parseFunctionResultList()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00071">mlir::detail::Parser::parseFunctionResultTypes()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00116">mlir::function_interface_impl::parseFunctionSignature()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00036">parseFunctionTypes()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00061">mlir::detail::Parser::parseFusedLocation()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00343">parseGangClause()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00569">parseGEPIndices()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01564">parseGlobalMemrefOpTypeAndInitialValue()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00903">parseGroupNonUniformArithmeticOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00371">parseImageOperands()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00708">mlir::detail::Parser::parseIntegerSetReference()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00357">parseKeywordList()</a>, <a class="el" href="OpImplementation_8h_source.html#l01217">mlir::AsmParser::parseKeywordType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00927">parseLaunchFuncOperands()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00157">parseLinearClause()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00814">parseLoadType()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00151">mlir::detail::Parser::parseLocationInstance()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00890">parseLoopControl()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00645">parseMapClause()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00254">parseMemoryAccessAttributes()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00169">mlir::detail::Parser::parseMemRefType()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00882">parseMultitileSizesTypes()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00208">parseNamedStructuredOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00201">parseNamedStructuredOpResults()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00095">mlir::detail::Parser::parseNameOrFileLineColLocation()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00072">parseOneResultSameOperandTypeOp()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00145">parseOperationOpAttributes()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00255">parseOptionalArrayStride()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00484">mlir::ExtensibleDialect::parseOptionalDynamicAttr()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00462">mlir::ExtensibleDialect::parseOptionalDynamicType()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l00241">mlir::detail::Parser::parseOptionalInteger()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l00312">mlir::detail::Parser::parseOptionalKeyword()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00334">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalKeyword()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00071">parseOptionalStaticSlice()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00240">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalString()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00470">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalSymbolName()</a>, <a class="el" href="OpImplementation_8h_source.html#l01067">mlir::AsmParser::parseOptionalSymbolName()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00024">mlir::detail::Parser::parseOptionalType()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l01032">mlir::impl::parseOptionalVisibilityKeyword()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00695">parsePassPipeline()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00082">parsePointer()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l04686">parsePtrAccessChainOpImpl()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00162">parseQuantParams()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00409">parseReductionVarList()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00224">parseRegions()</a>, <a class="el" href="OpImplementation_8h_source.html#l01082">mlir::AsmParser::parseResourceHandle()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00450">parseResultsValueType()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00326">parseScheduleClause()</a>, <a class="el" href="LinalgMatchOps_8cpp_source.html#l00759">parseSemiFunctionType()</a>, <a class="el" href="TransformOps_8cpp_source.html#l01619">parseSequenceOpOperands()</a>, <a class="el" href="IRDL_8cpp_source.html#l00050">parseSingleBlockRegion()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00658">parseSizeAssignment()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00285">parseSourceMemoryAccessAttributes()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00063">parseStorageRange()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00868">parseStoreType()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00601">parseStructMemberDecorations()</a>, <a class="el" href="LinalgMatchOps_8cpp_source.html#l00693">parseStructuredTransformDims()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l03872">parseSwitchCases()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00493">parseSwitchOpCases()</a>, <a class="el" href="OpImplementation_8h_source.html#l01053">mlir::AsmParser::parseSymbolName()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00554">parseSynchronizationHint()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l02711">parseTBAAMembers()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00268">parseTileLikeOp()</a>, <a class="el" href="MLProgramOps_8cpp_source.html#l00029">parseTokenOrdering()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00508">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseType()</a>, <a class="el" href="OpImplementation_8h_source.html#l01120">mlir::AsmParser::parseType()</a>, <a class="el" href="MLProgramOps_8cpp_source.html#l00084">parseTypedInitialValue()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00087">mlir::detail::Parser::parseTypeListNoParens()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00102">mlir::detail::Parser::parseTypeListParens()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00611">parseVariableDecorations()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00419">parseVectorClause()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00471">mlir::detail::Parser::parseVectorDimensionList()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00449">parseVerCapExtAttr()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00399">parseWorkerClause()</a>, <a class="el" href="PassRegistry_8h_source.html#l00191">mlir::PassPipelineRegistration&lt; EmptyPipelineOptions &gt;::PassPipelineRegistration()</a>, <a class="el" href="PassRegistry_8h_source.html#l00168">mlir::PassPipelineRegistration&lt; Options &gt;::PassPipelineRegistration()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03302">pdllConvertValues()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00119">peelForLoop()</a>, <a class="el" href="LoopPipelining_8cpp_source.html#l00498">mlir::scf::pipelineForLoop()</a>, <a class="el" href="TranslateToCpp_8cpp_source.html#l00185">printConstantOp()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00497">mlir::ExtensibleDialect::printIfDynamicAttr()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00475">mlir::ExtensibleDialect::printIfDynamicType()</a>, <a class="el" href="TranslateToCpp_8cpp_source.html#l00315">printOperation()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00318">processBuffer()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01360">processMapOperand()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00408">processParallelLoop()</a>, <a class="el" href="PatternMatch_8h_source.html#l01315">mlir::detail::pdl_function_builder::processResults()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00184">mlir::bufferization::promoteBufferResultsToOutParams()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00132">mlir::affine::promoteIfSingleIteration()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00541">mlir::scf::promoteIfSingleIteration()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00383">promoteIfSingleIteration()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00358">promoteSingleIterReductionLoop()</a>, <a class="el" href="Promotion_8cpp_source.html#l00213">mlir::linalg::promoteSubviewAsNewBuffer()</a>, <a class="el" href="Promotion_8cpp_source.html#l00265">promoteSubViews()</a>, <a class="el" href="Promotion_8cpp_source.html#l00395">mlir::linalg::promoteSubViews()</a>, <a class="el" href="Tools_2PDLL_2Parser_2Lexer_8cpp_source.html#l00108">mlir::pdll::Lexer::pushInclude()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00082">mlir::DialectBytecodeReader::readAttribute()</a>, <a class="el" href="Transport_8cpp_source.html#l00266">readLine()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00047">mlir::DialectBytecodeReader::readList()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00111">mlir::DialectBytecodeReader::readResourceHandle()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00353">readResourceHandle()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00099">mlir::DialectBytecodeReader::readType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03309">registerConversionPDLFunctions()</a>, <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00020">reifyValueBound()</a>, <a class="el" href="Dialect_2LLVMIR_2IR_2TypeDetail_8h_source.html#l00345">mlir::AttrTypeSubElementHandler&lt; LLVM::detail::LLVMStructTypeStorage::Key &gt;::replace()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01077">replaceDimOrSym()</a>, <a class="el" href="SwapExtractSliceWithProducerPatterns_8cpp_source.html#l00023">mlir::tensor::replaceExtractSliceWithTiledProducer()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l00971">mlir::transform::TransformState::Extension::replacePayloadValue()</a>, <a class="el" href="SCCP_8cpp_source.html#l00042">replaceWithConstant()</a>, <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00172">mlir::memref::replaceWithIndependentOp()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00327">resolveBroadcastShape()</a>, <a class="el" href="OpImplementation_8h_source.html#l01421">mlir::OpAsmParser::resolveOperands()</a>, <a class="el" href="Transforms_8cpp_source.html#l01497">mlir::linalg::DownscaleSizeOneWindowed2DConvolution&lt; Conv2DOp, Conv1DOp &gt;::returningMatchAndRewrite()</a>, <a class="el" href="Transforms_8cpp_source.html#l01688">mlir::linalg::DownscaleConv2DOp::returningMatchAndRewrite()</a>, <a class="el" href="Transforms_8cpp_source.html#l01620">mlir::linalg::DownscaleDepthwiseConv2DNhwcHwcOp::returningMatchAndRewrite()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00243">mlir::linalg::rewriteInDestinationPassingStyle()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01936">PadOpVectorizationWithInsertSlicePattern::rewriteUser()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01720">PadOpVectorizationWithTransferReadPattern::rewriteUser()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01782">PadOpVectorizationWithTransferWritePattern::rewriteUser()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00102">roundTripModule()</a>, <a class="el" href="mlir-lsp-server_2LSPServer_8cpp_source.html#l00285">mlir::lsp::runMlirLSPServer()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00446">mlir::bufferization::runOneShotModuleBufferize()</a>, <a class="el" href="mlir-pdll-lsp-server_2LSPServer_8cpp_source.html#l00283">mlir::lsp::runPdllLSPServer()</a>, <a class="el" href="tblgen-lsp-server_2LSPServer_8cpp_source.html#l00190">mlir::lsp::runTableGenLSPServer()</a>, <a class="el" href="Inliner_8cpp_source.html#l00293">runTransformOnCGSCCs()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02720">mlir::affine::separateFullTiles()</a>, <a class="el" href="Serializer_8cpp_source.html#l00089">mlir::spirv::Serializer::serialize()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00073">serializeModule()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00184">mlir::MlirOptMainConfig::setPassPipelineParser()</a>, <a class="el" href="ToolUtilities_8cpp_source.html#l00022">splitAndProcessBuffer()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00519">mlir::vector::splitFullAndPartialTransfer()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00128">splitFullAndPartialTransferPrecondition()</a>, <a class="el" href="UnsignedWhenEquivalent_8cpp_source.html#l00032">staticallyNonNegative()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00600">structFuncArgTypeConverter()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00778">mlir::affine::tilePerfectlyNested()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00821">mlir::affine::tilePerfectlyNestedParametric()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00275">mlir::linalg::TileLoopNest::tileRootOp()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02507">mlir::transform::tileToForallOpImpl()</a>, <a class="el" href="LoopAnnotationImporter_8cpp_source.html#l00460">mlir::LLVM::detail::LoopAnnotationImporter::translateAccessGroup()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00062">translateDataLayout()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00398">mlir::DenseElementsAttr::try_value_begin()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00407">mlir::DenseElementsAttr::try_value_end()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01180">mlir::DenseElementsAttr::tryGetComplexFloatValues()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01160">mlir::DenseElementsAttr::tryGetComplexIntValues()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01169">mlir::DenseElementsAttr::tryGetFloatValues()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00441">mlir::DenseElementsAttr::tryGetValues()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00840">tryIsolateBands()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00587">mlir::detail::OpToOpPassAdaptor::tryMergeInto()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01600">GenericPadOpVectorizationPattern::tryVectorizeCopy()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00025">typeOrAttrParser()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01979">mlir::presburger::IntegerRelation::unionBoundingBox()</a>, <a class="el" href="AttrTypeSubElements_8cpp_source.html#l00140">updateSubElementImpl()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01475">mlir::linalg::vectorize()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01856">mlir::affine::vectorizeAffineLoopNest()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01159">vectorizeAsLinalgGeneric()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01528">mlir::linalg::vectorizeCopy()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01315">mlir::linalg::vectorizeLinalgOpPrecondition()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01538">vectorizeLoopNest()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00323">mlir::quant::UniformQuantizedPerAxisType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00270">mlir::quant::UniformQuantizedType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00235">mlir::quant::AnyQuantizedType::verify()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01130">verifyAccessChain()</a>, <a class="el" href="PatternMatch_8h_source.html#l01063">mlir::detail::pdl_function_builder::ProcessPDLValueBasedOn&lt; T, BaseT &gt;::verifyAsArg()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00059">verifyCompatibleShape()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00096">verifyCompatibleShapes()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00531">mlir::detail::verifyDataLayoutSpec()</a>, <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00100">verifyDependencies()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01771">verifyLoopNesting()</a>, <a class="el" href="BufferDeallocation_8cpp_source.html#l00074">walkReturnOperations()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00315">mlir::BytecodeDialectInterface::writeAttribute()</a>, and <a class="el" href="BytecodeImplementation_8h_source.html#l00324">mlir::BytecodeDialectInterface::writeType()</a>.</p>

</div>
</div>
<a id="a04b8cb2bfcf870fb9909b4805c0aad13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b8cb2bfcf870fb9909b4805c0aad13">&#9670;&nbsp;</a></span>finalizeParallelLoopToGPUConversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::finalizeParallelLoopToGPUConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up after applyPartialConversion/applyFullConversion call. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPU_8cpp_source.html#l00693">693</a> of file <a class="el" href="SCFToGPU_8cpp_source.html">SCFToGPU.cpp</a>.</p>

</div>
</div>
<a id="adb672e2258ecd8657ec36b0fd391208a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb672e2258ecd8657ec36b0fd391208a">&#9670;&nbsp;</a></span>findPositionsOfType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::findPositionsOfType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt;&#160;</td>
          <td class="paramname"><em>iteratorTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utils::IteratorType&#160;</td>
          <td class="paramname"><em>iteratorTypeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return positions in <code>iteratorTypes</code> that match <code>iteratorTypeName</code>. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00053">53</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>.</p>

</div>
</div>
<a id="a3983eab6c9a05efd28747c0e79dd9d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3983eab6c9a05efd28747c0e79dd9d44">&#9670;&nbsp;</a></span>floorDiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::floorDiv </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of MLIR's floordiv operation on constants. </p>
<p>The RHS is expected to be non-zero. </p>

<p class="definition">Definition at line <a class="el" href="MathExtras_8h_source.html#l00033">33</a> of file <a class="el" href="MathExtras_8h_source.html">MathExtras.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00079">mlir::scf::addLoopRangeConstraints()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00370">createPrivateMemRef()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01971">generateCopy()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00712">getBoundForExpr()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00099">mlir::memref::multiBuffer()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00840">simplifyExprAndOperands()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00735">simplifyFloorDiv()</a>.</p>

</div>
</div>
<a id="ac3cdbb0a157a6008648d2e54c55bd46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3cdbb0a157a6008648d2e54c55bd46c">&#9670;&nbsp;</a></span>foldDynamicIndexList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::foldDynamicIndexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ofrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>success</code> when any of the elements in <code>ofrs</code> was produced by <a class="el" href="classmlir_1_1arith_1_1ConstantIndexOp.html" title="Specialization of arith.constant op that returns an integer of index type.">arith::ConstantIndexOp</a>. </p>
<p>In that case the constant attribute replaces the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. Returns <code>failure</code> when no folding happened. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00029">29</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Builders_8cpp_source.html#l00121">mlir::Builder::getIndexAttr()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="a2b0271e4a2b1e694242618a6e91a9c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0271e4a2b1e694242618a6e91a9c37">&#9670;&nbsp;</a></span>foldReshapeOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReshapeOpTy , typename InverseReshapeOpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::foldReshapeOp </td>
          <td>(</td>
          <td class="paramtype">ReshapeOpTy&#160;</td>
          <td class="paramname"><em>reshapeOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00086">86</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

</div>
</div>
<a id="a2d3bd1afbf84ef9cca6c336a104d7280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3bd1afbf84ef9cca6c336a104d7280">&#9670;&nbsp;</a></span>generateLocationsFromIR() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::generateLocationsFromIR </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates new locations from the given IR by snapshotting the IR to the given stream, and using the printed locations within that stream. </p>
<p>The generated locations replace the current operation locations. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00101">101</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

</div>
</div>
<a id="a94e9bde94caabba0feba96a044a09afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e9bde94caabba0feba96a044a09afc">&#9670;&nbsp;</a></span>generateLocationsFromIR() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::generateLocationsFromIR </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates new locations from the given IR by snapshotting the IR to the given stream, and using the printed locations within that stream. </p>
<p>The generated locations are represented as a NameLoc with the given tag as the name, and then fused with the existing locations. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00117">117</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

</div>
</div>
<a id="af16c6823f94d6ce99fa7da7547658345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16c6823f94d6ce99fa7da7547658345">&#9670;&nbsp;</a></span>generateLocationsFromIR() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::generateLocationsFromIR </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates new locations from the given IR by snapshotting the IR to the given file, and using the printed locations within that file. </p>
<p>If <code>filename</code> is empty, a temporary file is generated instead. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00108">108</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

</div>
</div>
<a id="ab170389f5f17475f89037e332018b4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab170389f5f17475f89037e332018b4f8">&#9670;&nbsp;</a></span>generateLocationsFromIR() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::generateLocationsFromIR </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates new locations from the given IR by snapshotting the IR to the given file, and using the printed locations within that file. </p>
<p>If <code>filename</code> is empty, a temporary file is generated instead. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00125">125</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

</div>
</div>
<a id="ab4871db68c59a176135e0e35a3625e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4871db68c59a176135e0e35a3625e73">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method that injects context only if needed, this helps unify some of the attribute construction methods. </p>

<p class="definition">Definition at line <a class="el" href="BytecodeImplementation_8h_source.html#l00368">368</a> of file <a class="el" href="BytecodeImplementation_8h_source.html">BytecodeImplementation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="OperationSupport_8h_source.html#l00993">mlir::OperationState::addAttribute()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l00298">addResumeFunction()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00413">mlir::UnrankedMemRefDescriptor::allocatedPtr()</a>, <a class="el" href="Promotion_8cpp_source.html#l00409">allocateSubviewGPUMemoryInAddressSpace()</a>, <a class="el" href="Promotion_8cpp_source.html#l00047">allocBuffer()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00431">mlir::sparse_tensor::allocDenseTensor()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00066">mlir::NamedAttrList::append()</a>, <a class="el" href="Arith_2Transforms_2EmulateWideInt_8cpp_source.html#l00143">appendX1Dim()</a>, <a class="el" href="TosaToLinalgNamed_8cpp_source.html#l00033">applyPad()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00133">applyPassManagerCLOptions()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00140">broadcast()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00507">broadcastIfNeeded()</a>, <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00453">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00052">mlir::bufferization::BufferizeTypeConverter::BufferizeTypeConverter()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01667">mlir::affine::AffineDmaStartOp::build()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01847">mlir::affine::AffineDmaWaitOp::build()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l02006">buildLLVMFunctionType()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00673">buildPackingLoopNestImpl()</a>, <a class="el" href="QuantUtils_8cpp_source.html#l00335">mlir::tosa::buildQTypeAttrFromMinMax()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00172">buildSequentialConstant()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00546">buildVectorWrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00700">calculateGatherOffset()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00856">canonicalizeStridedLayout()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00128">castDataPtr()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00153">mlir::quant::QuantizedType::castFromExpressedType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00103">mlir::quant::QuantizedType::castFromStorageType()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00441">castToElemPtrPtr()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00181">mlir::quant::QuantizedType::castToExpressedType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00126">mlir::quant::QuantizedType::castToStorageType()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00278">mlir::TensorType::cloneWith()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00356">mlir::BaseMemRefType::cloneWith()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00588">collectSymbolScopes()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00040">collectValidReferencesFor()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02306">computeCollapsedLayoutMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02190">computeExpandedLayoutMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00365">mlir::AffineMap::constantFold()</a>, <a class="el" href="CommonFolders_8h_source.html#l00032">constFoldBinaryOpConditional()</a>, <a class="el" href="AttrTypeSubElements_8h_source.html#l00433">mlir::detail::constructSubElementReplacement()</a>, <a class="el" href="UniformSupport_8cpp_source.html#l00035">mlir::quant::ExpressedToQuantizedConverter::convert()</a>, <a class="el" href="AttrToLLVMConverter_8cpp_source.html#l00034">mlir::arith::convertArithFastMathAttrToLLVM()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00250">convertArrayType()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00382">convertBoolMemrefType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03065">convertFuncOpTypes()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00223">mlir::LLVMTypeConverter::convertFunctionSignature()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00254">mlir::LLVMTypeConverter::convertFunctionTypeCWrapper()</a>, <a class="el" href="NVGPUToNVVM_8cpp_source.html#l00068">convertIntrinsicResult()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00342">convertOmpCritical()</a>, <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00140">convertOperationImpl()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00274">convertRuntimeArrayType()</a>, <a class="el" href="ODSSupport_8cpp_source.html#l00033">convertToAttribute()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00071">copy()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00228">mlir::ConvertToLLVMPattern::copyUnrankedDescriptors()</a>, <a class="el" href="AsyncParallelFor_8cpp_source.html#l00464">createAsyncDispatchFunction()</a>, <a class="el" href="MathToFuncs_8cpp_source.html#l00651">createCtlzFunc()</a>, <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00049">createDeviceFunctionCall()</a>, <a class="el" href="MathToFuncs_8cpp_source.html#l00412">createElementFPowIFunc()</a>, <a class="el" href="MathToFuncs_8cpp_source.html#l00185">createElementIPowIFunc()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00300">createFullPartialVectorTransferRead()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00422">createFullPartialVectorTransferWrite()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l03046">mlir::LLVM::createGlobalString()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00468">createGroupReduceOpImpl()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00213">createI32ConstantOf()</a>, <a class="el" href="LoopAnnotationImporter_8cpp_source.html#l00270">createIfNonNull()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01009">createMask()</a>, <a class="el" href="ControlFlowToLLVM_8cpp_source.html#l00047">createPrintMsg()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00370">createPrivateMemRef()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00923">createQuickSort()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00987">createSortStableFunc()</a>, <a class="el" href="Promotion_8cpp_source.html#l00083">defaultAllocBufferCallBack()</a>, <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00301">defineDeclaredSymbols()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00040">deserializeModule()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00332">mlir::spirv::Deserializer::processOp&lt; spirv::EntryPointOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00381">mlir::spirv::Deserializer::processOp&lt; spirv::ExecutionModeOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00414">mlir::spirv::Deserializer::processOp&lt; spirv::FunctionCallOp &gt;()</a>, <a class="el" href="Arith_2Transforms_2EmulateWideInt_8cpp_source.html#l00126">dropTrailingX1Dim()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00515">elementwiseMatchAndRewriteHelper()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00128">encodeKernelName()</a>, <a class="el" href="LoopEmitter_8cpp_source.html#l00866">mlir::sparse_tensor::LoopEmitter::enterCoIterationOverTensorsAtLvls()</a>, <a class="el" href="LowerVectorTransfer_8cpp_source.html#l00038">extendVectorRank()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00214">mlir::detail::OpPassManagerImpl::finalizePassList()</a>, <a class="el" href="Sparsification_8cpp_source.html#l01364">finalizeWhileOp()</a>, <a class="el" href="IndexOps_8cpp_source.html#l00091">foldBinaryOpChecked()</a>, <a class="el" href="IndexOps_8cpp_source.html#l00065">foldBinaryOpUnchecked()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00336">foldMemRefCasts()</a>, <a class="el" href="SparseTensorStorageLayout_8cpp_source.html#l00168">mlir::sparse_tensor::foreachFieldAndTypeInSparseTensor()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00399">mlir::sparse_tensor::genAlloca()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00414">mlir::sparse_tensor::genAllocaScalar()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01971">generateCopy()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00790">generateNewRefAttr()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00065">mlir::gpu::MMAMatrixType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01032">mlir::spirv::StructType::get()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00136">mlir::spirv::InterfaceVarABIAttr::get()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00210">mlir::spirv::VerCapExtAttr::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00852">mlir::detail::DenseArrayAttrImpl&lt; T &gt;::get()</a>, <a class="el" href="DLTI_8cpp_source.html#l00136">mlir::DataLayoutSpecAttr::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01000">mlir::DenseElementsAttr::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01576">mlir::detail::DenseResourceElementsAttrBase&lt; T &gt;::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00411">mlir::spirv::ImageType::get()</a>, <a class="el" href="DLTI_8cpp_source.html#l00052">mlir::DataLayoutEntryAttr::get()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00869">mlir::FlatSymbolRefAttr::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01170">mlir::spirv::MatrixType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00535">mlir::spirv::RuntimeArrayType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00231">mlir::spirv::CooperativeMatrixNVType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00296">mlir::spirv::JointMatrixINTELType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00051">mlir::spirv::ArrayType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00370">mlir::quant::CalibratedQuantizedType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00803">mlir::spirv::SampledImageType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00478">mlir::spirv::PointerType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00303">mlir::quant::UniformQuantizedPerAxisType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00252">mlir::quant::UniformQuantizedType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00216">mlir::quant::AnyQuantizedType::get()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00288">mlir::spirv::TargetEnvAttr::get()</a>, <a class="el" href="CodegenUtils_8h_source.html#l00192">mlir::sparse_tensor::get1DMemRefType()</a>, <a class="el" href="Builders_8cpp_source.html#l00312">mlir::Builder::getAffineMapArrayAttr()</a>, <a class="el" href="AffineOps_8h_source.html#l00204">mlir::affine::AffineDmaStartOp::getAffineMapAttrForMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00324">mlir::affine::AffineDmaWaitOp::getAffineMapAttrForMemRef()</a>, <a class="el" href="Builders_8cpp_source.html#l00259">mlir::Builder::getArrayAttr()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00106">getAsIndexOpFoldResult()</a>, <a class="el" href="Builders_8h_source.html#l00099">mlir::Builder::getAttr()</a>, <a class="el" href="lib_2Conversion_2PDLToPDLInterp_2Predicate_8h_source.html#l00583">mlir::pdl_to_pdl_interp::PredicateBuilder::getAttribute()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00406">mlir::FloatType::getBF16()</a>, <a class="el" href="ArithOps_8cpp_source.html#l01619">getBoolAttribute()</a>, <a class="el" href="Builders_8cpp_source.html#l00129">mlir::Builder::getBoolVectorAttr()</a>, <a class="el" href="Traits_8cpp_source.html#l00133">mlir::OpTrait::util::getBroadcastedType()</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00060">mlir::bufferization::func_ext::getBufferizedFunctionArgType()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02916">getCanonicalSubViewResultType()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00156">getCastCompatibleMemRefType()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00096">getCharPtr()</a>, <a class="el" href="TosaToLinalgNamed_8cpp_source.html#l00098">getConvOutputDim()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00483">mlir::sparse_tensor::getCOOFromTypeWithOrdering()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00133">mlir::detail::getDefaultABIAlignment()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01182">mlir::detail::getDefaultDiagnosticEmitFn()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00186">mlir::detail::getDefaultPreferredAlignment()</a>, <a class="el" href="TargetAndABI_8cpp_source.html#l00157">mlir::spirv::getDefaultResourceLimits()</a>, <a class="el" href="FakeQuantSupport_8cpp_source.html#l00015">getDefaultStorageParams()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00051">mlir::detail::getDefaultTypeSizeInBits()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00716">getDenseResource()</a>, <a class="el" href="IRCore_8cpp_source.html#l00906">mlir::python::PyDialects::getDialectForKey()</a>, <a class="el" href="Builders_8cpp_source.html#l00117">mlir::Builder::getDictionaryAttr()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01055">mlir::spirv::StructType::getEmpty()</a>, <a class="el" href="AsmParser_2Lexer_8cpp_source.html#l00044">mlir::Lexer::getEncodedSourceLocation()</a>, <a class="el" href="TargetAndABI_8cpp_source.html#l00124">mlir::spirv::getEntryPointABIAttr()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00653">getExpandedType()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00039">mlir::shape::getExtentTensorType()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00426">mlir::FloatType::getF128()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00410">mlir::FloatType::getF16()</a>, <a class="el" href="Builders_8cpp_source.html#l00243">mlir::Builder::getF16FloatAttr()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00414">mlir::FloatType::getF32()</a>, <a class="el" href="Builders_8cpp_source.html#l00239">mlir::Builder::getF32FloatAttr()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00418">mlir::FloatType::getF64()</a>, <a class="el" href="Builders_8cpp_source.html#l00235">mlir::Builder::getF64FloatAttr()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00422">mlir::FloatType::getF80()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00919">mlir::LLVM::getFixedVectorType()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00402">mlir::FloatType::getFloat8E4M3B11FNUZ()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00390">mlir::FloatType::getFloat8E4M3FN()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00398">mlir::FloatType::getFloat8E4M3FNUZ()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00386">mlir::FloatType::getFloat8E5M2()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00394">mlir::FloatType::getFloat8E5M2FNUZ()</a>, <a class="el" href="Builders_8cpp_source.html#l00247">mlir::Builder::getFloatAttr()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00362">mlir::sparse_tensor::getFunc()</a>, <a class="el" href="Builders_8cpp_source.html#l00093">mlir::Builder::getFunctionType()</a>, <a class="el" href="Builders_8cpp_source.html#l00028">mlir::Builder::getFusedLoc()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00239">getGetValueTypeOpValueType()</a>, <a class="el" href="Builders_8cpp_source.html#l00216">mlir::Builder::getI16IntegerAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00078">mlir::Builder::getI16Type()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00118">getI1SameShape()</a>, <a class="el" href="Builders_8cpp_source.html#l00070">mlir::Builder::getI1Type()</a>, <a class="el" href="Builders_8cpp_source.html#l00072">mlir::Builder::getI2Type()</a>, <a class="el" href="Builders_8cpp_source.html#l00202">mlir::Builder::getI32IntegerAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00181">mlir::Builder::getI32TensorAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00080">mlir::Builder::getI32Type()</a>, <a class="el" href="Builders_8cpp_source.html#l00135">mlir::Builder::getI32VectorAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00074">mlir::Builder::getI4Type()</a>, <a class="el" href="Builders_8cpp_source.html#l00125">mlir::Builder::getI64IntegerAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00188">mlir::Builder::getI64TensorAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00082">mlir::Builder::getI64Type()</a>, <a class="el" href="Builders_8cpp_source.html#l00141">mlir::Builder::getI64VectorAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00220">mlir::Builder::getI8IntegerAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00076">mlir::Builder::getI8Type()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01045">mlir::spirv::StructType::getIdentified()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00419">mlir::LLVM::LLVMStructType::getIdentified()</a>, <a class="el" href="Builders_8cpp_source.html#l00280">mlir::Builder::getIndexArrayAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00121">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00195">mlir::Builder::getIndexTensorAttr()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00173">mlir::LLVMTypeConverter::getIndexType()</a>, <a class="el" href="Builders_8cpp_source.html#l00068">mlir::Builder::getIndexType()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00119">getIndexType()</a>, <a class="el" href="Builders_8cpp_source.html#l00147">mlir::Builder::getIndexVectorAttr()</a>, <a class="el" href="SparseTensorStorageLayout_8cpp_source.html#l00077">mlir::sparse_tensor::SparseTensorSpecifier::getInitValue()</a>, <a class="el" href="Builders_8cpp_source.html#l00224">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00117">mlir::sparse_tensor::detail::getIntegerOrIndexType()</a>, <a class="el" href="Builders_8cpp_source.html#l00084">mlir::Builder::getIntegerType()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00082">getInterfaceVariables()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00041">mlir::ConvertToLLVMPattern::getIntPtrType()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00447">mlir::LLVM::LLVMStructType::getLiteral()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00323">mlir::LLVM::detail::getLLVMConstant()</a>, <a class="el" href="DeadCodeAnalysis_8cpp_source.html#l00084">mlir::dataflow::CFGEdge::getLoc()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00080">getMangledSortHelperFunc()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00806">mlir::bufferization::getMemRefType()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00831">mlir::bufferization::getMemRefTypeWithFullyDynamicLayout()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00854">mlir::bufferization::getMemRefTypeWithStaticIdentityLayout()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00100">mlir::nvgpu::getMmaSyncRegisterType()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00609">getMmaSyncVectorOperandType()</a>, <a class="el" href="Builders_8cpp_source.html#l00101">mlir::Builder::getNoneType()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00581">getNormalizedEncodingForSpecifier()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00459">mlir::LLVM::LLVMStructType::getOpaque()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00391">mlir::sparse_tensor::getOpaquePointerType()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00649">getOrInsertBuiltinVariable()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00501">mlir::MLIRContext::getOrLoadDynamicDialect()</a>, <a class="el" href="Transforms_8cpp_source.html#l01209">getPackOpSourceOrPaddedSource()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00217">getPointerType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00178">mlir::LLVMTypeConverter::getPointerType()</a>, <a class="el" href="DataFlowFramework_8h_source.html#l00218">mlir::DataFlowSolver::getProgramPoint()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00053">getPtrToElementType()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00930">mlir::LLVM::getScalableVectorType()</a>, <a class="el" href="Builders_8cpp_source.html#l00206">mlir::Builder::getSI32IntegerAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00255">mlir::Builder::getStringAttr()</a>, <a class="el" href="DebugTranslation_8cpp_source.html#l00186">getSubprogram()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00103">mlir::memref::getTensorTypeFromMemRefType()</a>, <a class="el" href="Builders_8cpp_source.html#l00097">mlir::Builder::getTupleType()</a>, <a class="el" href="ShapeUtils_8h_source.html#l00069">mlir::tosa::ValueKnowledge::getType()</a>, <a class="el" href="Builders_8h_source.html#l00092">mlir::Builder::getType()</a>, <a class="el" href="Builders_8cpp_source.html#l00306">mlir::Builder::getTypeArrayAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00211">mlir::Builder::getUI32IntegerAttr()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00990">getUnaryOpResultType()</a>, <a class="el" href="Builders_8cpp_source.html#l00111">mlir::Builder::getUnitAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00026">mlir::Builder::getUnknownLoc()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l02331">getValAndBoolStructType()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00895">mlir::LLVM::getVectorType()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00947">getVectorType()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00046">mlir::ConvertToLLVMPattern::getVoidType()</a>, <a class="el" href="LLVMInlining_8cpp_source.html#l00050">handleInlinedAllocas()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00089">handleMultidimensionalVectors()</a>, <a class="el" href="CLOptionsSetup_8cpp_source.html#l00072">mlir::tracing::InstallDebugHandler::Impl::Impl()</a>, <a class="el" href="NVGPUToNVVM_8cpp_source.html#l00029">inferIntrinsicResultType()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00219">mlir::detail::inferReturnTensorTypes()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02892">inferStridedSliceOpResultType()</a>, <a class="el" href="VectorOps_8cpp_source.html#l03466">inferTransferOpMaskType()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l03176">inferTransposeResultType()</a>, <a class="el" href="LLVMImportInterface_8h_source.html#l00088">mlir::LLVMImportInterface::initializeImport()</a>, <a class="el" href="LoopEmitter_8cpp_source.html#l00343">mlir::sparse_tensor::LoopEmitter::initializeLoopEmit()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00077">invertPredicate()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00046">isColumnMajorMatmul()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00072">isRowMajorBatchMatmul()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00020">isRowMajorMatmul()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00338">joinShapes()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00787">mlir::spirv::linearizeIndex()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00024">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00289">loadIRDLDialects()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00143">mlir::SymbolTable::lookup()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00048">mlir::LLVM::lookupOrCreateFn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00153">mlir::LLVM::lookupOrCreateFreeFn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00175">mlir::LLVM::lookupOrCreateGenericFreeFn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00184">mlir::LLVM::lookupOrCreateMemRefCopyFn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00078">mlir::LLVM::lookupOrCreatePrintBF16Fn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00122">mlir::LLVM::lookupOrCreatePrintCloseFn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00127">mlir::LLVM::lookupOrCreatePrintCommaFn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00072">mlir::LLVM::lookupOrCreatePrintF16Fn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00084">mlir::LLVM::lookupOrCreatePrintF32Fn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00090">mlir::LLVM::lookupOrCreatePrintF64Fn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00060">mlir::LLVM::lookupOrCreatePrintI64Fn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00132">mlir::LLVM::lookupOrCreatePrintNewlineFn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00117">mlir::LLVM::lookupOrCreatePrintOpenFn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00110">mlir::LLVM::lookupOrCreatePrintStrFn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00066">mlir::LLVM::lookupOrCreatePrintU64Fn()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00315">mlir::SymbolTable::lookupSymbolIn()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00118">lowerEntryPointABIAttr()</a>, <a class="el" href="LoweringOptions_8cpp_source.html#l00018">mlir::LowerToLLVMOptions::LowerToLLVMOptions()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00271">mlir::linalg::makeComposedPadHighOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02517">makeI64ArrayAttr()</a>, <a class="el" href="LinalgToStandard_8cpp_source.html#l00028">makeStridedLayoutDynamic()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01411">mlir::linalg::maskedVectorize()</a>, <a class="el" href="NamedOpConversions_8cpp_source.html#l00036">matchAndReplaceDepthwiseConv()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00020">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00219">mlir::GPUPrintfOpToHIPLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00330">mlir::GPUPrintfOpToLLVMCallLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00385">mlir::GPUPrintfOpToVPrintfLowering::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00434">ConvertLoad::matchAndRewrite()</a>, <a class="el" href="Transforms_8cpp_source.html#l01302">mlir::linalg::GeneralizeOuterUnitDimsPackOpPattern::matchAndRewrite()</a>, <a class="el" href="Transforms_8cpp_source.html#l01388">mlir::linalg::GeneralizeOuterUnitDimsUnPackOpPattern::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00136">ConsolidateTransposeOptimization::matchAndRewrite()</a>, <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00162">mlir::spirv::MemorySpaceToStorageClassConverter::MemorySpaceToStorageClassConverter()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00157">minMaxValueForFloat()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00166">minMaxValueForSignedInt()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00176">minMaxValueForUnsignedInt()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00039">mlirAffineMapAttrGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00055">mlirArrayAttrGet()</a>, <a class="el" href="IR_8cpp_source.html#l00850">mlirAttributeGetType()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00153">mlirComplexTypeGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00079">mlirDictionaryAttrGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00100">mlirDictionaryAttrGetElementByName()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00113">mlirFloatAttrDoubleGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00377">mlirFunctionTypeGet()</a>, <a class="el" href="IR_8cpp_source.html#l00882">mlirIdentifierGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00063">mlirIndexTypeGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00135">mlirIntegerAttrGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00029">mlirIntegerTypeGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00033">mlirIntegerTypeSignedGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00037">mlirIntegerTypeUnsignedGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00027">mlirLLVMArrayTypeGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00031">mlirLLVMFunctionTypeGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00019">mlirLLVMPointerTypeGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00023">mlirLLVMVoidTypeGet()</a>, <a class="el" href="IR_8cpp_source.html#l00184">mlirLocationCallSiteGet()</a>, <a class="el" href="IR_8cpp_source.html#l00177">mlirLocationFileLineColGet()</a>, <a class="el" href="IR_8cpp_source.html#l00188">mlirLocationFusedGet()</a>, <a class="el" href="IR_8cpp_source.html#l00196">mlirLocationNameGet()</a>, <a class="el" href="IR_8cpp_source.html#l00205">mlirLocationUnknownGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00298">mlirMemRefTypeContiguousGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00274">mlirMemRefTypeGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00141">mlirNoneTypeGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00183">mlirOpaqueAttrGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00413">mlirOpaqueTypeGet()</a>, <a class="el" href="CAPI_2Dialect_2PDL_8cpp_source.html#l00035">mlirPDLAttributeTypeGet()</a>, <a class="el" href="CAPI_2Dialect_2PDL_8cpp_source.html#l00047">mlirPDLOperationTypeGet()</a>, <a class="el" href="CAPI_2Dialect_2PDL_8cpp_source.html#l00059">mlirPDLRangeTypeGet()</a>, <a class="el" href="CAPI_2Dialect_2PDL_8cpp_source.html#l00075">mlirPDLTypeTypeGet()</a>, <a class="el" href="CAPI_2Dialect_2PDL_8cpp_source.html#l00087">mlirPDLValueTypeGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00239">mlirRankedTensorTypeGet()</a>, <a class="el" href="MlirReduceMain_8cpp_source.html#l00049">mlirReduceMain()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00859">mlirSparseElementsAttribute()</a>, <a class="el" href="SparseTensor_8cpp_source.html#l00048">mlirSparseTensorEncodingAttrGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00884">mlirStridedLayoutAttrGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00207">mlirStringAttrGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00211">mlirStringAttrTypedGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00227">mlirSymbolRefAttrGet()</a>, <a class="el" href="IR_8cpp_source.html#l00935">mlirSymbolTableReplaceAllSymbolUses()</a>, <a class="el" href="Transform_8cpp_source.html#l00028">mlirTransformAnyOpTypeGet()</a>, <a class="el" href="Transform_8cpp_source.html#l00040">mlirTransformOperationTypeGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00354">mlirTupleTypeGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00280">mlirTypeAttrGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00296">mlirUnitAttrGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00331">mlirUnrankedMemRefTypeGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00259">mlirUnrankedTensorTypeGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00212">mlirVectorTypeGet()</a>, <a class="el" href="AVXTranspose_8cpp_source.html#l00031">mlir::x86vector::avx2::inline_asm::mm256BlendPsAsm()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01772">mlir::affine::normalizeMemRefType()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00483">mlir::UnrankedMemRefDescriptor::offsetBasePtr()</a>, <a class="el" href="IntegerRangeAnalysis_8cpp_source.html#l00038">mlir::dataflow::IntegerValueRangeLattice::onUpdate()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00735">mlir::OperationName::OperationName()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00199">mlir::MemRefType::Builder::operator MemRefType()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00262">mlir::RankedTensorType::Builder::operator RankedTensorType()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00320">mlir::VectorType::Builder::operator Type()</a>, <a class="el" href="LLVMDialect_8h_source.html#l00164">mlir::LLVM::GEPIndicesAdaptor&lt; DynamicRange &gt;::iterator::operator*()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00602">mlir::DenseElementsAttr::AttributeElementIterator::operator*()</a>, <a class="el" href="SparseTensorStorageLayout_8cpp_source.html#l00026">optionalLevelAttr()</a>, <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00269">outlineExecuteOp()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00172">outlineKernelFuncImpl()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00187">outlineSingleBlockRegion()</a>, <a class="el" href="ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00144">packFunctionArguments()</a>, <a class="el" href="Transforms_8cpp_source.html#l00056">padOperandToSmallestStaticBoundingBox()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l02723">parseAsmSourceFile()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00051">mlir::detail::Parser::parseAttribute()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02031">parseBound()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00029">mlir::detail::Parser::parseCallSiteLocation()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00131">parseClauseAttr()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00120">mlir::detail::Parser::parseComplexType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00405">mlir::detail::Parser::parseDecOrHexAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00934">mlir::detail::Parser::parseDenseArrayAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l01004">mlir::detail::Parser::parseDenseResourceElementsAttr()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00491">parseDependVarList()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00232">mlir::detail::Parser::parseExtendedAttr()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00279">mlir::detail::Parser::parseExtendedType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00339">mlir::detail::Parser::parseFloatAttr()</a>, <a class="el" href="TransformOps_8cpp_source.html#l00585">parseForeachMatchSymbols()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00164">mlir::function_interface_impl::parseFunctionOp()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00061">mlir::detail::Parser::parseFusedLocation()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00343">parseGangClause()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01564">parseGlobalMemrefOpTypeAndInitialValue()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00371">parseImageOperands()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00151">mlir::detail::Parser::parseLocationInstance()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00890">parseLoopControl()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00645">parseMapClause()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00095">mlir::detail::Parser::parseNameOrFileLineColLocation()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00261">mlir::detail::Parser::parseNonFunctionType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00243">mlir::detail::Parser::parseOptionalAttribute()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00470">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalSymbolName()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00406">parseRangeType()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00409">parseReductionVarList()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00450">parseResultsValueType()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00326">parseScheduleClause()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l01064">mlir::detail::Parser::parseSparseElementsAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l01140">mlir::detail::Parser::parseStridedLayoutAttr()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00493">parseSwitchOpCases()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00554">parseSynchronizationHint()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l02711">parseTBAAMembers()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00356">mlir::detail::Parser::parseTensorType()</a>, <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00056">parseTransformModuleFromFile()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00410">mlir::detail::Parser::parseTupleType()</a>, <a class="el" href="IR_2Dialect_8cpp_source.html#l00066">mlir::Dialect::parseType()</a>, <a class="el" href="MLProgramOps_8cpp_source.html#l00084">parseTypedInitialValue()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00419">parseVectorClause()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00436">mlir::detail::Parser::parseVectorType()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00399">parseWorkerClause()</a>, <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00237">performOptionalDebugActions()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00539">populateAMDGPUToROCDLConversionPatterns()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l01239">populateAsyncStructuralTypeConversionsAndLegality()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00962">populateGpuToLLVMConversionPatterns()</a>, <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00314">populateGpuToNVVMConversionPatterns()</a>, <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00212">populateGpuToROCDLConversionPatterns()</a>, <a class="el" href="AffineOps_8cpp_source.html#l04077">printMinMaxBound()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01360">processMapOperand()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01442">processMemoryEffects()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01459">processPassthroughAttrs()</a>, <a class="el" href="Promotion_8cpp_source.html#l00265">promoteSubViews()</a>, <a class="el" href="BytecodeReader_8cpp_source.html#l01839">readBytecodeFileImpl()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00042">reducedVectorTypeBack()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00032">reducedVectorTypeFront()</a>, <a class="el" href="Arith_2Transforms_2EmulateWideInt_8cpp_source.html#l00052">reduceInnermostDim()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00027">registerFromLLVMIRTranslation()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00574">mlir::Operation::removeAttr()</a>, <a class="el" href="ModuleCombiner_8cpp_source.html#l00033">renameSymbol()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00802">replaceAllSymbolUsesImpl()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00068">mlir::IntegerSet::replaceDimsAndSymbols()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00113">replaceUnitDims()</a>, <a class="el" href="TosaMakeBroadcastable_8cpp_source.html#l00081">reshapeLowerToHigher()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00638">mlir::sparse_tensor::reshapeValuesToLevels()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00076">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01936">PadOpVectorizationWithInsertSlicePattern::rewriteUser()</a>, <a class="el" href="SerializeToBlob_8cpp_source.html#l00064">mlir::gpu::SerializeToBlobPass::runOnOperation()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00133">mlir::NamedAttrList::set()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00427">mlir::UnrankedMemRefDescriptor::setAllocatedPtr()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00554">mlir::Operation::setAttr()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00302">mlir::Operation::setAttrs()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00488">mlir::Operation::setDiscardableAttrs()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00184">mlir::MlirOptMainConfig::setPassPipelineParser()</a>, <a class="el" href="SymbolTable_8h_source.html#l00095">mlir::SymbolTable::setSymbolName()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00247">mlir::SymbolTable::setSymbolVisibility()</a>, <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00149">setupCoroMachinery()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00134">mlir::MemRefDescriptor::size()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00521">mlir::UnrankedMemRefDescriptor::sizeBasePtr()</a>, <a class="el" href="Detensorize_8cpp_source.html#l00031">sourceMaterializationCallback()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00519">mlir::vector::splitFullAndPartialTransfer()</a>, <a class="el" href="CodegenEnv_8cpp_source.html#l00072">mlir::sparse_tensor::CodegenEnv::startEmit()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00118">mlir::SymbolTable::SymbolTable()</a>, <a class="el" href="DebugImporter_8cpp_source.html#l00026">mlir::LLVM::detail::DebugImporter::translate()</a>, <a class="el" href="LoopAnnotationImporter_8cpp_source.html#l00460">mlir::LLVM::detail::LoopAnnotationImporter::translateAccessGroup()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00062">translateDataLayout()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01670">translateLLVMIRToModule()</a>, <a class="el" href="DebugImporter_8cpp_source.html#l00230">mlir::LLVM::detail::DebugImporter::translateLoc()</a>, <a class="el" href="AVXTranspose_8cpp_source.html#l00114">mlir::x86vector::avx2::transpose4x8xf32()</a>, <a class="el" href="AVXTranspose_8cpp_source.html#l00139">mlir::x86vector::avx2::transpose8x8xf32()</a>, <a class="el" href="LowerVectorTranspose_8cpp_source.html#l00208">transposeToShuffle16x16()</a>, <a class="el" href="VectorDropLeadUnitDim_8cpp_source.html#l00024">trimLeadingOneDims()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01600">GenericPadOpVectorizationPattern::tryVectorizeCopy()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00048">updateFuncOp()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01174">vectorizeAffineLoad()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01159">vectorizeAsLinalgGeneric()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01528">mlir::linalg::vectorizeCopy()</a>, <a class="el" href="Arith_2Transforms_2EmulateWideInt_8cpp_source.html#l01094">mlir::arith::WideIntEmulationConverter::WideIntEmulationConverter()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00472">mlir::detail::wrapIntegerMemorySpace()</a>, and <a class="el" href="GPUOpsLowering_8cpp_source.html#l00500">wrapNumericMemorySpace()</a>.</p>

</div>
</div>
<a id="a6e8a0f44c623301035b6151ca51cca4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8a0f44c623301035b6151ca51cca4d">&#9670;&nbsp;</a></span>getAffineBinaryOpExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineBinaryOpExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00047">47</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01610">createDimSizeExprForTiledLayout()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00120">mlirAffineAddExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00173">mlirAffineCeilDivExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00159">mlirAffineFloorDivExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00146">mlirAffineModExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00133">mlirAffineMulExprGet()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00134">mlir::AffineExpr::replace()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00066">mlir::AffineExpr::replaceDimsAndSymbols()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00537">simplifyAdd()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00840">simplifyExprAndOperands()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00452">simplifySemiAffine()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00459">mlir::affine::substWithMin()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00395">symbolicDivide()</a>.</p>

</div>
</div>
<a id="ab26cdced424aa629fde4150cc8674d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26cdced424aa629fde4150cc8674d50">&#9670;&nbsp;</a></span>getAffineConstantExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineConstantExpr </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>constant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00527">527</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="StorageUniquer_8h_source.html#l00195">mlir::StorageUniquer::get()</a>, and <a class="el" href="MLIRContext_8cpp_source.html#l01098">mlir::MLIRContext::getAffineUniquer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01483">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00821">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00506">mlir::AffineMap::compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01125">composeAffineMapAndOperands()</a>, <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00152">computeMaxLinearIndex()</a>, <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00140">computeSuffixProduct()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00063">createInBoundsCond()</a>, <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00181">delinearize()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00336">detectAsFloorDiv()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00226">detectAsMod()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00778">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="Builders_8cpp_source.html#l00347">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00904">getAffineExprFromFlatForm()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00742">mlir::FlatLinearConstraints::getAsIntegerSet()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00102">mlir::AffineMap::getConstantMap()</a>, <a class="el" href="mlir_2IR_2IntegerSet_8h_source.html#l00056">mlir::IntegerSet::getEmptySet()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00947">getSemiAffineExprFromFlatForm()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00455">mlir::FlatLinearConstraints::getSliceBounds()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00727">getStridesAndOffset()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00142">mlir::vector::getTransferMinorIdentityMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00691">inverseAndBroadcastProjectedPermutation()</a>, <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00161">linearize()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00894">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00068">makePermutationMap()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01752">makeStridedLinearLayoutMap()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00104">mlirAffineConstantExprGet()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00877">mlir::AffineExpr::operator%()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00712">mlir::AffineExpr::operator*()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00652">mlir::AffineExpr::operator+()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00725">mlir::AffineExpr::operator-()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00523">mlir::AffineExpr::operator==()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00384">mlir::AffineMap::partialConstantFold()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00734">projectCommonImpl()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00113">replaceUnitDims()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00373">replaceUnitExtents()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00537">simplifyAdd()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00791">simplifyCeilDiv()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00840">simplifyExprAndOperands()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00735">simplifyFloorDiv()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00943">simplifyMinOrMaxExprWithOperands()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00834">simplifyMod()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00665">simplifyMul()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00452">simplifySemiAffine()</a>, <a class="el" href="VectorUnroll_8cpp_source.html#l00101">sliceTransferIndices()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00395">symbolicDivide()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00144">transferReadSupportsMMAMatrixType()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01179">mlir::SimpleAffineExprFlattener::visitModExpr()</a>.</p>

</div>
</div>
<a id="addfd4323ef72147332661606b030d04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfd4323ef72147332661606b030d04d">&#9670;&nbsp;</a></span>getAffineDimExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineDimExpr </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These free functions allow clients of the API to not use classes in detail. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00502">502</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133ab49b848e4bb608f4d5650e4b2817c641">DimId</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00491">getAffineDimOrSymbol()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerVectorContract_8cpp_source.html#l00069">adjustMap()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00310">mlir::detail::bindDims()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00334">bindDimsList()</a>, <a class="el" href="VectorDistribute_8cpp_source.html#l00035">calculateImplicitMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01483">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01440">canonicalizePromotedSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00482">mlir::AffineMap::compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01125">composeAffineMapAndOperands()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00713">mlir::FlatLinearConstraints::computeLocalVars()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00804">mlir::linalg::computeTileSizes()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00133">convertReassociationIndicesToExprs()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00063">createInBoundsCond()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00515">elementwiseMatchAndRewriteHelper()</a>, <a class="el" href="Builders_8cpp_source.html#l00339">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00904">getAffineExprFromFlatForm()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01305">getCollapsedOpIndexingMap()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00948">getDimMap()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00850">mlir::FlatLinearValueConstraints::getHyperrectangular()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00238">mlir::nvgpu::getLaneIdToLdMatrixMatrixCoord()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00262">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00212">mlir::AffineMap::getPermutationMap()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00947">getSemiAffineExprFromFlatForm()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00455">mlir::FlatLinearConstraints::getSliceBounds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00691">inverseAndBroadcastProjectedPermutation()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00667">inversePermutation()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00293">mlir::AffineExpr::isFunctionOfDim()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01780">mlir::linalg::makeAffineDimExprs()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00926">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00068">makePermutationMap()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01752">makeStridedLinearLayoutMap()</a>, <a class="el" href="Transforms_8cpp_source.html#l01038">mlir::linalg::PadOpTransformationPattern::matchAndRewrite()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00072">mlirAffineDimExprGet()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00734">projectCommonImpl()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01077">replaceDimOrSym()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00113">replaceUnitDims()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00110">mlir::AffineExpr::shiftDims()</a>, <a class="el" href="VectorUnroll_8cpp_source.html#l00101">sliceTransferIndices()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00542">mlir::sparse_tensor::toStoredDim()</a>, and <a class="el" href="VectorToGPU_8cpp_source.html#l00144">transferReadSupportsMMAMatrixType()</a>.</p>

</div>
</div>
<a id="a8ad71c14bebce843758768ff160e2283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad71c14bebce843758768ff160e2283">&#9670;&nbsp;</a></span>getAffineExprFromFlatForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineExprFromFlatForm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>flatExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>localExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an affine expression from a flat ArrayRef. </p>
<p>If there are local identifiers (neither dimensional nor symbolic) that appear in the sum of products expression, 'localExprs' is expected to have the <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> for it, and is substituted into. The ArrayRef 'eq' is expected to be in the format [dims, symbols, locals, constant term].</p>
<p>If there are local identifiers (neither dimensional nor symbolic) that appear in the sum of products expression, <code>localExprs</code> is expected to have the <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> for it, and is substituted into. The ArrayRef <code>flatExprs</code> is expected to be in the format [dims, symbols, locals, constant term]. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00904">904</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00527">getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00502">getAffineDimExpr()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00512">getAffineSymbolExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00742">mlir::FlatLinearConstraints::getAsIntegerSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00312">mlir::affine::FlatAffineValueConstraints::getIneqAsAffineValueMap()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00366">mlir::FlatLinearConstraints::getLowerAndUpperBound()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01407">simplifyAffineExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01179">mlir::SimpleAffineExprFlattener::visitModExpr()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01130">mlir::SimpleAffineExprFlattener::visitMulExpr()</a>.</p>

</div>
</div>
<a id="aefb7ba5a55b4f16631528884d3617a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb7ba5a55b4f16631528884d3617a47">&#9670;&nbsp;</a></span>getAffineSymbolExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineSymbolExpr </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00512">512</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00491">getAffineDimOrSymbol()</a>, and <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133aea00d3c6059a4ff11d351696747fc7ff">SymbolId</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00319">mlir::detail::bindSymbols()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00348">bindSymbolsList()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01483">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01440">canonicalizePromotedSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00482">mlir::AffineMap::compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01125">composeAffineMapAndOperands()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00713">mlir::FlatLinearConstraints::computeLocalVars()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00683">mlir::linalg::computeSliceParameters()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00904">getAffineExprFromFlatForm()</a>, <a class="el" href="Builders_8cpp_source.html#l00343">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00947">getSemiAffineExprFromFlatForm()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00455">mlir::FlatLinearConstraints::getSliceBounds()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00304">mlir::AffineExpr::isFunctionOfSymbol()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00894">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01752">makeStridedLinearLayoutMap()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00088">mlirAffineSymbolExprGet()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00734">projectCommonImpl()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01077">replaceDimOrSym()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00113">replaceUnitDims()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00122">mlir::AffineExpr::shiftSymbols()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00468">mlir::linalg::updateBoundsForCyclicDistribution()</a>.</p>

</div>
</div>
<a id="aa18214f3aabbab8c3e5197b719ba72dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18214f3aabbab8c3e5197b719ba72dc">&#9670;&nbsp;</a></span>getAsIndexOpFoldResult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::getAsIndexOpFoldResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00110">110</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00106">getAsIndexOpFoldResult()</a>.</p>

</div>
</div>
<a id="a0c18958fe34840cfafad41a1226f7a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c18958fe34840cfafad41a1226f7a68">&#9670;&nbsp;</a></span>getAsIndexOpFoldResult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::getAsIndexOpFoldResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert int64_t to integer attributes of index type and return them as <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00106">106</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00368">get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StaticValueUtils_8cpp_source.html#l00110">getAsIndexOpFoldResult()</a>, and <a class="el" href="GPUTransformOps_8cpp_source.html#l00765">mlir::transform::gpu::mapNestedForallToThreadsImpl()</a>.</p>

</div>
</div>
<a id="a622f03f8cb8e4cfde7e34c30e9aa02b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622f03f8cb8e4cfde7e34c30e9aa02b6">&#9670;&nbsp;</a></span>getAsOpFoldResult() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::getAsOpFoldResult </td>
          <td>(</td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>arrayAttr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert <code>arrayAttr</code> to a vector of <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00098">98</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

</div>
</div>
<a id="ac19b7af1333485b34ebfe4bf6300c362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19b7af1333485b34ebfe4bf6300c362">&#9670;&nbsp;</a></span>getAsOpFoldResult() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::getAsOpFoldResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a value, try to extract a constant <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>. </p>
<p>If this fails, return the original value. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00081">81</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00287">m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00378">matchPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StaticValueUtils_8cpp_source.html#l00092">getAsOpFoldResult()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00086">getBoundedTileSize()</a>, <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00154">InsertSliceOfInsertSliceFolder&lt; OpTy &gt;::matchAndRewrite()</a>, <a class="el" href="Transforms_8cpp_source.html#l01388">mlir::linalg::GeneralizeOuterUnitDimsUnPackOpPattern::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01397">replaceConstantUsesOf()</a>, and <a class="el" href="ViewLikeInterfaceUtils_8h_source.html#l00082">mlir::affine::resolveIndicesIntoOpWithOffsetsAndStrides()</a>.</p>

</div>
</div>
<a id="a0f4688956ac5cd539b0b3e134af30248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4688956ac5cd539b0b3e134af30248">&#9670;&nbsp;</a></span>getAsOpFoldResult() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::getAsOpFoldResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an array of values, try to extract a constant <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> from each value. </p>
<p>If this fails, return the original value. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00092">92</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00081">getAsOpFoldResult()</a>.</p>

</div>
</div>
<a id="aeb0562ab78d537c81de4f7c55795c42d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0562ab78d537c81de4f7c55795c42d">&#9670;&nbsp;</a></span>getBackwardSlice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getBackwardSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *&#160;</td>
          <td class="paramname"><em>backwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills <code>backwardSlice</code> with the computed backward slice (i.e. </p>
<p>all the transitive defs of op), <b>without</b> including that operation.</p>
<p>This additionally takes a TransitiveFilter which acts as a frontier: when looking at defs transitively, an operation that does not pass the filter is never propagated through. This allows in particular to carve out the scope within a ForOp or the scope within an IfOp.</p>
<p>The implementation traverses the def chains in postorder traversal for efficiency reasons: if an operation is already in <code>backwardSlice</code>, no need to traverse its definitions again. Since useuse-def chains form a DAG, this terminates.</p>
<p>Upon return to the root call, <code>backwardSlice</code> is filled with a postorder list of defs. This happens to be a topological order, from the point of view of the use-def chains.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Example starting from node 8</h1>
<p>1 2 3 4 |_______| |______| | | | | 5 6 |___|_____________| | | 7 8 |_______________| | 9</p>
<p>Assuming all local orders match the numbering order: {1, 2, 5, 3, 4, 6} </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00117">117</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SliceAnalysis_8cpp_source.html#l00223">dependsOnCarriedVals()</a>, and <a class="el" href="SliceAnalysis_8cpp_source.html#l00129">getBackwardSlice()</a>.</p>

</div>
</div>
<a id="a65e9895417040ce49f83fc36f100ee72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e9895417040ce49f83fc36f100ee72">&#9670;&nbsp;</a></span>getBackwardSlice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getBackwardSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *&#160;</td>
          <td class="paramname"><em>backwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value-rooted version of <code>getBackwardSlice</code>. </p>
<p>Return the union of all backward slices for the op defining or owning the value <code>root</code>. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00129">129</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00113">mlir::Value::cast()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00117">getBackwardSlice()</a>, and <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>.</p>

</div>
</div>
<a id="a22bfcc5fa9deffb32e7c39183f732c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bfcc5fa9deffb32e7c39183f732c90">&#9670;&nbsp;</a></span>getConstantIntValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; int64_t &gt; mlir::getConstantIntValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If ofr is a constant integer or an IntegerAttr, return the integer. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00117">117</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Attributes_8h_source.html#l00171">mlir::Attribute::dyn_cast_or_null()</a>, <a class="el" href="Matchers_8h_source.html#l00401">m_ConstantInt()</a>, and <a class="el" href="Matchers_8h_source.html#l00378">matchPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00079">mlir::scf::addLoopRangeConstraints()</a>, <a class="el" href="TensorOps_8cpp_source.html#l03559">asShapeWithAnyValueAsDynamic()</a>, <a class="el" href="Tiling_8cpp_source.html#l00218">canOmitTileOffsetInBoundsCheck()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00683">mlir::linalg::computeSliceParameters()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00234">constantTripCount()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00155">constifyIndexValues()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00086">getBoundedTileSize()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00077">mlir::ValueBoundsConstraintSet::getExpr()</a>, <a class="el" href="Transforms_8cpp_source.html#l01209">getPackOpSourceOrPaddedSource()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00276">getSlicedDimensions()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00133">isConstantIntValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00330">isDimOpValidSymbol()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00142">isEqualConstantIntOrValue()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02996">isTrivialSubViewOp()</a>, <a class="el" href="Transforms_8cpp_source.html#l01302">mlir::linalg::GeneralizeOuterUnitDimsPackOpPattern::matchAndRewrite()</a>, <a class="el" href="Transforms_8cpp_source.html#l00736">mlir::linalg::pack()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00119">peelForLoop()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00071">tileDividesIterationDomain()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01600">GenericPadOpVectorizationPattern::tryVectorizeCopy()</a>.</p>

</div>
</div>
<a id="a252aee27751e05d584d0b1a8e793ecf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252aee27751e05d584d0b1a8e793ecf0">&#9670;&nbsp;</a></span>getElementTypeOrSelf() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::getElementTypeOrSelf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the element type or return the type itself. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00034">34</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Attributes_8h_source.html#l00166">mlir::Attribute::dyn_cast()</a>, and <a class="el" href="TypeUtilities_8cpp_source.html#l00024">getElementTypeOrSelf()</a>.</p>

</div>
</div>
<a id="a82686ceb29eb0f78b59e29021f1b2cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82686ceb29eb0f78b59e29021f1b2cdd">&#9670;&nbsp;</a></span>getElementTypeOrSelf() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::getElementTypeOrSelf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the element type or return the type itself. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00024">24</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00311">mlir::Type::dyn_cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00507">broadcastIfNeeded()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00612">buildGenericRegion()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00546">buildVectorWrite()</a>, <a class="el" href="Arith_2Transforms_2ExpandOps_8cpp_source.html#l00027">createConst()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00026">createFloatConst()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00038">createIntConst()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00515">elementwiseMatchAndRewriteHelper()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00254">exp2I32()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00060">fillStructuredOpRegion()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00213">frexp()</a>, <a class="el" href="Traits_8cpp_source.html#l00133">mlir::OpTrait::util::getBroadcastedType()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00030">getElementTypeOrSelf()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00082">getScalarOrElementWidth()</a>, <a class="el" href="ArithOps_8cpp_source.html#l01094">getUnderlyingType()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01948">mlir::vector::isBroadcastableTo()</a>, <a class="el" href="Transforms_8cpp_source.html#l00480">mlir::linalg::lowerPack()</a>, <a class="el" href="Transforms_8cpp_source.html#l00736">mlir::linalg::pack()</a>, <a class="el" href="Transforms_8cpp_source.html#l00056">padOperandToSmallestStaticBoundingBox()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01159">vectorizeAsLinalgGeneric()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01528">mlir::linalg::vectorizeCopy()</a>.</p>

</div>
</div>
<a id="ae81d443c449b61825fb2c2ec6aa90d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81d443c449b61825fb2c2ec6aa90d35">&#9670;&nbsp;</a></span>getElementTypeOrSelf() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::getElementTypeOrSelf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00030">30</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeUtilities_8cpp_source.html#l00024">getElementTypeOrSelf()</a>, and <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a59222c6d1f54e57a5f71291f205911da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59222c6d1f54e57a5f71291f205911da">&#9670;&nbsp;</a></span>getEnclosingRepetitiveRegion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Region.html">Region</a> * mlir::getEnclosingRepetitiveRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first enclosing region of the given op that may be executed repetitively as per RegionBranchOpInterface or <code>nullptr</code> if no such region exists. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00332">332</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotAnalysis_8cpp_source.html#l00384">canUseOpDominance()</a>.</p>

</div>
</div>
<a id="abea4281da1b0006e0c9622cff14858a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea4281da1b0006e0c9622cff14858a7">&#9670;&nbsp;</a></span>getEnclosingRepetitiveRegion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Region.html">Region</a> * mlir::getEnclosingRepetitiveRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first enclosing region of the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> that may be executed repetitively as per RegionBranchOpInterface or <code>nullptr</code> if no such region exists. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00342">342</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00041">mlir::Value::getParentRegion()</a>.</p>

</div>
</div>
<a id="a787e2019eb81129624ee13f365dcfd03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787e2019eb81129624ee13f365dcfd03">&#9670;&nbsp;</a></span>getFlattenedAffineExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getFlattenedAffineExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>flattenedExpr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a> *&#160;</td>
          <td class="paramname"><em>cst</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens 'expr' into 'flattenedExpr', which contains the coefficients of the dimensions, symbols, and additional variables that represent floor divisions of dimensions, symbols, and in turn other floor divisions. </p>
<p>Returns failure if 'expr' could not be flattened (i.e., semi-affine is not yet handled). 'cst' contains constraints that connect newly introduced local variables to existing dimensional and symbolic variables. See documentation for AffineExprFlattener on how mod's and div's are flattened. </p>

<p class="definition">Definition at line <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00106">106</a> of file <a class="el" href="FlatLinearValueConstraints_8cpp_source.html">FlatLinearValueConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00119">getFlattenedAffineExprs()</a>.</p>

</div>
</div>
<a id="a9cb13d4a8ddc5d1ed24afc4287ffc60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb13d4a8ddc5d1ed24afc4287ffc60d">&#9670;&nbsp;</a></span>getFlattenedAffineExprs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getFlattenedAffineExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>flattenedExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a> *&#160;</td>
          <td class="paramname"><em>localVarCst</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens the result expressions of the map to their corresponding flattened forms and set in 'flattenedExprs'. </p>
<p>Flattens the expressions in map.</p>
<p>Returns failure if any expression in the map could not be flattened (i.e., semi-affine is not yet handled). 'cst' contains constraints that connect newly introduced local variables to existing dimensional and / symbolic variables. See documentation for AffineExprFlattener on how mod's and div's are flattened. For all affine expressions that share the same operands (like those of an affine map), this method should be used instead of repeatedly calling getFlattenedAffineExpr since local variables added to deal with div's and mod's will be reused across expressions.</p>
<p>Returns failure if 'expr' was unable to be flattened (i.e., semi-affine expressions not handled yet). </p>

<p class="definition">Definition at line <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00119">119</a> of file <a class="el" href="FlatLinearValueConstraints_8cpp_source.html">FlatLinearValueConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00072">getFlattenedAffineExprs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00324">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00332">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00328">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00337">mlir::AffineMap::getResults()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00800">mlir::FlatLinearValueConstraints::FlatLinearValueConstraints()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00628">mlir::FlatLinearConstraints::flattenAlignedMapAndMergeLocals()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00106">getFlattenedAffineExpr()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01318">getMultiAffineFunctionFromMap()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00493">mlir::affine::getRelationFromMap()</a>.</p>

</div>
</div>
<a id="a99d3ec2b375b73649766ce133c49aa1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d3ec2b375b73649766ce133c49aa1e">&#9670;&nbsp;</a></span>getFlattenedAffineExprs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getFlattenedAffineExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>flattenedExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a> *&#160;</td>
          <td class="paramname"><em>cst</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00133">133</a> of file <a class="el" href="FlatLinearValueConstraints_8cpp_source.html">FlatLinearValueConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00041">mlir::IntegerSet::getConstraints()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00072">getFlattenedAffineExprs()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00021">mlir::IntegerSet::getNumConstraints()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00015">mlir::IntegerSet::getNumDims()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00016">mlir::IntegerSet::getNumSymbols()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="a46bbb7497276c5ea7e8ed4ad1315bf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46bbb7497276c5ea7e8ed4ad1315bf40">&#9670;&nbsp;</a></span>getFlattenedTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, 10 &gt; mlir::getFlattenedTypes </td>
          <td>(</td>
          <td class="paramtype">TupleType&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the types within a nested Tuple. </p>
<p>A helper for the class method that handles storage concerns, which is tricky to do in tablegen. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00040">40</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

</div>
</div>
<a id="ac046ca544c3373919620bd8c704f95e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac046ca544c3373919620bd8c704f95e4">&#9670;&nbsp;</a></span>getForwardSlice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getForwardSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *&#160;</td>
          <td class="paramname"><em>forwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills <code>forwardSlice</code> with the computed forward slice (i.e. </p>
<p>all the transitive uses of op), <b>without</b> including that operation.</p>
<p>This additionally takes a TransitiveFilter which acts as a frontier: when looking at uses transitively, an operation that does not pass the filter is never propagated through. This allows in particular to carve out the scope within a ForOp or the scope within an IfOp.</p>
<p>The implementation traverses the use chains in postorder traversal for efficiency reasons: if an operation is already in <code>forwardSlice</code>, no need to traverse its uses again. Since use-def chains form a DAG, this terminates.</p>
<p>Upon return to the root call, <code>forwardSlice</code> is filled with a postorder list of uses (i.e. a reverse topological order). To get a proper topological order, we just just reverse the order in <code>forwardSlice</code> before returning.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Example starting from node 0</h1>
<pre class="fragment">          0
</pre><p> ___________|___________ 1 2 3 4 |_______| |______| | | | | 5 6 |___|_____________| | | 7 8 |_______________| | 9</p>
<p>Assuming all local orders match the numbering order:</p><ol type="1">
<li>after getting back to the root getForwardSlice, <code>forwardSlice</code> may contain: {9, 7, 8, 5, 1, 2, 6, 3, 4}</li>
<li>reversing the result of 1. gives: {4, 3, 6, 2, 1, 5, 8, 7, 9} </li>
</ol>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00053">53</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00798">hoistOpsBetween()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00079">mlir::linalg::hoistRedundantVectorTransfers()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00358">promoteSingleIterReductionLoop()</a>.</p>

</div>
</div>
<a id="a104c4215efb1da3eeadeb9d21a3f70d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104c4215efb1da3eeadeb9d21a3f70d1">&#9670;&nbsp;</a></span>getForwardSlice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getForwardSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *&#160;</td>
          <td class="paramname"><em>forwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value-rooted version of <code>getForwardSlice</code>. </p>
<p>Return the union of all forward slices for the uses of the value <code>root</code>. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00069">69</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00027">getForwardSliceImpl()</a>, and <a class="el" href="Value_8h_source.html#l00217">mlir::Value::getUsers()</a>.</p>

</div>
</div>
<a id="a84637d8636fade36ebdd466b38527c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84637d8636fade36ebdd466b38527c23">&#9670;&nbsp;</a></span>getI64SubArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; mlir::getI64SubArray </td>
          <td>(</td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>arrayAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dropFront</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dropBack</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to return a subset of <code>arrayAttr</code> as a vector of int64_t. </p>

<p class="definition">Definition at line <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00237">237</a> of file <a class="el" href="Utils_2IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="CRunnerUtils_8h_source.html#l00118">dropFront()</a>.</p>

</div>
</div>
<a id="a820f3296c3cd59eaed418f42f874a217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820f3296c3cd59eaed418f42f874a217">&#9670;&nbsp;</a></span>getInnermostParallelLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::getInnermostParallelLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>rootOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; scf::ParallelOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of innermost parallel loops contained in <code>rootOp</code>. </p>
<p>Innermost parallel loops are those that do not contain further parallel loops themselves. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00314">314</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00638">mlir::Operation::getRegions()</a>.</p>

</div>
</div>
<a id="ace39a548030ae8416f5ae52af1eb24e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace39a548030ae8416f5ae52af1eb24e1">&#9670;&nbsp;</a></span>getLinearizedDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallBitVector mlir::getLinearizedDimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociationIndices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine which dimensions are linearized by a <code>tensor.collapse_shape</code> op by inspecting its reassociation indices. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00293">293</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>.</p>

</div>
</div>
<a id="a74485bec820f2186ce852a09f45ebd47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74485bec820f2186ce852a09f45ebd47">&#9670;&nbsp;</a></span>getMaxDimAndSymbol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AffineExprContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mlir::getMaxDimAndSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineExprContainer &gt;&#160;</td>
          <td class="paramname"><em>exprsList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>maxDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>maxSym</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates maximum dimension and symbol positions from the expressions in <code>exprsLists</code> and stores them in <code>maxDim</code> and <code>maxSym</code> respectively. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00631">631</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00199">max()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00227">inferFromExprList()</a>, and <a class="el" href="MLIRContext_8cpp_source.html#l01118">willBeValidAffineMap()</a>.</p>

</div>
</div>
<a id="abe07ed04a2b4a8d370ba318bb94316a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe07ed04a2b4a8d370ba318bb94316a2">&#9670;&nbsp;</a></span>getMixedValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::getMixedValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>staticValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>dynamicValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector of OpFoldResults with the same size a staticValues, but all elements for which ShapedType::isDynamic is true, will be replaced by dynamicValues. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00163">163</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00125">mlir::Builder::getI64IntegerAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Utils_2IndexingUtils_8cpp_source.html#l00074">mlir::linalg::getMixedDimensions()</a>.</p>

</div>
</div>
<a id="aeb248e9fd529c9528e4e235a52941e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb248e9fd529c9528e4e235a52941e67">&#9670;&nbsp;</a></span>getMultiAffineFunctionFromMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getMultiAffineFunctionFromMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1presburger_1_1MultiAffineFunction.html">presburger::MultiAffineFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>multiAff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01318">1318</a> of file <a class="el" href="FlatLinearValueConstraints_8cpp_source.html">FlatLinearValueConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00044">mlir::LogicalResult::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00119">getFlattenedAffineExprs()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00918">mlir::presburger::IntegerRelation::getLocalReprs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00324">mlir::AffineMap::getNumDims()</a>, <a class="el" href="Analysis_2Presburger_2Utils_8h_source.html#l00126">mlir::presburger::DivisionRepr::getNumDivs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00333">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00332">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00328">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="Analysis_2Presburger_2Utils_8h_source.html#l00134">mlir::presburger::DivisionRepr::hasAllReprs()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="a27f0d71a753f94ea84efabe636ea4da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f0d71a753f94ea84efabe636ea4da7">&#9670;&nbsp;</a></span>getMutableRegionBranchSuccessorOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1MutableOperandRange.html">MutableOperandRange</a> &gt; mlir::getMutableRegionBranchSuccessorOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>regionIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the mutable operands that are passed to the region with the given <code>regionIndex</code>. </p>
<p>If the operation does not implement the <code>RegionBranchTerminatorOpInterface</code> and is not marked as <code>ReturnLike</code>, the result will be <code>std::nullopt</code>. In all other cases, the resulting <code><a class="el" href="classmlir_1_1OperandRange.html" title="This class implements the operand iterators for the Operation class.">OperandRange</a></code> represents all operands that are passed to the specified successor region. If <code>regionIndex</code> is <code>std::nullopt</code>, all operands that are passed to the parent operation will be returned. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00373">373</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00690">mlir::Operation::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00394">getRegionBranchSuccessorOperands()</a>.</p>

</div>
</div>
<a id="a0d96a98d184d13853b53c410d814775c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d96a98d184d13853b53c410d814775c">&#9670;&nbsp;</a></span>getOffsetsSizesAndStrides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt; mlir::getOffsetsSizesAndStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>ranges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an array of <a class="el" href="structmlir_1_1Range.html" title="Represents a range (offset, size, and stride) where each element of the triple may be dynamic or stat...">Range</a> values, return a tuple of (offset vector, sizes vector, and strides vector) formed by separating out the individual elements of each range. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00032">32</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

</div>
</div>
<a id="a45e134959101de052e7dbfd12610b5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e134959101de052e7dbfd12610b5d6">&#9670;&nbsp;</a></span>getOrCreateRanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a>, 8 &gt; mlir::getOrCreateRanges </td>
          <td>(</td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the list of <a class="el" href="structmlir_1_1Range.html" title="Represents a range (offset, size, and stride) where each element of the triple may be dynamic or stat...">Range</a> (i.e. </p>
<p>offset, size, stride). Each <a class="el" href="structmlir_1_1Range.html" title="Represents a range (offset, size, and stride) where each element of the triple may be dynamic or stat...">Range</a> entry contains either the dynamic value or a ConstantIndexOp constructed with <code>b</code> at location <code>loc</code>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02883">2883</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

</div>
</div>
<a id="a002c6258ba17b3a08e25cde241861c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002c6258ba17b3a08e25cde241861c3f">&#9670;&nbsp;</a></span>getPerfectlyNestedLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getPerfectlyNestedLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; scf::ForOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>nestedLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get perfectly nested sequence of loops starting at root of loop nest (the first op being another AffineFor, and the second op - a terminator). </p>
<p>A loop is perfectly nested iff: the first op in the loop's body is another AffineForOp, and the second op is a terminator). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00962">962</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00862">getPerfectlyNestedLoopsImpl()</a>.</p>

</div>
</div>
<a id="ac1bdf7e87740dbe0f603efdbc83c0a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1bdf7e87740dbe0f603efdbc83c0a68">&#9670;&nbsp;</a></span>getPositionsOfShapeOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallBitVector mlir::getPositionsOfShapeOne </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00045">45</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a id="ab45e3ce76869b05848f96a5f8b97fc90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45e3ce76869b05848f96a5f8b97fc90">&#9670;&nbsp;</a></span>getProjectedMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::getProjectedMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>projectedDimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressDimsFlag</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressSymbolsFlag</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <code>projectDims(map, projectedDimensions, compressDimsFlag)</code>. </p>
<p>If <code>compressSymbolsFlag</code> is true, additionally call <code>compressUnusedSymbols</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00794">794</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00639">compressUnusedSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00780">projectDims()</a>.</p>

</div>
</div>
<a id="aeba376b9b63ed400e64bb041e459a62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba376b9b63ed400e64bb041e459a62e">&#9670;&nbsp;</a></span>getPrunedAttributeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &gt; mlir::getPrunedAttributeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt;&#160;</td>
          <td class="paramname"><em>elidedAttrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00120">120</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00453">mlir::tensor::bubbleUpPadSlice()</a>.</p>

</div>
</div>
<a id="a12acf2020ef95ce0a5d7c3f2bbb6af14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12acf2020ef95ce0a5d7c3f2bbb6af14">&#9670;&nbsp;</a></span>getReassociationAttrName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getReassociationAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> name for the ArrayAttr which encodes reassociation indices. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00031">31</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

</div>
</div>
<a id="a8ecbdeef85cdbc2ce3b49a088fa5946a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecbdeef85cdbc2ce3b49a088fa5946a">&#9670;&nbsp;</a></span>getReassociationIndicesAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrayAttr mlir::getReassociationIndicesAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a list of reassociations in an ArrayAttr. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00160">160</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00259">mlir::Builder::getArrayAttr()</a>, and <a class="el" href="Builders_8cpp_source.html#l00274">mlir::Builder::getI64ArrayAttr()</a>.</p>

</div>
</div>
<a id="a76b303e750705222900d23e44f2a22ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b303e750705222900d23e44f2a22ce">&#9670;&nbsp;</a></span>getReassociationIndicesForCollapse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; &gt; mlir::getReassociationIndicesForCollapse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sourceShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>targetShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the reassociation maps to collapse <code>sourceShape</code> to <code>targetShape</code> if possible. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00032">32</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00020">getReassociationIndicesForReshape()</a>.</p>

</div>
</div>
<a id="a6783c78835273b8062a5b5e2a710d863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6783c78835273b8062a5b5e2a710d863">&#9670;&nbsp;</a></span>getReassociationIndicesForReshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; &gt; mlir::getReassociationIndicesForReshape </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>sourceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>targetType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the reassociations maps to use to reshape given the source type and the target type when possible. </p>
<p>Return std::nullopt when this computation failed. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00020">20</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00032">getReassociationIndicesForCollapse()</a>.</p>

</div>
</div>
<a id="a5e4b4f99b16bb38cda262c81fd2ad933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4b4f99b16bb38cda262c81fd2ad933">&#9670;&nbsp;</a></span>getRegionBranchSuccessorOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a> &gt; mlir::getRegionBranchSuccessorOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>regionIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the read only operands that are passed to the region with the given <code>regionIndex</code>. </p>
<p>See <code>getMutableRegionBranchSuccessorOperands</code> for more information. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00394">394</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00373">getMutableRegionBranchSuccessorOperands()</a>.</p>

</div>
</div>
<a id="ab22ed238130b85dadcd9f75892b540b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22ed238130b85dadcd9f75892b540b1">&#9670;&nbsp;</a></span>getSCFMinMaxExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::pair&lt;<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&gt; &gt; mlir::getSCFMinMaxExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>loopFilter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the min/max expressions for <code>value</code> if it is an induction variable from scf.for or scf.parallel loop. </p>
<p>if <code>loopFilter</code> is passed, the filter determines which loop to consider. Other induction variables are ignored. </p>

</div>
</div>
<a id="a03521cb5a2e00b91574ef1df705310bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03521cb5a2e00b91574ef1df705310bd">&#9670;&nbsp;</a></span>getSinglyExecutedRegionsToSink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getSinglyExecutedRegionsToSink </td>
          <td>(</td>
          <td class="paramtype">RegionBranchOpInterface&#160;</td>
          <td class="paramname"><em>branch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>regions</code> with regions of the provided region branch op that are executed at most once at that are reachable given the current operands of the op. </p>
<p>These regions can be passed to <code>controlFlowSink</code> to perform sinking on the regions of the operation. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowSinkUtils_8cpp_source.html#l00135">135</a> of file <a class="el" href="ControlFlowSinkUtils_8cpp_source.html">ControlFlowSinkUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00204">mlir::InvocationBounds::getUpperBound()</a>, <a class="el" href="Matchers_8h_source.html#l00287">m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00378">matchPattern()</a>.</p>

</div>
</div>
<a id="a8315b4bdb757698beea82cf7535dae7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8315b4bdb757698beea82cf7535dae7d">&#9670;&nbsp;</a></span>getSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::getSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a>&#160;</td>
          <td class="paramname"><em>backwardFilter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a>&#160;</td>
          <td class="paramname"><em>forwardFilter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iteratively computes backward slices and forward slices until a fixed point is reached. </p>
<p>Returns an <code>SetVector&lt;<a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> *&gt;</code> which <b>includes</b> the original operation.</p>
<p>This allows building a slice (i.e. multi-root DAG where everything that is reachable from an <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> in forward and backward direction is contained in the slice). This is the abstraction we need to materialize all the operations for supervectorization without worrying about orderings and <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> replacements.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Example starting from any node</h1>
<p>1 2 3 4 |_______| |______| | | | | | 5 6___| |___|_____________| | | | | 7 8 | |_______________| | | | 9 10</p>
<p>Return the whole DAG in some topological order.</p>
<p>The implementation works by just filling up a worklist with iterative alternate calls to <code>getBackwardSlice</code> and <code>getForwardSlice</code>.</p>
<p>The following section describes some additional implementation considerations for a potentially more efficient implementation but they are just an intuition without proof, we still use a worklist for now.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Additional implementation considerations</h1>
<p>Consider the defs-op-uses hourglass. </p><hr  />
<p> \ / defs (in some topological order) \/ op /\ / \ uses (in some topological order) /____\</p>
<p>We want to iteratively apply <code>getSlice</code> to construct the whole list of <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> that are reachable by (use|def)+ from op. We want the resulting slice in topological order. Ideally we would like the ordering to be maintained in-place to avoid copying <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> at each step. Keeping this ordering by construction seems very unclear, so we list invariants in the hope of seeing whether useful properties pop up.</p>
<p>In the following: we use |= for set inclusion; we use &lt;&lt; for set topological ordering (i.e. each pair is ordered).</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Assumption:</h1>
<p>We wish to maintain the following property by a recursive argument: """ defs &lt;&lt; {op} &lt;&lt;uses are in topological order. """ The property clearly holds for 0 and 1-sized uses and defs;</p>
<p>Invariants:</p><ol type="1">
<li>defs and uses are in topological order internally, by construction;</li>
<li>for any {x} |= defs, defs(x) |= defs; because all go through op</li>
<li>for any {x} |= uses, defs |= defs(x); because all go through op</li>
<li>for any {x} |= defs, uses |= uses(x); because all go through op</li>
<li>for any {x} |= uses, uses(x) |= uses; because all go through op</li>
</ol>
<p>Intuitively, we should be able to recurse like: preorder(defs) - op - postorder(uses) and keep things ordered but this is still hand-wavy and not worth the trouble for now: punt to a simple worklist-based solution. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00139">139</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

</div>
</div>
<a id="a10337918edd90e6a270db09d71d66dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10337918edd90e6a270db09d71d66dc5">&#9670;&nbsp;</a></span>getSlicedDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallBitVector mlir::getSlicedDimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sliceInputShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>sliceParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The input parameters <code>offsets</code>, <code>sizes</code>, <code>strides</code> specify a rectangular non rank-reducing slice of the collapse_shape output. </p>
<p>Try to find which dimensions have been sliced and which dimensions are not sliced (offset = 0, size = dim, size = 1). Note that this conservative as it cannot detect if a dynamic size corresponds to the full tensor dimension or not. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00276">276</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00117">getConstantIntValue()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00142">isEqualConstantIntOrValue()</a>.</p>

</div>
</div>
<a id="a91209454b6a2bc993c1d3ebc2ac3aab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91209454b6a2bc993c1d3ebc2ac3aab1">&#9670;&nbsp;</a></span>getStridesAndOffset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;, int64_t &gt; mlir::getStridesAndOffset </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around getStridesAndOffset(MemRefType, SmallVectorImpl&lt;int64_t&gt;, int64_t) that will assert if the logical result is not succeeded. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00815">815</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00785">getStridesAndOffset()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00068">succeeded()</a>.</p>

</div>
</div>
<a id="a506c478f802ab2f874c0b34a18bc091b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506c478f802ab2f874c0b34a18bc091b">&#9670;&nbsp;</a></span>getStridesAndOffset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getStridesAndOffset </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the strides of the MemRef if the layout map is in strided form. </p>
<p>MemRefs with a layout map in strided form include:</p><ol type="1">
<li>empty or identity layout map, in which case the stride information is the canonical form computed from sizes;</li>
<li>a StridedLayoutAttr layout;</li>
<li>any other layout that be converted into a single affine map layout of the form <code>K + k0 * d0 + ... kn * dn</code>, where K and ki's are constants or symbols.</li>
</ol>
<p>A stride specification is a list of integer values that are either static or dynamic (encoded with ShapedType::kDynamic). Strides encode the distance in the number of elements between successive entries along a particular dimension. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00785">785</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefBuilder_8cpp_source.html#l00202">mlir::MemRefDescriptor::bufferPtr()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00414">mlir::LLVMTypeConverter::canConvertToBarePtr()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00028">mlir::bufferization::castOrReallocMemRefValue()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02306">computeCollapsedLayoutMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02190">computeExpandedLayoutMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00965">computeMemRefRankReductionMask()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00063">mlir::AllocationOpLLVMLowering::createIndexConstant()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00050">mlir::MemRefDescriptor::fromStaticShape()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00156">getCastCompatibleMemRefType()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00203">getConstantOffset()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00216">getConstantStrides()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00125">getMemrefConstantHorizontalStride()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00842">mlir::spirv::getOpenCLElementPtr()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00815">getStridesAndOffset()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00140">getTypeNumBytes()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00811">mlir::spirv::getVulkanElementPtr()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00026">hasFullyDynamicLayoutMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02787">haveCompatibleOffsets()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l03176">inferTransposeResultType()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00135">mlir::vector::isLastMemrefDimUnitStride()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l01497">isLastMemrefDimUnitStride()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00099">isMemRefTypeSupported()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00936">isStrided()</a>.</p>

</div>
</div>
<a id="a561d5231fcefc471a4c9069fce2eaf87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561d5231fcefc471a4c9069fce2eaf87">&#9670;&nbsp;</a></span>getSymbolLessAffineMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, 4 &gt; mlir::getSymbolLessAffineMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ae5cf0e24a954fa30fb469105d4ca5dd8">ReassociationExprs</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs affine maps out of Array&lt;Array&lt;AffineExpr&gt;&gt;. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00184">184</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01135">mlir::AffineMap::get()</a>.</p>

</div>
</div>
<a id="ac61c6bb6068af953a0711cf404a99645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61c6bb6068af953a0711cf404a99645">&#9670;&nbsp;</a></span>getUnusedDimsBitVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallBitVector mlir::getUnusedDimsBitVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00804">804</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00625">compressUnusedDims()</a>.</p>

</div>
</div>
<a id="a2798707e1d2321021e16802305d3c152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2798707e1d2321021e16802305d3c152">&#9670;&nbsp;</a></span>getUnusedSymbolsBitVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallBitVector mlir::getUnusedSymbolsBitVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00816">816</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00639">compressUnusedSymbols()</a>.</p>

</div>
</div>
<a id="a2c45b388f069e9396c50660f41a7eacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c45b388f069e9396c50660f41a7eacf">&#9670;&nbsp;</a></span>getUsedValuesDefinedAbove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill <code>values</code> with a list of values used within any of the regions provided but defined in one of the ancestors. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00070">70</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00063">getUsedValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="a98f08e970a346cd42559db87f97f0b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f08e970a346cd42559db87f97f0b91">&#9670;&nbsp;</a></span>getUsedValuesDefinedAbove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill <code>values</code> with a list of values defined at the ancestors of the <code>limit</code> region and used within <code>region</code> or its descendants. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00063">63</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00137">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00036">visitUsedValuesDefinedAbove()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassDetail_8cpp_source.html#l00020">mlir::async::cloneConstantsIntoTheRegion()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01626">convertOmpTarget()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00070">getUsedValuesDefinedAbove()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00080">makeRegionIsolatedFromAbove()</a>, <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00269">outlineExecuteOp()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00172">outlineKernelFuncImpl()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00187">outlineSingleBlockRegion()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00117">sinkOperationsIntoLaunchOp()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01159">vectorizeAsLinalgGeneric()</a>.</p>

</div>
</div>
<a id="a7d8bbfc3d0c15e92f5cba28e5ef447b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8bbfc3d0c15e92f5cba28e5ef447b5">&#9670;&nbsp;</a></span>getValueOrCreateCastToIndexLike()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::getValueOrCreateCastToIndexLike </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>targetType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a cast from an index-like value (index or integer) to another index-like value. </p>
<p>If the value type and the target type are the same, it returns the original value. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00066">66</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Types_8h_source.html#l00311">mlir::Type::dyn_cast()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getType()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00049">mlir::Type::isIndex()</a>.</p>

</div>
</div>
<a id="ab09c62516a7b31fc96892014feeae832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09c62516a7b31fc96892014feeae832">&#9670;&nbsp;</a></span>getValueOrCreateConstantIndexOp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::getValueOrCreateConstantIndexOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>valueOrAttrVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the other overload, but converts multiple OpFoldResults into Values. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00132">132</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00057">getValueOrCreateConstantIndexOp()</a>.</p>

</div>
</div>
<a id="aa058eb9c12d3b97deb073543c1372195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa058eb9c12d3b97deb073543c1372195">&#9670;&nbsp;</a></span>getValueOrCreateConstantIndexOp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::getValueOrCreateConstantIndexOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>
<p>Returns the fold result if it casts to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> or creates a ConstantIndexOp if it casts to an IntegerAttribute. Other attribute types are not supported. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00057">57</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00453">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00305">calculateExpandedAccessIndices()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01418">mlir::linalg::collapseGenericOpIterationDims()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01879">mlir::affine::delinearizeIndex()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00116">generateTileLoopNest()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00086">getBoundedTileSize()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00132">getValueOrCreateConstantIndexOp()</a>, <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00055">invertSliceIndexing()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00099">mlir::memref::multiBuffer()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00936">mlir::linalg::offsetIndices()</a>, <a class="el" href="Promotion_8cpp_source.html#l00213">mlir::linalg::promoteSubviewAsNewBuffer()</a>, <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00081">mlir::affine::resolveIndicesIntoOpWithOffsetsAndStrides()</a>, <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00113">resolveSourceIndicesCollapseShape()</a>, <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00062">resolveSourceIndicesExpandShape()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00130">unpackRanges()</a>.</p>

</div>
</div>
<a id="ad2bf7271ea0c5e95377e621f7923baa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2bf7271ea0c5e95377e621f7923baa7">&#9670;&nbsp;</a></span>getValuesSortedByKey() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; mlir::getValuesSortedByKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt;&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00227">227</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fraction_8h_source.html#l00059">mlir::presburger::compare()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00199">getValuesSortedByKeyImpl()</a>.</p>

</div>
</div>
<a id="af3ec25d896f63f835649e57fa1156deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ec25d896f63f835649e57fa1156deb">&#9670;&nbsp;</a></span>getValuesSortedByKey() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::getValuesSortedByKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt;&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00221">221</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fraction_8h_source.html#l00059">mlir::presburger::compare()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00199">getValuesSortedByKeyImpl()</a>.</p>

</div>
</div>
<a id="ae8b5c05e14ade6108624f49c4c8bf104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b5c05e14ade6108624f49c4c8bf104">&#9670;&nbsp;</a></span>getValuesSortedByKey() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::getValuesSortedByKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt;&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to sort <code>values</code> according to matching <code>keys</code>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00215">215</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fraction_8h_source.html#l00059">mlir::presburger::compare()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00199">getValuesSortedByKeyImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUTransformOps_8cpp_source.html#l00460">rewriteOneForallCommonImpl()</a>.</p>

</div>
</div>
<a id="aaf9994bf5e77db2932598481cf8e46fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9994bf5e77db2932598481cf8e46fb">&#9670;&nbsp;</a></span>getValuesSortedByKeyImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;V&gt; mlir::getValuesSortedByKeyImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; K &gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; V &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(K, K)&gt;&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to sort <code>values</code> according to matching <code>keys</code>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00199">199</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="StaticValueUtils_8cpp_source.html#l00215">getValuesSortedByKey()</a>.</p>

</div>
</div>
<a id="a421cf43aced4fd4aff1907fa48080b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421cf43aced4fd4aff1907fa48080b4e">&#9670;&nbsp;</a></span>hasEffect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... EffectTys&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::hasEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>op</code> has an effect of type <code>EffectTy</code> on <code>value</code>. </p>
<p>If no <code>value</code> is provided, simply check if effects of the given type(s) are present. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00133">133</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

</div>
</div>
<a id="ad9141d8b586a68549d2ecaccbce99a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9141d8b586a68549d2ecaccbce99a69">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> hashable. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00240">240</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="OperationSupport_8h_source.html#l01207">mlir::OperationEquivalence::directHashValue()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00369">llvm::DenseMapInfo&lt; mlir::AffineExpr &gt;::getHashValue()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00660">llvm::DenseMapInfo&lt; mlir::AffineMap &gt;::getHashValue()</a>, <a class="el" href="IR_2Attributes_8h_source.html#l00322">llvm::DenseMapInfo&lt; mlir::Attribute &gt;::getHashValue()</a>, <a class="el" href="mlir_2IR_2IntegerSet_8h_source.html#l00142">llvm::DenseMapInfo&lt; mlir::IntegerSet &gt;::getHashValue()</a>, <a class="el" href="Location_8h_source.html#l00208">llvm::DenseMapInfo&lt; mlir::Location &gt;::getHashValue()</a>, <a class="el" href="IR_2Attributes_8h_source.html#l00367">llvm::DenseMapInfo&lt; mlir::NamedAttribute &gt;::getHashValue()</a>, <a class="el" href="IR_2Types_8h_source.html#l00340">llvm::DenseMapInfo&lt; mlir::Type &gt;::getHashValue()</a>, <a class="el" href="TypeID_8h_source.html#l00347">llvm::DenseMapInfo&lt; mlir::TypeID &gt;::getHashValue()</a>, and <a class="el" href="Value_8h_source.html#l00499">llvm::DenseMapInfo&lt; mlir::Value &gt;::getHashValue()</a>.</p>

</div>
</div>
<a id="a032c893ca9a2fff3b16e5a7cb6d413cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032c893ca9a2fff3b16e5a7cb6d413cd">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00365">365</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

</div>
</div>
<a id="a68bae84b1d7cdba11b048d9af3478a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bae84b1d7cdba11b048d9af3478a07">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Attributes_8h_source.html#l00180">180</a> of file <a class="el" href="IR_2Attributes_8h_source.html">Attributes.h</a>.</p>

</div>
</div>
<a id="aac18c17aca8d8a8549fef55a52af5393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac18c17aca8d8a8549fef55a52af5393">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AsmDialectResourceHandle.html">AsmDialectResourceHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="OpImplementation_8h_source.html#l00043">mlir::AsmDialectResourceHandle::getResource()</a>.</p>

</div>
</div>
<a id="aa4b795f2f972c070efff53082563f976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b795f2f972c070efff53082563f976">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Attributes_8h_source.html#l00238">238</a> of file <a class="el" href="IR_2Attributes_8h_source.html">Attributes.h</a>.</p>

</div>
</div>
<a id="a655bb0e17a21ea2c35194f7c822c9ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655bb0e17a21ea2c35194f7c822c9ca5">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2IntegerSet_8h_source.html#l00124">124</a> of file <a class="el" href="mlir_2IR_2IntegerSet_8h_source.html">IntegerSet.h</a>.</p>

</div>
</div>
<a id="aa6261878bc5197cfcc003e5b3fa735ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6261878bc5197cfcc003e5b3fa735ea">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Location_8h_source.html#l00123">123</a> of file <a class="el" href="Location_8h_source.html">Location.h</a>.</p>

</div>
</div>
<a id="ad93109842c1b05424c5052d9bd9a4394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93109842c1b05424c5052d9bd9a4394">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00493">493</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00463">mlir::OperationName::getAsOpaquePointer()</a>.</p>

</div>
</div>
<a id="a31eede9183d3fdae566e18d94a5ef51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31eede9183d3fdae566e18d94a5ef51b">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00296">296</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="aafb3bcc9d23b2cfd1367b84f5b00b7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb3bcc9d23b2cfd1367b84f5b00b7c1">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable hashing <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a>. </p>

<p class="definition">Definition at line <a class="el" href="TypeID_8h_source.html#l00149">149</a> of file <a class="el" href="TypeID_8h_source.html">TypeID.h</a>.</p>

</div>
</div>
<a id="abb322b17530b4289c3e3ec1f4ad2ecce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb322b17530b4289c3e3ec1f4ad2ecce">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make <a class="el" href="classmlir_1_1TypeRange.html" title="This class provides an abstraction over the various different ranges of value types.">TypeRange</a> hashable. </p>

<p class="definition">Definition at line <a class="el" href="TypeRange_8h_source.html#l00072">72</a> of file <a class="el" href="TypeRange_8h_source.html">TypeRange.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeRange_8h_source.html#l00200">llvm::DenseMapInfo&lt; mlir::TypeRange &gt;::getHashValue()</a>.</p>

</div>
</div>
<a id="ab710b1f6f21f3f35197575b609aae4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab710b1f6f21f3f35197575b609aae4b4">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> hashable. </p>

<p class="definition">Definition at line <a class="el" href="Value_8h_source.html#l00475">475</a> of file <a class="el" href="Value_8h_source.html">Value.h</a>.</p>

</div>
</div>
<a id="a1858ec5ab152ee2a09d4ceaf95cf2811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1858ec5ab152ee2a09d4ceaf95cf2811">&#9670;&nbsp;</a></span>hasNonIdentityLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::hasNonIdentityLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the type is a MemRefType and has a non-identity layout. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00269">269</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00311">mlir::Type::dyn_cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ReshapeOpsUtils_8h_source.html#l00232">mlir::ComposeCollapseOfExpandOp&lt; CollapseOpTy, ExpandOpTy, CastOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00298">mlir::ComposeExpandOfCollapseOp&lt; ExpandOpTy, CollapseOpTy &gt;::matchAndRewrite()</a>, and <a class="el" href="ReshapeOpsUtils_8h_source.html#l00175">mlir::ComposeReassociativeReshapeOps&lt; ReshapeOpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a775618793f22a592cfb8ccf36831ca44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775618793f22a592cfb8ccf36831ca44">&#9670;&nbsp;</a></span>hasSingleEffect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EffectTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::hasSingleEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>op</code> has only an effect of type <code>EffectTy</code> (and of no other type) on <code>value</code>. </p>
<p>If no value is provided, simply check if effects of that type and only of that type are present. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00106">106</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

</div>
</div>
<a id="afa82b2f82348c0eacc76f1c4a862a796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa82b2f82348c0eacc76f1c4a862a796">&#9670;&nbsp;</a></span>inlineCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::inlineCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallOpInterface&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallableOpInterface&#160;</td>
          <td class="paramname"><em>callable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCloneInlinedRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inlines a given region, 'src', of a callable operation, 'callable', into the location defined by the given call operation. </p>
<p>This function returns failure if inlining is not possible, success otherwise. On failure, no changes are made to the module. 'shouldCloneInlinedRegion' corresponds to whether the source region should be cloned into the 'call' or spliced directly. </p>

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00429">429</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00060">mlir::Region::empty()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Inliner_8cpp_source.html#l00464">inlineCallsInSCC()</a>.</p>

</div>
</div>
<a id="ad1236e68e2c467729ae0f0c6189e3d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1236e68e2c467729ae0f0c6189e3d55">&#9670;&nbsp;</a></span>inlineRegion() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::inlineRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>inlineBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>inlinePoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>resultsToReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>regionResultTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>inlineLoc</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCloneInlinedRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00367">367</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="InliningUtils_8cpp_source.html#l00221">inlineRegionImpl()</a>.</p>

</div>
</div>
<a id="ad1be5dbac3676f88a7f87669ec0f2484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1be5dbac3676f88a7f87669ec0f2484">&#9670;&nbsp;</a></span>inlineRegion() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::inlineRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>inlineBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>inlinePoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>inlinedOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>resultsToReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>inlineLoc</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCloneInlinedRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00389">389</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="InliningUtils_8cpp_source.html#l00221">inlineRegionImpl()</a>.</p>

</div>
</div>
<a id="a754f32a9d62efdcb48e4e0a2f3da1576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754f32a9d62efdcb48e4e0a2f3da1576">&#9670;&nbsp;</a></span>inlineRegion() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::inlineRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>inlinePoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>resultsToReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>regionResultTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>inlineLoc</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCloneInlinedRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inlines a region, 'src', into another. </p>
<p>This function returns failure if it is not possible to inline this function. If the function returned failure, then no changes to the module have been made.</p>
<p>The provided 'inlinePoint' must be within a region, and corresponds to the location where the 'src' region should be inlined. 'mapping' contains any remapped operands that are used within the region, and <em>must</em> include remappings for the entry arguments to the region. 'resultsToReplace' corresponds to any results that should be replaced by terminators within the inlined region. 'regionResultTypes' specifies the expected return types of the terminators in the region. 'inlineLoc' is an optional <a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> that, if provided, will be used to update the inlined operations' location information. 'shouldCloneInlinedRegion' corresponds to whether the source region should be cloned into the 'inlinePoint' or spliced directly. </p>

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00357">357</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InliningUtils_8cpp_source.html#l00379">inlineRegion()</a>.</p>

</div>
</div>
<a id="a16442f718030c48c28c7ae986fa39acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16442f718030c48c28c7ae986fa39acf">&#9670;&nbsp;</a></span>inlineRegion() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::inlineRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>inlinePoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>inlinedOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>resultsToReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>inlineLoc</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCloneInlinedRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is an overload of the above 'inlineRegion' that allows for providing the set of operands ('inlinedOperands') that should be used in-favor of the region arguments when inlining. </p>

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00379">379</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, and <a class="el" href="InliningUtils_8cpp_source.html#l00357">inlineRegion()</a>.</p>

</div>
</div>
<a id="a426b7e62d7400b01d368a3db835df9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426b7e62d7400b01d368a3db835df9d3">&#9670;&nbsp;</a></span>insideMutuallyExclusiveRegions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::insideMutuallyExclusiveRegions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>a</code> and <code>b</code> are in mutually exclusive regions as per RegionBranchOpInterface. </p>
<p>Return <code>true</code> if <code>a</code> and <code>b</code> are in mutually exclusive regions.</p>
<ol type="1">
<li>Find the first common of <code>a</code> and <code>b</code> (ancestor) that implements RegionBranchOpInterface.</li>
<li>Determine the regions <code>regionA</code> and <code>regionB</code> in which <code>a</code> and <code>b</code> are contained.</li>
<li>Check if <code>regionA</code> and <code>regionB</code> are mutually exclusive. They are mutually exclusive if they are not reachable from each other as per RegionBranchOpInterface::getSuccessorRegions. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00267">267</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00238">mlir::Operation::getParentOfType()</a>, and <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00226">isRegionReachable()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotAnalysis_8cpp_source.html#l00454">hasReadAfterWriteInterference()</a>.</p>

</div>
</div>
<a id="a39612be2ef116102866d3bb9c6a8ca88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39612be2ef116102866d3bb9c6a8ca88">&#9670;&nbsp;</a></span>inverseAndBroadcastProjectedPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::inverseAndBroadcastProjectedPermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the reverse map of a projected permutation where the projected dimensions are transformed into 0s. </p>
<p>Prerequisites: <code>map</code> must be a projected permutation.</p>
<p>Example 1:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1, d2, d3) -&gt; (d2, d0)&gt;</div>
</div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1) -&gt; (d1, 0, d0, 0)&gt;</div>
</div><!-- fragment --><p>Example 2:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1, d2, d3) -&gt; (d0, d3)&gt;</div>
</div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1) -&gt; (d0, 0, 0, d1)&gt;</div>
</div><!-- fragment --><p>Example 3:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1, d2, d3) -&gt; (d2)&gt;</div>
</div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0) -&gt; (0, 0, d0, 0)&gt;</div>
</div><!-- fragment --><p> Example 4:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1, d2) -&gt; (d0, 0)&gt;</div>
</div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1) -&gt; (d0, 0, 0)&gt;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00691">691</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01135">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00527">getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00502">getAffineDimExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00271">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00345">mlir::AffineMap::getDimPosition()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00333">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00332">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00341">mlir::AffineMap::getResult()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00521">mlir::AffineMap::isProjectedPermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01159">vectorizeAsLinalgGeneric()</a>.</p>

</div>
</div>
<a id="a52b322818d83a2256d4e4391acbf78a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b322818d83a2256d4e4391acbf78a2">&#9670;&nbsp;</a></span>inversePermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::inversePermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map of codomain to domain dimensions such that the first codomain dimension for a particular domain dimension is selected. </p>
<p>Returns an empty map if the input map is empty. Returns null map (not empty map) if <code>map</code> is not invertible (i.e. <code>map</code> does not contain a subset that is a permutation of full domain rank).</p>
<p>Prerequisites:</p><ol type="1">
<li><code>map</code> has no symbols.</li>
</ol>
<p>Example 1:</p>
<div class="fragment"><div class="line">(d0, d1, d2) -&gt; (d1, d1, d0, d2, d1, d2, d1, d0)</div>
<div class="line">                  0       2   3</div>
</div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">(d0, d1, d2, d3, d4, d5, d6, d7) -&gt; (d2, d0, d3)</div>
</div><!-- fragment --><p>Example 2:</p>
<div class="fragment"><div class="line">(d0, d1, d2) -&gt; (d1, d0 + d1, d0, d2, d1, d2, d1, d0)</div>
<div class="line">                  0            2   3</div>
</div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">(d0, d1, d2, d3, d4, d5, d6, d7) -&gt; (d2, d0, d3)</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00667">667</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01135">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00502">getAffineDimExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00271">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00324">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00333">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00332">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00328">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00337">mlir::AffineMap::getResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00297">mlir::AffineMap::isEmpty()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00546">buildVectorWrite()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00031">mlir::linalg::detail::canOpOperandsBeDroppedImpl()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00277">mlir::linalg::fuseElementwiseOps()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00045">getIndexingMapOfProducerOperandsInCoordinatesOfFusedOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l03466">inferTransferOpMaskType()</a>, <a class="el" href="Interchange_8cpp_source.html#l00050">mlir::linalg::interchangeGenericOp()</a>, <a class="el" href="Interchange_8cpp_source.html#l00036">interchangeGenericOpPrecondition()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00331">mlir::linalg::makeTransposeOp()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00113">replaceUnitDims()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00211">mlir::linalg::rewriteInIm2Col()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01159">vectorizeAsLinalgGeneric()</a>.</p>

</div>
</div>
<a id="afc254f56cba37671e1e5b2b933c6a090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc254f56cba37671e1e5b2b933c6a090">&#9670;&nbsp;</a></span>invertPermutationVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; mlir::invertPermutationVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>permutation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to apply to inverse a permutation. </p>

<p class="definition">Definition at line <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00194">194</a> of file <a class="el" href="Utils_2IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transforms_8cpp_source.html#l01249">getPackUnpackNormalizedPerm()</a>, <a class="el" href="Transforms_8cpp_source.html#l00480">mlir::linalg::lowerPack()</a>, and <a class="el" href="Transforms_8cpp_source.html#l01388">mlir::linalg::GeneralizeOuterUnitDimsUnPackOpPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a336eaa1f1417cbe1468e56b34ce866a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336eaa1f1417cbe1468e56b34ce866a1">&#9670;&nbsp;</a></span>isBytecode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isBytecode </td>
          <td>(</td>
          <td class="paramtype">llvm::MemoryBufferRef&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given buffer starts with the magic bytes that signal MLIR bytecode. </p>

<p class="definition">Definition at line <a class="el" href="BytecodeReader_8cpp_source.html#l01831">1831</a> of file <a class="el" href="BytecodeReader_8cpp_source.html">BytecodeReader.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BytecodeReader_8cpp_source.html#l01839">readBytecodeFileImpl()</a>.</p>

</div>
</div>
<a id="a0dfea8ee2dd0eba944b0cd299591ccf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfea8ee2dd0eba944b0cd299591ccf9">&#9670;&nbsp;</a></span>isColumnMajorMatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isColumnMajorMatmul </td>
          <td>(</td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>indexingMaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given maps describe a column major matmul. </p>
<p>The test is permutation-invariant. Note that this only checks the affine maps from an operation, so does not perform any checks on the math being performed within the reduction. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00046">46</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01135">mlir::AffineMap::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">get()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00025">mlir::AffineExpr::getContext()</a>.</p>

</div>
</div>
<a id="a043789541ff1881513700b717bf5491d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043789541ff1881513700b717bf5491d">&#9670;&nbsp;</a></span>isConstantIntValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isConstantIntValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if <code>ofr</code> is constant integer equal to <code>value</code>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00133">133</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00117">getConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00453">mlir::tensor::bubbleUpPadSlice()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00247">calculateTileOffsetsAndSizes()</a>.</p>

</div>
</div>
<a id="a2ee77c6f0feb82212b1b817785f95f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee77c6f0feb82212b1b817785f95f48">&#9670;&nbsp;</a></span>isEqualConstantIntOrValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isEqualConstantIntOrValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if ofr1 and ofr2 are the same integer constant attribute values or the same SSA value. </p>
<p>Ignore integer bitwitdh and type mismatch that come from the fact there is no IndexAttr and that IndexType have no bitwidth.</p>
<p>Ignore integer bitwidth and type mismatch that come from the fact there is no IndexAttr and that IndexType has no bitwidth. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00142">142</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00117">getConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00276">getSlicedDimensions()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01831">PadOpVectorizationWithTransferWritePattern::hasSameTensorSize()</a>, <a class="el" href="TensorOps_8cpp_source.html#l03732">haveSameTiles()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00150">isEqualConstantIntOrValueArray()</a>.</p>

</div>
</div>
<a id="ab03d63917414f04e985c804f24086b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03d63917414f04e985c804f24086b76">&#9670;&nbsp;</a></span>isEqualConstantIntOrValueArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isEqualConstantIntOrValueArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>ofrs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>ofrs2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00150">150</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00142">isEqualConstantIntOrValue()</a>.</p>

</div>
</div>
<a id="af233cbc2b6252b0f87bbc95f2bc8c553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af233cbc2b6252b0f87bbc95f2bc8c553">&#9670;&nbsp;</a></span>isLegalForBranchOpInterfaceTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isLegalForBranchOpInterfaceTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if op is a BranchOpInterface op whose operands are all legal according to converter. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00124">124</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

</div>
</div>
<a id="ab6b78043105c4babf3635efc8a0c5db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b78043105c4babf3635efc8a0c5db1">&#9670;&nbsp;</a></span>isLegalForReturnOpTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isLegalForReturnOpTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>returnOpAlwaysLegal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For ReturnLike ops (except <code>return</code>), return True. </p>
<p>If op is a <code>return</code> &amp;&amp; returnOpAlwaysLegal is false, legalize op according to converter. Otherwise, return false. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00145">145</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

</div>
</div>
<a id="a5799849a369b839d27241c96a9572de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5799849a369b839d27241c96a9572de7">&#9670;&nbsp;</a></span>isMemoryEffectFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isMemoryEffectFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given operation is free of memory effects. </p>
<p>An operation is free of memory effects if its implementation of <code>MemoryEffectOpInterface</code> indicates that it has no memory effects. For example, it may implement <code>NoMemoryEffect</code> in ODS. Alternatively, if the operation has the <code>HasRecursiveMemoryEffects</code> trait, then it is free of memory effects if all of its nested operations are free of memory effects.</p>
<p>If the operation has both, then it is free of memory effects if both conditions are satisfied. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00158">158</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SliceAnalysis_8cpp_source.html#l00274">matchReduction()</a>, and <a class="el" href="Hoisting_8cpp_source.html#l00055">noAliasingUseInLoop()</a>.</p>

</div>
</div>
<a id="a625259a35e521a9f6d7b7fe115423e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625259a35e521a9f6d7b7fe115423e87">&#9670;&nbsp;</a></span>isNotBranchOpInterfaceOrReturnLikeOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isNotBranchOpInterfaceOrReturnLikeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if op is neither BranchOpInterface nor ReturnLike. </p>
<p>TODO Try to get rid of this function and invert the meaning of <code>isLegalForBranchOpInterfaceTypeConversionPattern</code> and <code>isLegalForReturnOpTypeConversionPattern</code>. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00159">159</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

</div>
</div>
<a id="a4bd6b581b08699ce79d3e9f820c1ade9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd6b581b08699ce79d3e9f820c1ade9">&#9670;&nbsp;</a></span>isOpaqueTypeWithName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isOpaqueTypeWithName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>dialect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>typeData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified type is an opaque type with the specified dialect and typeData. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00048">48</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00311">mlir::Type::dyn_cast()</a>.</p>

</div>
</div>
<a id="a8583719d6a8f0699c36ac4c4b53057f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8583719d6a8f0699c36ac4c4b53057f2">&#9670;&nbsp;</a></span>isOpTriviallyDead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isOpTriviallyDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the given operation is unused, and has no side effects on memory that prevent erasing. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00034">34</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

</div>
</div>
<a id="aeb49fb26d8c1e3dc571db7ff9e34cb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb49fb26d8c1e3dc571db7ff9e34cb7f">&#9670;&nbsp;</a></span>isPermutationVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isPermutationVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>interchange</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to check if an interchange vector is a permutation. </p>

<p class="definition">Definition at line <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00204">204</a> of file <a class="el" href="Utils_2IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l03437">commonPermutationOfPackAndUnPackOp()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00087">mlir::tensor::computeTransposedType()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00331">mlir::linalg::makeTransposeOp()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l01087">packMatmulGreedily()</a>, and <a class="el" href="Transforms_8cpp_source.html#l00917">mlir::linalg::packTranspose()</a>.</p>

</div>
</div>
<a id="a550cdaef652bf5d59dfe33a15dc81af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550cdaef652bf5d59dfe33a15dc81af5">&#9670;&nbsp;</a></span>isPure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isPure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given operation is pure, i.e., is speculatable that does not touch memory. </p>
<p>The implementation of this function replicates the <code>def Pure : TraitList</code> in <code>SideEffectInterfaces.td</code> and has to be kept in sync manually.</p>
<p>This function is the C++ equivalent of the <code>Pure</code> trait. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00208">208</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

</div>
</div>
<a id="ae209f096d9240a818927afbab10f43b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae209f096d9240a818927afbab10f43b8">&#9670;&nbsp;</a></span>isRankReducedType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">SliceVerificationResult</a> mlir::isRankReducedType </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>originalType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>candidateReducedType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if <code>originalType</code> can be rank reduced to <code>candidateReducedType</code> type by dropping some dimensions with static size <code>1</code>. </p>
<p>Return <code><a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a505a83f220c02df2f85c3810cd9ceb38">SliceVerificationResult::Success</a></code> on success or an appropriate error code. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00424">424</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00398">computeRankReductionMask()</a>, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a6341e1bfc09d56fa49bb1b9400459d8e">ElemTypeMismatch</a>, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a780dd32ee9af184442cea3f2a2a75271">RankTooLarge</a>, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a87c69361ccd090c9c844e19d08432a26">SizeMismatch</a>, and <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a505a83f220c02df2f85c3810cd9ceb38">Success</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l02799">isRankReducedMemRefType()</a>, and <a class="el" href="TensorOps_8cpp_source.html#l02187">verifyInsertSliceOp()</a>.</p>

</div>
</div>
<a id="a9e3d6f94b6a941066c3e7e5535817a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3d6f94b6a941066c3e7e5535817a9b">&#9670;&nbsp;</a></span>isReassociationValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isReassociationValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>invalidIndex</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the reassociation specification is valid, false otherwise. </p>
<p>When false, the <code>invalidIndex</code> integer pointer is optionally filled with the index of the offending reassociation map. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00197">197</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>.</p>

</div>
</div>
<a id="a9220af1b0ef10468f05c1e37e24371e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9220af1b0ef10468f05c1e37e24371e4">&#9670;&nbsp;</a></span>isRegionReturnLike()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isRegionReturnLike </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given operation is either annotated with the <code>ReturnLike</code> trait or implements the <code>RegionBranchTerminatorOpInterface</code>. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00360">360</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00690">mlir::Operation::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferOptimizations_8cpp_source.html#l00070">leavesAllocationScope()</a>, and <a class="el" href="BufferDeallocation_8cpp_source.html#l00074">walkReturnOperations()</a>.</p>

</div>
</div>
<a id="aa28d7afae3a8e6d54489b5857b938d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28d7afae3a8e6d54489b5857b938d07">&#9670;&nbsp;</a></span>isRowMajorBatchMatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isRowMajorBatchMatmul </td>
          <td>(</td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>indexingMaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given maps describe a row major batch matmul. </p>
<p>The test is permutation-invariant. Note that this only checks the affine maps from an operation, so does not perform any checks on the math being performed within the reduction. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00072">72</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01135">mlir::AffineMap::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">get()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00025">mlir::AffineExpr::getContext()</a>.</p>

</div>
</div>
<a id="ae53f9bcf99efe125a11237ad6b64642c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53f9bcf99efe125a11237ad6b64642c">&#9670;&nbsp;</a></span>isRowMajorMatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isRowMajorMatmul </td>
          <td>(</td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>indexingMaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given maps describe a row major matmul. </p>
<p>The test is permutation-invariant. Note that this only checks the affine maps from an operation, so does not perform any checks on the math being performed within the reduction. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00020">20</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01135">mlir::AffineMap::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">get()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00025">mlir::AffineExpr::getContext()</a>.</p>

</div>
</div>
<a id="a7a2c465ce654633415e61167b64b8a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2c465ce654633415e61167b64b8a91">&#9670;&nbsp;</a></span>isSpeculatable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isSpeculatable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given operation is speculatable, i.e. </p>
<p>has no undefined behavior or other side effects.</p>
<p>An operation can indicate that it is speculatable by implementing the getSpeculatability hook in the ConditionallySpeculatable op interface. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00182">182</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

</div>
</div>
<a id="ad0c26bcf64137533f38f2cda9abd75af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c26bcf64137533f38f2cda9abd75af">&#9670;&nbsp;</a></span>isStrided()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isStrided </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the layout for <code>t</code> is compatible with strided semantics. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00936">936</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00785">getStridesAndOffset()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00068">succeeded()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01711">mlir::affine::AffineDmaStartOp::parse()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01689">mlir::affine::AffineDmaStartOp::print()</a>.</p>

</div>
</div>
<a id="a04dd9fbdfc3426b88a910e2e7ded495c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04dd9fbdfc3426b88a910e2e7ded495c">&#9670;&nbsp;</a></span>isZeroIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isZeroIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if <code>v</code> is an IntegerAttr with value <code>0</code> of a ConstantIndexOp with attribute with value <code>0</code>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00018">18</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00790">mlir::linalg::computeTileOffsets()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00804">mlir::linalg::computeTileSizes()</a>, and <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00284">mlir::linalg::rewriteInDestinationPassingStyle()</a>.</p>

</div>
</div>
<a id="a4bfe9337070eb0f67cb7a3098ee136ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfe9337070eb0f67cb7a3098ee136ee">&#9670;&nbsp;</a></span>JitRunnerMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mlir::JitRunnerMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1JitRunnerConfig.html">JitRunnerConfig</a>&#160;</td>
          <td class="paramname"><em>config</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for all CPU runners. </p>
<p>Expects the common argc/argv arguments for standard C++ main functions. The supplied dialect registry is expected to contain any registers that appear in the input IR, they will be loaded on-demand by the parser.</p>
<p>Expects the common argc/argv arguments for standard C++ main functions. </p>

<p class="definition">Definition at line <a class="el" href="JitRunner_8cpp_source.html#l00353">353</a> of file <a class="el" href="JitRunner_8cpp_source.html">JitRunner.cpp</a>.</p>

<p class="reference">References <a class="el" href="JitRunner_8cpp_source.html#l00275">compileAndExecuteVoidFunction()</a>, <a class="el" href="MlirTblgenMain_8cpp_source.html#l00028">Error</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00163">getCommandLineOptLevel()</a>, <a class="el" href="JitRunner_8h_source.html#l00059">mlir::JitRunnerConfig::llvmModuleBuilder</a>, <a class="el" href="namespacemlir.html#a643fb5da616fe37fef528fbcf735b8ec">makeOptimizingTransformer()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00158">makeStringError()</a>, <a class="el" href="JitRunner_8h_source.html#l00053">mlir::JitRunnerConfig::mlirTransformer</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="JitRunner_8cpp_source.html#l00134">parseMLIRInput()</a>, and <a class="el" href="JitRunner_8h_source.html#l00063">mlir::JitRunnerConfig::runtimesymbolMap</a>.</p>

</div>
</div>
<a id="ac84b6a6dfd9d9eb78ca02c17cabbebed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84b6a6dfd9d9eb78ca02c17cabbebed">&#9670;&nbsp;</a></span>linearize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::linearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the linearized index of 'offsets' w.r.t. </p>
<p>'basis'.</p>
<p><code>basis</code> elements are asserted to be non-negative. </p>

<p class="definition">Definition at line <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00093">93</a> of file <a class="el" href="Utils_2IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00046">linearizeImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l01496">foldExtractFromShapeCast()</a>, <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00167">linearize()</a>, and <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00062">resolveSourceIndicesExpandShape()</a>.</p>

</div>
</div>
<a id="a3e83fe20fc8231df5769e1eebe268bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e83fe20fc8231df5769e1eebe268bdd">&#9670;&nbsp;</a></span>linearize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::linearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the linearized index of 'offsets' w.r.t. </p>
<p>'basis'.</p>
<p>Assuming <code>offsets</code> is <code>[o0, .. on]</code> and <code>basis</code> is <code>[b0, .. bn]</code>, return the <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> <code>o0 * b0 + .. + on * bn</code>.</p>
<p>It is the caller's responsibility to pass proper <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> kind that result in valid <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> (i.e. cannot multiply 2 <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> or divide by an <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a>).</p>
<p><code>basis</code> elements are expected to bind to non-negative values. </p>

<p class="definition">Definition at line <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00161">161</a> of file <a class="el" href="Utils_2IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00527">getAffineConstantExpr()</a>, and <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00046">linearizeImpl()</a>.</p>

</div>
</div>
<a id="a1c0b8417b72fde91ffbc7d792fc97121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0b8417b72fde91ffbc7d792fc97121">&#9670;&nbsp;</a></span>linearize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::linearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00167">167</a> of file <a class="el" href="Utils_2IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00527">getAffineConstantExpr()</a>, and <a class="el" href="Utils_2IndexingUtils_8cpp_source.html#l00093">linearize()</a>.</p>

</div>
</div>
<a id="af912da94236cff04e9076f6e052676b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af912da94236cff04e9076f6e052676b1">&#9670;&nbsp;</a></span>LLVM_ENABLE_BITMASK_ENUMS_IN_NAMESPACE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::LLVM_ENABLE_BITMASK_ENUMS_IN_NAMESPACE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Bitmask enums for <a class="el" href="structmlir_1_1OperationEquivalence.html#a292ebf6a0885a07fd4c94f9750587dfe">OperationEquivalence::Flags</a>. </p>

</div>
</div>
<a id="a040c47f3f5d15eecb05a18c6343df489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040c47f3f5d15eecb05a18c6343df489">&#9670;&nbsp;</a></span>loopUnrollByFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::loopUnrollByFactor </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(unsigned, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt;&#160;</td>
          <td class="paramname"><em>annotateFn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls this for operation by the specified unroll factor. </p>
<p>Unrolls 'forOp' by 'unrollFactor', returns success if the loop is unrolled.</p>
<p>Returns failure if the loop cannot be unrolled either due to restrictions or due to invalid unroll factors. Requires positive loop bounds and step. If specified, annotates the Ops in each unrolled iteration by applying <code>annotateFn</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00460">460</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MathExtras_8h_source.html#l00023">ceilDiv()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00339">ceilDivPositive()</a>, <a class="el" href="Builders_8cpp_source.html#l00520">mlir::OpBuilder::clone()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00407">generateUnrolledLoop()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00383">promoteIfSingleIteration()</a>, <a class="el" href="Builders_8h_source.html#l00379">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>, and <a class="el" href="Arith_8h_source.html#l00096">mlir::arith::ConstantIndexOp::value()</a>.</p>

</div>
</div>
<a id="af4cd463c8738400fd147e2f040e89948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4cd463c8738400fd147e2f040e89948">&#9670;&nbsp;</a></span>lowerAffineLowerBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::lowerAffineLowerBound </td>
          <td>(</td>
          <td class="paramtype">affine::AffineForOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that computes the lower bound of the given affine loop using standard arithmetic operations. </p>

<p class="reference">Referenced by <a class="el" href="SCFToGPU_8cpp_source.html#l00094">getOrEmitLowerBound()</a>.</p>

</div>
</div>
<a id="a59b670d3c5d9075cd52ef9d183168708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b670d3c5d9075cd52ef9d183168708">&#9670;&nbsp;</a></span>lowerAffineUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::lowerAffineUpperBound </td>
          <td>(</td>
          <td class="paramtype">affine::AffineForOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that computes the upper bound of the given affine loop using standard arithmetic operations. </p>

<p class="reference">Referenced by <a class="el" href="SCFToGPU_8cpp_source.html#l00100">getOrEmitUpperBound()</a>.</p>

</div>
</div>
<a id="a8ea33aa665368d4f2108eb2d41c85111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea33aa665368d4f2108eb2d41c85111">&#9670;&nbsp;</a></span>m_AnyZeroFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_AnyZeroFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float (both positive and negative) zero. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00317">317</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00040">isZeroValue()</a>.</p>

</div>
</div>
<a id="a18d87ea3290be975b746704e58465017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d87ea3290be975b746704e58465017">&#9670;&nbsp;</a></span>m_Attr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1AttrOpMatcher.html">detail::AttrOpMatcher</a> mlir::m_Attr </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>attrName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a named attribute operation. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00292">292</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a3132b68de242f1e938904d71be736db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3132b68de242f1e938904d71be736db8">&#9670;&nbsp;</a></span>m_Attr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AttrT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1AttrOpBinder.html">detail::AttrOpBinder</a>&lt;AttrT&gt; mlir::m_Attr </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>attrName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AttrT *&#160;</td>
          <td class="paramname"><em>bindValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a named attribute operation and writes the value to bind_value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00310">310</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="ad402a86ee4c9000c6fa1fceaddab560b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad402a86ee4c9000c6fa1fceaddab560b">&#9670;&nbsp;</a></span>m_Constant() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__op__matcher.html">detail::constant_op_matcher</a> mlir::m_Constant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant foldable operation. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00287">287</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LocalAliasAnalysis_8cpp_source.html#l00249">mlir::LocalAliasAnalysis::aliasImpl()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01483">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01240">createOrFold()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02276">foldLoopBounds()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00081">getAsOpFoldResult()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00048">mlir::shape::getShapeVec()</a>, <a class="el" href="ControlFlowSinkUtils_8cpp_source.html#l00135">getSinglyExecutedRegionsToSink()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00192">mlir::ValueShapeRange::getValueAsShape()</a>, <a class="el" href="LLVMInlining_8cpp_source.html#l00050">handleInlinedAllocas()</a>, <a class="el" href="AsyncParallelFor_8cpp_source.html#l00191">integerConstants()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00499">isDefinedOutsideOrConstant()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00392">mlir::affine::isValidSymbol()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00271">mlir::linalg::makeComposedPadHighOp()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01110">mlir::LLVM::ModuleImport::matchIntegerAttr()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00050">materializeConstant()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00056">movePaddingToFillOrGenericOp()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00052">remainsLegalAfterInline()</a>.</p>

</div>
</div>
<a id="a10b6da5781fbe1b019fcb64dcd6921dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b6da5781fbe1b019fcb64dcd6921dd">&#9670;&nbsp;</a></span>m_Constant() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AttrT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__op__binder.html">detail::constant_op_binder</a>&lt;AttrT&gt; mlir::m_Constant </td>
          <td>(</td>
          <td class="paramtype">AttrT *&#160;</td>
          <td class="paramname"><em>bind_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a value from a constant foldable operation and writes the value to bind_value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00304">304</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a41f267f37c147c72f6ca26a41ff9f7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f267f37c147c72f6ca26a41ff9f7bb">&#9670;&nbsp;</a></span>m_ConstantFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__op__binder.html">detail::constant_float_op_binder</a> mlir::m_ConstantFloat </td>
          <td>(</td>
          <td class="paramtype">FloatAttr::ValueType *&#160;</td>
          <td class="paramname"><em>bind_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant holding a scalar/vector/tensor float (splat) and writes the float value to bind_value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00394">394</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a930dbe1d176d999aec049a4581838974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930dbe1d176d999aec049a4581838974">&#9670;&nbsp;</a></span>m_ConstantInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__op__binder.html">detail::constant_int_op_binder</a> mlir::m_ConstantInt </td>
          <td>(</td>
          <td class="paramtype">IntegerAttr::ValueType *&#160;</td>
          <td class="paramname"><em>bind_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant holding a scalar/vector/tensor integer (splat) and writes the integer value to bind_value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00401">401</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Promotion_8cpp_source.html#l00409">allocateSubviewGPUMemoryInAddressSpace()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01418">mlir::linalg::collapseGenericOpIterationDims()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00486">destructureIndices()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00117">getConstantIntValue()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00027">getConstantIntValue()</a>, <a class="el" href="AMDGPUDialect_8cpp_source.html#l00097">getConstantUint32()</a>, and <a class="el" href="KernelOutlining_8cpp_source.html#l00152">maybeConstantDimsAttr()</a>.</p>

</div>
</div>
<a id="a9e89b015211525b010832d2d2c37650b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e89b015211525b010832d2d2c37650b">&#9670;&nbsp;</a></span>m_NegInfFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_NegInfFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float negative infinity. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00348">348</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="aa9eba8d1292854c0da6c062988ecac9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9eba8d1292854c0da6c062988ecac9b">&#9670;&nbsp;</a></span>m_NegZeroFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_NegZeroFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float negative zero. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00327">327</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a94bb42600b9be680591776fdc14a53cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bb42600b9be680591776fdc14a53cd">&#9670;&nbsp;</a></span>m_NonZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a> mlir::m_NonZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer that is any non-zero value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00361">361</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a907f415a4c803b15ef57db37cc732f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907f415a4c803b15ef57db37cc732f39">&#9670;&nbsp;</a></span>m_One()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a> mlir::m_One </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer one. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00366">366</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="af0495d84f34cf3238a7741fa6974a485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0495d84f34cf3238a7741fa6974a485">&#9670;&nbsp;</a></span>m_OneFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_OneFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float ones. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00332">332</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="ac2418532386147bec2ca5aadf5414406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2418532386147bec2ca5aadf5414406">&#9670;&nbsp;</a></span>m_Op() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpClass &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">detail::op_matcher</a>&lt;OpClass&gt; mlir::m_Op </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches the given OpClass. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00372">372</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a7ecde76b07cd295bae0d6ef10d1c45d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecde76b07cd295bae0d6ef10d1c45d8">&#9670;&nbsp;</a></span>m_Op() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpType , typename... Matchers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::m_Op </td>
          <td>(</td>
          <td class="paramtype">Matchers...&#160;</td>
          <td class="paramname"><em>matchers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00406">406</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a69b52f968271c9a4da1bc766ee083a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b52f968271c9a4da1bc766ee083a9c">&#9670;&nbsp;</a></span>m_Op() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1NameOpMatcher.html">detail::NameOpMatcher</a> mlir::m_Op </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>opName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a named operation. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00297">297</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="adc93dfeaa35bda23b16591c462c335f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc93dfeaa35bda23b16591c462c335f6">&#9670;&nbsp;</a></span>m_PosInfFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_PosInfFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float positive infinity. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00340">340</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a774a1ae971f4ef00eb57389293dfe617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774a1ae971f4ef00eb57389293dfe617">&#9670;&nbsp;</a></span>m_PosZeroFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_PosZeroFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float positive zero. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00322">322</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a7f5d8af15bd8994b1a7abeaaacfe1b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5d8af15bd8994b1a7abeaaacfe1b06">&#9670;&nbsp;</a></span>m_Zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a> mlir::m_Zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer zero. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00355">355</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00116">generateTileLoopNest()</a>, and <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00040">isZeroValue()</a>.</p>

</div>
</div>
<a id="ac603376cc0dac0b2bd27c2dcde3c2e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac603376cc0dac0b2bd27c2dcde3c2e14">&#9670;&nbsp;</a></span>makeCanonicalStridedLayoutExpr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::makeCanonicalStridedLayoutExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>exprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given MemRef <code>sizes</code> that are either static or dynamic, returns the canonical "contiguous" strides <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a>. </p>
<p>Strides are multiplicative and once a dynamic dimension is encountered, all canonical strides become dynamic and need to be encoded with a different symbol. For canonical strides expressions, the offset is always 0 and and fastest varying stride is always <code>1</code>.</p>
<p>Examples:</p><ul>
<li>memref&lt;3x4x5xf32&gt; has canonical stride expression <code>20*exprs[0] + 5*exprs[1] + exprs[2]</code>.</li>
<li>memref&lt;3x?x5xf32&gt; has canonical stride expression <code>s0*exprs[0] + 5*exprs[1] + exprs[2]</code>.</li>
<li>memref&lt;3x4x?xf32&gt; has canonical stride expression <code>s1*exprs[0] + s0*exprs[1] + exprs[2]</code>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00894">894</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00527">getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00512">getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00242">mlir::AffineMap::inferFromExprList()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01407">simplifyAffineExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00856">canonicalizeStridedLayout()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00727">getStridesAndOffset()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00926">makeCanonicalStridedLayoutExpr()</a>.</p>

</div>
</div>
<a id="ad25cd8672ecb721d7a4f0ecd22bac6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25cd8672ecb721d7a4f0ecd22bac6e8">&#9670;&nbsp;</a></span>makeCanonicalStridedLayoutExpr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::makeCanonicalStridedLayoutExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the result of makeCanonicalStrudedLayoutExpr for the common case where <code>exprs</code> is {d0, d1, .., d_(sizes.size()-1)}. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00926">926</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00502">getAffineDimExpr()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00894">makeCanonicalStridedLayoutExpr()</a>.</p>

</div>
</div>
<a id="a643fb5da616fe37fef528fbcf735b8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643fb5da616fe37fef528fbcf735b8ec">&#9670;&nbsp;</a></span>makeOptimizingTransformer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;llvm::Error(llvm::Module *)&gt; mlir::makeOptimizingTransformer </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>optLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>sizeLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::TargetMachine *&#160;</td>
          <td class="paramname"><em>targetMachine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a module transformer function for MLIR <a class="el" href="classmlir_1_1ExecutionEngine.html" title="JIT-backed execution engine for MLIR.">ExecutionEngine</a> that runs <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR passes corresponding to the given speed and size optimization levels (e.g. </p>
<p>-O2 or -Os). If not null, <code>targetMachine</code> is used to initialize passes that provide target-specific information to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> optimizer. <code>targetMachine</code> must outlive the returned std::function. </p>

<p class="reference">Referenced by <a class="el" href="JitRunner_8cpp_source.html#l00353">JitRunnerMain()</a>.</p>

</div>
</div>
<a id="a7d806144c2d33e56f341109c75c3d277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d806144c2d33e56f341109c75c3d277">&#9670;&nbsp;</a></span>makeRegionIsolatedFromAbove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::makeRegionIsolatedFromAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>cloneOperationIntoRegion</em> = <code>[](<a class="el" href="classmlir_1_1Operation.html">Operation</a>&#160;*)&#160;{&#160;return&#160;false;&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a region isolated from above. </p>
<ul>
<li>Capture the values that are defined above the region and used within it.</li>
<li>Append to the entry block arguments that represent the captured values (one per captured value).</li>
<li>Replace all uses within the region of the captured values with the newly added arguments.</li>
<li><code>cloneOperationIntoRegion</code> is a callback that allows caller to specify if the operation defining an <code><a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a></code> needs to be cloned into the region. Then the operands of this operation become part of the captured values set (unless the operations that define the operands themeselves are to be cloned). The cloned operations are added to the entry block of the region. Return the set of captured values for the operation. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00080">80</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00055">mlir::Region::begin()</a>, <a class="el" href="Builders_8cpp_source.html#l00520">mlir::OpBuilder::clone()</a>, <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00107">computeTopologicalSorting()</a>, <a class="el" href="Builders_8cpp_source.html#l00405">mlir::OpBuilder::createBlock()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="Block_8h_source.html#l00076">mlir::Block::getArguments()</a>, <a class="el" href="Block_8cpp_source.html#l00137">mlir::Block::getArgumentTypes()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Block_8h_source.html#l00117">mlir::Block::getNumArguments()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00373">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00410">mlir::Operation::getResults()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00063">getUsedValuesDefinedAbove()</a>, <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00356">mlir::RewriterBase::mergeBlocks()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00232">mlir::RewriterBase::replaceOpWithIf()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00309">mlir::RewriterBase::replaceUsesWithIf()</a>, and <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="a923fafcbdcfdcb3b735fab2ab293a1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923fafcbdcfdcb3b735fab2ab293a1ad">&#9670;&nbsp;</a></span>makeStridedLinearLayoutMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::makeStridedLinearLayoutMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of strides (in which ShapedType::kDynamic represents a dynamic value), return the single result <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> which represents the linearized strided layout map. </p>
<p>Dimensions correspond to the offset followed by the strides in order. Symbols are inserted for each dynamic dimension in order. A stride is always positive.</p>
<h1><a class="anchor" id="autotoc_md28"></a>
Examples:</h1>
<ol type="1">
<li>For offset: 0 strides: ?, ?, 1 return (i, j, k)[M, N]-&gt;(M * i + N * j + k)</li>
<li>For offset: 3 strides: 32, ?, 16 return (i, j, k)[M]-&gt;(3 + 32 * i + M * j + 16 * k)</li>
<li>For offset: ? strides: ?, ?, ? return (i, j, k)[off, M, N, P]-&gt;(off + M * i + N * j + P * k) </li>
</ol>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01752">1752</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01135">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00527">getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00502">getAffineDimExpr()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00512">getAffineSymbolExpr()</a>.</p>

</div>
</div>
<a id="ac7736bcb70dbd9f242cd5182dd443031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7736bcb70dbd9f242cd5182dd443031">&#9670;&nbsp;</a></span>matchConstantIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">detail::op_matcher</a>&lt; <a class="el" href="classmlir_1_1arith_1_1ConstantIndexOp.html">arith::ConstantIndexOp</a> &gt; mlir::matchConstantIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a ConstantIndexOp. </p>
<p>TODO: This should probably just be a general matcher that uses matchConstant and checks the operation for an index type. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00022">22</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a id="a1b97d57dcd6c08b495fbd3ef22aeda6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b97d57dcd6c08b495fbd3ef22aeda6f">&#9670;&nbsp;</a></span>matchPattern() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pattern &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::matchPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entry point for matching a pattern over an <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00387">387</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a0190228b09e7b51a4bc1e013c01d404c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0190228b09e7b51a4bc1e013c01d404c">&#9670;&nbsp;</a></span>matchPattern() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pattern &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::matchPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entry point for matching a pattern over a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00378">378</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LocalAliasAnalysis_8cpp_source.html#l00249">mlir::LocalAliasAnalysis::aliasImpl()</a>, <a class="el" href="Promotion_8cpp_source.html#l00409">allocateSubviewGPUMemoryInAddressSpace()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01483">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01418">mlir::linalg::collapseGenericOpIterationDims()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01240">createOrFold()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00486">destructureIndices()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02276">foldLoopBounds()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00116">generateTileLoopNest()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00081">getAsOpFoldResult()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00117">getConstantIntValue()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00027">getConstantIntValue()</a>, <a class="el" href="AMDGPUDialect_8cpp_source.html#l00097">getConstantUint32()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00048">mlir::shape::getShapeVec()</a>, <a class="el" href="ControlFlowSinkUtils_8cpp_source.html#l00135">getSinglyExecutedRegionsToSink()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00192">mlir::ValueShapeRange::getValueAsShape()</a>, <a class="el" href="LLVMInlining_8cpp_source.html#l00050">handleInlinedAllocas()</a>, <a class="el" href="AsyncParallelFor_8cpp_source.html#l00191">integerConstants()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00499">isDefinedOutsideOrConstant()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00392">mlir::affine::isValidSymbol()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00040">isZeroValue()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00271">mlir::linalg::makeComposedPadHighOp()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01110">mlir::LLVM::ModuleImport::matchIntegerAttr()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00050">materializeConstant()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00152">maybeConstantDimsAttr()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00056">movePaddingToFillOrGenericOp()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00052">remainsLegalAfterInline()</a>.</p>

</div>
</div>
<a id="a6bc751bc8f30d71ad4cb771c0fcc788b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc751bc8f30d71ad4cb771c0fcc788b">&#9670;&nbsp;</a></span>matchReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::matchReduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt;&#160;</td>
          <td class="paramname"><em>iterCarriedArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>redPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>combinerOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to match a generic reduction given a list of iteration-carried arguments, <code>iterCarriedArgs</code> and the position of the potential reduction argument within the list, <code>redPos</code>. </p>
<p>If a reduction is matched, returns the reduced value and the topologically-sorted list of combiner operations involved in the reduction. Otherwise, returns a null value.</p>
<p>The matching algorithm relies on the following invariants, which are subject to change:</p><ol type="1">
<li>The first combiner operation must be a binary operation with the iteration-carried value and the reduced value as operands.</li>
<li>The iteration-carried value and combiner operations must be side effect-free, have single result and a single use.</li>
<li>Combiner operations must be immediately nested in the region op performing the reduction.</li>
<li>Reduction def-use chain must end in a terminator op that yields the next iteration/output values in the same order as the iteration-carried values in <code>iterCarriedArgs</code>.</li>
<li><code>iterCarriedArgs</code> must contain all the iteration-carried/output values of the region op performing the reduction.</li>
</ol>
<p>This utility is generic enough to detect reductions involving multiple combiner operations (disabled for now) across multiple dialects, including Linalg, Affine and SCF. For the sake of genericity, it does not return specific enum values for the combiner operations since its goal is also matching reductions without pre-defined semantics in core MLIR. It's up to each client to make sense out of the list of combiner operations. It's also up to each client to check for additional invariants on the expected reductions not covered by this generic matching. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00274">274</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00223">dependsOnCarriedVals()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00341">mlir::Operation::getNumOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00399">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00345">mlir::Operation::getOperand()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00814">mlir::Operation::getUsers()</a>, <a class="el" href="Value_8h_source.html#l00217">mlir::Value::getUsers()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00790">mlir::Operation::hasOneUse()</a>, <a class="el" href="Value_8h_source.html#l00204">mlir::Value::hasOneUse()</a>, <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00158">isMemoryEffectFree()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00698">mlir::Operation::mightHaveTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00491">matchLinalgReduction()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00042">matchSimpleReduction()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01431">vectorizeAffineYieldOp()</a>.</p>

</div>
</div>
<a id="a5ed40bd15766a7dff96f3d30577d8f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed40bd15766a7dff96f3d30577d8f87">&#9670;&nbsp;</a></span>mayHaveSSADominance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::mayHaveSSADominance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return "true" if the given region may have SSA dominance. </p>
<p>This function also returns "true" in case the owner op is an unregistered op or an op that does not implement the RegionKindInterface. </p>

<p class="definition">Definition at line <a class="el" href="RegionKindInterface_8cpp_source.html#l00020">20</a> of file <a class="el" href="RegionKindInterface_8cpp_source.html">RegionKindInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00200">mlir::Region::getParentOp()</a>, and <a class="el" href="IR_2Region_8cpp_source.html#l00062">mlir::Region::getRegionNumber()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Iterators_8h_source.html#l00053">mlir::ForwardDominanceIterator&lt; NoGraphRegions &gt;::makeIterable()</a>, and <a class="el" href="Iterators_8h_source.html#l00095">mlir::ReverseDominanceIterator&lt; NoGraphRegions &gt;::makeIterable()</a>.</p>

</div>
</div>
<a id="af3ad163144fafb93cf9814b2235ccf59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ad163144fafb93cf9814b2235ccf59">&#9670;&nbsp;</a></span>MlirLspServerMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::MlirLspServerMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation for tools like <code>mlir-lsp-server</code>. </p>
<ul>
<li>registry should contain all the dialects that can be parsed in source IR passed to the server. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MlirLspServerMain_8cpp_source.html#l00021">21</a> of file <a class="el" href="MlirLspServerMain_8cpp_source.html">MlirLspServerMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581aa603905470e2a5b8c13e96b579ef0dba">mlir::lsp::Logger::Debug</a>, <a class="el" href="Transport_8h_source.html#l00043">mlir::lsp::Delimited</a>, <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581a902b0d55fddef6f8d651fe1035b7d4bd">mlir::lsp::Logger::Error</a>, <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581a4059b0251f66a18cb56f544728796875">mlir::lsp::Logger::Info</a>, <a class="el" href="lsp-server-support_2Protocol_8cpp_source.html#l00243">mlir::lsp::URIForFile::registerSupportedScheme()</a>, <a class="el" href="mlir-lsp-server_2LSPServer_8cpp_source.html#l00285">mlir::lsp::runMlirLSPServer()</a>, <a class="el" href="Logging_8cpp_source.html#l00017">mlir::lsp::Logger::setLogLevel()</a>, and <a class="el" href="Transport_8h_source.html#l00041">mlir::lsp::Standard</a>.</p>

</div>
</div>
<a id="a1f6b96254b4e476bf34403287c27825a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6b96254b4e476bf34403287c27825a">&#9670;&nbsp;</a></span>MlirOptMain() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::MlirOptMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>toolName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation for tools like <code>mlir-opt</code>. </p>
<ul>
<li>toolName is used for the header displayed by <code>--help</code>.</li>
<li>registry should contain all the dialects that can be parsed in the source. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MlirOptMain_8cpp_source.html#l00398">398</a> of file <a class="el" href="MlirOptMain_8cpp_source.html">MlirOptMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="MlirOptMain_8cpp_source.html#l00179">mlir::MlirOptMainConfig::createFromCLOptions()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="DialectRegistry_8h_source.html#l00164">mlir::DialectRegistry::getDialectNames()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00364">MlirOptMain()</a>, <a class="el" href="namespacemlir.html#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">openInputFile()</a>, <a class="el" href="namespacemlir.html#a4c8c9750d9c8efdbcc7542f3b1564d8d">openOutputFile()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00178">registerAsmPrinterCLOptions()</a>, <a class="el" href="DebugCounter_8cpp_source.html#l00112">mlir::tracing::DebugCounter::registerCLOptions()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00174">mlir::MlirOptMainConfig::registerCLOptions()</a>, <a class="el" href="Timing_8cpp_source.html#l00557">registerDefaultTimingManagerCLOptions()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00089">registerMLIRContextCLOptions()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00128">registerPassManagerCLOptions()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="a440508357b9fe36f36010043c99e2f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440508357b9fe36f36010043c99e2f22">&#9670;&nbsp;</a></span>MlirOptMain() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::MlirOptMain </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>outputStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; llvm::MemoryBuffer &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1MlirOptMainConfig.html">MlirOptMainConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the core processing behind <code>mlir-opt</code>. </p>
<ul>
<li>outputStream is the stream where the resulting IR is printed.</li>
<li>buffer is the in-memory file to parser and process.</li>
<li>registry should contain all the dialects that can be parsed in the source.</li>
<li>config contains the configuration options for the tool. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MlirOptMain_8cpp_source.html#l00364">364</a> of file <a class="el" href="MlirOptMain_8cpp_source.html">MlirOptMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00164">mlir::DialectRegistry::getDialectNames()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00621">mlir::MLIRContext::getThreadPool()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00563">mlir::MLIRContext::isMultithreadingEnabled()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00318">processBuffer()</a>, <a class="el" href="MlirOptMain_8h_source.html#l00134">mlir::MlirOptMainConfig::shouldShowDialects()</a>, <a class="el" href="MlirOptMain_8h_source.html#l00142">mlir::MlirOptMainConfig::shouldSplitInputFile()</a>, and <a class="el" href="ToolUtilities_8cpp_source.html#l00022">splitAndProcessBuffer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00398">MlirOptMain()</a>.</p>

</div>
</div>
<a id="afcf1fa346908020b9dbc2009bb3630ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf1fa346908020b9dbc2009bb3630ce">&#9670;&nbsp;</a></span>MlirPdllLspServerMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::MlirPdllLspServerMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation for tools like <code>mlir-pdll-lsp-server</code>. </p>

<p class="definition">Definition at line <a class="el" href="MlirPdllLspServerMain_8cpp_source.html#l00020">20</a> of file <a class="el" href="MlirPdllLspServerMain_8cpp_source.html">MlirPdllLspServerMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581aa603905470e2a5b8c13e96b579ef0dba">mlir::lsp::Logger::Debug</a>, <a class="el" href="Transport_8h_source.html#l00043">mlir::lsp::Delimited</a>, <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581a902b0d55fddef6f8d651fe1035b7d4bd">mlir::lsp::Logger::Error</a>, <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581a4059b0251f66a18cb56f544728796875">mlir::lsp::Logger::Info</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="mlir-pdll-lsp-server_2LSPServer_8cpp_source.html#l00283">mlir::lsp::runPdllLSPServer()</a>, <a class="el" href="Logging_8cpp_source.html#l00017">mlir::lsp::Logger::setLogLevel()</a>, and <a class="el" href="Transport_8h_source.html#l00041">mlir::lsp::Standard</a>.</p>

</div>
</div>
<a id="ab515fd3b6aebea7df681f094b42d9e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab515fd3b6aebea7df681f094b42d9e71">&#9670;&nbsp;</a></span>mlirReduceMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::mlirReduceMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MlirReduceMain_8cpp_source.html#l00049">49</a> of file <a class="el" href="MlirReduceMain_8cpp_source.html">MlirReduceMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassRegistry_8cpp_source.html#l00932">mlir::PassPipelineCLParser::addToPipeline()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="OwningOpRef_8h_source.html#l00050">mlir::OwningOpRef&lt; OpTy &gt;::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">get()</a>, <a class="el" href="MlirReduceMain_8cpp_source.html#l00033">loadModule()</a>, <a class="el" href="namespacemlir.html#a4c8c9750d9c8efdbcc7542f3b1564d8d">openOutputFile()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="ad4175a8043cece857c2779663ef3ba91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4175a8043cece857c2779663ef3ba91">&#9670;&nbsp;</a></span>MlirTblgenMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mlir::MlirTblgenMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main Program for tools like 'mlir-tblgen' with custom backends. </p>
<p>To add a new backend, simply create a new '<a class="el" href="structmlir_1_1GenRegistration.html" title="GenRegistration provides a global initializer that registers a generator function.">mlir::GenRegistration</a>' global variable. See its documentation for more info.</p>
<p>The 'argc' and 'argv' arguments are simply forwarded from a main function. The return value is the exit code from llvm::TableGenMain. </p>

<p class="definition">Definition at line <a class="el" href="MlirTblgenMain_8cpp_source.html#l00140">140</a> of file <a class="el" href="MlirTblgenMain_8cpp_source.html">MlirTblgenMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="MlirTblgenMain_8cpp_source.html#l00030">actionOnDeprecatedValue</a>, <a class="el" href="MlirTblgenMain_8cpp_source.html#l00028">Error</a>, <a class="el" href="MlirTblgenMain_8cpp_source.html#l00125">generator</a>, <a class="el" href="MlirTblgenMain_8cpp_source.html#l00129">mlirTableGenMain()</a>, <a class="el" href="MlirTblgenMain_8cpp_source.html#l00028">None</a>, and <a class="el" href="MlirTblgenMain_8cpp_source.html#l00028">Warn</a>.</p>

</div>
</div>
<a id="ab673e648679ec83d87417b04baf281dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab673e648679ec83d87417b04baf281dd">&#9670;&nbsp;</a></span>mlirTranslateMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::mlirTranslateMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>toolName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate to/from an MLIR module from/to an external representation (e.g. </p>
<p><a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR, SPIRV binary, ...). This is the entry point for the implementation of tools like <code>mlir-translate</code>. The translation to perform is parsed from the command line. The <code>toolName</code> argument is used for the header displayed by <code>--help</code>. </p>

</div>
</div>
<a id="afca33cad5b0cd935568ea0fc0a439abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca33cad5b0cd935568ea0fc0a439abd">&#9670;&nbsp;</a></span>mod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::mod </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns MLIR's mod operation on constants. </p>
<p>MLIR's mod operation yields the remainder of the Euclidean division of 'lhs' by 'rhs', and is therefore not C's % operator. The RHS is always expected to be positive, and the result is always non-negative. </p>

<p class="definition">Definition at line <a class="el" href="MathExtras_8h_source.html#l00045">45</a> of file <a class="el" href="MathExtras_8h_source.html">MathExtras.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AllocLikeConversion_8cpp_source.html#l00047">mlir::AllocationOpLLVMLowering::createAligned()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00712">getBoundForExpr()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00326">parseScheduleClause()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l01296">prepareLLVMModule()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00834">simplifyMod()</a>, and <a class="el" href="OpenMPDialect_8cpp_source.html#l00286">verifyScheduleModifiers()</a>.</p>

</div>
</div>
<a id="a56b9f2d2e0330c53880b673633907ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b9f2d2e0330c53880b673633907ac6">&#9670;&nbsp;</a></span>moveLoopInvariantCode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mlir::moveLoopInvariantCode </td>
          <td>(</td>
          <td class="paramtype">LoopLikeOpInterface&#160;</td>
          <td class="paramname"><em>loopLike</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move side-effect free loop invariant code out of a loop-like op using methods provided by the interface. </p>

<p class="definition">Definition at line <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00097">97</a> of file <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html">LoopInvariantCodeMotionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00050">moveLoopInvariantCode()</a>.</p>

</div>
</div>
<a id="a7770d05a67ea19ac133fde220298b3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7770d05a67ea19ac133fde220298b3c7">&#9670;&nbsp;</a></span>moveLoopInvariantCode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mlir::moveLoopInvariantCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a>&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>isDefinedOutsideRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>shouldMoveOutOfRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>moveOutOfRegion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of regions, perform loop-invariant code motion. </p>
<p>An operation is loop-invariant if it depends only of values defined outside of the loop. LICM moves these operations out of the loop body so that they are not computed more than once.</p>
<p>Example:</p>
<div class="fragment"><div class="line">affine.for %arg0 = 0 to 10 {</div>
<div class="line">  affine.for %arg1 = 0 to 10 {</div>
<div class="line">    %v0 = arith.addi %arg0, %arg0 : i32</div>
<div class="line">    %v1 = arith.addi %v0, %arg1 : i32</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>After LICM:</p>
<div class="fragment"><div class="line">affine.for %arg0 = 0 to 10 {</div>
<div class="line">  %v0 = arith.addi %arg0, %arg0 : i32</div>
<div class="line">  affine.for %arg1 = 0 to 10 {</div>
<div class="line">    %v1 = arith.addi %v0, %arg1 : i32</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Users must supply three callbacks.</p>
<ul>
<li><code>isDefinedOutsideRegion</code> returns true if the given value is invariant with respect to the given region. A common implementation might be: <code>value.getParentRegion()-&gt;isProperAncestor(region)</code>.</li>
<li><code>shouldMoveOutOfRegion</code> returns true if the provided operation can be moved of the given region, e.g. if it is side-effect free.</li>
<li><code>moveOutOfRegion</code> moves the operation out of the given region. A common implementation might be: <code>op-&gt;moveBefore(region-&gt;getParentOp())</code>.</li>
</ul>
<p>An operation is moved if all of its operands satisfy <code>isDefinedOutsideRegion</code> and it satisfies <code>shouldMoveOutOfRegion</code>.</p>
<p>Returns the number of operations moved. </p>

<p class="definition">Definition at line <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00050">50</a> of file <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html">LoopInvariantCodeMotionUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Hoisting_8cpp_source.html#l00079">mlir::linalg::hoistRedundantVectorTransfers()</a>, and <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00097">moveLoopInvariantCode()</a>.</p>

</div>
</div>
<a id="a4ec63c3f9b9b50f77b7cc8b92f506204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec63c3f9b9b50f77b7cc8b92f506204">&#9670;&nbsp;</a></span>openInputFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; llvm::MemoryBuffer &gt; mlir::openInputFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>inputFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Align&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>errorMessage</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the file specified by its name for reading, with the given buffer alignment constraint. </p>
<p>Write the error message to <code>errorMessage</code> if errors occur and <code>errorMessage</code> is not nullptr. </p>

<p class="definition">Definition at line <a class="el" href="FileUtilities_8cpp_source.html#l00043">43</a> of file <a class="el" href="FileUtilities_8cpp_source.html">FileUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="FileUtilities_8cpp_source.html#l00023">openInputFileImpl()</a>.</p>

</div>
</div>
<a id="a0c2eb0b34f6d7e90435b0a6ce3d8ffaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">&#9670;&nbsp;</a></span>openInputFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::MemoryBuffer&gt; mlir::openInputFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>inputFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>errorMessage</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the file specified by its name for reading. </p>
<p>Write the error message to <code>errorMessage</code> if errors occur and <code>errorMessage</code> is not nullptr. </p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00289">loadIRDLDialects()</a>, <a class="el" href="MlirReduceMain_8cpp_source.html#l00033">loadModule()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00398">MlirOptMain()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00134">parseMLIRInput()</a>, and <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00056">parseTransformModuleFromFile()</a>.</p>

</div>
</div>
<a id="a4c8c9750d9c8efdbcc7542f3b1564d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8c9750d9c8efdbcc7542f3b1564d8d">&#9670;&nbsp;</a></span>openOutputFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::ToolOutputFile&gt; mlir::openOutputFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>outputFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>errorMessage</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the file specified by its name for writing. </p>
<p>Write the error message to <code>errorMessage</code> if errors occur and <code>errorMessage</code> is not nullptr. </p>

<p class="reference">Referenced by <a class="el" href="ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00083">mlir::SimpleObjectCache::dumpToObjectFile()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00421">mlir::PassManager::enableCrashReproducerGeneration()</a>, <a class="el" href="CLOptionsSetup_8cpp_source.html#l00072">mlir::tracing::InstallDebugHandler::Impl::Impl()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00398">MlirOptMain()</a>, and <a class="el" href="MlirReduceMain_8cpp_source.html#l00049">mlirReduceMain()</a>.</p>

</div>
</div>
<a id="aee326f96469cd288efb48265e173295e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee326f96469cd288efb48265e173295e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00258">258</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00107">mlir::OpState::getOperation()</a>.</p>

</div>
</div>
<a id="a8db56ba5c170b04848e194937be59a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db56ba5c170b04848e194937be59a56">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01012">1012</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a6bb385e3105982b905c5ef4db9f9f21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb385e3105982b905c5ef4db9f9f21b">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01018">1018</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a48146d74baebce1c83140c378053f3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48146d74baebce1c83140c378053f3c2">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01024">1024</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a4bfbb1c5941d2cc005eb3f483e881202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfbb1c5941d2cc005eb3f483e881202">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01028">1028</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a4f5d450d84010aaf140c9cccddf00804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5d450d84010aaf140c9cccddf00804">&#9670;&nbsp;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> mlir::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataFlowFramework_8h_source.html#l00044">44</a> of file <a class="el" href="DataFlowFramework_8h_source.html">DataFlowFramework.h</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999da4bac8cdf0a968472b519b3b295d0d48b">NoChange</a>.</p>

</div>
</div>
<a id="a9137193b56dc5134c3092273b13e3f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9137193b56dc5134c3092273b13e3f47">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::operator* </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00245">245</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

</div>
</div>
<a id="a8f6f52bcd2d859c9d9a6f393ad5481c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6f52bcd2d859c9d9a6f393ad5481c1">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::operator+ </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00244">244</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

</div>
</div>
<a id="a72aa3fc8e169b33e5d4a63f593172d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72aa3fc8e169b33e5d4a63f593172d4e">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::operator- </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00246">246</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

</div>
</div>
<a id="a6d315bdf3396a4c2cac6ead94cfc0e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d315bdf3396a4c2cac6ead94cfc0e26">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT , typename ElementT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; ElementT &gt;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="ab69273e2629a0b7e18af99582f687692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69273e2629a0b7e18af99582f687692">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a627aa7e5b958743b9a67a4ccbe1418c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627aa7e5b958743b9a67a4ccbe1418c9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a424d21ac06bbb37dee5c29f22e9d261a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424d21ac06bbb37dee5c29f22e9d261a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const APFloat &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a462d4f34f404bcc705506899944185f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462d4f34f404bcc705506899944185f6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT , typename T , std::enable_if_t&lt;!std::is_convertible&lt; T &amp;, Value &amp; &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Type &amp; &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Attribute &amp; &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, ValueRange &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, APFloat &amp; &gt;::value &amp;&amp;!llvm::is_one_of&lt; T, bool, float, double &gt;::value, T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a970e10cc4cef6e2f2dd48772041b4773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970e10cc4cef6e2f2dd48772041b4773">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_same&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value &amp;&amp; std::is_convertible&lt;T &amp;, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a4d69cef9b50344549afeaaa734f8172d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d69cef9b50344549afeaaa734f8172d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> &amp;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a26ecef972faf3b5c78d8415d69a86728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ecef972faf3b5c78d8415d69a86728">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT , typename ValueRangeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a>&lt; ValueRangeT &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="ad013c3d87cad19d6a7fa6ce16eb6bd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad013c3d87cad19d6a7fa6ce16eb6bd58">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="ac31efc2a6e3489b511bf1640b6e3b9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31efc2a6e3489b511bf1640b6e3b9eb">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[10/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a97986a4859106d3c96b089e726e26c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97986a4859106d3c96b089e726e26c7c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[11/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="ad554d3204bdbdc4a87d291ed94c1e575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad554d3204bdbdc4a87d291ed94c1e575">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[12/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00470">470</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmPrinter.html#a922b7c99e121802c2e58a80f964b8561">mlir::OpAsmPrinter::printSuccessor()</a>.</p>

</div>
</div>
<a id="a58c02ebe7d299d1683ae658ea4e9352c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c02ebe7d299d1683ae658ea4e9352c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[13/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::enable_if_t&lt; std::is_convertible&lt; T &amp;, ValueRange &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Value &amp; &gt;::value, T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00465">465</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="OpImplementation_8h_source.html#l00381">mlir::OpAsmPrinter::printOperands()</a>.</p>

</div>
</div>
<a id="acabdc4e9d44aae13942c9ea9b41b9a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabdc4e9d44aae13942c9ea9b41b9a33">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[14/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00456">456</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmPrinter.html#acddd5eb143c94fa8528920c75799e3ba">mlir::OpAsmPrinter::printOperand()</a>.</p>

</div>
</div>
<a id="ae69078b1d3f3263a1769df2e0f1730df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69078b1d3f3263a1769df2e0f1730df">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[15/37]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00894">894</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l03605">mlir::AffineExpr::print()</a>.</p>

</div>
</div>
<a id="a6f93a44db5e2d93372201d5a594e51cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f93a44db5e2d93372201d5a594e51cd">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[16/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00598">598</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l03619">mlir::AffineMap::print()</a>.</p>

</div>
</div>
<a id="a5e8f0e932c305de3ac1584560d1b03d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8f0e932c305de3ac1584560d1b03d0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[17/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Attributes_8h_source.html#l00150">150</a> of file <a class="el" href="IR_2Attributes_8h_source.html">Attributes.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l03556">mlir::Attribute::print()</a>.</p>

</div>
</div>
<a id="af8130946445de43cbbe975607457e51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8130946445de43cbbe975607457e51c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[18/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AliasResult.html">AliasResult</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AliasAnalysis_8h_source.html#l00078">78</a> of file <a class="el" href="AliasAnalysis_8h_source.html">AliasAnalysis.h</a>.</p>

<p class="reference">References <a class="el" href="AliasAnalysis_8cpp_source.html#l00030">mlir::AliasResult::print()</a>.</p>

</div>
</div>
<a id="aa90cebc5db982e1f7b1147c8c6595595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90cebc5db982e1f7b1147c8c6595595">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[19/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AnalysisState.html">AnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataFlowFramework_8h_source.html#l00456">456</a> of file <a class="el" href="DataFlowFramework_8h_source.html">DataFlowFramework.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AnalysisState.html#a6abd2440851a3aeb4417c0d7c09abdd9">mlir::AnalysisState::print()</a>.</p>

</div>
</div>
<a id="a85b9a8e647d5e73b7e107b0669ec9e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b9a8e647d5e73b7e107b0669ec9e29">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[20/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;&#160;</td>
          <td class="paramname"><em>diag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html#l00296">296</a> of file <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="ModuleImport_8cpp_source.html#l00050">diag()</a>.</p>

</div>
</div>
<a id="ae72e36349258a6b2baeae78188a74550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72e36349258a6b2baeae78188a74550">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[21/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DiagnosticArgument.html">DiagnosticArgument</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html#l00144">144</a> of file <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00058">mlir::DiagnosticArgument::print()</a>.</p>

</div>
</div>
<a id="a279adec3f964e12de632fa76060d2669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279adec3f964e12de632fa76060d2669">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[22/37]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IRUnit.html">IRUnit</a> &amp;&#160;</td>
          <td class="paramname"><em>unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab097ddf5971ea2a3956fc814005f459f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab097ddf5971ea2a3956fc814005f459f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[23/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Location_8h_source.html#l00117">117</a> of file <a class="el" href="Location_8h_source.html">Location.h</a>.</p>

<p class="reference">References <a class="el" href="Location_8h_source.html#l00098">mlir::Location::print()</a>.</p>

</div>
</div>
<a id="a0e8ea3e011d372d1f5b3bc1fb34e1286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8ea3e011d372d1f5b3bc1fb34e1286">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[24/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ModRefResult.html">ModRefResult</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AliasAnalysis_8h_source.html#l00165">165</a> of file <a class="el" href="AliasAnalysis_8h_source.html">AliasAnalysis.h</a>.</p>

<p class="reference">References <a class="el" href="AliasAnalysis_8cpp_source.html#l00051">mlir::ModRefResult::print()</a>.</p>

</div>
</div>
<a id="ab0dd71f700f3e4336e89a94f69ff28de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0dd71f700f3e4336e89a94f69ff28de">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[25/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Operation_8h_source.html#l01034">1034</a> of file <a class="el" href="IR_2Operation_8h_source.html">Operation.h</a>.</p>

</div>
</div>
<a id="ac7e879c874e4fdc6aaf9d4742abdb876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e879c874e4fdc6aaf9d4742abdb876">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[26/37]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1Range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02875">2875</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8h_source.html#l00031">mlir::Range::offset</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00032">mlir::Range::size</a>, and <a class="el" href="StaticValueUtils_8h_source.html#l00033">mlir::Range::stride</a>.</p>

</div>
</div>
<a id="a40e22b31f6f0d59955e0e73f0d387613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e22b31f6f0d59955e0e73f0d387613">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[27/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> &amp;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit a type range to the given output stream. </p>

<p class="definition">Definition at line <a class="el" href="TypeRange_8h_source.html#l00077">77</a> of file <a class="el" href="TypeRange_8h_source.html">TypeRange.h</a>.</p>

</div>
</div>
<a id="aef74da457499b5816049abe29cc25d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef74da457499b5816049abe29cc25d04">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[28/37]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">mlir::Block</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CFGLoopInfo_8cpp_source.html#l00027">27</a> of file <a class="el" href="CFGLoopInfo_8cpp_source.html">CFGLoopInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l03711">mlir::Block::print()</a>.</p>

</div>
</div>
<a id="a45dade5c2740697bc36ceb8d6554ee00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45dade5c2740697bc36ceb8d6554ee00">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[29/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a>&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00487">487</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l00055">mlir::OperationName::print()</a>.</p>

</div>
</div>
<a id="a8c357b30f2e56803678fe5f7b75e80a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c357b30f2e56803678fe5f7b75e80a1">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[30/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow printing to a stream. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00273">273</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="SPIRVAttributes_8cpp_source.html#l00622">print()</a>.</p>

</div>
</div>
<a id="af07e7b01e09b3da975cc984b4e1c506d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07e7b01e09b3da975cc984b4e1c506d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[31/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow printing to a stream. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00282">282</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="acee66a47ca548fabe02261ad8b96eea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee66a47ca548fabe02261ad8b96eea5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[32/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00784">784</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8cpp_source.html#l00102">mlir::PDLValue::print()</a>.</p>

</div>
</div>
<a id="a778366ed204055f8c0ae4e113220a5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778366ed204055f8c0ae4e113220a5bd">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[33/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PDLValue.html#aa5a98d42f4638805a23d5390ddb28ac0">PDLValue::Kind</a>&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00789">789</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

</div>
</div>
<a id="a66be8071673bc737aec05de131f066cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66be8071673bc737aec05de131f066cf">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[34/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ProgramPoint.html">ProgramPoint</a>&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataFlowFramework_8h_source.html#l00461">461</a> of file <a class="el" href="DataFlowFramework_8h_source.html">DataFlowFramework.h</a>.</p>

<p class="reference">References <a class="el" href="DataFlowFramework_8cpp_source.html#l00037">mlir::ProgramPoint::print()</a>.</p>

</div>
</div>
<a id="a78425f2c879f5b708f5c58af03931e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78425f2c879f5b708f5c58af03931e9f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[35/37]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SymbolTable.html#a4f1a6f39b93a08abe4e80a5c15fe32b8">SymbolTable::Visibility</a>&#160;</td>
          <td class="paramname"><em>visibility</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SymbolTable_8cpp_source.html#l00396">396</a> of file <a class="el" href="SymbolTable_8cpp_source.html">SymbolTable.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1SymbolTable.html#a4f1a6f39b93a08abe4e80a5c15fe32b8a13c479c348969ab459513a4bfd559bb9">mlir::SymbolTable::Nested</a>, <a class="el" href="classmlir_1_1SymbolTable.html#a4f1a6f39b93a08abe4e80a5c15fe32b8a47f9082fc380ca62d531096aa1d110f1">mlir::SymbolTable::Private</a>, and <a class="el" href="classmlir_1_1SymbolTable.html#a4f1a6f39b93a08abe4e80a5c15fe32b8a3d067bedfe2f4677470dd6ccf64d05ed">mlir::SymbolTable::Public</a>.</p>

</div>
</div>
<a id="acd5bfd80339235fbb32a685ff75f4e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5bfd80339235fbb32a685ff75f4e16">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[36/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00239">239</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l03577">mlir::Type::print()</a>.</p>

</div>
</div>
<a id="a3df16c49c963cdc57cf6f9e7c3e9f822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df16c49c963cdc57cf6f9e7c3e9f822">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[37/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Value_8h_source.html#l00244">244</a> of file <a class="el" href="Value_8h_source.html">Value.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l03633">mlir::Value::print()</a>.</p>

</div>
</div>
<a id="a8fc3d1f66f267d9111234fac1effdfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc3d1f66f267d9111234fac1effdfce">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a>&lt; RangeT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeRange_8h_source.html#l00163">163</a> of file <a class="el" href="TypeRange_8h_source.html">TypeRange.h</a>.</p>

</div>
</div>
<a id="abc4f129dda2c412845b5ec66a77325a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4f129dda2c412845b5ec66a77325a3">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00255">255</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00107">mlir::OpState::getOperation()</a>.</p>

</div>
</div>
<a id="a543c4328a4fa5ed530aa88a9d7d158a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543c4328a4fa5ed530aa88a9d7d158a9">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define comparisons for StringAttr against nullptr and itself to avoid the StringRef overloads from being chosen when not desirable. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01011">1011</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00489">mlir::ValueBoundsConstraintSet::BoundBuilder::operator==()</a>.</p>

</div>
</div>
<a id="a40ce38cb70a016263f28574d4982475b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ce38cb70a016263f28574d4982475b">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01015">1015</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a075d7bf5dfe5d33c409763bc28330180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075d7bf5dfe5d33c409763bc28330180">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow direct comparison with StringRef. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01021">1021</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a50c46bfb0a0fbbe700ef6c07a611dbf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c46bfb0a0fbbe700ef6c07a611dbf8">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01025">1025</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a609ab9ceb7a2ad554864c86fc7ece4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609ab9ceb7a2ad554864c86fc7ece4fd">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> mlir::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataFlowFramework_8h_source.html#l00037">37</a> of file <a class="el" href="DataFlowFramework_8h_source.html">DataFlowFramework.h</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999daf4ec5f57bd4d31b803312d873be40da9">Change</a>.</p>

</div>
</div>
<a id="a001ec055bf293748f02c00aff842dc38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001ec055bf293748f02c00aff842dc38">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&amp; mlir::operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataFlowFramework_8h_source.html#l00040">40</a> of file <a class="el" href="DataFlowFramework_8h_source.html">DataFlowFramework.h</a>.</p>

</div>
</div>
<a id="a10aad3624e000c0585087c96357ea857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10aad3624e000c0585087c96357ea857">&#9670;&nbsp;</a></span>outlineIfOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::outlineIfOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::IfOp&#160;</td>
          <td class="paramname"><em>ifOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">func::FuncOp *&#160;</td>
          <td class="paramname"><em>thenFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>thenFnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">func::FuncOp *&#160;</td>
          <td class="paramname"><em>elseFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>elseFnName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outline the then and/or else regions of <code>ifOp</code> as follows: </p>
<ul>
<li>if <code>thenFn</code> is not null, <code>thenFnName</code> must be specified and the <code>then</code> region is inlined into a new FuncOp that is captured by the pointer.</li>
<li>if <code>elseFn</code> is not null, <code>elseFnName</code> must be specified and the <code>else</code> region is inlined into a new FuncOp that is captured by the pointer. Creates new FuncOps and thus cannot be used in a FuncOp pass. The client is responsible for providing a unique <code>thenFnName</code>/<code>elseFnName</code> that will not collide with another FuncOp name. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00291">291</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00187">outlineSingleBlockRegion()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="ae9152a09d079148a1a2f40d4946f7c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9152a09d079148a1a2f40d4946f7c17">&#9670;&nbsp;</a></span>outlineKernelFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gpu::GPUFuncOp mlir::outlineKernelFunc </td>
          <td>(</td>
          <td class="paramtype">gpu::LaunchOp&#160;</td>
          <td class="paramname"><em>launchOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>kernelFnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">llvm::SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a gpu.func created from outlining the region of a gpu.launch op with the given <code>kernelFnName</code>. </p>
<p>The region of the <code>launchOp</code> can use values from above. These need to be captured and passed as arguments to the generated gpu.func. The generated function has arguments</p><ul>
<li>corresponding to the values passed in as <code>operands</code>, in that order.</li>
<li>any additional values that might be used within the region of the <code>launchOp</code> and defined above it. These captured values are appended to the <code>operands</code> list. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="KernelOutlining_8cpp_source.html#l00257">257</a> of file <a class="el" href="KernelOutlining_8cpp_source.html">KernelOutlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="KernelOutlining_8cpp_source.html#l00172">outlineKernelFuncImpl()</a>.</p>

</div>
</div>
<a id="abdec8fa23b93085ee2e142defd7c5599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdec8fa23b93085ee2e142defd7c5599">&#9670;&nbsp;</a></span>outlineSingleBlockRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; func::FuncOp &gt; mlir::outlineSingleBlockRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>funcName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">func::CallOp *&#160;</td>
          <td class="paramname"><em>callOp</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outline a region with a single block into a new FuncOp. </p>
<p>Assumes the FuncOp result types is the type of the yielded operands of the single block. This constraint makes it easy to determine the result. This method also clones the <code><a class="el" href="classmlir_1_1arith_1_1ConstantIndexOp.html" title="Specialization of arith.constant op that returns an integer of index type.">arith::ConstantIndexOp</a></code> at the start of <code>outlinedFuncBody</code> to alloc simple canonicalizations. Creates a new FuncOp and thus cannot be used in a FuncOp pass. The client is responsible for providing a unique <code>funcName</code> that will not collide with another FuncOp name. If <code>callOp</code> is provided, it will be set to point to the operation that calls the outlined function.</p>
<p>Assumes the FuncOp result types is the type of the yielded operands of the single block. This constraint makes it easy to determine the result. This method also clones the <code><a class="el" href="classmlir_1_1arith_1_1ConstantIndexOp.html" title="Specialization of arith.constant op that returns an integer of index type.">arith::ConstantIndexOp</a></code> at the start of <code>outlinedFuncBody</code> to alloc simple canonicalizations. If <code>callOp</code> is provided, it will be set to point to the operation that calls the outlined function. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00187">187</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00055">mlir::Region::begin()</a>, <a class="el" href="Builders_8cpp_source.html#l00520">mlir::OpBuilder::clone()</a>, <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8cpp_source.html#l00405">mlir::OpBuilder::createBlock()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00285">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">get()</a>, <a class="el" href="Block_8h_source.html#l00076">mlir::Block::getArguments()</a>, <a class="el" href="IR_2Region_8h_source.html#l00081">mlir::Region::getArguments()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Block_8h_source.html#l00117">mlir::Block::getNumArguments()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00373">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00392">mlir::Operation::getOperandTypes()</a>, <a class="el" href="UseDefLists_8h_source.html#l00040">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="IR_2Region_8h_source.html#l00205">mlir::Region::getParentOfType()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00402">mlir::Operation::getResult()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00423">mlir::Operation::getResultTypes()</a>, <a class="el" href="Block_8cpp_source.html#l00232">mlir::Block::getTerminator()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00063">getUsedValuesDefinedAbove()</a>, <a class="el" href="IR_2Region_8h_source.html#l00068">mlir::Region::hasOneBlock()</a>, <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00356">mlir::RewriterBase::mergeBlocks()</a>, <a class="el" href="Value_8cpp_source.html#l00082">mlir::Value::replaceUsesWithIf()</a>, <a class="el" href="Builders_8h_source.html#l00379">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00417">mlir::OpBuilder::setInsertionPointToEnd()</a>, and <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00291">outlineIfOp()</a>.</p>

</div>
</div>
<a id="ad02ff92115796118c612bc82db603b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02ff92115796118c612bc82db603b7e">&#9670;&nbsp;</a></span>parallelFor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::parallelFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements between [begin, end) asynchronously. </p>
<p>Diagnostics emitted during processing are ordered relative to the element's position within [begin, end). If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00141">141</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="Threading_8h_source.html#l00117">parallelForEach()</a>.</p>

</div>
</div>
<a id="a7acf0c58d63da562112dd8f6a81b49e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acf0c58d63da562112dd8f6a81b49e3">&#9670;&nbsp;</a></span>parallelForEach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename FuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::parallelForEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements between [begin, end) asynchronously. </p>
<p>Diagnostics emitted during processing are ordered relative to the element's position within [begin, end). If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00117">117</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="Threading_8h_source.html#l00036">failableParallelForEach()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Threading_8h_source.html#l00141">parallelFor()</a>, and <a class="el" href="Threading_8h_source.html#l00130">parallelForEach()</a>.</p>

</div>
</div>
<a id="af1232c5821e793866aa3cf2234e1ba93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1232c5821e793866aa3cf2234e1ba93">&#9670;&nbsp;</a></span>parallelForEach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT , typename FuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::parallelForEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeT &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements in the provided range asynchronously. </p>
<p>Diagnostics emitted during processing are ordered relative to the element's position within the range. If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00130">130</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="Threading_8h_source.html#l00117">parallelForEach()</a>.</p>

</div>
</div>
<a id="a351183b9c1036310349dea952c1f2d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351183b9c1036310349dea952c1f2d5a">&#9670;&nbsp;</a></span>parseAffineMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::parseAffineMap </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single IntegerSet/AffineMap to an MLIR context if it was valid. </p>
<p>If not, an error message is emitted through a new <a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html" title="This class is a utility diagnostic handler for use with llvm::SourceMgr.">SourceMgrDiagnosticHandler</a> constructed from a new SourceMgr with a single MemoryBuffer wrapping <code>str</code>. If the passed <code>str</code> has additional tokens that were not part of the IntegerSet/AffineMap, a failure is returned. </p>

</div>
</div>
<a id="a2ce4d766139754b57d04b314aefacea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce4d766139754b57d04b314aefacea5">&#9670;&nbsp;</a></span>parseAsmSourceFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::parseAsmSourceFile </td>
          <td>(</td>
          <td class="paramtype">const llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParserState.html">AsmParserState</a> *&#160;</td>
          <td class="paramname"><em>asmState</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParserCodeCompleteContext.html">AsmParserCodeCompleteContext</a> *&#160;</td>
          <td class="paramname"><em>codeCompleteContext</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated SourceMgr and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. If <code>sourceFileLoc</code> is non-null, it is populated with a file location representing the start of the source file that is being parsed. If <code>asmState</code> is non-null, it is populated with detailed information about the parsed IR (including exact locations for SSA uses and definitions). <code>asmState</code> should only be provided if this detailed information is desired. If <code>codeCompleteContext</code> is non-null, it is used to signal tracking of a code completion event (generally only ever useful for LSP or other high level language tooling). </p>

<p class="definition">Definition at line <a class="el" href="AsmParser_2Parser_8cpp_source.html#l02723">2723</a> of file <a class="el" href="AsmParser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00368">get()</a>, and <a class="el" href="AsmState_8h_source.html#l00472">mlir::ParserConfig::getContext()</a>.</p>

</div>
</div>
<a id="a6658f887276425945e0ebe6fcc194c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6658f887276425945e0ebe6fcc194c23">&#9670;&nbsp;</a></span>parseAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::parseAttribute </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>attrStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>numRead</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isKnownNullTerminated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single MLIR attribute to an MLIR context if it was valid. </p>
<p>If not, an error diagnostic is emitted to the context and a null value is returned. If <code>numRead</code> is provided, it is set to the number of consumed characters on succesful parse. Otherwise, parsing fails if the entire string is not consumed. Some internal copying can be skipped if the source string is known to be null terminated. </p>

<p class="reference">Referenced by <a class="el" href="IR_8cpp_source.html#l00842">mlirAttributeParseGet()</a>.</p>

</div>
</div>
<a id="ac7f4b6d36ff77aeffcb446b5822022c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f4b6d36ff77aeffcb446b5822022c5">&#9670;&nbsp;</a></span>parseDynamicIndexList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> mlir::parseDynamicIndexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a> &amp;&#160;</td>
          <td class="paramname"><em>integers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a>&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pasrer hook for custom directive in assemblyFormat. </p>
<p>custom&lt;DynamicIndexList&gt;($values, $integers)</p>
<p>where <code>values</code> is of ODS type <code>Variadic&lt;Index&gt;</code> and <code>integers</code> is of ODS type <code>I64ArrayAttr</code>. Parse a mixed list with either (1) static integer values or (2) SSA values. Fill <code>integers</code> with the integer ArrayAttr, where <code>dynVal</code> encodes the position of SSA values. Add the parsed SSA values to <code>values</code> in-order. E.g. after parsing "[%arg0, 7, 42, %arg42]":</p><ol type="1">
<li><code>result</code> is filled with the i64 ArrayAttr "[`dynVal`, 7, 42, `dynVal`]"</li>
<li><code>ssa</code> is filled with "[%arg0, %arg1]". </li>
</ol>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00123">123</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">mlir::AsmParser::getBuilder()</a>, <a class="el" href="Builders_8cpp_source.html#l00169">mlir::Builder::getDenseI64ArrayAttr()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a8d00f93debeb1567ae8f7bbb76cdea37">mlir::AsmParser::getNameLoc()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2839f5b817f7fd118a6b0381da695436">mlir::AsmParser::parseCommaSeparatedList()</a>, <a class="el" href="OpImplementation_8h_source.html#l00641">mlir::AsmParser::parseInteger()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a8fd765b541880aa1f11ca238ce62ad9d">mlir::OpAsmParser::parseOptionalOperand()</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">succeeded()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Transform_2Utils_2Utils_8cpp_source.html#l00028">mlir::transform::parsePackedOrDynamicIndexList()</a>.</p>

</div>
</div>
<a id="a4cdbef9427aac1eeac4dbf017bae583b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cdbef9427aac1eeac4dbf017bae583b">&#9670;&nbsp;</a></span>parseEnumKeywordAttr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EnumClass , typename ParserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> mlir::parseEnumKeywordAttr </td>
          <td>(</td>
          <td class="paramtype">EnumClass &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParserType &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>attrName</em> = <code>spirv::attributeName&lt;EnumClass&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses the next keyword in <code>parser</code> as an enumerant of the given <code>EnumClass</code>. </p>

<p class="definition">Definition at line <a class="el" href="ParserUtils_8h_source.html#l00027">27</a> of file <a class="el" href="ParserUtils_8h_source.html">ParserUtils.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVDialect_8cpp_source.html#l00324">parseCooperativeMatrixType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00217">parseEnumKeywordAttr()</a>, and <a class="el" href="SPIRVDialect_8cpp_source.html#l00355">parseJointMatrixType()</a>.</p>

</div>
</div>
<a id="acda383f3d69ddb866ea67abc7ba9e75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda383f3d69ddb866ea67abc7ba9e75e">&#9670;&nbsp;</a></span>parseIntegerSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> mlir::parseIntegerSet </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8d10077c7edf58c1152a1170257d739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d10077c7edf58c1152a1170257d739">&#9670;&nbsp;</a></span>parsePassPipeline() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::parsePassPipeline </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>pipeline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>errorStream</em> = <code>llvm::errs()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the textual representation of a pass pipeline, adding the result to 'pm' on success. </p>
<p>Returns failure if the given pipeline was invalid. 'errorStream' is the output stream used to emit errors found during parsing. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8cpp_source.html#l00695">695</a> of file <a class="el" href="PassRegistry_8cpp_source.html">PassRegistry.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassRegistry_8cpp_source.html#l00932">mlir::PassPipelineCLParser::addToPipeline()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00484">mlir::PassReproducerOptions::apply()</a>, <a class="el" href="CAPI_2IR_2Pass_8cpp_source.html#l00074">mlirOpPassManagerAddPipeline()</a>, <a class="el" href="CAPI_2IR_2Pass_8cpp_source.html#l00089">mlirParsePassPipeline()</a>, and <a class="el" href="PassRegistry_8cpp_source.html#l00709">parsePassPipeline()</a>.</p>

</div>
</div>
<a id="aef5abaea7950d9dc385a018dbbb40d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5abaea7950d9dc385a018dbbb40d0b">&#9670;&nbsp;</a></span>parsePassPipeline() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt; mlir::parsePassPipeline </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>pipeline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>errorStream</em> = <code>llvm::errs()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the given textual representation of a pass pipeline, and return the parsed pipeline on success. </p>
<p>The given pipeline string should be wrapped with the desired type of operation to root the created operation, i.e. <code>builtin.module(cse)</code> over <code>cse</code>. Returns failure if the given pipeline was invalid. 'errorStream' is the output stream used to emit errors found during parsing. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8cpp_source.html#l00709">709</a> of file <a class="el" href="PassRegistry_8cpp_source.html">PassRegistry.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, and <a class="el" href="PassRegistry_8cpp_source.html#l00695">parsePassPipeline()</a>.</p>

</div>
</div>
<a id="ab0f975095772c8ece0dbda8bf7f455eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f975095772c8ece0dbda8bf7f455eb">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">const llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated SourceMgr and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. If <code>sourceFileLoc</code> is non-null, it is populated with a file location representing the start of the source file that is being parsed. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00020">20</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="MLIRServer_8cpp_source.html#l01286">mlir::lsp::MLIRServer::convertFromBytecode()</a>, and <a class="el" href="ParseUtilities_8h_source.html#l00027">parseSourceFileForTool()</a>.</p>

</div>
</div>
<a id="a8735a3d1b2704c1497e7c4b8173e8d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8735a3d1b2704c1497e7c4b8173e8d99">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT  = Operation *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ContainerOpT&gt; mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">const llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated SourceMgr. </p>
<p>If the source IR contained a single instance of <code>ContainerOpT</code>, it is returned. Otherwise, a new instance of <code>ContainerOpT</code> is constructed containing all of the parsed operations. If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context, and failure is returned. <code>ContainerOpT</code> is required to have a single region containing a single block, and must implement the <code>SingleBlockImplicitTerminator</code> trait. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00177">177</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

</div>
</div>
<a id="a537a80c31d8487a710f53cd9a38e390a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537a80c31d8487a710f53cd9a38e390a">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR). </p>
<p>This is useful, for example, to avoid copying some large resources into the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> and instead referencing the data directly from the input buffers. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00034">34</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

</div>
</div>
<a id="a2b9ed7461f16d832b9a3d5c1c444ff7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9ed7461f16d832b9a3d5c1c444ff7e">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT  = Operation *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ContainerOpT&gt; mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR). </p>
<p>This is useful, for example, to avoid copying some large resources into the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> and instead referencing the data directly from the input buffers. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00187">187</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

</div>
</div>
<a id="a006a32917056b7f14d65e9ea5cc08392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006a32917056b7f14d65e9ea5cc08392">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. If <code>sourceFileLoc</code> is non-null, it is populated with a file location representing the start of the source file that is being parsed. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00049">49</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

</div>
</div>
<a id="a54875232f3a58ed939964dc275d1e36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54875232f3a58ed939964dc275d1e36f">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR). </p>
<p>This is useful, for example, to avoid copying some large resources into the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> and instead referencing the data directly from the input buffers. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00082">82</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

</div>
</div>
<a id="af9e06cd142a5019f145069349181e2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e06cd142a5019f145069349181e2e0">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT  = Operation *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ContainerOpT&gt; mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR). </p>
<p>This is useful, for example, to avoid copying some large resources into the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> and instead referencing the data directly from the input buffers. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00227">227</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

</div>
</div>
<a id="a13ad011b0b3c1635c410fe60bfd557c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ad011b0b3c1635c410fe60bfd557c2">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename using the provided SourceMgr and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. If <code>sourceFileLoc</code> is non-null, it is populated with a file location representing the start of the source file that is being parsed. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00074">74</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

</div>
</div>
<a id="a3f46d0b9658a27fa31f7ce98851ca7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f46d0b9658a27fa31f7ce98851ca7fe">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT  = Operation *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ContainerOpT&gt; mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename using the provided SourceMgr. </p>
<p>If the source IR contained a single instance of <code>ContainerOpT</code>, it is returned. Otherwise, a new instance of <code>ContainerOpT</code> is constructed containing all of the parsed operations. If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context, and failure is returned. <code>ContainerOpT</code> is required to have a single region containing a single block, and must implement the <code>SingleBlockImplicitTerminator</code> trait. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00215">215</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

</div>
</div>
<a id="a731c3e653fe7b19e18f2ca619aa763fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731c3e653fe7b19e18f2ca619aa763fa">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT  = Operation *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ContainerOpT&gt; mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename. </p>
<p>If the source IR contained a single instance of <code>ContainerOpT</code>, it is returned. Otherwise, a new instance of <code>ContainerOpT</code> is constructed containing all of the parsed operations. If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context, and failure is returned. <code>ContainerOpT</code> is required to have a single region containing a single block, and must implement the <code>SingleBlockImplicitTerminator</code> trait. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00201">201</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

</div>
</div>
<a id="a718d37dc4122f9a0851238684eb13a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718d37dc4122f9a0851238684eb13a39">&#9670;&nbsp;</a></span>parseSourceFileForTool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; mlir::parseSourceFileForTool </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>insertImplicitModule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated SourceMgr. </p>
<p>If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context. If 'insertImplicitModule' is true a top-level 'builtin.module' op will be inserted that contains the parsed IR, unless one exists already. </p>

<p class="definition">Definition at line <a class="el" href="ParseUtilities_8h_source.html#l00027">27</a> of file <a class="el" href="ParseUtilities_8h_source.html">ParseUtilities.h</a>.</p>

<p class="reference">References <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00020">parseSourceFile()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirReduceMain_8cpp_source.html#l00033">loadModule()</a>, and <a class="el" href="JitRunner_8cpp_source.html#l00134">parseMLIRInput()</a>.</p>

</div>
</div>
<a id="a80178c9e23c4fd7db357124cbe19651a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80178c9e23c4fd7db357124cbe19651a">&#9670;&nbsp;</a></span>parseSourceString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::parseSourceString </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>sourceStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>sourceName</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the IR string and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. <code>sourceName</code> is used as the file name of the source; any IR without locations will get a <code>FileLineColLoc</code> location with <code>sourceName</code> as the file name. If <code>sourceFileLoc</code> is non-null, it is populated with a file location representing the start of the source file that is being parsed. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00090">90</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_8cpp_source.html#l00389">mlirOperationCreateParse()</a>, and <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00245">parseSourceString()</a>.</p>

</div>
</div>
<a id="a1bfecc94be370f449013ec1f80818da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bfecc94be370f449013ec1f80818da8">&#9670;&nbsp;</a></span>parseSourceString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT  = Operation *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ContainerOpT&gt; mlir::parseSourceString </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>sourceStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>sourceName</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the provided string containing MLIR. </p>
<p>If the source IR contained a single instance of <code>ContainerOpT</code>, it is returned. Otherwise, a new instance of <code>ContainerOpT</code> is constructed containing all of the parsed operations. If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context, and failure is returned. <code>ContainerOpT</code> is required to have a single region containing a single block, and must implement the <code>SingleBlockImplicitTerminator</code> trait. <code>sourceName</code> is used as the file name of the source; any IR without locations will get a <code>FileLineColLoc</code> location with <code>sourceName</code> as the file name. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00245">245</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="AsmState_8h_source.html#l00472">mlir::ParserConfig::getContext()</a>, and <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00090">parseSourceString()</a>.</p>

</div>
</div>
<a id="abab8375de28e1d1916659a658e7ad318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab8375de28e1d1916659a658e7ad318">&#9670;&nbsp;</a></span>parseType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::parseType </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>typeStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>numRead</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isKnownNullTerminated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single MLIR type to an MLIR context if it was valid. </p>
<p>If not, an error diagnostic is emitted to the context. If <code>numRead</code> is provided, it is set to the number of consumed characters on succesful parse. Otherwise, parsing fails if the entire string is not consumed. Some internal copying can be skipped if the source string is known to be null terminated. </p>

<p class="reference">Referenced by <a class="el" href="IR_8cpp_source.html#l00815">mlirTypeParseGet()</a>.</p>

</div>
</div>
<a id="aee7856a3b7ff811204524bbc9959c8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7856a3b7ff811204524bbc9959c8c9">&#9670;&nbsp;</a></span>populateAffineToStdConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateAffineToStdConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the Affine dialect to the Standard dialect, in particular convert structured affine control flow into CFG branch-based control flow. </p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00523">523</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ad6a984b6da6b0bf690f727bd2e20dd31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a984b6da6b0bf690f727bd2e20dd31">&#9670;&nbsp;</a></span>populateAffineToVectorConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateAffineToVectorConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert vector-related Affine ops to the <a class="el" href="structVector.html">Vector</a> dialect. </p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00541">541</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a9dca6cbddde02ebb60f3f7d61835e63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dca6cbddde02ebb60f3f7d61835e63a">&#9670;&nbsp;</a></span>populateAMDGPUToROCDLConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateAMDGPUToROCDLConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1amdgpu_1_1Chipset.html">amdgpu::Chipset</a>&#160;</td>
          <td class="paramname"><em>chipset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00539">539</a> of file <a class="el" href="AMDGPUToROCDL_8cpp_source.html">AMDGPUToROCDL.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00146">mlir::TypeConverter::addConversion()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">get()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00035">mlir::Type::getContext()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00040">mlir::Type::isFloat8E4M3FNUZ()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00039">mlir::Type::isFloat8E5M2FNUZ()</a>.</p>

</div>
</div>
<a id="a996cc8b761f1373132a5d77b16d2076a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996cc8b761f1373132a5d77b16d2076a">&#9670;&nbsp;</a></span>populateAMXLegalizeForLLVMExportPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateAMXLegalizeForLLVMExportPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to lower AMX ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00214">214</a> of file <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="ab5d377212fbb36b5d552063fab3c054e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d377212fbb36b5d552063fab3c054e">&#9670;&nbsp;</a></span>populateAnyFunctionOpInterfaceTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateAnyFunctionOpInterfaceTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03127">3127</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a6f862550b655bdc6a10caa74ce4ae0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f862550b655bdc6a10caa74ce4ae0af">&#9670;&nbsp;</a></span>populateArmSVELegalizeForLLVMExportPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateArmSVELegalizeForLLVMExportPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to lower ArmSVE ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>
<p>Populate the given list with patterns that convert from ArmSVE to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ArmSVE_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00070">70</a> of file <a class="el" href="ArmSVE_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00169">mlir::LLVMTypeConverter::getContext()</a>.</p>

</div>
</div>
<a id="aa9ea90e10c603e639fe6b6cbc9f24265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ea90e10c603e639fe6b6cbc9f24265">&#9670;&nbsp;</a></span>populateAsyncFuncToAsyncRuntimeConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateAsyncFuncToAsyncRuntimeConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00826">826</a> of file <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html">AsyncToAsyncRuntime.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00832">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a9659670212051d0795efd99cf38772ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9659670212051d0795efd99cf38772ed">&#9670;&nbsp;</a></span>populateAsyncStructuralTypeConversionsAndLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateAsyncStructuralTypeConversionsAndLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns for async structural type conversions. </p>
<p>A "structural" type conversion is one where the underlying ops are completely agnostic to the actual types involved and simply need to update their types. An example of this is async.execute &ndash; the async.execute op and the corresponding async.yield ops need to update their types accordingly to the <a class="el" href="classmlir_1_1TypeConverter.html" title="Type conversion class.">TypeConverter</a>, but otherwise don't care what type conversions are happening. </p>

<p class="definition">Definition at line <a class="el" href="AsyncToLLVM_8cpp_source.html#l01239">1239</a> of file <a class="el" href="AsyncToLLVM_8cpp_source.html">AsyncToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00146">mlir::TypeConverter::addConversion()</a>, <a class="el" href="DialectConversion_8h_source.html#l00832">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02901">mlir::TypeConverter::convertType()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">get()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a3df32552b0e40b3e55a3a098fb0f8f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df32552b0e40b3e55a3a098fb0f8f52">&#9670;&nbsp;</a></span>populateBranchOpInterfaceTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateBranchOpInterfaceTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(BranchOpInterface branchOp, int idx)&gt;&#160;</td>
          <td class="paramname"><em>shouldConvertBranchOperand</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pattern to the given pattern list to rewrite branch operations to use operands that have been legalized by the conversion framework. </p>
<p>This can only be done if the branch operation implements the BranchOpInterface. Only needed for partial conversions.</p>
<p>If for some branch ops, we need to convert/legalize only a sub-set of the op's operands, such filtering behavior can be specified in shouldConvertBranchOperand. This callback should return true if branchOp's operand at index idx should be converted. </p>

</div>
</div>
<a id="acfbd8691a3dda5dad95817bf02cdd3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbd8691a3dda5dad95817bf02cdd3cd">&#9670;&nbsp;</a></span>populateBufferizationToMemRefConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateBufferizationToMemRefConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert memory-related operations from the Bufferization dialect to the MemRef dialect. </p>

<p class="definition">Definition at line <a class="el" href="BufferizationToMemRef_8cpp_source.html#l00084">84</a> of file <a class="el" href="BufferizationToMemRef_8cpp_source.html">BufferizationToMemRef.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a3a9a918bfb0fc3727c4d2490164be0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9a918bfb0fc3727c4d2490164be0c3">&#9670;&nbsp;</a></span>populateBuiltinFuncToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateBuiltinFuncToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating the builtin <code>func</code> op to the SPIR-V dialect. </p>
<p>These patterns do not handle shader interface/ABI; they convert function parameters to be of SPIR-V allowed types. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l00616">616</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a155010c68de4c682e3cb8890e9460283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155010c68de4c682e3cb8890e9460283">&#9670;&nbsp;</a></span>populateCallOpTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateCallOpTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pattern to the given pattern list to convert the operand and result types of a CallOp with the given type converter. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00046">46</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Arith_2Transforms_2EmulateWideInt_8cpp_source.html#l01154">mlir::arith::populateArithWideIntEmulationPatterns()</a>.</p>

</div>
</div>
<a id="a6657dab425bc62dafe146c813979dc2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6657dab425bc62dafe146c813979dc2b">&#9670;&nbsp;</a></span>populateCommutativityUtilsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateCommutativityUtilsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the commutativity utility patterns. </p>

<p class="definition">Definition at line <a class="el" href="CommutativityUtils_8cpp_source.html#l00312">312</a> of file <a class="el" href="CommutativityUtils_8cpp_source.html">CommutativityUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="af655a0b587c08462a963b23b6c656ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af655a0b587c08462a963b23b6c656ca5">&#9670;&nbsp;</a></span>populateComplexToLibmConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateComplexToLibmConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Complex to Libm calls. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToLibm_8cpp_source.html#l00102">102</a> of file <a class="el" href="ComplexToLibm_8cpp_source.html">ComplexToLibm.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a75bf16b29d948811335c75976eb7b876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75bf16b29d948811335c75976eb7b876">&#9670;&nbsp;</a></span>populateComplexToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateComplexToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Complex to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToLLVM_8cpp_source.html#l00307">307</a> of file <a class="el" href="ComplexToLLVM_8cpp_source.html">ComplexToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="af85f17cc052c1e0019cecc9053c5afb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85f17cc052c1e0019cecc9053c5afb6">&#9670;&nbsp;</a></span>populateComplexToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateComplexToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating Complex ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToSPIRV_8cpp_source.html#l00086">86</a> of file <a class="el" href="ComplexToSPIRV_8cpp_source.html">ComplexToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a09be0ab6e12c19fefea09a6cb423c54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09be0ab6e12c19fefea09a6cb423c54d">&#9670;&nbsp;</a></span>populateComplexToStandardConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateComplexToStandardConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Complex to Standard. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToStandard_8cpp_source.html#l01055">1055</a> of file <a class="el" href="ComplexToStandard_8cpp_source.html">ComplexToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a45f6113274b77800e7c3b22dd83771e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f6113274b77800e7c3b22dd83771e0">&#9670;&nbsp;</a></span>populateConvertArmNeon2dToIntrPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateConvertArmNeon2dToIntrPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns for the lowering of Arm NEON 2D ops to intrinsics. </p>
<p>See createConvertArmNeon2dToIntrPass. </p>

<p class="definition">Definition at line <a class="el" href="ArmNeon2dToIntr_8cpp_source.html#l00070">70</a> of file <a class="el" href="ArmNeon2dToIntr_8cpp_source.html">ArmNeon2dToIntr.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ae6e66615eb7e50976ed8c89b2bb05adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e66615eb7e50976ed8c89b2bb05adc">&#9670;&nbsp;</a></span>populateConvertShapeConstraintsConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateConvertShapeConstraintsConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertShapeConstraints_8cpp_source.html#l00044">44</a> of file <a class="el" href="ConvertShapeConstraints_8cpp_source.html">ConvertShapeConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a65ee5fd8a8bcd80a922acd227a213e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ee5fd8a8bcd80a922acd227a213e2e">&#9670;&nbsp;</a></span>populateDecomposeCallGraphTypesPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateDecomposeCallGraphTypesPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueDecomposer.html">ValueDecomposer</a> &amp;&#160;</td>
          <td class="paramname"><em>decomposer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the patterns needed to drive the conversion process for decomposing call graph types with the given <code><a class="el" href="classmlir_1_1ValueDecomposer.html" title="This class provides a hook that expands one Value into multiple Value&#39;s, with a TypeConverter-inspire...">ValueDecomposer</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="DecomposeCallGraphTypes_8cpp_source.html#l00190">190</a> of file <a class="el" href="DecomposeCallGraphTypes_8cpp_source.html">DecomposeCallGraphTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="ac9d2110655a5086ecee6eac3405c8e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d2110655a5086ecee6eac3405c8e25">&#9670;&nbsp;</a></span>populateExpandCeilFPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandCeilFPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00436">436</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00147">convertCeilOp()</a>.</p>

</div>
</div>
<a id="ad882bbe96acab6803e205bac71f694fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad882bbe96acab6803e205bac71f694fe">&#9670;&nbsp;</a></span>populateExpandCtlzPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandCtlzPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00420">420</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00255">convertCtlzOp()</a>.</p>

</div>
</div>
<a id="ab7d2ac5ca6fe4c18adb5d7c32da4d914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d2ac5ca6fe4c18adb5d7c32da4d914">&#9670;&nbsp;</a></span>populateExpandExp2FPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandExp2FPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00440">440</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00183">convertExp2fOp()</a>.</p>

</div>
</div>
<a id="af4d52687fa07fb3c88f0d4f19471094a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d52687fa07fb3c88f0d4f19471094a">&#9670;&nbsp;</a></span>populateExpandFloorFPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandFloorFPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00452">452</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00122">convertFloorOp()</a>.</p>

</div>
</div>
<a id="a377a5d6d036008ba5e6416dc651dba6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377a5d6d036008ba5e6416dc651dba6e">&#9670;&nbsp;</a></span>populateExpandFmaFPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandFmaFPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00432">432</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00105">convertFmaFOp()</a>.</p>

</div>
</div>
<a id="a760b455909b9e4e765071fa20fbd6aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760b455909b9e4e765071fa20fbd6aef">&#9670;&nbsp;</a></span>populateExpandPowFPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandPowFPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00444">444</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00166">convertPowfOp()</a>.</p>

</div>
</div>
<a id="ae53fc446b430869ef74c6382f675b1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53fc446b430869ef74c6382f675b1ba">&#9670;&nbsp;</a></span>populateExpandRoundEvenPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandRoundEvenPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00456">456</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00298">convertRoundEvenOp()</a>.</p>

</div>
</div>
<a id="aa7559586e5b98d3d19dd9b234ee93b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7559586e5b98d3d19dd9b234ee93b39">&#9670;&nbsp;</a></span>populateExpandRoundFPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandRoundFPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00448">448</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00195">convertRoundOp()</a>.</p>

</div>
</div>
<a id="a2fbc60c17752a76af9b0f28ffa36d4f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbc60c17752a76af9b0f28ffa36d4f9">&#9670;&nbsp;</a></span>populateExpandTanhPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandTanhPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00428">428</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00064">convertTanhOp()</a>.</p>

</div>
</div>
<a id="a84e85fbc0b8884dd2405be7b78b0c8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e85fbc0b8884dd2405be7b78b0c8e7">&#9670;&nbsp;</a></span>populateExpandTanPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandTanPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00424">424</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00094">convertTanOp()</a>.</p>

</div>
</div>
<a id="a5d10b46e0e40ef1301b7492f47596ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d10b46e0e40ef1301b7492f47596ba4">&#9670;&nbsp;</a></span>populateFinalizeMemRefToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateFinalizeMemRefToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert memory-related operations from the MemRef dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>

<p class="definition">Definition at line <a class="el" href="MemRefToLLVM_8cpp_source.html#l01882">1882</a> of file <a class="el" href="MemRefToLLVM_8cpp_source.html">MemRefToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, <a class="el" href="LoweringOptions_8h_source.html#l00050">mlir::LowerToLLVMOptions::allocLowering</a>, and <a class="el" href="TypeConverter_8h_source.html#l00093">mlir::LLVMTypeConverter::getOptions()</a>.</p>

</div>
</div>
<a id="a1ab8b50117bb49a7ce3d85628dd374b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab8b50117bb49a7ce3d85628dd374b8">&#9670;&nbsp;</a></span>populateFunctionOpInterfaceTypeConversionPattern() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncOpT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateFunctionOpInterfaceTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00614">614</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03120">populateFunctionOpInterfaceTypeConversionPattern()</a>.</p>

</div>
</div>
<a id="a12287a4adc9d89ce2ed49712b091c5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12287a4adc9d89ce2ed49712b091c5fa">&#9670;&nbsp;</a></span>populateFunctionOpInterfaceTypeConversionPattern() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateFunctionOpInterfaceTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>functionLikeOpName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pattern to the given pattern list to convert the signature of a FunctionOpInterface op with the given type converter. </p>
<p>This only supports ops which use FunctionType to represent their type. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03120">3120</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8h_source.html#l00614">populateFunctionOpInterfaceTypeConversionPattern()</a>.</p>

</div>
</div>
<a id="a6caa6cc89d0b3c43a871101ba9fe6216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6caa6cc89d0b3c43a871101ba9fe6216">&#9670;&nbsp;</a></span>populateFuncToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateFuncToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the patterns to convert from the Func dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>
<p>The conversion patterns capture the <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> and the <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a> by reference meaning the references have to remain alive during the entire pattern lifetime. </p>

<p class="definition">Definition at line <a class="el" href="FuncToLLVM_8cpp_source.html#l00721">721</a> of file <a class="el" href="FuncToLLVM_8cpp_source.html">FuncToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00716">populateFuncToLLVMFuncOpConversionPattern()</a>.</p>

</div>
</div>
<a id="aefa6b16e02f4faa0e2d43ac82fca0185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa6b16e02f4faa0e2d43ac82fca0185">&#9670;&nbsp;</a></span>populateFuncToLLVMFuncOpConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateFuncToLLVMFuncOpConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the default pattern to convert a FuncOp to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>
<p>If <code>emitCWrappers</code> is set, the pattern will also produce functions that pass memref descriptors by pointer-to-structure in addition to the default unpacked form. </p>

<p class="definition">Definition at line <a class="el" href="FuncToLLVM_8cpp_source.html#l00716">716</a> of file <a class="el" href="FuncToLLVM_8cpp_source.html">FuncToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FuncToLLVM_8cpp_source.html#l00721">populateFuncToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a6b9ec4369b7b5946147ad4545d22d6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9ec4369b7b5946147ad4545d22d6c6">&#9670;&nbsp;</a></span>populateFuncToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateFuncToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating Func ops to SPIR-V ops. </p>
<p>Also adds the patterns to legalize ops not directly translated to SPIR-V dialect. </p>

<p class="definition">Definition at line <a class="el" href="FuncToSPIRV_8cpp_source.html#l00091">91</a> of file <a class="el" href="FuncToSPIRV_8cpp_source.html">FuncToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a5aa68a69789ad46739cf87f7166e52cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa68a69789ad46739cf87f7166e52cf">&#9670;&nbsp;</a></span>populateFuncTypeConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateFuncTypeConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OneToNFuncConversions_8cpp_source.html#l00119">119</a> of file <a class="el" href="OneToNFuncConversions_8cpp_source.html">OneToNFuncConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a9701a7692a76e65edd69bd6f22156776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9701a7692a76e65edd69bd6f22156776">&#9670;&nbsp;</a></span>populateGpuAllReducePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuAllReducePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to rewrite all-reduce ops within the GPU dialect. </p>

<p class="definition">Definition at line <a class="el" href="AllReduceLowering_8cpp_source.html#l00419">419</a> of file <a class="el" href="AllReduceLowering_8cpp_source.html">AllReduceLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l00060">populateGpuRewritePatterns()</a>.</p>

</div>
</div>
<a id="a9a64af4be39c0a24e5cf7dd18d7f619f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a64af4be39c0a24e5cf7dd18d7f619f">&#9670;&nbsp;</a></span>populateGpuMemorySpaceAttributeConversions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuMemorySpaceAttributeConversions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#ae70a1dffc17ef544b387b99ba05784d2">MemorySpaceMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates memory space attribute conversion rules for lowering gpu.address_space to integer values. </p>

<p class="definition">Definition at line <a class="el" href="GPUOpsLowering_8cpp_source.html#l00504">504</a> of file <a class="el" href="GPUOpsLowering_8cpp_source.html">GPUOpsLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00211">mlir::TypeConverter::addTypeAttributeConversion()</a>, and <a class="el" href="GPUOpsLowering_8cpp_source.html#l00500">wrapNumericMemorySpace()</a>.</p>

</div>
</div>
<a id="a4ae1d309360c9e54edaa39ddb48d3ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae1d309360c9e54edaa39ddb48d3ea1">&#9670;&nbsp;</a></span>populateGpuRewritePatterns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuRewritePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collect all patterns to rewrite ops within the GPU dialect. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l00060">60</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

<p class="reference">References <a class="el" href="AllReduceLowering_8cpp_source.html#l00419">populateGpuAllReducePatterns()</a>.</p>

</div>
</div>
<a id="ac7f6887e784993598ab77e0fb8f7e7bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f6887e784993598ab77e0fb8f7e7bf">&#9670;&nbsp;</a></span>populateGpuSubgroupReduceOpLoweringPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuSubgroupReduceOpLoweringPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate GpuSubgroupReduce pattern to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>. </p>
<p>It generates a specific nvvm op that is not available on every GPU. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00309">309</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="a6a18674fd61de5e49caca18b463db1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a18674fd61de5e49caca18b463db1b7">&#9670;&nbsp;</a></span>populateGpuToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>gpuBinaryAnnotation</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>kernelBarePtrCallConv</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> and populate converter for gpu types. </p>

<p class="definition">Definition at line <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00962">962</a> of file <a class="el" href="GPUToLLVMConversion_8cpp_source.html">GPUToLLVMConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00146">mlir::TypeConverter::addConversion()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">get()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00169">mlir::LLVMTypeConverter::getContext()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00178">mlir::LLVMTypeConverter::getPointerType()</a>.</p>

</div>
</div>
<a id="ac0cfe15e8fb355926517f8b4dc0d0c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cfe15e8fb355926517f8b4dc0d0c0a">&#9670;&nbsp;</a></span>populateGpuToNVVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuToNVVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00314">314</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">get()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00169">mlir::LLVMTypeConverter::getContext()</a>, and <a class="el" href="GPUDialect_8cpp_source.html#l00125">kSharedMemorySpace</a>.</p>

</div>
</div>
<a id="ac6de97155f64d87208f5ce9e4041885a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6de97155f64d87208f5ce9e4041885a">&#9670;&nbsp;</a></span>populateGpuToROCDLConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuToROCDLConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1gpu_1_1amd.html#a8637afbd01b984be30dbd1cdb78ae45f">gpu::amd::Runtime</a>&#160;</td>
          <td class="paramname"><em>runtime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the GPU dialect to ROCDL. </p>
<p>If <code>runtime</code> is Unknown, gpu.printf will not be lowered The resulting pattern set should be run over a gpu.module op </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00212">212</a> of file <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html">LowerGpuOpsToROCDLOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">get()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00169">mlir::LLVMTypeConverter::getContext()</a>, <a class="el" href="Runtimes_8h_source.html#l00017">mlir::gpu::amd::HIP</a>, and <a class="el" href="Runtimes_8h_source.html#l00018">mlir::gpu::amd::OpenCL</a>.</p>

</div>
</div>
<a id="a822bcc3b680bed98c042cdabebc7f94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822bcc3b680bed98c042cdabebc7f94a">&#9670;&nbsp;</a></span>populateGPUToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGPUToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating GPU Ops to SPIR-V ops. </p>
<p>For a gpu.func to be converted, it should have a spirv.entry_point_abi attribute. </p>

<p class="definition">Definition at line <a class="el" href="GPUToSPIRV_8cpp_source.html#l00584">584</a> of file <a class="el" href="GPUToSPIRV_8cpp_source.html">GPUToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="abea1280606a190334088962debe41bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea1280606a190334088962debe41bf0">&#9670;&nbsp;</a></span>populateGpuWMMAToNVVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuWMMAToNVVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert WMMA ops from GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="WmmaOpsToNvvm_8cpp_source.html#l00391">391</a> of file <a class="el" href="WmmaOpsToNvvm_8cpp_source.html">WmmaOpsToNvvm.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="a66b62af15c65e051633cba1f6022fb5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b62af15c65e051633cba1f6022fb5a">&#9670;&nbsp;</a></span>populateGpuWMMAToSPIRVConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuWMMAToSPIRVConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert WMMA ops from GPU dialect to SPIRV. </p>

<p class="definition">Definition at line <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html#l00257">257</a> of file <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html">WmmaOpsToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a2f1602ebfb960be063051996895d9eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1602ebfb960be063051996895d9eae">&#9670;&nbsp;</a></span>populateLinalgToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateLinalgToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Linalg to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToLLVM_8cpp_source.html#l00074">74</a> of file <a class="el" href="LinalgToLLVM_8cpp_source.html">LinalgToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="a747b91bacc09bde115c3e891deb5ebe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747b91bacc09bde115c3e891deb5ebe5">&#9670;&nbsp;</a></span>populateMathAlgebraicSimplificationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateMathAlgebraicSimplificationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AlgebraicSimplification_8cpp_source.html#l00224">224</a> of file <a class="el" href="AlgebraicSimplification_8cpp_source.html">AlgebraicSimplification.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ada84ecb306c38b4e2a547962acc98dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada84ecb306c38b4e2a547962acc98dfd">&#9670;&nbsp;</a></span>populateMathPolynomialApproximationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateMathPolynomialApproximationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MathPolynomialApproximationOptions.html">MathPolynomialApproximationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PolynomialApproximation_8cpp_source.html#l01382">1382</a> of file <a class="el" href="PolynomialApproximation_8cpp_source.html">PolynomialApproximation.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="a7d02c131fc732f88a4f4bbd96470b159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d02c131fc732f88a4f4bbd96470b159">&#9670;&nbsp;</a></span>populateMathToLibmConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateMathToLibmConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Math to Libm calls. </p>
<p>If log1pBenefit is present, use it instead of benefit for the Log1p op. </p>

<p class="definition">Definition at line <a class="el" href="MathToLibm_8cpp_source.html#l00162">162</a> of file <a class="el" href="MathToLibm_8cpp_source.html">MathToLibm.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ae9136f1dde93f4d0f24d7aaeb6e91743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9136f1dde93f4d0f24d7aaeb6e91743">&#9670;&nbsp;</a></span>populateMathToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateMathToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>approximateLog1p</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathToLLVM_8cpp_source.html#l00303">303</a> of file <a class="el" href="MathToLLVM_8cpp_source.html">MathToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="ac7a0a3321fbef0b7dcd1fe6e0bfba227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a0a3321fbef0b7dcd1fe6e0bfba227">&#9670;&nbsp;</a></span>populateMathToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateMathToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating Math ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="MathToSPIRV_8cpp_source.html#l00370">370</a> of file <a class="el" href="MathToSPIRV_8cpp_source.html">MathToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a95c0c6dd7df034b1f340ca9a14c9a0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c0c6dd7df034b1f340ca9a14c9a0a6">&#9670;&nbsp;</a></span>populateMemRefToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateMemRefToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating MemRef ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="MemRefToSPIRV_8cpp_source.html#l00732">732</a> of file <a class="el" href="MemRefToSPIRV_8cpp_source.html">MemRefToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a6a68bf61fe2cf12c77f265e4851897c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a68bf61fe2cf12c77f265e4851897c8">&#9670;&nbsp;</a></span>populateNVGPUToNVVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateNVGPUToNVVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NVGPUToNVVM_8cpp_source.html#l00693">693</a> of file <a class="el" href="NVGPUToNVVM_8cpp_source.html">NVGPUToNVVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="a075dcb844c996870c4c38bf277a4d175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075dcb844c996870c4c38bf277a4d175">&#9670;&nbsp;</a></span>populateOpenACCToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateOpenACCToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the patterns to convert from the OpenACC dialect LLVMIR dialect. </p>

<p class="definition">Definition at line <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00156">156</a> of file <a class="el" href="OpenACCToLLVM_8cpp_source.html">OpenACCToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="a725b3caed685f9615fba2027124f359f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725b3caed685f9615fba2027124f359f">&#9670;&nbsp;</a></span>populateOpenACCToSCFConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateOpenACCToSCFConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the patterns to convert from the OpenACC dialect to OpenACC with SCF dialect. </p>

<p class="definition">Definition at line <a class="el" href="OpenACCToSCF_8cpp_source.html#l00063">63</a> of file <a class="el" href="OpenACCToSCF_8cpp_source.html">OpenACCToSCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a1111bfc29c10d7cd2ebba33996e38509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1111bfc29c10d7cd2ebba33996e38509">&#9670;&nbsp;</a></span>populateOpenMPToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateOpenMPToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from OpenMP to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00213">213</a> of file <a class="el" href="OpenMPToLLVM_8cpp_source.html">OpenMPToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="a1727b1783cbf671c6ee60cc2a5c2f132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1727b1783cbf671c6ee60cc2a5c2f132">&#9670;&nbsp;</a></span>populateParallelLoopToGPUPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateParallelLoopToGPUPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the conversion pattern from <code>scf.parallel</code> to <code>gpu.launch</code> to the provided pattern list. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPU_8cpp_source.html#l00681">681</a> of file <a class="el" href="SCFToGPU_8cpp_source.html">SCFToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="af03e3926df8ddc0e88e2f37216bb0924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03e3926df8ddc0e88e2f37216bb0924">&#9670;&nbsp;</a></span>populatePostSparsificationRewriting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populatePostSparsificationRewriting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableRT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableForeach</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableConvert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorRewriting_8cpp_source.html#l01169">1169</a> of file <a class="el" href="SparseTensorRewriting_8cpp_source.html">SparseTensorRewriting.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a10daa5ecf515d29ea9079368f9b9b08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10daa5ecf515d29ea9079368f9b9b08d">&#9670;&nbsp;</a></span>populatePrepareVectorToMMAPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populatePrepareVectorToMMAPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useNvGpu</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to transform vector ops into a canonical form to convert to MMA matrix operations. </p>
<p>If <code>useNvGpu</code> is true, then the patterns will populated will prepare for conversion to <code>nvgpu</code> mma operations rather than the <code>gpu</code> dialect WMMA operations. </p>

<p class="definition">Definition at line <a class="el" href="VectorToGPU_8cpp_source.html#l01207">1207</a> of file <a class="el" href="VectorToGPU_8cpp_source.html">VectorToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l01246">mlir::vector::populateVectorContractCanonicalizeMatmulToMMT()</a>.</p>

</div>
</div>
<a id="a667f68e2860101c8caec8f46732e316e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667f68e2860101c8caec8f46732e316e">&#9670;&nbsp;</a></span>populatePreSparsificationRewriting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populatePreSparsificationRewriting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorRewriting_8cpp_source.html#l01164">1164</a> of file <a class="el" href="SparseTensorRewriting_8cpp_source.html">SparseTensorRewriting.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a7c65dfcafc10b8117f172e7c150ac1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c65dfcafc10b8117f172e7c150ac1ad">&#9670;&nbsp;</a></span>populateReconcileUnrealizedCastsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateReconcileUnrealizedCastsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>patterns</code> with rewrite patterns that eliminate noop <code>unrealized_conversion_cast</code> operation sequences. </p>

<p class="definition">Definition at line <a class="el" href="ReconcileUnrealizedCasts_8cpp_source.html#l00127">127</a> of file <a class="el" href="ReconcileUnrealizedCasts_8cpp_source.html">ReconcileUnrealizedCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ac260b877914dd5ce7bf80eb50ff87a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac260b877914dd5ce7bf80eb50ff87a4b">&#9670;&nbsp;</a></span>populateRemoveShapeConstraintsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateRemoveShapeConstraintsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RemoveShapeConstraints_8cpp_source.html#l00064">64</a> of file <a class="el" href="RemoveShapeConstraints_8cpp_source.html">RemoveShapeConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a2eb02814adc084d318ce037a93a326df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb02814adc084d318ce037a93a326df">&#9670;&nbsp;</a></span>populateReturnOpTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateReturnOpTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pattern to the given pattern list to rewrite <code>return</code> ops to use operands that have been legalized by the conversion framework. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00140">140</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Arith_2Transforms_2EmulateWideInt_8cpp_source.html#l01154">mlir::arith::populateArithWideIntEmulationPatterns()</a>.</p>

</div>
</div>
<a id="a9fc663ae01ea2b6384c3f6ce299be3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc663ae01ea2b6384c3f6ce299be3b0">&#9670;&nbsp;</a></span>populateSCFToControlFlowConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSCFToControlFlowConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert SCF operations to CFG branch-based operations within the ControlFlow dialect. </p>

<p class="definition">Definition at line <a class="el" href="SCFToControlFlow_8cpp_source.html#l00683">683</a> of file <a class="el" href="SCFToControlFlow_8cpp_source.html">SCFToControlFlow.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a3094753f32222ddd712d5b2321c38eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3094753f32222ddd712d5b2321c38eea">&#9670;&nbsp;</a></span>populateSCFToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSCFToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ScfToSPIRVContext.html">ScfToSPIRVContext</a> &amp;&#160;</td>
          <td class="paramname"><em>scfToSPIRVContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects a set of patterns to lower from scf.for, scf.if, and loop.terminator to CFG operations within the SPIR-V dialect. </p>

<p class="definition">Definition at line <a class="el" href="SCFToSPIRV_8cpp_source.html#l00435">435</a> of file <a class="el" href="SCFToSPIRV_8cpp_source.html">SCFToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="SCFToSPIRV_8h_source.html#l00029">mlir::ScfToSPIRVContext::getImpl()</a>.</p>

</div>
</div>
<a id="a068b739b7424900d4d98c15c81e4609e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068b739b7424900d4d98c15c81e4609e">&#9670;&nbsp;</a></span>populateShapeRewritePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateShapeRewritePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects a set of patterns to rewrite ops within the Shape dialect. </p>

<p class="definition">Definition at line <a class="el" href="ShapeToShapeLowering_8cpp_source.html#l00081">81</a> of file <a class="el" href="ShapeToShapeLowering_8cpp_source.html">ShapeToShapeLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a9d32c331310df6a35924ac128fa789f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d32c331310df6a35924ac128fa789f3">&#9670;&nbsp;</a></span>populateShapeToStandardConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateShapeToStandardConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ShapeToStandard_8cpp_source.html#l00712">712</a> of file <a class="el" href="ShapeToStandard_8cpp_source.html">ShapeToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a6168f425252f728e066433be9ee022b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6168f425252f728e066433be9ee022b2">&#9670;&nbsp;</a></span>populateSparseBufferRewriting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSparseBufferRewriting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableBufferInitialization</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseBufferRewriting_8cpp_source.html#l01433">1433</a> of file <a class="el" href="SparseBufferRewriting_8cpp_source.html">SparseBufferRewriting.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ad48873e0e6f944a5579b28be3cc1c944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48873e0e6f944a5579b28be3cc1c944">&#9670;&nbsp;</a></span>populateSparseGPUCodegenPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSparseGPUCodegenPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseGPUCodegen_8cpp_source.html#l00382">382</a> of file <a class="el" href="SparseGPUCodegen_8cpp_source.html">SparseGPUCodegen.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ae09b2f8703a1dd600360ce7154d53993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09b2f8703a1dd600360ce7154d53993">&#9670;&nbsp;</a></span>populateSparseTensorCodegenPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSparseTensorCodegenPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createSparseDeallocs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableBufferInitialization</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up sparse tensor conversion rules. </p>
<p>Populates the given patterns list with conversion rules required for the sparsification of linear algebra operations. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorCodegen_8cpp_source.html#l01783">1783</a> of file <a class="el" href="SparseTensorCodegen_8cpp_source.html">SparseTensorCodegen.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a7e144d2e73a085c2781475b2808bb059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e144d2e73a085c2781475b2808bb059">&#9670;&nbsp;</a></span>populateSparseTensorConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSparseTensorConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1SparseTensorConversionOptions.html">SparseTensorConversionOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1SparseTensorConversionOptions.html">SparseTensorConversionOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up sparse tensor conversion rules. </p>
<p>Populates the given patterns list with conversion rules required for the sparsification of linear algebra operations. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorConversion_8cpp_source.html#l01458">1458</a> of file <a class="el" href="SparseTensorConversion_8cpp_source.html">SparseTensorConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="a76dc06de29760922469c1e4bd10a62c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76dc06de29760922469c1e4bd10a62c9">&#9670;&nbsp;</a></span>populateSparseVectorizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSparseVectorizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>vectorLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableVLAVectorization</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableSIMDIndex32</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the given patterns list with vectorization rules. </p>

<p class="definition">Definition at line <a class="el" href="SparseVectorization_8cpp_source.html#l00661">661</a> of file <a class="el" href="SparseVectorization_8cpp_source.html">SparseVectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a86f7f8933f0baf6ebeddfdc698327c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f7f8933f0baf6ebeddfdc698327c31">&#9670;&nbsp;</a></span>populateSparsificationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSparsificationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up sparsification rewriting rules with the given options. </p>
<p>Populates the given patterns list with rewriting rules required for the sparsification of linear algebra operations. </p>

<p class="definition">Definition at line <a class="el" href="Sparsification_8cpp_source.html#l01951">1951</a> of file <a class="el" href="Sparsification_8cpp_source.html">Sparsification.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="aeb7de728c22748c6b736dd346296b69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7de728c22748c6b736dd346296b69f">&#9670;&nbsp;</a></span>populateSPIRVToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSPIRVToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the given list with patterns that convert from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01485">1485</a> of file <a class="el" href="SPIRVToLLVM_8cpp_source.html">SPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a1eaf01d677b8c5bc75e77f5093d9ca8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eaf01d677b8c5bc75e77f5093d9ca8f">&#9670;&nbsp;</a></span>populateSPIRVToLLVMFunctionConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSPIRVToLLVMFunctionConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the given list with patterns for function conversion from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01600">1600</a> of file <a class="el" href="SPIRVToLLVM_8cpp_source.html">SPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="aa1a0a0e3398946973ed32c1fb07d8936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a0a0e3398946973ed32c1fb07d8936">&#9670;&nbsp;</a></span>populateSPIRVToLLVMModuleConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSPIRVToLLVMModuleConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the given patterns for module conversion from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01605">1605</a> of file <a class="el" href="SPIRVToLLVM_8cpp_source.html">SPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="aae66c52897a19a19fdec8d7022372b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae66c52897a19a19fdec8d7022372b7d">&#9670;&nbsp;</a></span>populateSPIRVToLLVMTypeConversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSPIRVToLLVMTypeConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates type conversions with additional SPIR-V types. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01470">1470</a> of file <a class="el" href="SPIRVToLLVM_8cpp_source.html">SPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00146">mlir::TypeConverter::addConversion()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00250">convertArrayType()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00265">convertPointerType()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00274">convertRuntimeArrayType()</a>, and <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00284">convertStructType()</a>.</p>

</div>
</div>
<a id="a7cf4f84eb4b51c520a9697b10967438f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf4f84eb4b51c520a9697b10967438f">&#9670;&nbsp;</a></span>populateStorageSpecifierToLLVMPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateStorageSpecifierToLLVMPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseStorageSpecifierToLLVM_8cpp_source.html#l00350">350</a> of file <a class="el" href="SparseStorageSpecifierToLLVM_8cpp_source.html">SparseStorageSpecifierToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a5b8ecf548ab4c5b21eddf5ee62e618e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8ecf548ab4c5b21eddf5ee62e618e8">&#9670;&nbsp;</a></span>populateTensorToLinalgPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateTensorToLinalgPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating tensor ops to Linalg ops. </p>

<p class="definition">Definition at line <a class="el" href="TensorToLinalg_8cpp_source.html#l00028">28</a> of file <a class="el" href="TensorToLinalg_8cpp_source.html">TensorToLinalg.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="abaf6b62cc455701b989bc81364a091f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf6b62cc455701b989bc81364a091f7">&#9670;&nbsp;</a></span>populateTensorToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateTensorToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>byteCountThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating tensor ops to SPIR-V ops. </p>
<p>Note: Normally tensors will be stored in buffers before converting to SPIR-V, given that is how a large amount of data is sent to the GPU. However, SPIR-V supports converting from tensors directly too. This is for the cases where the tensor just contains a small amount of elements and it makes sense to directly inline them as a small data array in the shader. To handle this, internally the conversion might create new local variables. SPIR-V consumers in GPU drivers may or may not optimize that away. So this has implications over register pressure. Therefore, a threshold is used to control when the patterns should kick in. </p>

<p class="definition">Definition at line <a class="el" href="TensorToSPIRV_8cpp_source.html#l00105">105</a> of file <a class="el" href="TensorToSPIRV_8cpp_source.html">TensorToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a7fdbf57d9d955aea59286a07c5c3c03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdbf57d9d955aea59286a07c5c3c03a">&#9670;&nbsp;</a></span>populateVectorReductionToSPIRVDotProductPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateVectorReductionToSPIRVDotProductPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns to convert vector reduction of the form: </p>
<div class="fragment"><div class="line">vector.reduction &lt;add&gt;, (muli (ext %lhs), (ext %rhs)), [%acc]</div>
</div><!-- fragment --><p>to SPIR-V integer dot product ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSPIRV_8cpp_source.html#l00562">562</a> of file <a class="el" href="VectorToSPIRV_8cpp_source.html">VectorToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a75a70c08f12898f5942f022ea27ba371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a70c08f12898f5942f022ea27ba371">&#9670;&nbsp;</a></span>populateVectorToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateVectorToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reassociateFPReductions</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force32BitVectorIndices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>
<p>Populate the given list with patterns that convert from <a class="el" href="structVector.html">Vector</a> to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l01698">1698</a> of file <a class="el" href="ConvertVectorToLLVM_8cpp_source.html">ConvertVectorToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, <a class="el" href="TypeConverter_8h_source.html#l00091">mlir::LLVMTypeConverter::getDialect()</a>, <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00351">mlir::vector::populateVectorInsertExtractStridedSliceTransforms()</a>, and <a class="el" href="LowerVectorTransfer_8cpp_source.html#l00593">mlir::vector::populateVectorTransferLoweringPatterns()</a>.</p>

</div>
</div>
<a id="a75cce579ffaa7f6e5b4da65897ae4e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cce579ffaa7f6e5b4da65897ae4e41">&#9670;&nbsp;</a></span>populateVectorToLLVMMatrixConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateVectorToLLVMMatrixConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from <a class="el" href="structVector.html">Vector</a> contractions to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> Matrix Intrinsics. </p>
<p>To lower to assembly, the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> flag -lower-matrix-intrinsics will be needed when invoking <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l01727">1727</a> of file <a class="el" href="ConvertVectorToLLVM_8cpp_source.html">ConvertVectorToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="a96c6c9c53e199da9b2def6f5e62eec02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c6c9c53e199da9b2def6f5e62eec02">&#9670;&nbsp;</a></span>populateVectorToSCFConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateVectorToSCFConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to SCF + func. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSCF_8cpp_source.html#l01270">1270</a> of file <a class="el" href="VectorToSCF_8cpp_source.html">VectorToSCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="a32404bdce26e3b9e768fa1e790e77a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32404bdce26e3b9e768fa1e790e77a44">&#9670;&nbsp;</a></span>populateVectorToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateVectorToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating <a class="el" href="structVector.html">Vector</a> Ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSPIRV_8cpp_source.html#l00549">549</a> of file <a class="el" href="VectorToSPIRV_8cpp_source.html">VectorToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01626">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ac1ec093f212c96c69468a9e7df149fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ec093f212c96c69468a9e7df149fb5">&#9670;&nbsp;</a></span>populateX86VectorLegalizeForLLVMExportPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateX86VectorLegalizeForLLVMExportPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to lower X86Vector ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>
<p>Populate the given list with patterns that convert from X86Vector to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="X86Vector_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00161">161</a> of file <a class="el" href="X86Vector_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01650">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="ad4c681ca596f8f10e3b69a87aa9973c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c681ca596f8f10e3b69a87aa9973c6">&#9670;&nbsp;</a></span>printDynamicIndexList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::printDynamicIndexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>integers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a>&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Printer hook for custom directive in assemblyFormat. </p>
<p>custom&lt;DynamicIndexList&gt;($values, $integers)</p>
<p>where <code>values</code> is of ODS type <code>Variadic&lt;Index&gt;</code> and <code>integers</code> is of ODS type <code>I64ArrayAttr</code>. Prints a list with either (1) the static integer value in <code>integers</code> is <code>dynVal</code> or (2) the next value otherwise. This allows idiomatic printing of mixed value and integer attributes in a list. E.g. <code>[arg0, 7, 42, arg42]</code>. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00102">102</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

</div>
</div>
<a id="ae1261e0343cefe25ab1724c67005b7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1261e0343cefe25ab1724c67005b7d2">&#9670;&nbsp;</a></span>projectDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::projectDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>projectedDimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressDimsFlag</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map that results from projecting out the dimensions specified in <code>projectedDimensions</code>. </p>
<p>The projected dimensions are set to 0.</p>
<p>Example: 1) map : affine_map&lt;(d0, d1, d2) -&gt; (d0, d1)&gt; projected_dimensions : {2} result : affine_map&lt;(d0, d1) -&gt; (d0, d1)&gt;</p>
<p>2) map : affine_map&lt;(d0, d1) -&gt; (d0 + d1)&gt; projected_dimensions : {1} result : affine_map&lt;(d0) -&gt; (d0)&gt;</p>
<p>3) map : affine_map&lt;(d0, d1, d2) -&gt; (d0, d1)&gt; projected_dimensions : {1} result : affine_map&lt;(d0, d1) -&gt; (d0, 0)&gt;</p>
<p>This function also compresses the dims when the boolean flag is true. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00780">780</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00620">compressDims()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00794">getProjectedMap()</a>.</p>

</div>
</div>
<a id="ae5ec6082bc5758f83f4b0938b00b160d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ec6082bc5758f83f4b0938b00b160d">&#9670;&nbsp;</a></span>projectSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::projectSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>projectedSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressSymbolsFlag</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symbol counterpart of <code>projectDims</code>. </p>
<p>This function also compresses the symbols when the boolean flag is true. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00787">787</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00634">compressSymbols()</a>.</p>

</div>
</div>
<a id="ab5e4727751a2af7968a7f722b77620ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e4727751a2af7968a7f722b77620ff">&#9670;&nbsp;</a></span>promoteIfSingleIteration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::promoteIfSingleIteration </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes the loop body of a scf::ForOp to its containing block if the loop was known to have a single iteration. </p>
<p>Promotes the loop body of a forOp to its containing block if the forOp it can be determined that the loop has a single iteration. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00383">383</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00234">constantTripCount()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00367">replaceIterArgsAndYieldResults()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00460">loopUnrollByFactor()</a>.</p>

</div>
</div>
<a id="a7173c36d6b113dcdb0599eb672526b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7173c36d6b113dcdb0599eb672526b43">&#9670;&nbsp;</a></span>promoteToWorkgroupMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::promoteToWorkgroupMemory </td>
          <td>(</td>
          <td class="paramtype">gpu::GPUFuncOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes a function argument to workgroup memory in the given function. </p>
<p>The copies will be inserted in the beginning and in the end of the function. </p>

</div>
</div>
<a id="af98f1102c5f82e37f4e4cf21be1736f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98f1102c5f82e37f4e4cf21be1736f8">&#9670;&nbsp;</a></span>readBytecodeFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::readBytecodeFile </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An overload with a source manager whose main file buffer is used for parsing. </p>
<p>The lifetime of the source manager may be freely extended during parsing such that the source manager is not destroyed before the parsed IR. </p>

<p class="definition">Definition at line <a class="el" href="BytecodeReader_8cpp_source.html#l01859">1859</a> of file <a class="el" href="BytecodeReader_8cpp_source.html">BytecodeReader.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeReader_8cpp_source.html#l01839">readBytecodeFileImpl()</a>.</p>

</div>
</div>
<a id="ad3b71d67f0d7fe035e455a121e826f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b71d67f0d7fe035e455a121e826f08">&#9670;&nbsp;</a></span>readBytecodeFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::readBytecodeFile </td>
          <td>(</td>
          <td class="paramtype">llvm::MemoryBufferRef&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the operations defined within the given memory buffer, containing MLIR bytecode, into the provided block. </p>

<p class="definition">Definition at line <a class="el" href="BytecodeReader_8cpp_source.html#l01854">1854</a> of file <a class="el" href="BytecodeReader_8cpp_source.html">BytecodeReader.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeReader_8cpp_source.html#l01839">readBytecodeFileImpl()</a>.</p>

</div>
</div>
<a id="a2ef4c7804d8356c0813ce04f87b2b1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef4c7804d8356c0813ce04f87b2b1ff">&#9670;&nbsp;</a></span>readResourceHandle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::readResourceHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectBytecodeReader.html">DialectBytecodeReader</a> &amp;&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for resource handle reading that returns <a class="el" href="structmlir_1_1LogicalResult.html" title="This class represents an efficient way to signal success or failure.">LogicalResult</a>. </p>

<p class="definition">Definition at line <a class="el" href="BytecodeImplementation_8h_source.html#l00353">353</a> of file <a class="el" href="BytecodeImplementation_8h_source.html">BytecodeImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00111">mlir::DialectBytecodeReader::readResourceHandle()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="afe55df95d48191f0fa2c5ab8f4e81e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe55df95d48191f0fa2c5ab8f4e81e34">&#9670;&nbsp;</a></span>registerAllDialects() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerAllDialects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add all the MLIR dialects to the provided registry. </p>

<p class="definition">Definition at line <a class="el" href="InitAllDialects_8h_source.html#l00087">87</a> of file <a class="el" href="InitAllDialects_8h_source.html">InitAllDialects.h</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00117">mlir::DialectRegistry::insert()</a>, <a class="el" href="Arith_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00197">mlir::arith::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00458">mlir::bufferization::func_ext::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="Linalg_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00126">mlir::linalg::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="MemRef_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00058">mlir::memref::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="SCF_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l01168">mlir::scf::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="Shape_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00138">mlir::shape::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="SparseTensor_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00311">mlir::sparse_tensor::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="Tensor_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l01093">mlir::tensor::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="Vector_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00288">mlir::vector::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html#l00203">mlir::tensor::registerInferTypeOpInterfaceExternalModels()</a>, <a class="el" href="RuntimeOpVerification_8cpp_source.html#l00181">mlir::memref::registerRuntimeVerifiableOpInterfaceExternalModels()</a>, <a class="el" href="TilingInterfaceImpl_8cpp_source.html#l00420">mlir::linalg::registerTilingInterfaceExternalModels()</a>, <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00664">mlir::tensor::registerTilingInterfaceExternalModels()</a>, <a class="el" href="AffineTransformOps_8cpp_source.html#l00175">mlir::affine::registerTransformDialectExtension()</a>, <a class="el" href="BufferizationTransformOps_8cpp_source.html#l00145">mlir::bufferization::registerTransformDialectExtension()</a>, <a class="el" href="GPUTransformOps_8cpp_source.html#l00922">mlir::gpu::registerTransformDialectExtension()</a>, <a class="el" href="DialectExtension_8cpp_source.html#l00056">mlir::linalg::registerTransformDialectExtension()</a>, <a class="el" href="MemRefTransformOps_8cpp_source.html#l00174">mlir::memref::registerTransformDialectExtension()</a>, <a class="el" href="namespacemlir_1_1scf.html#a131df27a14db6c8a12e643fa2a0a5603">mlir::scf::registerTransformDialectExtension()</a>, <a class="el" href="TensorTransformOps_8cpp_source.html#l00129">mlir::tensor::registerTransformDialectExtension()</a>, <a class="el" href="VectorTransformOps_8cpp_source.html#l00198">mlir::vector::registerTransformDialectExtension()</a>, <a class="el" href="Affine_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00087">mlir::affine::registerValueBoundsOpInterfaceExternalModels()</a>, <a class="el" href="Arith_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00073">mlir::arith::registerValueBoundsOpInterfaceExternalModels()</a>, <a class="el" href="Linalg_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00064">mlir::linalg::registerValueBoundsOpInterfaceExternalModels()</a>, <a class="el" href="MemRef_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00116">mlir::memref::registerValueBoundsOpInterfaceExternalModels()</a>, <a class="el" href="SCF_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00121">mlir::scf::registerValueBoundsOpInterfaceExternalModels()</a>, and <a class="el" href="Tensor_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00114">mlir::tensor::registerValueBoundsOpInterfaceExternalModels()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CAPI_2RegisterEverything_2RegisterEverything_8cpp_source.html#l00017">mlirRegisterAllDialects()</a>, and <a class="el" href="InitAllDialects_8h_source.html#l00163">registerAllDialects()</a>.</p>

</div>
</div>
<a id="a5fcd07e2ad26a58627d961ce8e544f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fcd07e2ad26a58627d961ce8e544f1b">&#9670;&nbsp;</a></span>registerAllDialects() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerAllDialects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append all the MLIR dialects to the registry contained in the given context. </p>

<p class="definition">Definition at line <a class="el" href="InitAllDialects_8h_source.html#l00163">163</a> of file <a class="el" href="InitAllDialects_8h_source.html">InitAllDialects.h</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00381">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="InitAllDialects_8h_source.html#l00087">registerAllDialects()</a>.</p>

</div>
</div>
<a id="a5b51fcb4b20988958223a34812c119a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b51fcb4b20988958223a34812c119a3">&#9670;&nbsp;</a></span>registerAllFromLLVMIRTranslations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mlir::registerAllFromLLVMIRTranslations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers all dialects that can be translated from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR and the corresponding translation interfaces. </p>

<p class="definition">Definition at line <a class="el" href="All_8h_source.html#l00052">52</a> of file <a class="el" href="All_8h_source.html">All.h</a>.</p>

<p class="reference">References <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html#l00290">registerLLVMDialectImport()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00027">registerFromLLVMIRTranslation()</a>.</p>

</div>
</div>
<a id="afb552a159c6c887b98b3583dfd5cbe5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb552a159c6c887b98b3583dfd5cbe5d">&#9670;&nbsp;</a></span>registerAllPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerAllPasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InitAllPasses_8h_source.html#l00051">51</a> of file <a class="el" href="InitAllPasses_8h_source.html">InitAllPasses.h</a>.</p>

<p class="reference">References <a class="el" href="SerializeToCubin_8cpp_source.html#l00155">registerGpuSerializeToCubinPass()</a>, <a class="el" href="SerializeToHsaco_8cpp_source.html#l00496">registerGpuSerializeToHsacoPass()</a>, and <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00118">mlir::sparse_tensor::registerSparseTensorPipelines()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CAPI_2RegisterEverything_2RegisterEverything_8cpp_source.html#l00027">mlirRegisterAllPasses()</a>.</p>

</div>
</div>
<a id="ad1e68be8ebf61b3be9572769e19bc467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e68be8ebf61b3be9572769e19bc467">&#9670;&nbsp;</a></span>registerAllToLLVMIRTranslations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mlir::registerAllToLLVMIRTranslations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers all dialects that can be translated to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR and the corresponding translation interfaces. </p>

<p class="definition">Definition at line <a class="el" href="All_8h_source.html#l00035">35</a> of file <a class="el" href="All_8h_source.html">All.h</a>.</p>

<p class="reference">References <a class="el" href="AMXToLLVMIRTranslation_8cpp_source.html#l00045">registerAMXDialectTranslation()</a>, <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html#l00046">registerArmNeonDialectTranslation()</a>, <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html#l00045">registerArmSVEDialectTranslation()</a>, <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html#l00036">registerBuiltinDialectTranslation()</a>, <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html#l00034">registerGPUDialectTranslation()</a>, <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00383">registerLLVMDialectTranslation()</a>, <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00208">registerNVVMDialectTranslation()</a>, <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00495">registerOpenACCDialectTranslation()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01830">registerOpenMPDialectTranslation()</a>, <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00165">registerROCDLDialectTranslation()</a>, and <a class="el" href="X86VectorToLLVMIRTranslation_8cpp_source.html#l00046">registerX86VectorDialectTranslation()</a>.</p>

</div>
</div>
<a id="a8d16808b31b66905b067720d428adf61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d16808b31b66905b067720d428adf61">&#9670;&nbsp;</a></span>registerAllTranslations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerAllTranslations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InitAllTranslations_8h_source.html#l00028">28</a> of file <a class="el" href="InitAllTranslations_8h_source.html">InitAllTranslations.h</a>.</p>

<p class="reference">References <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00027">registerFromLLVMIRTranslation()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00058">registerFromSPIRVTranslation()</a>, <a class="el" href="Cpp_2TranslateRegistration_8cpp_source.html#l00029">registerToCppTranslation()</a>, <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00025">registerToLLVMIRTranslation()</a>, and <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00086">registerToSPIRVTranslation()</a>.</p>

</div>
</div>
<a id="a0465249a74e23df5fdc548001933239c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0465249a74e23df5fdc548001933239c">&#9670;&nbsp;</a></span>registerAMXDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerAMXDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the AMX dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="AMXToLLVMIRTranslation_8cpp_source.html#l00045">45</a> of file <a class="el" href="AMXToLLVMIRTranslation_8cpp_source.html">AMXToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00117">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00035">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="AMXToLLVMIRTranslation_8cpp_source.html#l00052">registerAMXDialectTranslation()</a>.</p>

</div>
</div>
<a id="aa4a637ec7428727c66f27117b9892f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a637ec7428727c66f27117b9892f1e">&#9670;&nbsp;</a></span>registerAMXDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerAMXDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the AMX dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="AMXToLLVMIRTranslation_8cpp_source.html#l00052">52</a> of file <a class="el" href="AMXToLLVMIRTranslation_8cpp_source.html">AMXToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00381">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="AMXToLLVMIRTranslation_8cpp_source.html#l00045">registerAMXDialectTranslation()</a>.</p>

</div>
</div>
<a id="ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad">&#9670;&nbsp;</a></span>registerArmNeonDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerArmNeonDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ArmNeon dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html#l00046">46</a> of file <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html">ArmNeonToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00117">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00035">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html#l00054">registerArmNeonDialectTranslation()</a>.</p>

</div>
</div>
<a id="a559f20bb41c97729f2d089e6f7a72e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559f20bb41c97729f2d089e6f7a72e4e">&#9670;&nbsp;</a></span>registerArmNeonDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerArmNeonDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ArmNeon dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html#l00054">54</a> of file <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html">ArmNeonToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00381">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html#l00046">registerArmNeonDialectTranslation()</a>.</p>

</div>
</div>
<a id="a53be2d34e1d4e96ea100bbf93af35a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53be2d34e1d4e96ea100bbf93af35a2c">&#9670;&nbsp;</a></span>registerArmSVEDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerArmSVEDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ArmSVE dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html#l00045">45</a> of file <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html">ArmSVEToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00117">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00035">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html#l00052">registerArmSVEDialectTranslation()</a>.</p>

</div>
</div>
<a id="afc9c160fac7074517c6f013864acee68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9c160fac7074517c6f013864acee68">&#9670;&nbsp;</a></span>registerArmSVEDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerArmSVEDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ArmSVE dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html#l00052">52</a> of file <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html">ArmSVEToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00381">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html#l00045">registerArmSVEDialectTranslation()</a>.</p>

</div>
</div>
<a id="a894a08aa6ed051f55e57bc35859a379f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894a08aa6ed051f55e57bc35859a379f">&#9670;&nbsp;</a></span>registerAsmPrinterCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerAsmPrinterCLOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a set of useful command-line options that can be used to configure various flags within the <a class="el" href="classmlir_1_1AsmPrinter.html" title="This base class exposes generic asm printer hooks, usable across the various derived printers.">AsmPrinter</a>. </p>

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l00178">178</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l00174">clOptions</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00398">MlirOptMain()</a>.</p>

</div>
</div>
<a id="a857314125d33fcc46a38cd3aca4d1d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857314125d33fcc46a38cd3aca4d1d12">&#9670;&nbsp;</a></span>registerBuiltinDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerBuiltinDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the translation from the builtin dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry. </p>

<p class="definition">Definition at line <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html#l00036">36</a> of file <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html">BuiltinToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CAPI_2RegisterEverything_2RegisterEverything_8cpp_source.html#l00021">mlirRegisterAllLLVMTranslations()</a>, <a class="el" href="All_8h_source.html#l00035">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html#l00042">registerBuiltinDialectTranslation()</a>.</p>

</div>
</div>
<a id="a1af1c7f18bef740745581f7130c8c46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af1c7f18bef740745581f7130c8c46e">&#9670;&nbsp;</a></span>registerBuiltinDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerBuiltinDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the translation from the builtin dialect in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html#l00042">42</a> of file <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html">BuiltinToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00381">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html#l00036">registerBuiltinDialectTranslation()</a>.</p>

</div>
</div>
<a id="ae53cd627dc538a8da5a61d8ba621e603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53cd627dc538a8da5a61d8ba621e603">&#9670;&nbsp;</a></span>registerConversionPDLFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerConversionPDLFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the dialect conversion PDL functions with the given pattern set. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03309">3309</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02901">mlir::TypeConverter::convertType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02949">mlir::TypeConverter::convertTypes()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00965">mlir::detail::ConversionPatternRewriterImpl::currentTypeConverter</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="PatternMatch_8h_source.html#l01632">mlir::RewritePatternSet::getPDLPatterns()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03302">pdllConvertValues()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00207">mlir::PDLPatternModule::registerRewriteFunction()</a>.</p>

</div>
</div>
<a id="a1da5a75b8bc3193908b0e222a6da1d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da5a75b8bc3193908b0e222a6da1d85">&#9670;&nbsp;</a></span>registerDefaultTimingManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerDefaultTimingManagerCLOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a set of useful command-line options that can be used to configure a <code><a class="el" href="classmlir_1_1DefaultTimingManager.html" title="Facilities for time measurement and report printing to an output stream.">DefaultTimingManager</a></code>. </p>
<p>The values of these options can be applied via the <code>applyDefaultTimingManagerCLOptions</code> method. </p>

<p class="definition">Definition at line <a class="el" href="Timing_8cpp_source.html#l00557">557</a> of file <a class="el" href="Timing_8cpp_source.html">Timing.cpp</a>.</p>

<p class="reference">References <a class="el" href="Timing_8cpp_source.html#l00555">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00398">MlirOptMain()</a>.</p>

</div>
</div>
<a id="a7a267e7e7ec38e0a09285a20831414d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a267e7e7ec38e0a09285a20831414d3">&#9670;&nbsp;</a></span>registerFromLLVMIRTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerFromLLVMIRTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00027">27</a> of file <a class="el" href="ConvertFromLLVMIR_8cpp_source.html">ConvertFromLLVMIR.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">emitError()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">get()</a>, <a class="el" href="All_8h_source.html#l00052">registerAllFromLLVMIRTranslations()</a>, and <a class="el" href="ModuleImport_8cpp_source.html#l01670">translateLLVMIRToModule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00028">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a51ef91a9901d4d87a042990ccb79f2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ef91a9901d4d87a042990ccb79f2be">&#9670;&nbsp;</a></span>registerFromSPIRVTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerFromSPIRVTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00058">58</a> of file <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00040">deserializeModule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00028">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="aa9427230420827cff7cd15f78924cdb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9427230420827cff7cd15f78924cdb4">&#9670;&nbsp;</a></span>registerGPUDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerGPUDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the GPU dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html#l00034">34</a> of file <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html">GPUToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00117">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SerializeToBlob_8cpp_source.html#l00110">mlir::gpu::SerializeToBlobPass::getDependentDialects()</a>, <a class="el" href="All_8h_source.html#l00035">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html#l00041">registerGPUDialectTranslation()</a>.</p>

</div>
</div>
<a id="afe90c6efbbc0e7e7469f14619fd7445b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe90c6efbbc0e7e7469f14619fd7445b">&#9670;&nbsp;</a></span>registerGPUDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerGPUDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the GPU dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html#l00041">41</a> of file <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html">GPUToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00381">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html#l00034">registerGPUDialectTranslation()</a>.</p>

</div>
</div>
<a id="a408ccd7b20bede5af6274d2243aaf4ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408ccd7b20bede5af6274d2243aaf4ce">&#9670;&nbsp;</a></span>registerGpuSerializeToCubinPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerGpuSerializeToCubinPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register pass to serialize GPU kernel functions to a CUBIN binary annotation. </p>

<p class="definition">Definition at line <a class="el" href="SerializeToCubin_8cpp_source.html#l00155">155</a> of file <a class="el" href="SerializeToCubin_8cpp_source.html">SerializeToCubin.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllPasses_8h_source.html#l00051">registerAllPasses()</a>.</p>

</div>
</div>
<a id="a309cdd85b1689eff02c2259ef8d0bb6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309cdd85b1689eff02c2259ef8d0bb6c">&#9670;&nbsp;</a></span>registerGpuSerializeToHsacoPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerGpuSerializeToHsacoPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register pass to serialize GPU kernel functions to a HSAco binary annotation. </p>

<p class="definition">Definition at line <a class="el" href="SerializeToHsaco_8cpp_source.html#l00496">496</a> of file <a class="el" href="SerializeToHsaco_8cpp_source.html">SerializeToHsaco.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllPasses_8h_source.html#l00051">registerAllPasses()</a>.</p>

</div>
</div>
<a id="ab01617995d72a114db65ee711b2422d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01617995d72a114db65ee711b2422d5">&#9670;&nbsp;</a></span>registerLLVMDialectImport() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerLLVMDialectImport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and its import from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry. </p>

<p class="definition">Definition at line <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html#l00290">290</a> of file <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html">LLVMIRToLLVMTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00117">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00052">registerAllFromLLVMIRTranslations()</a>, and <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html#l00297">registerLLVMDialectImport()</a>.</p>

</div>
</div>
<a id="a4a0110d23914c27f0140d63a8bb934d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0110d23914c27f0140d63a8bb934d4">&#9670;&nbsp;</a></span>registerLLVMDialectImport() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerLLVMDialectImport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and its import from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR with the given context. </p>

<p class="definition">Definition at line <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html#l00297">297</a> of file <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html">LLVMIRToLLVMTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00381">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html#l00290">registerLLVMDialectImport()</a>.</p>

</div>
</div>
<a id="a8b9759ca57d83ec47b341d58d966b9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9759ca57d83ec47b341d58d966b9e8">&#9670;&nbsp;</a></span>registerLLVMDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerLLVMDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00383">383</a> of file <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html">LLVMToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00117">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SerializeToBlob_8cpp_source.html#l00110">mlir::gpu::SerializeToBlobPass::getDependentDialects()</a>, <a class="el" href="CAPI_2RegisterEverything_2RegisterEverything_8cpp_source.html#l00021">mlirRegisterAllLLVMTranslations()</a>, <a class="el" href="All_8h_source.html#l00035">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00390">registerLLVMDialectTranslation()</a>.</p>

</div>
</div>
<a id="a74024a3b8ec9af8d50db598772774a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74024a3b8ec9af8d50db598772774a96">&#9670;&nbsp;</a></span>registerLLVMDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerLLVMDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00390">390</a> of file <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html">LLVMToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00381">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00383">registerLLVMDialectTranslation()</a>.</p>

</div>
</div>
<a id="a5254079fbbd31a78a3430bff18df2d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5254079fbbd31a78a3430bff18df2d7c">&#9670;&nbsp;</a></span>registerMLIRContextCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerMLIRContextCLOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a set of useful command-line options that can be used to configure various flags within the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a>. </p>
<p>These flags are used when constructing an MLIR context for initialization. </p>

<p class="definition">Definition at line <a class="el" href="MLIRContext_8cpp_source.html#l00089">89</a> of file <a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00076">clOptions</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00398">MlirOptMain()</a>.</p>

</div>
</div>
<a id="a2989267e0da323d644b3316b85b3942f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2989267e0da323d644b3316b85b3942f">&#9670;&nbsp;</a></span>registerNVVMDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerNVVMDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00208">208</a> of file <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html">NVVMToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00117">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00035">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00215">registerNVVMDialectTranslation()</a>.</p>

</div>
</div>
<a id="a00d03cc4e706acdb35969f4d4e78142a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d03cc4e706acdb35969f4d4e78142a">&#9670;&nbsp;</a></span>registerNVVMDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerNVVMDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00215">215</a> of file <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html">NVVMToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00381">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00208">registerNVVMDialectTranslation()</a>.</p>

</div>
</div>
<a id="ae9bc345c5d25bda3847f7ddf6cebe9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bc345c5d25bda3847f7ddf6cebe9bc">&#9670;&nbsp;</a></span>registerOpenACCDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerOpenACCDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the OpenACC dialect and the translation to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00495">495</a> of file <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html">OpenACCToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00117">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00035">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00502">registerOpenACCDialectTranslation()</a>.</p>

</div>
</div>
<a id="a889d8518a5c67b981e76d27c9a256d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889d8518a5c67b981e76d27c9a256d86">&#9670;&nbsp;</a></span>registerOpenACCDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerOpenACCDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the OpenACC dialect and the translation in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00502">502</a> of file <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html">OpenACCToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00381">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00495">registerOpenACCDialectTranslation()</a>.</p>

</div>
</div>
<a id="a6ea20d97a32efd36c02468e54db4b2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea20d97a32efd36c02468e54db4b2e7">&#9670;&nbsp;</a></span>registerOpenMPDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerOpenMPDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the OpenMP dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01830">1830</a> of file <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html">OpenMPToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00117">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00035">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01837">registerOpenMPDialectTranslation()</a>.</p>

</div>
</div>
<a id="aaa35b353841b70d090e1ead360536308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa35b353841b70d090e1ead360536308">&#9670;&nbsp;</a></span>registerOpenMPDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerOpenMPDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the OpenMP dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01837">1837</a> of file <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html">OpenMPToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00381">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01830">registerOpenMPDialectTranslation()</a>.</p>

</div>
</div>
<a id="a5a4626059212aef6f3aa5fa7088ce667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4626059212aef6f3aa5fa7088ce667">&#9670;&nbsp;</a></span>registerPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a48db7fd5d49bfa7ca8c81e5a6a058683">PassAllocatorFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a specific dialect pass allocator function with the system, typically used through the <a class="el" href="structmlir_1_1PassRegistration.html" title="PassRegistration provides a global initializer that registers a Pass allocation routine for a concret...">PassRegistration</a> template. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8cpp_source.html#l00119">119</a> of file <a class="el" href="PassRegistry_8cpp_source.html">PassRegistry.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassRegistry_8cpp_source.html#l00026">passRegistry</a>, and <a class="el" href="PassRegistry_8cpp_source.html#l00030">passRegistryTypeIDs</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassRegistry_8h_source.html#l00146">mlir::PassRegistration&lt; ConcretePass &gt;::PassRegistration()</a>.</p>

</div>
</div>
<a id="aa5c4edce10b597637635af55bb162477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c4edce10b597637635af55bb162477">&#9670;&nbsp;</a></span>registerPassManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerPassManagerCLOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a set of useful command-line options that can be used to configure a pass manager. </p>
<p>The values of these options can be applied via the 'applyPassManagerCLOptions' method below. </p>

<p class="definition">Definition at line <a class="el" href="PassManagerOptions_8cpp_source.html#l00128">128</a> of file <a class="el" href="PassManagerOptions_8cpp_source.html">PassManagerOptions.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00398">MlirOptMain()</a>.</p>

</div>
</div>
<a id="a83965c855ad737422194336251348893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83965c855ad737422194336251348893">&#9670;&nbsp;</a></span>registerPassPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerPassPipeline </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#af4ccb1e7accf2ec0c57b1aea967ccd02">PassRegistryFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(const <a class="el" href="classmlir_1_1detail_1_1PassOptions.html">detail::PassOptions</a> &amp;)&gt;)&gt;&#160;</td>
          <td class="paramname"><em>optHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a specific dialect pipeline registry function with the system, typically used through the <a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> template. </p>

<p class="reference">Referenced by <a class="el" href="PassRegistry_8h_source.html#l00191">mlir::PassPipelineRegistration&lt; EmptyPipelineOptions &gt;::PassPipelineRegistration()</a>, and <a class="el" href="PassRegistry_8h_source.html#l00168">mlir::PassPipelineRegistration&lt; Options &gt;::PassPipelineRegistration()</a>.</p>

</div>
</div>
<a id="ab895c88d57833ccee805eb3233c04ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab895c88d57833ccee805eb3233c04ca6">&#9670;&nbsp;</a></span>registerROCDLDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerROCDLDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ROCDL dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00165">165</a> of file <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html">ROCDLToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00117">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00035">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00172">registerROCDLDialectTranslation()</a>.</p>

</div>
</div>
<a id="a4e522221c6652cb1450a6a3803125534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e522221c6652cb1450a6a3803125534">&#9670;&nbsp;</a></span>registerROCDLDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerROCDLDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ROCDL dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00172">172</a> of file <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html">ROCDLToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00381">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00165">registerROCDLDialectTranslation()</a>.</p>

</div>
</div>
<a id="a9ed913befc935e3b4b3e622838655b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed913befc935e3b4b3e622838655b30">&#9670;&nbsp;</a></span>registerTestRoundtripDebugSPIRV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerTestRoundtripDebugSPIRV </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00137">137</a> of file <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00102">roundTripModule()</a>.</p>

</div>
</div>
<a id="a2b336390b16983a364b2d95bd2a64a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b336390b16983a364b2d95bd2a64a2f">&#9670;&nbsp;</a></span>registerTestRoundtripSPIRV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerTestRoundtripSPIRV </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00126">126</a> of file <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00102">roundTripModule()</a>.</p>

</div>
</div>
<a id="a520bc0aa5f34c15a39f2202fdf521382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520bc0aa5f34c15a39f2202fdf521382">&#9670;&nbsp;</a></span>registerToCppTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerToCppTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Cpp_2TranslateRegistration_8cpp_source.html#l00029">29</a> of file <a class="el" href="Cpp_2TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00028">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a003d72c96a8bffacc207ba165212e2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003d72c96a8bffacc207ba165212e2db">&#9670;&nbsp;</a></span>registerToLLVMIRTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerToLLVMIRTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00025">25</a> of file <a class="el" href="ConvertToLLVMIR_8cpp_source.html">ConvertToLLVMIR.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00028">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="af7f5d34c37689ae9b05537a040d9e0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f5d34c37689ae9b05537a040d9e0a0">&#9670;&nbsp;</a></span>registerToSPIRVTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerToSPIRVTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00086">86</a> of file <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00073">serializeModule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00028">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a3a41d372a37300e7b09f82fbd8b2d425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a41d372a37300e7b09f82fbd8b2d425">&#9670;&nbsp;</a></span>registerTranslationCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerTranslationCLOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register command-line options used by the translation registry. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8cpp_source.html#l00038">38</a> of file <a class="el" href="Translation_8cpp_source.html">Translation.cpp</a>.</p>

<p class="reference">References <a class="el" href="Translation_8cpp_source.html#l00036">clOptions</a>.</p>

</div>
</div>
<a id="a06a06304b237de21b74a8c5b3251ac35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a06304b237de21b74a8c5b3251ac35">&#9670;&nbsp;</a></span>registerX86VectorDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerX86VectorDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the X86Vector dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="X86VectorToLLVMIRTranslation_8cpp_source.html#l00046">46</a> of file <a class="el" href="X86VectorToLLVMIRTranslation_8cpp_source.html">X86VectorToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00117">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00035">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="X86VectorToLLVMIRTranslation_8cpp_source.html#l00054">registerX86VectorDialectTranslation()</a>.</p>

</div>
</div>
<a id="a087d9cf09c9d93a0bf0f287509afc5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087d9cf09c9d93a0bf0f287509afc5b4">&#9670;&nbsp;</a></span>registerX86VectorDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerX86VectorDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the X86Vector dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="X86VectorToLLVMIRTranslation_8cpp_source.html#l00054">54</a> of file <a class="el" href="X86VectorToLLVMIRTranslation_8cpp_source.html">X86VectorToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00381">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="X86VectorToLLVMIRTranslation_8cpp_source.html#l00046">registerX86VectorDialectTranslation()</a>.</p>

</div>
</div>
<a id="a24aeba82a83b5f51bfe338ed5156887a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24aeba82a83b5f51bfe338ed5156887a">&#9670;&nbsp;</a></span>reifyResultShapes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::reifyResultShapes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0a5ee68dc80640e6ac9c4a6011d18bc1">ReifiedRankedShapedTypeDims</a> &amp;&#160;</td>
          <td class="paramname"><em>reifiedReturnShapes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reify the shape of the result of an operation (typically in terms of the shape of its operands). </p>

<p class="definition">Definition at line <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00026">26</a> of file <a class="el" href="InferTypeOpInterface_8cpp_source.html">InferTypeOpInterface.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00118">mlir::bufferization::allocateTensorForShapedValue()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00064">mlir::tensor::getOrCreateDestination()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00121">reifyOrComputeDynamicSizes()</a>, <a class="el" href="Transforms_8cpp_source.html#l00184">mlir::linalg::rewriteAsPaddedOp()</a>, and <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00284">mlir::linalg::rewriteInDestinationPassingStyle()</a>.</p>

</div>
</div>
<a id="a1fa0a7e84eb2af3d70c98d59fc9ccbd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa0a7e84eb2af3d70c98d59fc9ccbd3">&#9670;&nbsp;</a></span>removeDuplicateExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::removeDuplicateExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map with the same dimension and symbol count as <code>map</code>, but whose results are the unique affine expressions of <code>map</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00658">658</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01135">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00271">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00324">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00328">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00337">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l02322">canonicalizeLoopBounds()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l02563">mlir::affine::createCanonicalizedAffineForOp()</a>.</p>

</div>
</div>
<a id="a15a5d204dd78ac563241168e6b2e40eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a5d204dd78ac563241168e6b2e40eb">&#9670;&nbsp;</a></span>replaceAllUsesInRegionWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::replaceAllUsesInRegionWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all uses of <code>orig</code> within the given region with <code>replacement</code>. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00028">28</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00201">mlir::Value::getUses()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00222">mlir::Region::isAncestor()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01648">mlir::affine::coalesceLoops()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00653">coalesceLoops()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00710">collapseParallelLoops()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00877">stripmineSink()</a>.</p>

</div>
</div>
<a id="ac397605c6399939f433c2e9d15975954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac397605c6399939f433c2e9d15975954">&#9670;&nbsp;</a></span>replaceLoopNestWithNewYields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; scf::ForOp &gt; mlir::replaceLoopNestWithNewYields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>loopNest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newIterOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#ae809ff18bf496d00671a691c71795f68">NewYieldValueFn</a> &amp;&#160;</td>
          <td class="paramname"><em>newYieldValueFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replaceIterOperandsUsesInLoop</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a perfectly nested loop nest to yield new values from the innermost loop and propagating it up through the loop nest. </p>
<p>This function</p><ul>
<li>Expects <code>loopNest</code> to be a perfectly nested loop with outer most loop first and innermost loop last.</li>
<li><code>newIterOperands</code> are the initialization values to be used for the outermost loop</li>
<li><code>newYielValueFn</code> is the callback that generates the new values to be yielded from within the innermost loop.</li>
<li>The original loops are not erased, but are left in a "no-op" state where the body of the loop just yields the basic block arguments that correspond to the initialization values of a loop. The original loops are dead after this method.</li>
<li>If <code>replaceIterOperandsUsesInLoop</code> is true, all uses of the <code>newIterOperands</code> within the generated new loop are replaced with the corresponding <code><a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a></code> in the loop body. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00109">109</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00042">replaceLoopWithNewYields()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00180">yieldTiledValues()</a>.</p>

</div>
</div>
<a id="a6f20cbb6f6483971021fdfdf5b731ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f20cbb6f6483971021fdfdf5b731ba1">&#9670;&nbsp;</a></span>replaceLoopWithNewYields() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scf::ForOp mlir::replaceLoopWithNewYields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newIterOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#ae809ff18bf496d00671a691c71795f68">NewYieldValueFn</a> &amp;&#160;</td>
          <td class="paramname"><em>newYieldValuesFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replaceIterOperandsUsesInLoop</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00042">42</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00432">mlir::OpBuilder::create()</a>, <a class="el" href="Block_8h_source.html#l00133">mlir::Block::end()</a>, <a class="el" href="Block_8h_source.html#l00076">mlir::Block::getArguments()</a>, <a class="el" href="Block_8h_source.html#l00126">mlir::Block::getOperations()</a>, <a class="el" href="UseDefLists_8h_source.html#l00040">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Block_8cpp_source.html#l00232">mlir::Block::getTerminator()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00216">mlir::Operation::isProperAncestor()</a>, <a class="el" href="Builders_8h_source.html#l00379">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="Builders_8h_source.html#l00417">mlir::OpBuilder::setInsertionPointToEnd()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SubsetHoisting_8cpp_source.html#l00399">hoistExtractInsertSlice()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00079">mlir::linalg::hoistRedundantVectorTransfers()</a>, <a class="el" href="SubsetHoisting_8cpp_source.html#l00340">hoistTransferReadWrite()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00794">padThroughLoopIterArg()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00109">replaceLoopNestWithNewYields()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html#l00060">replaceLoopWithNewYields()</a>.</p>

</div>
</div>
<a id="ac85035789b8e28cd6a8eb8ebcb2f6c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85035789b8e28cd6a8eb8ebcb2f6c07">&#9670;&nbsp;</a></span>replaceLoopWithNewYields() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scf::ForOp mlir::replaceLoopWithNewYields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newIterOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newYields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replaceIterOperandsUsesInLoop</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html#l00060">60</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00042">replaceLoopWithNewYields()</a>.</p>

</div>
</div>
<a id="a64a364dd32a6190474be758d1a6b9d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a364dd32a6190474be758d1a6b9d5f">&#9670;&nbsp;</a></span>reshapeLikeShapesAreCompatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::reshapeLikeShapesAreCompatible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(const Twine &amp;)&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>collapsedShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>expandedShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociationMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isExpandingReshape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that shapes of the reshaped types using following rules 1) if a dimension in the collapsed type is static, then the corresponding dimensions in the expanded shape should be a) static b) the product should be same as the collaped shape. </p>
<p>2) if a dimension in the collaped type is dynamic, one and only one of the corresponding dimensions in the expanded type should be dynamic. This rule is only needed with reshape operations that are expanding. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00227">227</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">emitError()</a>, <a class="el" href="Matchers_8h_source.html#l00262">mlir::detail::enumerate()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00734">fuseWithReshapeByExpansion()</a>.</p>

</div>
</div>
<a id="a9eb183dcb73d44f0e0aedb09b73c7fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb183dcb73d44f0e0aedb09b73c7fd7">&#9670;&nbsp;</a></span>runRegionDCE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::runRegionDCE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns success if any operations or arguments were deleted, failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00466">466</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00409">deleteDeadness()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00359">propagateLiveness()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8cpp_source.html#l00830">simplifyRegions()</a>.</p>

</div>
</div>
<a id="a37afe16f80bc8bacb6914dd6f0b869c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37afe16f80bc8bacb6914dd6f0b869c0">&#9670;&nbsp;</a></span>setupDebuggerExecutionContextHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::setupDebuggerExecutionContextHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1tracing_1_1ExecutionContext.html">tracing::ExecutionContext</a> &amp;&#160;</td>
          <td class="paramname"><em>executionContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DebuggerExecutionContextHook_8cpp_source.html#l00361">361</a> of file <a class="el" href="DebuggerExecutionContextHook_8cpp_source.html">DebuggerExecutionContextHook.cpp</a>.</p>

<p class="reference">References <a class="el" href="ExecutionContext_8h_source.html#l00114">mlir::tracing::ExecutionContext::addBreakpointManager()</a>, <a class="el" href="DebuggerExecutionContextHook_8cpp_source.html#l00331">debuggerCallBackFunction()</a>, <a class="el" href="DebuggerExecutionContextHook_8cpp_source.html#l00044">getGlobalDebuggerState()</a>, <a class="el" href="ExecutionContext_8cpp_source.html#l00053">mlir::tracing::ExecutionContext::registerObserver()</a>, and <a class="el" href="ExecutionContext_8h_source.html#l00080">mlir::tracing::ExecutionContext::setCallback()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CLOptionsSetup_8cpp_source.html#l00072">mlir::tracing::InstallDebugHandler::Impl::Impl()</a>.</p>

</div>
</div>
<a id="acbf369c69cfb613cd018ef4ce188809c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf369c69cfb613cd018ef4ce188809c">&#9670;&nbsp;</a></span>simplifyAffineExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::simplifyAffineExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify an affine expression by flattening and some amount of simple analysis. </p>
<p>Simplify the affine expression by flattening it and reconstructing it.</p>
<p>This has complexity linear in the number of nodes in 'expr'. Returns the simplified expression, which is the same as the input expression if it can't be simplified. When <code>expr</code> is semi-affine, a simplified semi-affine expression is constructed in the sorted order of dimension and symbol positions. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01407">1407</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00904">getAffineExprFromFlatForm()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00025">mlir::AffineExpr::getContext()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00947">getSemiAffineExprFromFlatForm()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00189">mlir::AffineExpr::isPureAffine()</a>, <a class="el" href="AffineExprVisitor_8h_source.html#l00271">mlir::SimpleAffineExprFlattener::localExprs</a>, <a class="el" href="AffineExprVisitor_8h_source.html#l00256">mlir::SimpleAffineExprFlattener::operandExprStack</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00452">simplifySemiAffine()</a>, and <a class="el" href="AffineExprVisitor_8h_source.html#l00075">mlir::AffineExprVisitor&lt; SubClass, RetTy &gt;::walkPostOrder()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00856">canonicalizeStridedLayout()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00370">createPrivateMemRef()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01453">getConstDifference()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00455">mlir::FlatLinearConstraints::getSliceBounds()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00727">getStridesAndOffset()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00894">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00864">mlir::MutableAffineMap::simplify()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00648">simplifyAffineMap()</a>.</p>

</div>
</div>
<a id="a014d8e82c51794d145267690b2b5bd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014d8e82c51794d145267690b2b5bd58">&#9670;&nbsp;</a></span>simplifyAffineMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::simplifyAffineMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies an affine map by simplifying its underlying <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> results. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00648">648</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01135">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00271">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00324">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00328">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00337">mlir::AffineMap::getResults()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01407">simplifyAffineExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00215">mlir::affine::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01125">composeAffineMapAndOperands()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00027">mlir::affine::AffineValueMap::difference()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01882">generatePointWiseCopy()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00497">mlir::affine::MemRefAccess::getAccessMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00057">getCleanupLoopLowerBound()</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00113">replaceUnitDims()</a>.</p>

</div>
</div>
<a id="a50c016066a116564e82772ece3edd84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c016066a116564e82772ece3edd84c">&#9670;&nbsp;</a></span>simplifyRegions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::simplifyRegions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a set of structural simplifications over the given regions. </p>
<p>This includes transformations like unreachable block elimination, dead argument elimination, as well as some other DCE. This function returns success if any of the regions were simplified, failure otherwise. The provided rewriter is used to notify callers of operation and block deletion.</p>
<p>This includes transformations like unreachable block elimination, dead argument elimination, as well as some other DCE. This function returns success if any of the regions were simplified, failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00830">830</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00179">eraseUnreachableBlocks()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00752">mergeIdenticalBlocks()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00466">runRegionDCE()</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">succeeded()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="aa6e007ae66428f560626d4ba3c58dfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e007ae66428f560626d4ba3c58dfe2">&#9670;&nbsp;</a></span>sinkOperationsIntoLaunchOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::sinkOperationsIntoLaunchOp </td>
          <td>(</td>
          <td class="paramtype">gpu::LaunchOp&#160;</td>
          <td class="paramname"><em>launchOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>isSinkingBeneficiary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sink operations into the <code>launchOp</code> to reduce the number of values that are used within the region of the operation, but defined outside of the region. </p>

<p class="definition">Definition at line <a class="el" href="KernelOutlining_8cpp_source.html#l00117">117</a> of file <a class="el" href="KernelOutlining_8cpp_source.html">KernelOutlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="KernelOutlining_8cpp_source.html#l00086">extractBeneficiaryOps()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00063">getUsedValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="a35009cf90a73229f64f9090d4e5aa2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35009cf90a73229f64f9090d4e5aa2b7">&#9670;&nbsp;</a></span>sortTopologically() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sortTopologically </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>isOperandReady</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a block, sort its operations in topological order, excluding its terminator if it has one. </p>
<p>This sort is stable. </p>

<p class="definition">Definition at line <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00097">97</a> of file <a class="el" href="TopologicalSortUtils_8cpp_source.html">TopologicalSortUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00141">mlir::Block::back()</a>, <a class="el" href="Block_8h_source.html#l00137">mlir::Block::empty()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00690">mlir::Operation::hasTrait()</a>, <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00051">sortTopologically()</a>, and <a class="el" href="Block_8h_source.html#l00198">mlir::Block::without_terminator()</a>.</p>

</div>
</div>
<a id="adb95f9dc749d6a604340f83fd16b19f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb95f9dc749d6a604340f83fd16b19f9">&#9670;&nbsp;</a></span>sortTopologically() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sortTopologically </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>isOperandReady</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a block, sort a range operations in said block in topological order. </p>
<p>The main purpose is readability of graph regions, potentially faster processing of certain transformations and analyses, or fixing the SSA dominance of blocks that require it after transformations. The function sorts the given operations such that, as much as possible, all users appear after their producers.</p>
<p>For example:</p>
<div class="fragment"><div class="line">%0 = test.foo</div>
<div class="line">%1 = test.bar %0, %2</div>
<div class="line">%2 = test.baz</div>
</div><!-- fragment --><p>Will become:</p>
<div class="fragment"><div class="line">%0 = test.foo</div>
<div class="line">%1 = test.baz</div>
<div class="line">%2 = test.bar %0, %1</div>
</div><!-- fragment --><p>The sort also works on operations with regions and implicit captures. For example:</p>
<div class="fragment"><div class="line">%0 = test.foo {</div>
<div class="line">  test.baz %1</div>
<div class="line">  %1 = test.bar %2</div>
<div class="line">}</div>
<div class="line">%2 = test.foo</div>
</div><!-- fragment --><p>Will become:</p>
<div class="fragment"><div class="line">%0 = test.foo</div>
<div class="line">%1 = test.foo {</div>
<div class="line">  test.baz %2</div>
<div class="line">  %2 = test.bar %0</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that the sort is not recursive on nested regions. This sort is stable; if the operations are already topologically sorted, nothing changes.</p>
<p>Operations that form cycles are moved to the end of the block in order. If the sort is left with only operations that form a cycle, it breaks the cycle by marking the first encountered operation as ready and moving on.</p>
<p>The function optionally accepts a callback that can be provided by users to virtually break cycles early. It is called on top-level operations in the block with value uses at or below those operations. The function should return true to mark that value as ready to be scheduled.</p>
<p>For example, if <code>isOperandReady</code> is set to always mark edges from <code>foo.A</code> to <code>foo.B</code> as ready, these operations:</p>
<div class="fragment"><div class="line">%0 = foo.B(%1)</div>
<div class="line">%1 = foo.C(%2)</div>
<div class="line">%2 = foo.A(%0)</div>
</div><!-- fragment --><p>Are sorted as:</p>
<div class="fragment"><div class="line">%0 = foo.A(%2)</div>
<div class="line">%1 = foo.C(%0)</div>
<div class="line">%2 = foo.B(%1)</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00051">51</a> of file <a class="el" href="TopologicalSortUtils_8cpp_source.html">TopologicalSortUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00097">sortTopologically()</a>.</p>

</div>
</div>
<a id="a3aa1a4192d65a00261a1f969b16c3e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa1a4192d65a00261a1f969b16c3e8a">&#9670;&nbsp;</a></span>sparseToSparseConversionStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36ca">SparseToSparseConversionStrategy</a> mlir::sparseToSparseConversionStrategy </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts command-line sparse2sparse flag to the strategy enum. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00346">346</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36caaa8c857c2f1b000c92f9794ebf53888d7">kAuto</a>, <a class="el" href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36caaa9a2bb1cd77c7a81a96b73f10722040e">kDirect</a>, and <a class="el" href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36caad0d3b7e52553c0a403cfe727b3ce47b3">kViaCOO</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SparseTensor_2Pipelines_2Passes_8h_source.html#l00139">mlir::sparse_tensor::SparseCompilerOptions::sparseTensorConversionOptions()</a>.</p>

</div>
</div>
<a id="ad0f624e2b686a5cf9b36bf1289e3a143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f624e2b686a5cf9b36bf1289e3a143">&#9670;&nbsp;</a></span>splitAndProcessBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::splitAndProcessBuffer </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; llvm::MemoryBuffer &gt;&#160;</td>
          <td class="paramname"><em>originalBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aafb0c2458571cd80ebb876d979e24346">ChunkBufferHandler</a>&#160;</td>
          <td class="paramname"><em>processChunkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableSplitting</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>insertMarkerInOutput</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits the specified buffer on a marker (<code>// -----</code>), processes each chunk independently according to the normal <code>processChunkBuffer</code> logic, and writes all results to <code>os</code>. </p>
<p>This is used to allow a large number of small independent tests to be put into a single file. <code>enableSplitting</code> can be used to toggle if splitting should be enabled, e.g. to allow for merging split and non-split code paths. When <code>insertMarkerInOutput</code> is true, split markers (<code>//-----</code>) are placed between each of the processed output chunks. </p>

<p class="definition">Definition at line <a class="el" href="ToolUtilities_8cpp_source.html#l00022">22</a> of file <a class="el" href="ToolUtilities_8cpp_source.html">ToolUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00364">MlirOptMain()</a>.</p>

</div>
</div>
<a id="a6f16fcf3a83d26d5a59da3bf0138ca24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f16fcf3a83d26d5a59da3bf0138ca24">&#9670;&nbsp;</a></span>structFuncArgTypeConverter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::structFuncArgTypeConverter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to convert function argument types. </p>
<p>Give structFuncArgTypeConverter access to memref-specific functions.</p>
<p>It converts a MemRef function argument to a list of non-aggregate types containing descriptor information, and an UnrankedmemRef function argument to a list containing the rank and a pointer to a descriptor struct. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00600">600</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02901">mlir::LLVMTypeConverter::convertType()</a>, <a class="el" href="IR_2Types_8h_source.html#l00311">mlir::Type::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="IR_2Types_8h_source.html#l00301">mlir::Type::isa()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="a57a1cb2e1046f84d6328600b92c99e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a1cb2e1046f84d6328600b92c99e52">&#9670;&nbsp;</a></span>succeeded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::succeeded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that returns true if the provided <a class="el" href="structmlir_1_1LogicalResult.html" title="This class represents an efficient way to signal success or failure.">LogicalResult</a> corresponds to a success value. </p>

<p class="definition">Definition at line <a class="el" href="LogicalResult_8h_source.html#l00068">68</a> of file <a class="el" href="LogicalResult_8h_source.html">LogicalResult.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00041">mlir::LogicalResult::succeeded()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02306">mlir::affine::affineDataCopyGenerate()</a>, <a class="el" href="LocalAliasAnalysis_8cpp_source.html#l00249">mlir::LocalAliasAnalysis::aliasImpl()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00118">mlir::bufferization::allocateTensorForShapedValue()</a>, <a class="el" href="ArithOps_8cpp_source.html#l01121">areValidCastInputsAndOutputs()</a>, <a class="el" href="PatternMatch_8h_source.html#l01284">mlir::detail::pdl_function_builder::assertArgs()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00458">mlir::PassReproducerOptions::attachResourceParser()</a>, <a class="el" href="PresburgerRelation_8cpp_source.html#l00595">mlir::presburger::SetCoalescer::coalesce()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00588">collectSymbolScopes()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01125">composeAffineMapAndOperands()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02901">mlir::TypeConverter::convertType()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00370">createPrivateMemRef()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00409">deleteDeadness()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00247">mlir::detail::DiagnosticEngineImpl::emit()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00670">extractStrides()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00231">mlir::detail::PassCrashReproducerGenerator::finalize()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00214">mlir::detail::OpPassManagerImpl::finalizePassList()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00592">mlir::Operation::fold()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02276">foldLoopBounds()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01739">mlir::presburger::IntegerRelation::fourierMotzkinEliminate()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00128">mlir::DynamicType::get()</a>, <a class="el" href="StorageUniquerSupport_8h_source.html#l00171">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::get()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00552">mlir::affine::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00113">getIndexedPtrs()</a>, <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00099">mlir::DiagnosedSilenceableFailure::getStatusString()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00815">getStridesAndOffset()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00727">getStridesAndOffset()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00415">mlir::DenseElementsAttr::getValues()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02787">haveCompatibleOffsets()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00937">mlir::linalg::hoistPaddingOnTensors()</a>, <a class="el" href="SubsetHoisting_8cpp_source.html#l00462">mlir::linalg::hoistRedundantSubsetExtractInsert()</a>, <a class="el" href="IR_8cpp_source.html#l00319">inferOperationTypes()</a>, <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00113">isFusionLegal()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00135">mlir::vector::isLastMemrefDimUnitStride()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00936">isStrided()</a>, <a class="el" href="Transforms_8cpp_source.html#l01117">mlir::linalg::GeneralizePadOpPattern::matchAndRewrite()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01110">mlir::LLVM::ModuleImport::matchIntegerAttr()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00799">mergeIdenticalBlocks()</a>, <a class="el" href="CAPI_2IR_2Pass_8cpp_source.html#l00089">mlirParsePassPipeline()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l01087">packMatmulGreedily()</a>, <a class="el" href="DLTI_8cpp_source.html#l00295">mlir::DataLayoutSpecAttr::parse()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00114">mlir::FieldParser&lt; std::optional&lt; AttributeT &gt;, std::enable_if_t&lt; std::is_base_of&lt; Attribute, AttributeT &gt;::value, std::optional&lt; AttributeT &gt; &gt; &gt;::parse()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00131">mlir::FieldParser&lt; std::optional&lt; IntT &gt;, std::enable_if_t&lt; std::is_integral&lt; IntT &gt;::value, std::optional&lt; IntT &gt; &gt; &gt;::parse()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00829">mlir::detail::DenseArrayAttrImpl&lt; T &gt;::parse()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00120">parseAnyType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00305">parseAsyncDependencies()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00559">mlir::DynamicDialect::parseAttribute()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00127">parseCommonStructuredOpParts()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00231">parseControlAttribute()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00067">parseCreateOperationOpAttributes()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00103">parseCreateOperationOpResults()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00123">parseDynamicIndexList()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00017">parseFunctionArgumentList()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00083">parseFunctionResultList()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00116">mlir::function_interface_impl::parseFunctionSignature()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00036">parseFunctionTypes()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00343">parseGangClause()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01564">parseGlobalMemrefOpTypeAndInitialValue()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00903">parseGroupNonUniformArithmeticOp()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00381">parseInterfaceVarABIAttr()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00357">parseKeywordList()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00890">parseLoopControl()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00145">parseOperationOpAttributes()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00243">mlir::detail::Parser::parseOptionalAttribute()</a>, <a class="el" href="OpImplementation_8h_source.html#l01015">mlir::AsmParser::parseOptionalAttribute()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02349">parseOptionalInterchange()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01661">parseOptionalKeywordAlternative()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00379">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalKeywordOrString()</a>, <a class="el" href="OpImplementation_8h_source.html#l01067">mlir::AsmParser::parseOptionalSymbolName()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00082">parsePointer()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00326">parseScheduleClause()</a>, <a class="el" href="TransformOps_8cpp_source.html#l01619">parseSequenceOpOperands()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00024">parseStorageType()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00868">parseStoreType()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00601">parseStructMemberDecorations()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00668">parseStructType()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l03872">parseSwitchCases()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00493">parseSwitchOpCases()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00554">parseSynchronizationHint()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00524">parseTargetEnvAttr()</a>, <a class="el" href="MLProgramOps_8cpp_source.html#l00029">parseTokenOrdering()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00532">mlir::DynamicDialect::parseType()</a>, <a class="el" href="MLProgramOps_8cpp_source.html#l00084">parseTypedInitialValue()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00194">parseUniformType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00611">parseVariableDecorations()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00419">parseVectorClause()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00399">parseWorkerClause()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00579">mlir::DynamicDialect::printAttribute()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01853">mlir::AsmPrinter::Impl::printLocationInternal()</a>, <a class="el" href="OpImplementation_8h_source.html#l00141">mlir::AsmPrinter::printStrippedAttrOrType()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00552">mlir::DynamicDialect::printType()</a>, <a class="el" href="PatternMatch_8h_source.html#l01326">mlir::detail::pdl_function_builder::processResults()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00121">reifyOrComputeDynamicSizes()</a>, <a class="el" href="AttrTypeSubElements_8h_source.html#l00451">mlir::detail::replaceImmediateSubElementsImpl()</a>, <a class="el" href="Transport_8cpp_source.html#l00197">mlir::lsp::JSONTransport::run()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00830">simplifyRegions()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00519">mlir::vector::splitFullAndPartialTransfer()</a>, <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00075">mlir::DiagnosedSilenceableFailure::succeeded()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00360">tileAndFuseFirstExtractUse()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00430">tileAndFuseFirstExtractUseThroughContainingOpBlockArgument()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00840">tryIsolateBands()</a>, <a class="el" href="Mem2Reg_8cpp_source.html#l00502">tryToPromoteMemorySlots()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01475">mlir::linalg::vectorize()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01315">mlir::linalg::vectorizeLinalgOpPrecondition()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01664">vectorizeLoops()</a>, <a class="el" href="PatternMatch_8h_source.html#l01267">mlir::detail::pdl_function_builder::verifyAsArgs()</a>, <a class="el" href="mlir_2CAPI_2Support_8h_source.html#l00034">wrap()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00614">mlir::scf::yieldReplacementForFusedProducer()</a>.</p>

</div>
</div>
<a id="a5f55c06c7c4aeace3f6824dd68f8b1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f55c06c7c4aeace3f6824dd68f8b1ed">&#9670;&nbsp;</a></span>success() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::success </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isSuccess</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to generate a <a class="el" href="structmlir_1_1LogicalResult.html" title="This class represents an efficient way to signal success or failure.">LogicalResult</a>. </p>
<p>If isSuccess is true a <code>success</code> result is generated, otherwise a 'failure' result is generated. </p>

<p class="definition">Definition at line <a class="el" href="LogicalResult_8h_source.html#l00056">56</a> of file <a class="el" href="LogicalResult_8h_source.html">LogicalResult.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00030">mlir::LogicalResult::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00069">mlir::affine::FlatAffineValueConstraints::addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00120">mlir::affine::FlatAffineValueConstraints::addAffineParallelOpDomain()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00652">mlir::FlatLinearConstraints::addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00149">mlir::affine::FlatAffineValueConstraints::addDomainFromSliceMaps()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01241">addMissingLoopIVBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00239">mlir::affine::FlatAffineValueConstraints::addSliceBounds()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00932">mlir::PassPipelineCLParser::addToPipeline()</a>, <a class="el" href="OpImplementation_8h_source.html#l01232">mlir::AsmParser::addTypesToList()</a>, <a class="el" href="OpImplementation_8h_source.html#l01224">mlir::AsmParser::addTypeToList()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02306">mlir::affine::affineDataCopyGenerate()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00236">mlir::affine::affineForOpBodySkew()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00346">mlir::affine::affineParallelize()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00358">mlir::bufferization::analyzeModuleOp()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00658">analyzeProfitability()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01797">appendMangledType()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00484">mlir::PassReproducerOptions::apply()</a>, <a class="el" href="TransformInterfaces_8h_source.html#l01134">mlir::transform::TransformEachOpTrait&lt; OpTy &gt;::apply()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00607">applyOpPatternsAndFold()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00133">applyPassManagerCLOptions()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00211">applyTilingToAll()</a>, <a class="el" href="lsp-server-support_2Protocol_8cpp_source.html#l00497">mlir::lsp::TextDocumentContentChangeEvent::applyTo()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00629">barePtrFuncArgTypeConverter()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00790">bufferizableInPlaceAnalysisImpl()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00409">mlir::bufferization::bufferizeModuleOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l04037">mlir::affine::AffineValueMap::canonicalize()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02322">canonicalizeLoopBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03558">canonicalizeMapExprAndTermOrder()</a>, <a class="el" href="VectorDropLeadUnitDim_8cpp_source.html#l00285">mlir::vector::castAwayContractionLeadingOneDim()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00136">checkAffineLoopNestMappable()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00110">checkAffineLoopNestMappableImpl()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01110">mlir::transform::detail::checkApplyToOne()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00070">checkCapabilityRequirements()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00310">checkCompatibleReturnType&lt; float &gt;()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00290">checkCompatibleReturnType&lt; int32_t &gt;()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00300">checkCompatibleReturnType&lt; int64_t &gt;()</a>, <a class="el" href="TransformOps_8cpp_source.html#l01701">checkDoubleConsume()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00731">ValueEquivalenceCache::checkEquivalent()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00042">checkExtensionRequirements()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00368">checkIfHyperRectangular()</a>, <a class="el" href="MathToSPIRV_8cpp_source.html#l00075">checkSourceOpTypes()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00296">checkTensorElementType()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01648">mlir::affine::coalesceLoops()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00653">coalesceLoops()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00096">collapseBranch()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00040">collectValidReferencesFor()</a>, <a class="el" href="DLTI_8cpp_source.html#l00195">combineOneSpec()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00181">compileAndExecute()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00319">compileAndExecuteSingleReturnFunction()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00158">mlir::FlatLinearConstraints::composeMatchingMap()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00220">mlir::ValueBoundsConstraintSet::computeBound()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00713">mlir::FlatLinearConstraints::computeLocalVars()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00612">mlir::detail::ExpectedDiag::computeRegex()</a>, <a class="el" href="TosaMakeBroadcastable_8cpp_source.html#l00049">computeReshapeOutput()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00365">mlir::AffineMap::constantFold()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01361">mlir::presburger::IntegerRelation::constantFoldVar()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00287">convertAffineLoopNestToGPULaunch()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00561">mlir::LLVM::ModuleImport::convertDataLayout()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03065">convertFuncOpTypes()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00576">mlir::LLVM::ModuleImport::convertFunctions()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00543">mlir::LLVM::ModuleImport::convertGlobals()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00514">mlir::LLVM::ModuleImport::convertMetadata()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01325">mlir::detail::ConversionPatternRewriterImpl::convertNonEntryRegionTypes()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01186">convertOmpAtomicCapture()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01060">convertOmpAtomicRead()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01117">convertOmpAtomicUpdate()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01083">convertOmpAtomicWrite()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00342">convertOmpCritical()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00315">convertOmpMaster()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00538">convertOmpOrdered()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00568">convertOmpOrderedRegion()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00257">convertOmpParallel()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01280">convertOmpReductionOp()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00601">convertOmpSections()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00952">convertOmpSimdLoop()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00669">convertOmpSingle()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01626">convertOmpTarget()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00737">convertOmpTaskgroupOp()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00687">convertOmpTaskOp()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01327">convertOmpThreadprivate()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00758">convertOmpWsLoop()</a>, <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00140">convertOperationImpl()</a>, <a class="el" href="FrozenRewritePatternSet_8cpp_source.html#l00021">convertPDLToPDLInterp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02972">mlir::TypeConverter::convertSignatureArg()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02987">mlir::TypeConverter::convertSignatureArgs()</a>, <a class="el" href="SparseTensorStorageLayout_8cpp_source.html#l00036">convertSparseTensorType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02901">mlir::TypeConverter::convertType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02949">mlir::TypeConverter::convertTypes()</a>, <a class="el" href="Promotion_8cpp_source.html#l00477">mlir::linalg::copyToGPUPrivateMemory()</a>, <a class="el" href="Promotion_8cpp_source.html#l00460">mlir::linalg::copyToWorkgroupMemory()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00228">mlir::ConvertToLLVMPattern::copyUnrankedDescriptors()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00775">mlir::bufferization::BufferizationOptions::createDealloc()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00786">mlir::bufferization::BufferizationOptions::createMemCpy()</a>, <a class="el" href="Promotion_8cpp_source.html#l00485">mlir::linalg::deallocateGPUPrivateMemory()</a>, <a class="el" href="Promotion_8cpp_source.html#l00453">mlir::linalg::deallocateWorkgroupMemory()</a>, <a class="el" href="Promotion_8cpp_source.html#l00109">defaultDeallocBufferCallBack()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00409">deleteDeadness()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00063">mlir::spirv::Deserializer::deserialize()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00456">mlir::spirv::Deserializer::processOp&lt; spirv::CopyMemoryOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00332">mlir::spirv::Deserializer::processOp&lt; spirv::EntryPointOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00381">mlir::spirv::Deserializer::processOp&lt; spirv::ExecutionModeOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00414">mlir::spirv::Deserializer::processOp&lt; spirv::FunctionCallOp &gt;()</a>, <a class="el" href="DropEquivalentBufferResults_8cpp_source.html#l00070">mlir::bufferization::dropEquivalentBufferResults()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00515">elementwiseMatchAndRewriteHelper()</a>, <a class="el" href="Transport_8cpp_source.html#l00138">encodeError()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00128">encodeKernelName()</a>, <a class="el" href="OperationSupport_8h_source.html#l01251">mlir::OperationEquivalence::exactValueMatch()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00670">extractStrides()</a>, <a class="el" href="Threading_8h_source.html#l00036">failableParallelForEach()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00214">mlir::detail::OpPassManagerImpl::finalizePassList()</a>, <a class="el" href="ReductionTreePass_8cpp_source.html#l00086">findOptimal()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00628">mlir::FlatLinearConstraints::flattenAlignedMapAndMergeLocals()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00592">mlir::Operation::fold()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00029">foldDynamicIndexList()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01210">foldExtractOpFromExtractChain()</a>, <a class="el" href="TensorOps_8cpp_source.html#l02226">foldInsertAfterInsertSlice()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02276">foldLoopBounds()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00088">mlir::bufferization::foldToMemrefToTensorPair()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00827">forwardPassthroughAttributes()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00862">forwardStoreToLoad()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00700">mlir::presburger::IntegerRelation::gaussianEliminateVar()</a>, <a class="el" href="Generalization_8cpp_source.html#l00038">generalizeNamedOpPrecondition()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00980">generateCleanupLoopForUnroll()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01971">generateCopy()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02503">mlir::affine::generateCopyForMemRegion()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00733">mlir::OpState::genericParseProperties()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00458">mlir::affine::MemRefAccess::getAccessRelation()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00552">mlir::affine::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="OpImplementation_8h_source.html#l00506">mlir::AsmParser::getCurrentLocation()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00286">getDefaultABIAttrs()</a>, <a class="el" href="Analysis_2Presburger_2Utils_8cpp_source.html#l00096">getDivRepr()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00119">getFlattenedAffineExprs()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00072">getFlattenedAffineExprs()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l00096">mlir::transform::TransformState::getHandlesForPayloadValue()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00082">getInterfaceVariables()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00110">getKernelGlobalVariables()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00084">getMemRefAlignment()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01318">getMultiAffineFunctionFromMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00493">mlir::affine::getRelationFromMap()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01525">mlir::ConversionPatternRewriter::getRemappedValues()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00048">mlir::shape::getShapeVec()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00537">mlir::affine::ComputationSliceState::getSourceAsConstraints()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00727">getStridesAndOffset()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00785">getStridesAndOffset()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01491">getTileSizePos()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00405">mlir::affine::hoistAffineIfOp()</a>, <a class="el" href="OperationSupport_8h_source.html#l01246">mlir::OperationEquivalence::ignoreValueEquivalence()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00220">incSlicePosition()</a>, <a class="el" href="IR_8cpp_source.html#l00319">inferOperationTypes()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00219">mlir::detail::inferReturnTensorTypes()</a>, <a class="el" href="include_2mlir_2Pass_2Pass_8h_source.html#l00185">mlir::Pass::initialize()</a>, <a class="el" href="CAPI_2IR_2Pass_8cpp_source.html#l00139">mlir::ExternalPass::initialize()</a>, <a class="el" href="ReductionNode_8cpp_source.html#l00038">mlir::ReductionNode::initialize()</a>, <a class="el" href="DataFlowFramework_8cpp_source.html#l00065">mlir::DataFlowSolver::initializeAndRun()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00270">VectorizationState::initState()</a>, <a class="el" href="CodegenEnv_8cpp_source.html#l00062">mlir::sparse_tensor::CodegenEnv::initTensorExp()</a>, <a class="el" href="Inliner_8cpp_source.html#l00464">inlineCallsInSCC()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00423">inlineConvertOmpRegions()</a>, <a class="el" href="Interchange_8cpp_source.html#l00036">interchangeGenericOpPrecondition()</a>, <a class="el" href="TranslateToCpp_8cpp_source.html#l00040">interleaveWithError()</a>, <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00455">mlir::transform::detail::interpreterBaseInitializeImpl()</a>, <a class="el" href="ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00382">mlir::ExecutionEngine::invokePacked()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00086">isAddMul()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00613">isGenericOpExpandable()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00610">isMatchingWidth()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00099">isMemRefTypeSupported()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00024">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00340">lookupSymbolInImpl()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01015">mlir::affine::loopUnrollByFactor()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00460">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00892">mlir::affine::loopUnrollFull()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01133">mlir::affine::loopUnrollJamByFactor()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00118">lowerEntryPointABIAttr()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00606">lvlIsInBounds()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01044">CanonicalizeContractAdd&lt; AddOpType &gt;::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00232">mlir::ComposeCollapseOfExpandOp&lt; CollapseOpTy, ExpandOpTy, CastOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00298">mlir::ComposeExpandOfCollapseOp&lt; ExpandOpTy, CollapseOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00020">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00219">mlir::GPUPrintfOpToHIPLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00330">mlir::GPUPrintfOpToLLVMCallLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00385">mlir::GPUPrintfOpToVPrintfLowering::matchAndRewrite()</a>, <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00154">InsertSliceOfInsertSliceFolder&lt; OpTy &gt;::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00175">mlir::ComposeReassociativeReshapeOps&lt; ReshapeOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00348">ConvertAccessChain::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00332">ConvertAddressOf::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00319">ConvertVariable::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00434">ConvertLoad::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00534">ConvertStore::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03431">DeduplicateAffineMinMaxExpressions&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03474">MergeAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03613">CanonicalizeAffineMinMaxOpExprAndTermOrder&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03627">CanonicalizeSingleResultAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="SwapExtractSliceWithFillPatterns_8cpp_source.html#l00022">SwapExtractSliceOfFill::matchAndRewrite()</a>, <a class="el" href="Transforms_8cpp_source.html#l01179">mlir::linalg::ExtractSliceOfPadTensorSwapPattern::matchAndRewrite()</a>, <a class="el" href="Transforms_8cpp_source.html#l01302">mlir::linalg::GeneralizeOuterUnitDimsPackOpPattern::matchAndRewrite()</a>, <a class="el" href="Transforms_8cpp_source.html#l01038">mlir::linalg::PadOpTransformationPattern::matchAndRewrite()</a>, <a class="el" href="Transforms_8cpp_source.html#l01117">mlir::linalg::GeneralizePadOpPattern::matchAndRewrite()</a>, <a class="el" href="Transforms_8cpp_source.html#l01388">mlir::linalg::GeneralizeOuterUnitDimsUnPackOpPattern::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00437">ConcatSliceOptimization::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00136">ConsolidateTransposeOptimization::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l02054">mlir::linalg::LinalgCopyVTRForwardingPattern::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l02131">mlir::linalg::LinalgCopyVTWForwardingPattern::matchAndRewrite()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00033">mlir::scf::matchForLikeLoop()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01110">mlir::LLVM::ModuleImport::matchIntegerAttr()</a>, <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00017">mlir::affine::mergeOffsetsSizesAndStrides()</a>, <a class="el" href="CAPI_2ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00075">mlirExecutionEngineInvokePacked()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00398">MlirOptMain()</a>, <a class="el" href="MlirReduceMain_8cpp_source.html#l00049">mlirReduceMain()</a>, <a class="el" href="Simplex_8cpp_source.html#l00758">mlir::presburger::LexSimplexBase::moveRowUnknownToColumn()</a>, <a class="el" href="Dialect_2LLVMIR_2IR_2TypeDetail_8h_source.html#l00243">mlir::LLVM::detail::LLVMStructTypeStorage::mutate()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00986">mlir::spirv::detail::StructTypeStorage::mutate()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00987">NAryInferReturnTypes()</a>, <a class="el" href="LogicalResult_8h_source.html#l00095">mlir::FailureOr&lt; T &gt;::operator LogicalResult()</a>, <a class="el" href="SerializeToBlob_8cpp_source.html#l00103">mlir::gpu::SerializeToBlobPass::optimizeLlvm()</a>, <a class="el" href="OptimizeSharedMemory_8cpp_source.html#l00181">mlir::nvgpu::optimizeSharedMemoryReadsAndWrites()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00291">outlineIfOp()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00918">mlir::detail::ParallelDiagnosticHandlerImpl::ParallelDiagnosticHandlerImpl()</a>, <a class="el" href="Threading_8h_source.html#l00117">parallelForEach()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00156">mlir::FieldParser&lt; ContainerT, std::enable_if_t&lt; llvm::is_detected&lt; detail::has_push_back_t, ContainerT &gt;::value, ContainerT &gt; &gt;::parse()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00269">mlir::DynamicAttr::parse()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00156">mlir::DynamicType::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01711">mlir::affine::AffineDmaStartOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01870">mlir::affine::AffineDmaWaitOp::parse()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00699">mlir::detail::Parser::parseAffineMapReference()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00248">parseAlignedClause()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00088">parseAllocateAndAllocator()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00785">parseArithmeticExtendedBinaryOp()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00518">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseArrowTypeList()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00964">parseAtomicReductionRegion()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00394">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseAttribute()</a>, <a class="el" href="OpImplementation_8h_source.html#l00892">mlir::AsmParser::parseAttribute()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00051">mlir::detail::Parser::parseAttribute()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00294">mlir::detail::Parser::parseAttributeDict()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00344">parseAttributions()</a>, <a class="el" href="Dialect_2Async_2IR_2Async_8cpp_source.html#l00292">parseAwaitResultType()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00251">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseBase64Bytes()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02031">parseBound()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00029">mlir::detail::Parser::parseCallSiteLocation()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01061">parseCallTypeAndResolveOperands()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00131">parseClauseAttr()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00122">parseCmpOp()</a>, <a class="el" href="OpImplementation_8h_source.html#l01192">mlir::AsmParser::parseColonType()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l00050">mlir::detail::Parser::parseCommaSeparatedList()</a>, <a class="el" href="PassOptions_8h_source.html#l00038">mlir::detail::pass_options::parseCommaSeparatedList()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l00139">mlir::detail::Parser::parseCommaSeparatedListUntil()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00127">parseCommonStructuredOpParts()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00231">parseControlAttribute()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00067">parseCreateOperationOpAttributes()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00103">parseCreateOperationOpResults()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00401">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseCustomAttributeWithFallback()</a>, <a class="el" href="OpImplementation_8h_source.html#l00923">mlir::AsmParser::parseCustomAttributeWithFallback()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00413">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseCustomTypeWithFallback()</a>, <a class="el" href="OpImplementation_8h_source.html#l01149">mlir::AsmParser::parseCustomTypeWithFallback()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01278">parseDenseI64ArrayAttr()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00491">parseDependVarList()</a>, <a class="el" href="BytecodeReader_8cpp_source.html#l00469">parseDialectGrouping()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00054">mlir::detail::Parser::parseDialectSymbolBody()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00524">mlir::detail::Parser::parseDimensionListRanked()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00961">parseDstStyleOp()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00123">parseDynamicIndexList()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00451">parseElementAttrHexValues()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00217">parseEnumKeywordAttr()</a>, <a class="el" href="ParserUtils_8h_source.html#l00027">parseEnumKeywordAttr()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00176">parseEnumStrAttr()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00273">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseFloat()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l00278">mlir::detail::Parser::parseFloatFromIntegerLiteral()</a>, <a class="el" href="TransformOps_8cpp_source.html#l00585">parseForeachMatchSymbols()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00272">mlir::detail::PassOptions::parseFromString()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00017">parseFunctionArgumentList()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00164">mlir::function_interface_impl::parseFunctionOp()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00083">parseFunctionResultList()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00071">mlir::detail::Parser::parseFunctionResultTypes()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00116">mlir::function_interface_impl::parseFunctionSignature()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00036">parseFunctionTypes()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00061">mlir::detail::Parser::parseFusedLocation()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00343">parseGangClause()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00569">parseGEPIndices()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01564">parseGlobalMemrefOpTypeAndInitialValue()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00371">parseImageOperands()</a>, <a class="el" href="TensorOps_8cpp_source.html#l02508">parseInferType()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01460">parseInsertExtractValueElementType()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00561">mlir::detail::Parser::parseIntegerInDimensionList()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00708">mlir::detail::Parser::parseIntegerSetReference()</a>, <a class="el" href="OpImplementation_8h_source.html#l00792">mlir::AsmParser::parseKeyword()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00322">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseKeyword()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00357">parseKeywordList()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00571">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseKeywordOrCompletion()</a>, <a class="el" href="OpImplementation_8h_source.html#l00812">mlir::AsmParser::parseKeywordOrString()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00927">parseLaunchFuncOperands()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00157">parseLinearClause()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00814">parseLoadType()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00151">mlir::detail::Parser::parseLocationInstance()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00645">parseMapClause()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00254">parseMemoryAccessAttributes()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00169">mlir::detail::Parser::parseMemRefType()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00882">parseMultitileSizesTypes()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00208">parseNamedStructuredOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00182">parseNamedStructuredOpRegion()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00201">parseNamedStructuredOpResults()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00095">mlir::detail::Parser::parseNameOrFileLineColLocation()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00072">parseOneResultSameOperandTypeOp()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00145">parseOperationOpAttributes()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00255">parseOptionalArrayStride()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00075">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalArrow()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00526">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalArrowTypeList()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00440">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalAttrDict()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00448">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalAttrDictWithKeyword()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00243">mlir::detail::Parser::parseOptionalAttribute()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01104">parseOptionalCallFuncPtr()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00105">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalColon()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00548">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalColonTypeList()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00115">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalComma()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00484">mlir::ExtensibleDialect::parseOptionalDynamicAttr()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00462">mlir::ExtensibleDialect::parseOptionalDynamicType()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00125">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalEllipsis()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00135">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalEqual()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00155">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalGreater()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l00241">mlir::detail::Parser::parseOptionalInteger()</a>, <a class="el" href="OpImplementation_8h_source.html#l00653">mlir::AsmParser::parseOptionalInteger()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02349">parseOptionalInterchange()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l00312">mlir::detail::Parser::parseOptionalKeyword()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00334">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalKeyword()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00379">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalKeywordOrString()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00085">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalLBrace()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00145">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalLess()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00165">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalLParen()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00185">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalLSquare()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00225">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalPlus()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00205">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalQuestion()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00095">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalRBrace()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00175">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalRParen()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00195">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalRSquare()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00215">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalStar()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00240">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalString()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00470">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalSymbolName()</a>, <a class="el" href="OpImplementation_8h_source.html#l01067">mlir::AsmParser::parseOptionalSymbolName()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00235">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalVerticalBar()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l01032">mlir::impl::parseOptionalVisibilityKeyword()</a>, <a class="el" href="Dialect_2Transform_2Utils_2Utils_8cpp_source.html#l00028">mlir::transform::parsePackedOrDynamicIndexList()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00695">parsePassPipeline()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00082">parsePointer()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l04686">parsePtrAccessChainOpImpl()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00162">parseQuantParams()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00406">parseRangeType()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00409">parseReductionVarList()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00224">parseRegions()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00450">parseResultsValueType()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00326">parseScheduleClause()</a>, <a class="el" href="LinalgMatchOps_8cpp_source.html#l00759">parseSemiFunctionType()</a>, <a class="el" href="TransformOps_8cpp_source.html#l01619">parseSequenceOpOperands()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01931">parseShuffleType()</a>, <a class="el" href="IRDL_8cpp_source.html#l00050">parseSingleBlockRegion()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00285">parseSourceMemoryAccessAttributes()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00063">parseStorageRange()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00868">parseStoreType()</a>, <a class="el" href="OpImplementation_8h_source.html#l00593">mlir::AsmParser::parseString()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00601">parseStructMemberDecorations()</a>, <a class="el" href="LinalgMatchOps_8cpp_source.html#l00693">parseStructuredTransformDims()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l03872">parseSwitchCases()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00493">parseSwitchOpCases()</a>, <a class="el" href="OpImplementation_8h_source.html#l01044">mlir::AsmParser::parseSymbolName()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00554">parseSynchronizationHint()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l02711">parseTBAAMembers()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00268">parseTileLikeOp()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l00233">mlir::detail::Parser::parseToken()</a>, <a class="el" href="MLProgramOps_8cpp_source.html#l00029">parseTokenOrdering()</a>, <a class="el" href="OpImplementation_8h_source.html#l01405">mlir::OpAsmParser::parseTrailingOperandList()</a>, <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00056">parseTransformModuleFromFile()</a>, <a class="el" href="OpImplementation_8h_source.html#l01120">mlir::AsmParser::parseType()</a>, <a class="el" href="MLProgramOps_8cpp_source.html#l00084">parseTypedInitialValue()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00087">mlir::detail::Parser::parseTypeListNoParens()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00102">mlir::detail::Parser::parseTypeListParens()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00611">parseVariableDecorations()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00419">parseVectorClause()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00471">mlir::detail::Parser::parseVectorDimensionList()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00449">parseVerCapExtAttr()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00399">parseWorkerClause()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00589">mlir::detail::Parser::parseXInDimensionList()</a>, <a class="el" href="PassRegistry_8h_source.html#l00191">mlir::PassPipelineRegistration&lt; EmptyPipelineOptions &gt;::PassPipelineRegistration()</a>, <a class="el" href="PassRegistry_8h_source.html#l00168">mlir::PassPipelineRegistration&lt; Options &gt;::PassPipelineRegistration()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00119">peelForLoop()</a>, <a class="el" href="TosaOps_8cpp_source.html#l01047">poolingInferReturnTypes()</a>, <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00071">preconditionsFoldExtractOrInsertWithTransferOp()</a>, <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00322">preconditionsFoldSubViewOpImpl()</a>, <a class="el" href="TranslateToCpp_8cpp_source.html#l00185">printConstantOp()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00497">mlir::ExtensibleDialect::printIfDynamicAttr()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00475">mlir::ExtensibleDialect::printIfDynamicType()</a>, <a class="el" href="TranslateToCpp_8cpp_source.html#l00249">printOperation()</a>, <a class="el" href="PatternMatch_8h_source.html#l01410">mlir::detail::pdl_function_builder::processArgsAndInvokeRewrite()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01557">mlir::LLVM::ModuleImport::processFunction()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01360">processMapOperand()</a>, <a class="el" href="PatternMatch_8h_source.html#l01306">mlir::detail::pdl_function_builder::processResults()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00184">mlir::bufferization::promoteBufferResultsToOutParams()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00132">mlir::affine::promoteIfSingleIteration()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00541">mlir::scf::promoteIfSingleIteration()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00383">promoteIfSingleIteration()</a>, <a class="el" href="Tools_2PDLL_2Parser_2Lexer_8cpp_source.html#l00108">mlir::pdll::Lexer::pushInclude()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00082">mlir::DialectBytecodeReader::readAttribute()</a>, <a class="el" href="Transport_8cpp_source.html#l00266">readLine()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00047">mlir::DialectBytecodeReader::readList()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00353">readResourceHandle()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00099">mlir::DialectBytecodeReader::readType()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00938">ReduceInferReturnTypes()</a>, <a class="el" href="mlir_2IR_2Diagnostics_8h_source.html#l00443">mlir::DiagnosticEngine::registerHandler()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01210">mlir::detail::ConversionPatternRewriterImpl::remapValues()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01077">replaceDimOrSym()</a>, <a class="el" href="SCCP_8cpp_source.html#l00042">replaceWithConstant()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00227">reshapeLikeShapesAreCompatible()</a>, <a class="el" href="TosaMakeBroadcastable_8cpp_source.html#l00081">reshapeLowerToHigher()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00327">resolveBroadcastShape()</a>, <a class="el" href="BytecodeReader_8cpp_source.html#l00314">resolveEntry()</a>, <a class="el" href="OpImplementation_8h_source.html#l01421">mlir::OpAsmParser::resolveOperands()</a>, <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00113">resolveSourceIndicesCollapseShape()</a>, <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00062">resolveSourceIndicesExpandShape()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01936">PadOpVectorizationWithInsertSlicePattern::rewriteUser()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01720">PadOpVectorizationWithTransferReadPattern::rewriteUser()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01782">PadOpVectorizationWithTransferWritePattern::rewriteUser()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00102">roundTripModule()</a>, <a class="el" href="Transport_8cpp_source.html#l00197">mlir::lsp::JSONTransport::run()</a>, <a class="el" href="TransformInterpreterPassBase_8h_source.html#l00137">mlir::transform::TransformInterpreterPassBase&lt; Concrete, GeneratedBase &gt;::runAfterInterpreter()</a>, <a class="el" href="TransformInterpreterPassBase_8h_source.html#l00132">mlir::transform::TransformInterpreterPassBase&lt; Concrete, GeneratedBase &gt;::runBeforeInterpreter()</a>, <a class="el" href="mlir-lsp-server_2LSPServer_8cpp_source.html#l00285">mlir::lsp::runMlirLSPServer()</a>, <a class="el" href="mlir-pdll-lsp-server_2LSPServer_8cpp_source.html#l00283">mlir::lsp::runPdllLSPServer()</a>, <a class="el" href="tblgen-lsp-server_2LSPServer_8cpp_source.html#l00190">mlir::lsp::runTableGenLSPServer()</a>, <a class="el" href="Inliner_8cpp_source.html#l00293">runTransformOnCGSCCs()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02720">mlir::affine::separateFullTiles()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00073">serializeModule()</a>, <a class="el" href="Serializer_8cpp_source.html#l00270">mlir::spirv::Serializer::processTypeDecoration&lt; spirv::ArrayType &gt;()</a>, <a class="el" href="Serializer_8cpp_source.html#l00280">mlir::spirv::Serializer::processTypeDecoration&lt; spirv::RuntimeArrayType &gt;()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01029">mlir::transform::TransformResults::setMappedValues()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00184">mlir::MlirOptMainConfig::setPassPipelineParser()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00337">mlir::Operation::setPropertiesFromAttribute()</a>, <a class="el" href="MlirOptMain_8h_source.html#l00113">mlir::MlirOptMainConfig::setupPassPipeline()</a>, <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00109">mlir::DiagnosedSilenceableFailure::silence()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00830">simplifyRegions()</a>, <a class="el" href="ToolUtilities_8cpp_source.html#l00022">splitAndProcessBuffer()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00519">mlir::vector::splitFullAndPartialTransfer()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00128">splitFullAndPartialTransferPrecondition()</a>, <a class="el" href="UnsignedWhenEquivalent_8cpp_source.html#l00032">staticallyNonNegative()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00600">structFuncArgTypeConverter()</a>, <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00048">mlir::DiagnosedSilenceableFailure::success()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00778">mlir::affine::tilePerfectlyNested()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00821">mlir::affine::tilePerfectlyNestedParametric()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00275">mlir::linalg::TileLoopNest::tileRootOp()</a>, <a class="el" href="LoopAnnotationImporter_8cpp_source.html#l00460">mlir::LLVM::detail::LoopAnnotationImporter::translateAccessGroup()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00062">translateDataLayout()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00840">tryIsolateBands()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00587">mlir::detail::OpToOpPassAdaptor::tryMergeInto()</a>, <a class="el" href="Mem2Reg_8cpp_source.html#l00502">tryToPromoteMemorySlots()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01600">GenericPadOpVectorizationPattern::tryVectorizeCopy()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00025">typeOrAttrParser()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01979">mlir::presburger::IntegerRelation::unionBoundingBox()</a>, <a class="el" href="mlir_2CAPI_2Support_8h_source.html#l00040">unwrap()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00048">updateFuncOp()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00345">mlir::BytecodeDialectInterface::upgradeFromVersion()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01475">mlir::linalg::vectorize()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01528">mlir::linalg::vectorizeCopy()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01315">mlir::linalg::vectorizeLinalgOpPrecondition()</a>, <a class="el" href="OpDefinition_8h_source.html#l00209">mlir::OpState::verify()</a>, <a class="el" href="StorageUniquerSupport_8h_source.html#l00222">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::verify()</a>, <a class="el" href="DLTI_8cpp_source.html#l00149">mlir::DataLayoutSpecAttr::verify()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00095">mlir::gpu::MMAMatrixType::verify()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00163">mlir::spirv::InterfaceVarABIAttr::verify()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00259">mlir::spirv::VerCapExtAttr::verify()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00489">mlir::LLVM::LLVMStructType::verify()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01180">mlir::spirv::MatrixType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00383">mlir::quant::CalibratedQuantizedType::verify()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00816">mlir::spirv::SampledImageType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00323">mlir::quant::UniformQuantizedPerAxisType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00270">mlir::quant::UniformQuantizedType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00032">mlir::quant::QuantizedType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00235">mlir::quant::AnyQuantizedType::verify()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01130">verifyAccessChain()</a>, <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00077">mlir::detail::verifyAffineMapAsLayout()</a>, <a class="el" href="PatternMatch_8h_source.html#l01115">mlir::detail::pdl_function_builder::ProcessDerivedPDLValue&lt; T, BaseT &gt;::verifyAsArg()</a>, <a class="el" href="PatternMatch_8h_source.html#l01080">mlir::detail::pdl_function_builder::ProcessPDLValueBasedOn&lt; T, BaseT &gt;::verifyAsArg()</a>, <a class="el" href="PatternMatch_8h_source.html#l01093">mlir::detail::pdl_function_builder::ProcessBuiltinPDLValue&lt; T &gt;::verifyAsArg()</a>, <a class="el" href="PatternMatch_8h_source.html#l01267">mlir::detail::pdl_function_builder::verifyAsArgs()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01218">verifyAtomicCompareExchangeImpl()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00752">verifyAtomicMemOp()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00105">verifyCompatibleDims()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00059">verifyCompatibleShape()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00096">verifyCompatibleShapes()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00531">mlir::detail::verifyDataLayoutSpec()</a>, <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00100">verifyDependencies()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00616">mlir::LLVM::LLVMStructType::verifyEntries()</a>, <a class="el" href="DataLayoutInterfaces_8h_source.html#l00111">mlir::DataLayoutDialectInterface::verifyEntry()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00958">verifyGroupNonUniformArithmeticOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00395">verifyImageOperands()</a>, <a class="el" href="ExtensibleDialect_8h_source.html#l00477">mlir::DynamicOpDefinition::verifyInherentAttrs()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00827">mlir::OperationName::UnregisteredOpModel::verifyInherentAttrs()</a>, <a class="el" href="OperationSupport_8h_source.html#l00574">mlir::RegisteredOperationName::Model&lt; ConcreteOp &gt;::verifyInherentAttrs()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00797">mlir::OperationName::UnregisteredOpModel::verifyInvariants()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01787">mlir::affine::AffineDmaStartOp::verifyInvariantsImpl()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01901">mlir::affine::AffineDmaWaitOp::verifyInvariantsImpl()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01771">verifyLoopNesting()</a>, <a class="el" href="IR_2Dialect_8h_source.html#l00151">mlir::Dialect::verifyOperationAttribute()</a>, <a class="el" href="VectorOps_8cpp_source.html#l03321">verifyPermutationMap()</a>, <a class="el" href="IR_2Dialect_8cpp_source.html#l00043">mlir::Dialect::verifyRegionArgAttribute()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00959">verifyRegionAttribute()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00801">mlir::OperationName::UnregisteredOpModel::verifyRegionInvariants()</a>, <a class="el" href="IR_2Dialect_8cpp_source.html#l00052">mlir::Dialect::verifyRegionResultAttribute()</a>, <a class="el" href="OpDefinition_8h_source.html#l00210">mlir::OpState::verifyRegions()</a>, <a class="el" href="OpDefinition_8h_source.html#l01632">mlir::op_definition_impl::verifyRegionTrait()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00286">verifyScheduleModifiers()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00657">verifyStructIndices()</a>, <a class="el" href="OpDefinition_8h_source.html#l01613">mlir::op_definition_impl::verifyTrait()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00653">verifyVectorConstructionInvariants()</a>, <a class="el" href="DeadCodeAnalysis_8cpp_source.html#l00219">mlir::dataflow::DeadCodeAnalysis::visit()</a>, and <a class="el" href="BufferDeallocation_8cpp_source.html#l00074">walkReturnOperations()</a>.</p>

</div>
</div>
<a id="a41ccf1eabcff0cf5b0ca167316f18822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ccf1eabcff0cf5b0ca167316f18822">&#9670;&nbsp;</a></span>success() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = std::enable_if_t&lt;!std::is_convertible_v&lt;T, bool&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::success </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap a value on the success path in a <a class="el" href="classmlir_1_1FailureOr.html" title="This class provides support for representing a failure result, or a valid value of type T.">FailureOr</a> of the same value type. </p>

<p class="definition">Definition at line <a class="el" href="LogicalResult_8h_source.html#l00106">106</a> of file <a class="el" href="LogicalResult_8h_source.html">LogicalResult.h</a>.</p>

</div>
</div>
<a id="ae71592b6a57d95558cc2094b140ec445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71592b6a57d95558cc2094b140ec445">&#9670;&nbsp;</a></span>TableGenLspServerMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::TableGenLspServerMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation for tools like <code>tblgen-lsp-server</code>. </p>

<p class="definition">Definition at line <a class="el" href="TableGenLspServerMain_8cpp_source.html#l00020">20</a> of file <a class="el" href="TableGenLspServerMain_8cpp_source.html">TableGenLspServerMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581aa603905470e2a5b8c13e96b579ef0dba">mlir::lsp::Logger::Debug</a>, <a class="el" href="Transport_8h_source.html#l00043">mlir::lsp::Delimited</a>, <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581a902b0d55fddef6f8d651fe1035b7d4bd">mlir::lsp::Logger::Error</a>, <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581a4059b0251f66a18cb56f544728796875">mlir::lsp::Logger::Info</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="tblgen-lsp-server_2LSPServer_8cpp_source.html#l00190">mlir::lsp::runTableGenLSPServer()</a>, <a class="el" href="Logging_8cpp_source.html#l00017">mlir::lsp::Logger::setLogLevel()</a>, and <a class="el" href="Transport_8h_source.html#l00041">mlir::lsp::Standard</a>.</p>

</div>
</div>
<a id="ab15bd4c107bb9ea52b7fcc11c283c129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15bd4c107bb9ea52b7fcc11c283c129">&#9670;&nbsp;</a></span>tile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>, 8 &gt; mlir::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>forOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>targets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs tiling fo imperfectly nested loops (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under each of the <code>targets</code>. </p>
<p>Returns the new AffineForOps, one per each of (<code>forOps</code>, <code>targets</code>) pair, nested immediately under each of <code>targets</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00927">927</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00877">stripmineSink()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00967">extractFixedOuterLoops()</a>, <a class="el" href="Transforms_8cpp_source.html#l01302">mlir::linalg::GeneralizeOuterUnitDimsPackOpPattern::matchAndRewrite()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00940">tile()</a>.</p>

</div>
</div>
<a id="adb3ac25a4d763e0e5234f6b347c7f17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3ac25a4d763e0e5234f6b347c7f17a">&#9670;&nbsp;</a></span>tile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a> mlir::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>forOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs tiling (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under <code>target</code>. </p>
<p>Returns the new AffineForOps, one per <code>forOps</code>, nested immediately under <code>target</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00940">940</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00927">tile()</a>.</p>

</div>
</div>
<a id="a76588ffa46e04caaa584360fa5cdde4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76588ffa46e04caaa584360fa5cdde4c">&#9670;&nbsp;</a></span>tilePerfectlyNested()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a> mlir::tilePerfectlyNested </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>rootForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile a nest of scf::ForOp loops rooted at <code>rootForOp</code> with the given (parametric) sizes. </p>
<p>Sizes are expected to be strictly positive values at runtime. If more sizes than loops are provided, discard the trailing values in sizes. Assumes the loop nest is permutable. Returns the newly created intra-tile loops. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00950">950</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00862">getPerfectlyNestedLoopsImpl()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01625">mlir::affine::tile()</a>.</p>

</div>
</div>
<a id="afbb30909b4006046e7b4248b8d5a5a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb30909b4006046e7b4248b8d5a5a26">&#9670;&nbsp;</a></span>topologicalSort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::topologicalSort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>toSort</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-root DAG topological sort. </p>
<p>Performs a topological sort of the <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> in the <code>toSort</code> SetVector. Returns a topologically sorted SetVector. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00199">199</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00178">dfsPostorder()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00358">promoteSingleIterReductionLoop()</a>.</p>

</div>
</div>
<a id="a23e5dd60111e86e0df4b52a7d3befd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e5dd60111e86e0df4b52a7d3befd33">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef mlir::toString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#ac84871bcca0aaa0176d43dbdbffe9a6c">AsmResourceEntryKind</a>&#160;</td>
          <td class="paramname"><em>kind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l01616">1616</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsmParserImpl_8h_source.html#l00251">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseBase64Bytes()</a>.</p>

</div>
</div>
<a id="a2f93379e5dbb5551bbe57170230a1d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f93379e5dbb5551bbe57170230a1d92">&#9670;&nbsp;</a></span>translateDataLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataLayoutSpecInterface mlir::translateDataLayout </td>
          <td>(</td>
          <td class="paramtype">const llvm::DataLayout &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate the given <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> data layout into an MLIR equivalent using the DLTI dialect. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutImporter_8cpp_source.html#l00309">309</a> of file <a class="el" href="DataLayoutImporter_8cpp_source.html">DataLayoutImporter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutImporter_8h_source.html#l00056">mlir::LLVM::detail::DataLayoutImporter::getDataLayout()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleTranslation_8cpp_source.html#l01296">prepareLLVMModule()</a>.</p>

</div>
</div>
<a id="afc1f3b8cc0f16fa8f9165cce0e5a875b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1f3b8cc0f16fa8f9165cce0e5a875b">&#9670;&nbsp;</a></span>translateLLVMIRToModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt; mlir::translateLLVMIRToModule </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; llvm::Module &gt;&#160;</td>
          <td class="paramname"><em>llvmModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> module into an MLIR module living in the given context. </p>
<p>The translation supports operations from any dialect that has a registered implementation of the <a class="el" href="classmlir_1_1LLVMImportDialectInterface.html" title="Base class for dialect interfaces used to import LLVM IR.">LLVMImportDialectInterface</a>. It returns nullptr if the translation fails and reports errors using the error handler registered with the MLIR context. </p>

<p class="definition">Definition at line <a class="el" href="ModuleImport_8cpp_source.html#l01670">1670</a> of file <a class="el" href="ModuleImport_8cpp_source.html">ModuleImport.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleImport_8cpp_source.html#l00561">mlir::LLVM::ModuleImport::convertDataLayout()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00576">mlir::LLVM::ModuleImport::convertFunctions()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00543">mlir::LLVM::ModuleImport::convertGlobals()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00514">mlir::LLVM::ModuleImport::convertMetadata()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="OwningOpRef_8h_source.html#l00050">mlir::OwningOpRef&lt; OpTy &gt;::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00368">get()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00410">mlir::MLIRContext::getAvailableDialects()</a>, <a class="el" href="ModuleImport_8h_source.html#l00054">mlir::LLVM::ModuleImport::initializeImportInterface()</a>, and <a class="el" href="MLIRContext_8cpp_source.html#l00536">mlir::MLIRContext::loadAllAvailableDialects()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00027">registerFromLLVMIRTranslation()</a>.</p>

</div>
</div>
<a id="adc149979459c3123124db882fb765dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc149979459c3123124db882fb765dba">&#9670;&nbsp;</a></span>translateModuleToLLVMIR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::Module&gt; mlir::translateModuleToLLVMIR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>llvmContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;LLVMDialectModule&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate operation that satisfies <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect module requirements into an <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR module living in the given context. </p>
<p>This translates operations from any dilalect that has a registered implementation of <a class="el" href="classmlir_1_1LLVMTranslationDialectInterface.html" title="Base class for dialect interfaces providing translation to LLVM IR.">LLVMTranslationDialectInterface</a>. </p>

<p class="reference">Referenced by <a class="el" href="ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00226">mlir::ExecutionEngine::create()</a>, and <a class="el" href="SerializeToBlob_8cpp_source.html#l00138">mlir::gpu::SerializeToBlobPass::translateToLLVMIR()</a>.</p>

</div>
</div>
<a id="af6a711d749b7adf4b8d57219d55753c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a711d749b7adf4b8d57219d55753c3">&#9670;&nbsp;</a></span>tryToPromoteMemorySlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::tryToPromoteMemorySlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; PromotableAllocationOpInterface &gt;&#160;</td>
          <td class="paramname"><em>allocators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>dominance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to promote the memory slots of the provided allocators. </p>
<p>Succeeds if at least one memory slot was promoted. </p>

<p class="definition">Definition at line <a class="el" href="Mem2Reg_8cpp_source.html#l00502">502</a> of file <a class="el" href="Mem2Reg_8cpp_source.html">Mem2Reg.cpp</a>.</p>

<p class="reference">References <a class="el" href="Mem2RegInterfaces_8h_source.html#l00021">mlir::MemorySlot::ptr</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">succeeded()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>, and <a class="el" href="Value_8h_source.html#l00207">mlir::Value::use_empty()</a>.</p>

</div>
</div>
<a id="ae4b1ba650fd43b50351e92bbb75bd4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b1ba650fd43b50351e92bbb75bd4c0">&#9670;&nbsp;</a></span>verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verifyRecursively</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform (potentially expensive) checks of invariants, used to detect compiler bugs, on this operation and any nested operations. </p>
<p>On error, this reports the error through the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> and returns failure. If <code>verifyRecursively</code> is false, this assumes that nested operations have already been properly verified, and does not recursively invoke the verifier on nested operations. </p>

<p class="definition">Definition at line <a class="el" href="Verifier_8cpp_source.html#l00374">374</a> of file <a class="el" href="Verifier_8cpp_source.html">Verifier.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="MLIRGen_8cpp_source.html#l00620">mlir::pdll::codegenPDLLToMLIR()</a>, <a class="el" href="StorageUniquerSupport_8h_source.html#l00171">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::get()</a>, <a class="el" href="StorageUniquerSupport_8h_source.html#l00191">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::getChecked()</a>, <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00455">mlir::transform::detail::interpreterBaseInitializeImpl()</a>, <a class="el" href="Tester_8cpp_source.html#l00027">mlir::Tester::isInteresting()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l01140">mlir::detail::Parser::parseStridedLayoutAttr()</a>, <a class="el" href="ExtensibleDialect_8h_source.html#l00400">mlir::DynamicOpDefinition::setVerifyFn()</a>, <a class="el" href="ExtensibleDialect_8h_source.html#l00407">mlir::DynamicOpDefinition::setVerifyRegionFn()</a>, <a class="el" href="RunnerUtils_8h_source.html#l00289">impl::MemRefDataVerifier&lt; T &gt;::verify()</a>, <a class="el" href="MlirOptMain_8h_source.html#l00153">mlir::MlirOptMainConfig::verifyDiagnostics()</a>, and <a class="el" href="MlirOptMain_8h_source.html#l00160">mlir::MlirOptMainConfig::verifyPasses()</a>.</p>

</div>
</div>
<a id="a961cf9926486f7d6e7160efa8f846d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961cf9926486f7d6e7160efa8f846d64">&#9670;&nbsp;</a></span>verifyCompatibleDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verifyCompatibleDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>dims</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dimensions are compatible if all non-dynamic dims are equal. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00105">105</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeUtilities_8cpp_source.html#l00121">verifyCompatibleShapes()</a>.</p>

</div>
</div>
<a id="acb414ad1d507c2ab841305c273f4deb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb414ad1d507c2ab841305c273f4deb8">&#9670;&nbsp;</a></span>verifyCompatibleShape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verifyCompatibleShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if the given two shapes are compatible. </p>
<p>That is, they have the same size and each pair of the elements are equal or one of them is dynamic. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00059">59</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeUtilities_8cpp_source.html#l00078">verifyCompatibleShape()</a>, and <a class="el" href="TypeUtilities_8cpp_source.html#l00096">verifyCompatibleShapes()</a>.</p>

</div>
</div>
<a id="ac54e5e6c31f51ef648f7c03652a29ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54e5e6c31f51ef648f7c03652a29ce6">&#9670;&nbsp;</a></span>verifyCompatibleShape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verifyCompatibleShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if the given two types have compatible shape. </p>
<p>That is, they are both scalars (not shaped), or they are both shaped types and at least one is unranked or they have compatible dimensions. Dimensions are compatible if at least one is dynamic or both are equal. The element type does not matter. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00078">78</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00311">mlir::Type::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>, and <a class="el" href="TypeUtilities_8cpp_source.html#l00059">verifyCompatibleShape()</a>.</p>

</div>
</div>
<a id="a132fff065736d8e977fe8179f2e7086c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132fff065736d8e977fe8179f2e7086c">&#9670;&nbsp;</a></span>verifyCompatibleShapes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verifyCompatibleShapes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if all given types have compatible shapes. </p>
<p>That is, they are all scalars (not shaped), or they are all shaped types and any ranked shapes have compatible dimensions. The element type does not matter.</p>
<p>That is, they are all scalars (not shaped), or they are all shaped types and any ranked shapes have compatible dimensions. Dimensions are compatible if all non-dynamic dims are equal. The element type does not matter. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00121">121</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>, and <a class="el" href="TypeUtilities_8cpp_source.html#l00105">verifyCompatibleDims()</a>.</p>

</div>
</div>
<a id="a2801a1733326688cf0c9bee8d633f234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2801a1733326688cf0c9bee8d633f234">&#9670;&nbsp;</a></span>verifyCompatibleShapes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verifyCompatibleShapes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>types1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>types2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if the given two arrays have the same number of elements and each pair wise entries have compatible shape. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00096">96</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>, and <a class="el" href="TypeUtilities_8cpp_source.html#l00059">verifyCompatibleShape()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithOps_8cpp_source.html#l01121">areValidCastInputsAndOutputs()</a>.</p>

</div>
</div>
<a id="ad1a1c57fc94caa37e2b98499a48eea86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a1c57fc94caa37e2b98499a48eea86">&#9670;&nbsp;</a></span>verifyListOfOperandsOrIntegers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verifyListOfOperandsOrIntegers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>expectedNumElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that a the <code>values</code> has as many elements as the number of entries in <code>attr</code> for which <code>isDynamic</code> evaluates to true. </p>
<p>Include the definitions of the loop-like interfaces. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00020">20</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

</div>
</div>
<a id="ad29ab36fc05840316f3a7e56271818a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29ab36fc05840316f3a7e56271818a6">&#9670;&nbsp;</a></span>verifyReshapeLikeShapes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verifyReshapeLikeShapes </td>
          <td>(</td>
          <td class="paramtype">OpTy&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>collapsedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>expandedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isExpandingReshape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00158">158</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

</div>
</div>
<a id="a59e37ef38e035b072204c4cc6f2bc6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e37ef38e035b072204c4cc6f2bc6a5">&#9670;&nbsp;</a></span>verifyReshapeLikeTypes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verifyReshapeLikeTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Op.html">Op</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>expandedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>collapsedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isExpansion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common verifier for reshape-like types. </p>
<p>Fills <code>expandedType</code> and <code>collapsedType</code> with the proper <code>src</code> or <code>result</code> type. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00105">105</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

</div>
</div>
<a id="a036e7ce3c7c3bf73fc0a653cd98bb7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036e7ce3c7c3bf73fc0a653cd98bb7c0">&#9670;&nbsp;</a></span>visitUsedValuesDefinedAbove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::visitUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <code>callback</code> for each use of a value within any of the regions provided that was defined in one of the ancestors. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00057">57</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00036">visitUsedValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="ae644ec0854505ef60f12c23b96de595b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae644ec0854505ef60f12c23b96de595b">&#9670;&nbsp;</a></span>visitUsedValuesDefinedAbove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::visitUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <code>callback</code> for each use of a value within <code>region</code> or its descendants that was defined at the ancestors of the <code>limit</code>. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00036">36</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8cpp_source.html#l00045">mlir::Region::getParentRegion()</a>, <a class="el" href="IR_2Region_8h_source.html#l00222">mlir::Region::isAncestor()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00279">mlir::Region::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8cpp_source.html#l00063">getUsedValuesDefinedAbove()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00057">visitUsedValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="a655db45ed8c23d04d5ed5ee0abe041ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655db45ed8c23d04d5ed5ee0abe041ad">&#9670;&nbsp;</a></span>wouldOpBeTriviallyDead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::wouldOpBeTriviallyDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the given operation would be dead if unused, and has no side effects on memory that would prevent erasing. </p>
<p>This is equivalent to checking <code>isOpTriviallyDead</code> if <code>op</code> was unused. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00152">152</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

</div>
</div>
<a id="ae17b909cf0c32c717226432e6a65f61e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17b909cf0c32c717226432e6a65f61e">&#9670;&nbsp;</a></span>writeBytecodeToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::writeBytecodeToFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1BytecodeWriterConfig.html">BytecodeWriterConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the bytecode for the given operation to the provided output stream. </p>
<p>For streams where it matters, the given stream should be in "binary" mode. It only ever fails if setDesiredByteCodeVersion can't be honored. </p>

<p class="definition">Definition at line <a class="el" href="BytecodeWriter_8cpp_source.html#l00890">890</a> of file <a class="el" href="BytecodeWriter_8cpp_source.html">BytecodeWriter.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a52f52f0c5e268decd5b4ff95c42ea054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f52f0c5e268decd5b4ff95c42ea054">&#9670;&nbsp;</a></span>has_sub_attr_or_type_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mlir::has_sub_attr_or_type_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    (!llvm::is_detected&lt;detail::has_default_sub_element_handler_t, Ts&gt;::value ||</div>
<div class="line">     ...)</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00317">317</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttrTypeSubElements_8h_source.html#l00451">mlir::detail::replaceImmediateSubElementsImpl()</a>, and <a class="el" href="AttrTypeSubElements_8h_source.html#l00412">mlir::detail::walkImmediateSubElementsImpl()</a>.</p>

</div>
</div>
<a id="a2887883f00b094c5ca61c631d7b093a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2887883f00b094c5ca61c631d7b093a0">&#9670;&nbsp;</a></span>kDeriveIndexBitwidthFromDataLayout</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned mlir::kDeriveIndexBitwidthFromDataLayout = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> to pass as bitwidth for the index type when the converter is expected to derive the bitwidth from the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> data layout. </p>

<p class="definition">Definition at line <a class="el" href="LoweringOptions_8h_source.html#l00026">26</a> of file <a class="el" href="LoweringOptions_8h_source.html">LoweringOptions.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoweringOptions_8h_source.html#l00060">mlir::LowerToLLVMOptions::overrideIndexBitwidth()</a>.</p>

</div>
</div>
<a id="a89827c63faec642164c91b4f8eb0bbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89827c63faec642164c91b4f8eb0bbbb">&#9670;&nbsp;</a></span>kPtrBasePosInDataDescriptor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned mlir::kPtrBasePosInDataDescriptor = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertOpenACCToLLVM_8h_source.html#l00022">22</a> of file <a class="el" href="ConvertOpenACCToLLVM_8h_source.html">ConvertOpenACCToLLVM.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00046">mlir::DataDescriptor::isValid()</a>, and <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00062">mlir::DataDescriptor::setBasePointer()</a>.</p>

</div>
</div>
<a id="a5b10e5f178951c728a16e10de4d038c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b10e5f178951c728a16e10de4d038c0">&#9670;&nbsp;</a></span>kPtrPosInDataDescriptor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned mlir::kPtrPosInDataDescriptor = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertOpenACCToLLVM_8h_source.html#l00023">23</a> of file <a class="el" href="ConvertOpenACCToLLVM_8h_source.html">ConvertOpenACCToLLVM.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00046">mlir::DataDescriptor::isValid()</a>, and <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00068">mlir::DataDescriptor::setPointer()</a>.</p>

</div>
</div>
<a id="a17d7fcc466ac5f8bdada62aa526a821e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d7fcc466ac5f8bdada62aa526a821e">&#9670;&nbsp;</a></span>kSizePosInDataDescriptor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned mlir::kSizePosInDataDescriptor = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertOpenACCToLLVM_8h_source.html#l00024">24</a> of file <a class="el" href="ConvertOpenACCToLLVM_8h_source.html">ConvertOpenACCToLLVM.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00046">mlir::DataDescriptor::isValid()</a>, and <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00073">mlir::DataDescriptor::setSize()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 4 2023 20:34:10 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
