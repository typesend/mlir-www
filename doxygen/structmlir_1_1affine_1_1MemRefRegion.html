<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::affine::MemRefRegion Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">17.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1affine.html">affine</a></li><li class="navelem"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html">MemRefRegion</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structmlir_1_1affine_1_1MemRefRegion-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::affine::MemRefRegion Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A region of a memref's data space; this is typically constructed by analyzing load/store op's on this memref and the index space of loops surrounding such op's.  
 <a href="structmlir_1_1affine_1_1MemRefRegion.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">mlir/Dialect/Affine/Analysis/Utils.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac6d5022fc3e167d5e4f2c9e9c116ae39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#ac6d5022fc3e167d5e4f2c9e9c116ae39">MemRefRegion</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> <a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#aff8b1c63008105dbed4b81d798babf92">loc</a>)</td></tr>
<tr class="separator:ac6d5022fc3e167d5e4f2c9e9c116ae39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13a4a3cfd19b007c475de4f04cfbc6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#ad13a4a3cfd19b007c475de4f04cfbc6a">compute</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, unsigned loopDepth, const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceState=nullptr, bool addMemRefDimBounds=true)</td></tr>
<tr class="memdesc:ad13a4a3cfd19b007c475de4f04cfbc6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the memory region accessed by this memref with the region represented as constraints symbolic/parametric in 'loopDepth' loops surrounding opInst.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#ad13a4a3cfd19b007c475de4f04cfbc6a">More...</a><br /></td></tr>
<tr class="separator:ad13a4a3cfd19b007c475de4f04cfbc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183baa082e4b25b1204cc5f9fa712d5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#a183baa082e4b25b1204cc5f9fa712d5b">getConstraints</a> ()</td></tr>
<tr class="separator:a183baa082e4b25b1204cc5f9fa712d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb1611afca2ff34d88c1c89a08c3497"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#aafb1611afca2ff34d88c1c89a08c3497">getConstraints</a> () const</td></tr>
<tr class="separator:aafb1611afca2ff34d88c1c89a08c3497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4255fd434f5d6dc27bebe8ffe3198dc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#a4255fd434f5d6dc27bebe8ffe3198dc7">isWrite</a> () const</td></tr>
<tr class="separator:a4255fd434f5d6dc27bebe8ffe3198dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0382cfe83a9301c5cc63f73a1a1e8d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#ab0382cfe83a9301c5cc63f73a1a1e8d3">setWrite</a> (bool flag)</td></tr>
<tr class="separator:ab0382cfe83a9301c5cc63f73a1a1e8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2540bedd9c6cfa5bb35b76a3c6e23c"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#a5d2540bedd9c6cfa5bb35b76a3c6e23c">getConstantBoundingSizeAndShape</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *shape=nullptr, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt;&gt; *lbs=nullptr, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *lbDivisors=nullptr) const</td></tr>
<tr class="memdesc:a5d2540bedd9c6cfa5bb35b76a3c6e23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant upper bound on the number of elements in this region if bounded by a known constant (always possible for static shapes), std::nullopt otherwise.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#a5d2540bedd9c6cfa5bb35b76a3c6e23c">More...</a><br /></td></tr>
<tr class="separator:a5d2540bedd9c6cfa5bb35b76a3c6e23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772a10d9c01365d3d3a697f8679e1afc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#a772a10d9c01365d3d3a697f8679e1afc">getLowerAndUpperBound</a> (unsigned pos, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;lbMap, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;ubMap) const</td></tr>
<tr class="memdesc:a772a10d9c01365d3d3a697f8679e1afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lower and upper bound map for the dimensional variable at <code>pos</code>.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#a772a10d9c01365d3d3a697f8679e1afc">More...</a><br /></td></tr>
<tr class="separator:a772a10d9c01365d3d3a697f8679e1afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfd177f379359bc52579c6bec09f581"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#a4dfd177f379359bc52579c6bec09f581">getConstantBoundOnDimSize</a> (unsigned pos, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *lb=nullptr, int64_t *lbFloorDivisor=nullptr) const</td></tr>
<tr class="memdesc:a4dfd177f379359bc52579c6bec09f581"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#abacdef68bce98a75e5f9e8369dbcd018" title="Returns the smallest known constant bound for the extent of the specified variable (pos^th),...">FlatAffineValueConstraints::getConstantBoundOnDimSize()</a>.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#a4dfd177f379359bc52579c6bec09f581">More...</a><br /></td></tr>
<tr class="separator:a4dfd177f379359bc52579c6bec09f581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb53fa6d699f6834738fa2f220ac783"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#a8fb53fa6d699f6834738fa2f220ac783">getRegionSize</a> ()</td></tr>
<tr class="memdesc:a8fb53fa6d699f6834738fa2f220ac783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of this <a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html" title="A region of a memref&#39;s data space; this is typically constructed by analyzing load/store op&#39;s on this...">MemRefRegion</a> in bytes.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#a8fb53fa6d699f6834738fa2f220ac783">More...</a><br /></td></tr>
<tr class="separator:a8fb53fa6d699f6834738fa2f220ac783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2761578967822bb7853e072a1a29bac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#aa2761578967822bb7853e072a1a29bac">unionBoundingBox</a> (const <a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html">MemRefRegion</a> &amp;other)</td></tr>
<tr class="separator:aa2761578967822bb7853e072a1a29bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22317444c57ececdfd0b3f5497d1971c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#a22317444c57ececdfd0b3f5497d1971c">getRank</a> () const</td></tr>
<tr class="memdesc:a22317444c57ececdfd0b3f5497d1971c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank of the memref that this region corresponds to.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#a22317444c57ececdfd0b3f5497d1971c">More...</a><br /></td></tr>
<tr class="separator:a22317444c57ececdfd0b3f5497d1971c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ac097fcae970f4cd44eb14f9484deaf43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#ac097fcae970f4cd44eb14f9484deaf43">memref</a></td></tr>
<tr class="memdesc:ac097fcae970f4cd44eb14f9484deaf43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memref that this region corresponds to.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#ac097fcae970f4cd44eb14f9484deaf43">More...</a><br /></td></tr>
<tr class="separator:ac097fcae970f4cd44eb14f9484deaf43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0de038280a27f97e36f354690dbe15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#aaa0de038280a27f97e36f354690dbe15">write</a> = false</td></tr>
<tr class="memdesc:aaa0de038280a27f97e36f354690dbe15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read or write.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#aaa0de038280a27f97e36f354690dbe15">More...</a><br /></td></tr>
<tr class="separator:aaa0de038280a27f97e36f354690dbe15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8b1c63008105dbed4b81d798babf92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#aff8b1c63008105dbed4b81d798babf92">loc</a></td></tr>
<tr class="memdesc:aff8b1c63008105dbed4b81d798babf92"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there is more than one load/store op associated with the region, the location information would correspond to one of those op's.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#aff8b1c63008105dbed4b81d798babf92">More...</a><br /></td></tr>
<tr class="separator:aff8b1c63008105dbed4b81d798babf92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0ae2cb9072efe63434e12545d10486"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#a3d0ae2cb9072efe63434e12545d10486">cst</a></td></tr>
<tr class="memdesc:a3d0ae2cb9072efe63434e12545d10486"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Region.html" title="This class contains a list of basic blocks and a link to the parent operation it is attached to.">Region</a> (data space) of the memref accessed.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#a3d0ae2cb9072efe63434e12545d10486">More...</a><br /></td></tr>
<tr class="separator:a3d0ae2cb9072efe63434e12545d10486"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A region of a memref's data space; this is typically constructed by analyzing load/store op's on this memref and the index space of loops surrounding such op's. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00432">432</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac6d5022fc3e167d5e4f2c9e9c116ae39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d5022fc3e167d5e4f2c9e9c116ae39">&#9670;&nbsp;</a></span>MemRefRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::affine::MemRefRegion::MemRefRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00433">433</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad13a4a3cfd19b007c475de4f04cfbc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13a4a3cfd19b007c475de4f04cfbc6a">&#9670;&nbsp;</a></span>compute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> MemRefRegion::compute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>loopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *&#160;</td>
          <td class="paramname"><em>sliceState</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addMemRefDimBounds</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the memory region accessed by this memref with the region represented as constraints symbolic/parametric in 'loopDepth' loops surrounding opInst. </p>
<p>Computes the memory region accessed by this memref with the region represented as constraints symbolic/parametric in 'loopDepth' loops surrounding opInst and any additional Function symbols.</p>
<p>The computed region's 'cst' field has exactly as many dimensional variables as the rank of the memref, and <em>potentially</em> additional symbolic variables which could include any of the loop IVs surrounding opInst up until 'loopDepth' and another additional Function symbols involved with the access (for eg., those appear in affine.apply's, loop bounds, etc.). If 'sliceState' is non-null, operands from 'sliceState' are added as symbols, and the following constraints are added to the system: *) Inequality constraints which represent loop bounds for 'sliceState' operands which are loop IVS (these represent the destination loop IVs of the slice, and are added as symbols to <a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html" title="A region of a memref&#39;s data space; this is typically constructed by analyzing load/store op&#39;s on this...">MemRefRegion</a>'s constraint system). *) Inequality constraints for the slice bounds in 'sliceState', which represent the bounds on the loop IVs in this constraint system w.r.t to slice operands (which correspond to symbols). If 'addMemRefDimBounds' is true, constant upper/lower bounds [0, memref.getDimSize(i)) are added for each MemRef dimension 'i'.</p>
<p>For example, the memref region for this operation at loopDepth = 1 will be:</p>
<p>affine.for i = 0 to 32 { affine.for ii = i to (d0) -&gt; (d0 + 8) (i) { load A[ii] } }</p>
<p>{memref = A, write = false, {i &lt;= m0 &lt;= i + 7} } The last field is a 2-d <a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html" title="FlatAffineValueConstraints is an extension of FlatLinearValueConstraints with helper functions for Af...">FlatAffineValueConstraints</a> symbolic in i. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00916">916</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00370">createPrivateMemRef()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l00568">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a5d2540bedd9c6cfa5bb35b76a3c6e23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2540bedd9c6cfa5bb35b76a3c6e23c">&#9670;&nbsp;</a></span>getConstantBoundingSizeAndShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; int64_t &gt; MemRefRegion::getConstantBoundingSizeAndShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>shape</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>lbs</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>lbDivisors</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant upper bound on the number of elements in this region if bounded by a known constant (always possible for static shapes), std::nullopt otherwise. </p>
<p>Note that the symbols of the region are treated specially, i.e., the returned bounding constant holds for <em>any given</em> value of the symbol variables. The 'shape' vector is set to the corresponding dimension-wise bounds major to minor. The number of elements and all the dimension-wise bounds are guaranteed to be non-negative. We use int64_t instead of uint64_t since index types can be at most int64_t. <code>lbs</code> are set to the lower bounds for each of the rank dimensions, and lbDivisors contains the corresponding denominators for floorDivs. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00814">814</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00215">mlir::affine::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00484">mlir::presburger::IntegerRelation::getConstantBoundOnDimSize64()</a>, and <a class="el" href="IntegerRelation_8h_source.html#l00167">mlir::presburger::IntegerRelation::getNumSymbolVars()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00370">createPrivateMemRef()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01971">generateCopy()</a>.</p>

</div>
</div>
<a id="a4dfd177f379359bc52579c6bec09f581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dfd177f379359bc52579c6bec09f581">&#9670;&nbsp;</a></span>getConstantBoundOnDimSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;int64_t&gt; mlir::affine::MemRefRegion::getConstantBoundOnDimSize </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>lb</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>lbFloorDivisor</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper around <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#abacdef68bce98a75e5f9e8369dbcd018" title="Returns the smallest known constant bound for the extent of the specified variable (pos^th),...">FlatAffineValueConstraints::getConstantBoundOnDimSize()</a>. </p>
<p>'pos' corresponds to the position of the memref shape's dimension (major to minor) which matches 1:1 with the dimensional variable positions in 'cst'. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00502">502</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00536">cst</a>, <a class="el" href="IntegerRelation_8h_source.html#l00484">mlir::presburger::IntegerRelation::getConstantBoundOnDimSize64()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00810">getRank()</a>.</p>

</div>
</div>
<a id="a183baa082e4b25b1204cc5f9fa712d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183baa082e4b25b1204cc5f9fa712d5b">&#9670;&nbsp;</a></span>getConstraints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a>* mlir::affine::MemRefRegion::getConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00471">471</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00536">cst</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00370">createPrivateMemRef()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01802">findHighestBlockForPlacement()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01971">generateCopy()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00894">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="aafb1611afca2ff34d88c1c89a08c3497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb1611afca2ff34d88c1c89a08c3497">&#9670;&nbsp;</a></span>getConstraints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a>* mlir::affine::MemRefRegion::getConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00472">472</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00536">cst</a>.</p>

</div>
</div>
<a id="a772a10d9c01365d3d3a697f8679e1afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772a10d9c01365d3d3a697f8679e1afc">&#9670;&nbsp;</a></span>getLowerAndUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemRefRegion::getLowerAndUpperBound </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>lbMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>ubMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the lower and upper bound map for the dimensional variable at <code>pos</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00875">875</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00333">mlir::AffineMap::getNumInputs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01971">generateCopy()</a>.</p>

</div>
</div>
<a id="a22317444c57ececdfd0b3f5497d1971c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22317444c57ececdfd0b3f5497d1971c">&#9670;&nbsp;</a></span>getRank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MemRefRegion::getRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the rank of the memref that this region corresponds to. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00810">810</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00502">getConstantBoundOnDimSize()</a>.</p>

</div>
</div>
<a id="a8fb53fa6d699f6834738fa2f220ac783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb53fa6d699f6834738fa2f220ac783">&#9670;&nbsp;</a></span>getRegionSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; int64_t &gt; MemRefRegion::getRegionSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of this <a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html" title="A region of a memref&#39;s data space; this is typically constructed by analyzing load/store op&#39;s on this...">MemRefRegion</a> in bytes. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01087">1087</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01068">mlir::affine::getMemRefIntOrFloatEltSizeInBytes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00568">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a4255fd434f5d6dc27bebe8ffe3198dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4255fd434f5d6dc27bebe8ffe3198dc7">&#9670;&nbsp;</a></span>isWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::MemRefRegion::isWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00473">473</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00522">write</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01971">generateCopy()</a>.</p>

</div>
</div>
<a id="ab0382cfe83a9301c5cc63f73a1a1e8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0382cfe83a9301c5cc63f73a1a1e8d3">&#9670;&nbsp;</a></span>setWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::MemRefRegion::setWrite </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00474">474</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00522">write</a>.</p>

</div>
</div>
<a id="aa2761578967822bb7853e072a1a29bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2761578967822bb7853e072a1a29bac">&#9670;&nbsp;</a></span>unionBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> MemRefRegion::unionBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html">MemRefRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00894">894</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00471">getConstraints()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00519">memref</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3d0ae2cb9072efe63434e12545d10486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0ae2cb9072efe63434e12545d10486">&#9670;&nbsp;</a></span>cst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> mlir::affine::MemRefRegion::cst</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Region.html" title="This class contains a list of basic blocks and a link to the parent operation it is attached to.">Region</a> (data space) of the memref accessed. </p>
<p>This set will thus have at least as many dimensional variables as the shape dimensionality of the memref, and these are the leading dimensions of the set appearing in that order (major to minor / outermost to innermost). There may be additional variables since getMemRefRegion() is called with a specific loop depth, and thus the region is symbolic in the outer surrounding loops at that depth. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00536">536</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00502">getConstantBoundOnDimSize()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00471">getConstraints()</a>.</p>

</div>
</div>
<a id="aff8b1c63008105dbed4b81d798babf92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8b1c63008105dbed4b81d798babf92">&#9670;&nbsp;</a></span>loc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Location.html">Location</a> mlir::affine::MemRefRegion::loc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If there is more than one load/store op associated with the region, the location information would correspond to one of those op's. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00526">526</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01971">generateCopy()</a>.</p>

</div>
</div>
<a id="ac097fcae970f4cd44eb14f9484deaf43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac097fcae970f4cd44eb14f9484deaf43">&#9670;&nbsp;</a></span>memref</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::affine::MemRefRegion::memref</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memref that this region corresponds to. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00519">519</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01971">generateCopy()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02503">mlir::affine::generateCopyForMemRegion()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01846">getMultiLevelStrides()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00894">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="aaa0de038280a27f97e36f354690dbe15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0de038280a27f97e36f354690dbe15">&#9670;&nbsp;</a></span>write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::MemRefRegion::write = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read or write. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00522">522</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00473">isWrite()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00474">setWrite()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/mlir/Dialect/Affine/Analysis/<a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a></li>
<li>lib/Dialect/Affine/Analysis/<a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 4 2023 20:34:12 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
