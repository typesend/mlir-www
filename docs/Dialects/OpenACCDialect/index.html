<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'acc' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.80.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'acc' Dialect</h1><p>An OpenACC dialect for MLIR.
This dialect models the construct from the OpenACC 3.1 directive language.</p><p><nav id=TableOfContents><ul><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#accattach-mliraccattachop><code>acc.attach</code> (::mlir::acc::AttachOp)</a></li><li><a href=#acccopyin-mliracccopyinop><code>acc.copyin</code> (::mlir::acc::CopyinOp)</a></li><li><a href=#acccopyout-mliracccopyoutop><code>acc.copyout</code> (::mlir::acc::CopyoutOp)</a></li><li><a href=#acccreate-mliracccreateop><code>acc.create</code> (::mlir::acc::CreateOp)</a></li><li><a href=#accbounds-mliraccdataboundsop><code>acc.bounds</code> (::mlir::acc::DataBoundsOp)</a></li><li><a href=#accdata-mliraccdataop><code>acc.data</code> (::mlir::acc::DataOp)</a></li><li><a href=#accdelete-mliraccdeleteop><code>acc.delete</code> (::mlir::acc::DeleteOp)</a></li><li><a href=#accdetach-mliraccdetachop><code>acc.detach</code> (::mlir::acc::DetachOp)</a></li><li><a href=#accdeviceptr-mliraccdeviceptrop><code>acc.deviceptr</code> (::mlir::acc::DevicePtrOp)</a></li><li><a href=#accenter_data-mliraccenterdataop><code>acc.enter_data</code> (::mlir::acc::EnterDataOp)</a></li><li><a href=#accexit_data-mliraccexitdataop><code>acc.exit_data</code> (::mlir::acc::ExitDataOp)</a></li><li><a href=#accgetdeviceptr-mliraccgetdeviceptrop><code>acc.getdeviceptr</code> (::mlir::acc::GetDevicePtrOp)</a></li><li><a href=#accinit-mliraccinitop><code>acc.init</code> (::mlir::acc::InitOp)</a></li><li><a href=#acckernels-mliracckernelsop><code>acc.kernels</code> (::mlir::acc::KernelsOp)</a></li><li><a href=#accloop-mliraccloopop><code>acc.loop</code> (::mlir::acc::LoopOp)</a></li><li><a href=#accnocreate-mliraccnocreateop><code>acc.nocreate</code> (::mlir::acc::NoCreateOp)</a></li><li><a href=#accparallel-mliraccparallelop><code>acc.parallel</code> (::mlir::acc::ParallelOp)</a></li><li><a href=#accpresent-mliraccpresentop><code>acc.present</code> (::mlir::acc::PresentOp)</a></li><li><a href=#accserial-mliraccserialop><code>acc.serial</code> (::mlir::acc::SerialOp)</a></li><li><a href=#accshutdown-mliraccshutdownop><code>acc.shutdown</code> (::mlir::acc::ShutdownOp)</a></li><li><a href=#accterminator-mliraccterminatorop><code>acc.terminator</code> (::mlir::acc::TerminatorOp)</a></li><li><a href=#accupdate-mliraccupdateop><code>acc.update</code> (::mlir::acc::UpdateOp)</a></li><li><a href=#accwait-mliraccwaitop><code>acc.wait</code> (::mlir::acc::WaitOp)</a></li><li><a href=#accyield-mliraccyieldop><code>acc.yield</code> (::mlir::acc::YieldOp)</a></li></ul></li><li><a href=#attribute-definition>Attribute definition</a><ul><li><a href=#clausedefaultvalueattr>ClauseDefaultValueAttr</a></li><li><a href=#reductionopattr>ReductionOpAttr</a></li></ul></li><li><a href=#type-definition>Type definition</a><ul><li><a href=#databoundstype>DataBoundsType</a></li></ul></li></ul></nav><h2 id=operation-definition>Operation definition&nbsp;<a class=headline-hash href=#operation-definition>¶</a></h2><h3 id=accattach-mliraccattachop><code>acc.attach</code> (::mlir::acc::AttachOp)&nbsp;<a class=headline-hash href=#accattach-mliraccattachop>¶</a></h3><p>Represents acc attach semantics which updates a pointer in device memory with the corresponding device address of the pointee.</p><p>Syntax:</p><pre><code>operation ::= `acc.attach` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dataClause</code></td><td style=text-align:center>::mlir::acc::DataClauseAttr</td><td>data clauses supported by OpenACC</td></tr><tr><td style=text-align:center><code>structured</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>implicit</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=acccopyin-mliracccopyinop><code>acc.copyin</code> (::mlir::acc::CopyinOp)&nbsp;<a class=headline-hash href=#acccopyin-mliracccopyinop>¶</a></h3><p>Represents copyin semantics for acc data clauses like acc copyin and acc copy.</p><p>Syntax:</p><pre><code>operation ::= `acc.copyin` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dataClause</code></td><td style=text-align:center>::mlir::acc::DataClauseAttr</td><td>data clauses supported by OpenACC</td></tr><tr><td style=text-align:center><code>structured</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>implicit</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=acccopyout-mliracccopyoutop><code>acc.copyout</code> (::mlir::acc::CopyoutOp)&nbsp;<a class=headline-hash href=#acccopyout-mliracccopyoutop>¶</a></h3><p>Represents acc copyout semantics - reverse of copyin.</p><p>Syntax:</p><pre><code>operation ::= `acc.copyout` `accPtr` `(` $accPtr `:` type($accPtr) `)`
              oilist(
              `bounds` `(` $bounds `)`
              | `to` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              ) attr-dict
</code></pre><ul><li><code>varPtr</code>: The address of variable to copy back to. This only applies to
<code>acc.copyout</code></li><li><code>accPtr</code>: The acc address of variable. This is the link from the data-entry
operation used.</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dataClause</code></td><td style=text-align:center>::mlir::acc::DataClauseAttr</td><td>data clauses supported by OpenACC</td></tr><tr><td style=text-align:center><code>structured</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>implicit</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>Type for representing acc data clause bounds information</td></tr></tbody></table><h3 id=acccreate-mliracccreateop><code>acc.create</code> (::mlir::acc::CreateOp)&nbsp;<a class=headline-hash href=#acccreate-mliracccreateop>¶</a></h3><p>Represents create semantics for acc data clauses like acc create and acc copyout.</p><p>Syntax:</p><pre><code>operation ::= `acc.create` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dataClause</code></td><td style=text-align:center>::mlir::acc::DataClauseAttr</td><td>data clauses supported by OpenACC</td></tr><tr><td style=text-align:center><code>structured</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>implicit</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accbounds-mliraccdataboundsop><code>acc.bounds</code> (::mlir::acc::DataBoundsOp)&nbsp;<a class=headline-hash href=#accbounds-mliraccdataboundsop>¶</a></h3><p>Represents normalized bounds information for acc data clause.</p><p>Syntax:</p><pre><code>operation ::= `acc.bounds` oilist(
              `lowerbound` `(` $lowerbound `:` type($lowerbound) `)`
              | `upperbound` `(` $upperbound `:` type($upperbound) `)`
              | `extent` `(` $extent `:` type($extent) `)`
              | `stride` `(` $stride `:` type($stride) `)`
              | `startIdx` `(` $startIdx `:` type($startIdx) `)`
              ) attr-dict
</code></pre><p>This operation is used to record bounds used in acc data clause in a
normalized fashion (zero-based). This works well with the <code>PointerLikeType</code>
requirement in data clauses - since a <code>lowerbound</code> of 0 means looking
at data at the zero offset from pointer.</p><p>The operation must have an <code>upperbound</code> or <code>extent</code> (or both are allowed -
but not checked for consistency). When the source language&rsquo;s arrays are
not zero-based, the <code>startIdx</code> must specify the zero-position index.</p><p>Examples below show copying a slice of 10-element array except first element.
Note that the examples use extent in data clause for C++ and upperbound
for Fortran (as per 2.7.1). To simplify examples, the constants are used
directly in the acc.bounds operands - this is not the syntax of operation.</p><p>C++:</p><pre><code>int array[10];
#pragma acc copy(array[1:9])
</code></pre><p>=></p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>acc<span class=p>.</span>bounds lb<span class=p>(</span><span class=m>1</span><span class=p>)</span> ub<span class=p>(</span><span class=m>9</span><span class=p>)</span> extent<span class=p>(</span><span class=m>9</span><span class=p>)</span> startIdx<span class=p>(</span><span class=m>0</span><span class=p>)</span>
</code></pre></div><p>Fortran:</p><pre><code>integer :: array(1:10)
!$acc copy(array(2:10))
</code></pre><p>=></p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>acc<span class=p>.</span>bounds lb<span class=p>(</span><span class=m>1</span><span class=p>)</span> ub<span class=p>(</span><span class=m>9</span><span class=p>)</span> extent<span class=p>(</span><span class=m>9</span><span class=p>)</span> startIdx<span class=p>(</span><span class=m>1</span><span class=p>)</span>
</code></pre></div><p>Traits: AttrSizedOperandSegments</p><p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>strideInBytes</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr></tbody></table><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lowerbound</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>upperbound</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>extent</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>stride</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>startIdx</code></td><td>integer or index</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>Type for representing acc data clause bounds information</td></tr></tbody></table><h3 id=accdata-mliraccdataop><code>acc.data</code> (::mlir::acc::DataOp)&nbsp;<a class=headline-hash href=#accdata-mliraccdataop>¶</a></h3><p>data construct</p><p>Syntax:</p><pre><code>operation ::= `acc.data` oilist(
              `if` `(` $ifCond `)`
              | `dataOperands` `(` $dataClauseOperands `:` type($dataClauseOperands) `)`
              | `copy` `(` $copyOperands `:` type($copyOperands) `)`
              | `copyin` `(` $copyinOperands `:` type($copyinOperands) `)`
              | `copyin_readonly` `(` $copyinReadonlyOperands `:`
              type($copyinReadonlyOperands) `)`
              | `copyout` `(` $copyoutOperands `:` type($copyoutOperands) `)`
              | `copyout_zero` `(` $copyoutZeroOperands `:`
              type($copyoutZeroOperands) `)`
              | `create` `(` $createOperands `:` type($createOperands) `)`
              | `create_zero` `(` $createZeroOperands `:`
              type($createZeroOperands) `)`
              | `no_create` `(` $noCreateOperands `:` type($noCreateOperands) `)`
              | `present` `(` $presentOperands `:` type($presentOperands) `)`
              | `deviceptr` `(` $deviceptrOperands `:` type($deviceptrOperands) `)`
              | `attach` `(` $attachOperands `:` type($attachOperands) `)`
              )
              $region attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.data&rdquo; operation represents a data construct. It defines vars to
be allocated in the current device memory for the duration of the region,
whether data should be copied from local memory to the current device
memory upon region entry , and copied from device memory to local memory
upon region exit.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>acc<span class=p>.</span>data present<span class=p>(</span><span class=nv>%a</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x10x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=nv>%b</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x10x</span><span class=k>f32</span><span class=p>&gt;,</span>
    <span class=nv>%c</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=nv>%d</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>{</span>
  <span class=c>// data region
</span><span class=c></span><span class=p>}</span>
</code></pre></div><p>Traits: AttrSizedOperandSegments, RecursiveMemoryEffects</p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>defaultAttr</code></td><td style=text-align:center>::mlir::acc::ClauseDefaultValueAttr</td><td>DefaultValue Clause</td></tr></tbody></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>copyOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>copyinOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>copyinReadonlyOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>copyoutOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>copyoutZeroOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>createOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>createZeroOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>noCreateOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>presentOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>deviceptrOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>attachOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>dataClauseOperands</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accdelete-mliraccdeleteop><code>acc.delete</code> (::mlir::acc::DeleteOp)&nbsp;<a class=headline-hash href=#accdelete-mliraccdeleteop>¶</a></h3><p>Represents acc delete semantics - reverse of create.</p><p>Syntax:</p><pre><code>operation ::= `acc.delete` `accPtr` `(` $accPtr `:` type($accPtr) `)`
              oilist(
              `bounds` `(` $bounds `)`
              | `to` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              ) attr-dict
</code></pre><ul><li><code>varPtr</code>: The address of variable to copy back to. This only applies to
<code>acc.copyout</code></li><li><code>accPtr</code>: The acc address of variable. This is the link from the data-entry
operation used.</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dataClause</code></td><td style=text-align:center>::mlir::acc::DataClauseAttr</td><td>data clauses supported by OpenACC</td></tr><tr><td style=text-align:center><code>structured</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>implicit</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>Type for representing acc data clause bounds information</td></tr></tbody></table><h3 id=accdetach-mliraccdetachop><code>acc.detach</code> (::mlir::acc::DetachOp)&nbsp;<a class=headline-hash href=#accdetach-mliraccdetachop>¶</a></h3><p>Represents acc detach semantics - reverse of attach.</p><p>Syntax:</p><pre><code>operation ::= `acc.detach` `accPtr` `(` $accPtr `:` type($accPtr) `)`
              oilist(
              `bounds` `(` $bounds `)`
              | `to` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              ) attr-dict
</code></pre><ul><li><code>varPtr</code>: The address of variable to copy back to. This only applies to
<code>acc.copyout</code></li><li><code>accPtr</code>: The acc address of variable. This is the link from the data-entry
operation used.</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dataClause</code></td><td style=text-align:center>::mlir::acc::DataClauseAttr</td><td>data clauses supported by OpenACC</td></tr><tr><td style=text-align:center><code>structured</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>implicit</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>Type for representing acc data clause bounds information</td></tr></tbody></table><h3 id=accdeviceptr-mliraccdeviceptrop><code>acc.deviceptr</code> (::mlir::acc::DevicePtrOp)&nbsp;<a class=headline-hash href=#accdeviceptr-mliraccdeviceptrop>¶</a></h3><p>Specifies that the variable pointer is a device pointer.</p><p>Syntax:</p><pre><code>operation ::= `acc.deviceptr` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dataClause</code></td><td style=text-align:center>::mlir::acc::DataClauseAttr</td><td>data clauses supported by OpenACC</td></tr><tr><td style=text-align:center><code>structured</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>implicit</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accenter_data-mliraccenterdataop><code>acc.enter_data</code> (::mlir::acc::EnterDataOp)&nbsp;<a class=headline-hash href=#accenter_data-mliraccenterdataop>¶</a></h3><p>enter data operation</p><p>Syntax:</p><pre><code>operation ::= `acc.enter_data` oilist(
              `if` `(` $ifCond `)`
              | `async` `(` $asyncOperand `:` type($asyncOperand) `)`
              | `wait_devnum` `(` $waitDevnum `:` type($waitDevnum) `)`
              | `wait` `(` $waitOperands `:` type($waitOperands) `)`
              | `copyin` `(` $copyinOperands `:` type($copyinOperands) `)`
              | `create` `(` $createOperands `:` type($createOperands) `)`
              | `create_zero` `(` $createZeroOperands `:`
              type($createZeroOperands) `)`
              | `attach` `(` $attachOperands `:` type($attachOperands) `)`
              | `dataOperands` `(` $dataClauseOperands `:` type($dataClauseOperands) `)`
              )
              attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.enter_data&rdquo; operation represents the OpenACC enter data directive.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>acc<span class=p>.</span>enter_data create<span class=p>(</span><span class=nv>%d1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;)</span> attributes <span class=p>{</span>async<span class=p>}</span>
</code></pre></div><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>async</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>wait</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>asyncOperand</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitDevnum</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitOperands</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>copyinOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>createOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>createZeroOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>attachOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>dataClauseOperands</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accexit_data-mliraccexitdataop><code>acc.exit_data</code> (::mlir::acc::ExitDataOp)&nbsp;<a class=headline-hash href=#accexit_data-mliraccexitdataop>¶</a></h3><p>exit data operation</p><p>Syntax:</p><pre><code>operation ::= `acc.exit_data` oilist(
              `if` `(` $ifCond `)`
              | `async` `(` $asyncOperand `:` type($asyncOperand) `)`
              | `wait_devnum` `(` $waitDevnum `:` type($waitDevnum) `)`
              | `wait` `(` $waitOperands `:` type($waitOperands) `)`
              | `copyout` `(` $copyoutOperands `:` type($copyoutOperands) `)`
              | `delete` `(` $deleteOperands `:` type($deleteOperands) `)`
              | `detach` `(` $detachOperands `:` type($detachOperands) `)`
              | `dataOperands` `(` $dataClauseOperands `:` type($dataClauseOperands) `)`
              )
              attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.exit_data&rdquo; operation represents the OpenACC exit data directive.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>acc<span class=p>.</span>exit_data delete<span class=p>(</span><span class=nv>%d1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;)</span> attributes <span class=p>{</span>async<span class=p>}</span>
</code></pre></div><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>async</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>wait</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>finalize</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>asyncOperand</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitDevnum</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitOperands</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>copyoutOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>deleteOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>detachOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>dataClauseOperands</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accgetdeviceptr-mliraccgetdeviceptrop><code>acc.getdeviceptr</code> (::mlir::acc::GetDevicePtrOp)&nbsp;<a class=headline-hash href=#accgetdeviceptr-mliraccgetdeviceptrop>¶</a></h3><p>Gets device address from host address if it exists on device.</p><p>Syntax:</p><pre><code>operation ::= `acc.getdeviceptr` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dataClause</code></td><td style=text-align:center>::mlir::acc::DataClauseAttr</td><td>data clauses supported by OpenACC</td></tr><tr><td style=text-align:center><code>structured</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>implicit</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accinit-mliraccinitop><code>acc.init</code> (::mlir::acc::InitOp)&nbsp;<a class=headline-hash href=#accinit-mliraccinitop>¶</a></h3><p>init operation</p><p>Syntax:</p><pre><code>operation ::= `acc.init` oilist(
              `device_type` `(` $deviceTypeOperands `:` type($deviceTypeOperands) `)`
              | `device_num` `(` $deviceNumOperand `:` type($deviceNumOperand) `)`
              | `if` `(` $ifCond `)`
              ) attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.init&rdquo; operation represents the OpenACC init executable
directive.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>acc<span class=p>.</span>init
acc<span class=p>.</span>init device_num<span class=p>(</span><span class=nv>%dev1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
</code></pre></div><p>Traits: AttrSizedOperandSegments</p><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>deviceTypeOperands</code></td><td>integer</td></tr><tr><td style=text-align:center><code>deviceNumOperand</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=acckernels-mliracckernelsop><code>acc.kernels</code> (::mlir::acc::KernelsOp)&nbsp;<a class=headline-hash href=#acckernels-mliracckernelsop>¶</a></h3><p>kernels construct</p><p>Syntax:</p><pre><code>operation ::= `acc.kernels` oilist(
              `dataOperands` `(` $dataClauseOperands `:` type($dataClauseOperands) `)`
              | `attach` `(` $attachOperands `:` type($attachOperands) `)`
              | `async` `(` $async `:` type($async) `)`
              | `copy` `(` $copyOperands `:` type($copyOperands) `)`
              | `copyin` `(` $copyinOperands `:` type($copyinOperands) `)`
              | `copyin_readonly` `(` $copyinReadonlyOperands `:`
              type($copyinReadonlyOperands) `)`
              | `copyout` `(` $copyoutOperands `:` type($copyoutOperands) `)`
              | `copyout_zero` `(` $copyoutZeroOperands `:`
              type($copyoutZeroOperands) `)`
              | `create` `(` $createOperands `:` type($createOperands) `)`
              | `create_zero` `(` $createZeroOperands `:` type($createZeroOperands) `)`
              | `deviceptr` `(` $devicePtrOperands `:` type($devicePtrOperands) `)`
              | `no_create` `(` $noCreateOperands `:` type($noCreateOperands) `)`
              | `num_gangs` `(` $numGangs `:` type($numGangs) `)`
              | `num_workers` `(` $numWorkers `:` type($numWorkers) `)`
              | `present` `(` $presentOperands `:` type($presentOperands) `)`
              | `vector_length` `(` $vectorLength `:` type($vectorLength) `)`
              | `wait` `(` $waitOperands `:` type($waitOperands) `)`
              | `self` `(` $selfCond `)`
              | `if` `(` $ifCond `)`
              )
              $region attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.kernels&rdquo; operation represents a kernels construct block. It has
one region to be compiled into a sequence of kernels for execution on the
current device.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>acc<span class=p>.</span>kernels num_gangs<span class=p>(</span><span class=nv>%c10</span><span class=p>)</span> num_workers<span class=p>(</span><span class=nv>%c10</span><span class=p>)</span>
    private<span class=p>(</span><span class=nv>%c</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>{</span>
  <span class=c>// kernels region
</span><span class=c></span><span class=p>}</span>
</code></pre></div><p>Traits: AttrSizedOperandSegments, RecursiveMemoryEffects</p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncAttr</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>waitAttr</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>selfAttr</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>defaultAttr</code></td><td style=text-align:center>::mlir::acc::ClauseDefaultValueAttr</td><td>DefaultValue Clause</td></tr></tbody></table><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>async</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitOperands</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>numGangs</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>numWorkers</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>vectorLength</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>selfCond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>copyOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>copyinOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>copyinReadonlyOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>copyoutOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>copyoutZeroOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>createOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>createZeroOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>noCreateOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>presentOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>devicePtrOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>attachOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>dataClauseOperands</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accloop-mliraccloopop><code>acc.loop</code> (::mlir::acc::LoopOp)&nbsp;<a class=headline-hash href=#accloop-mliraccloopop>¶</a></h3><p>loop construct</p><p>Syntax:</p><pre><code>operation ::= `acc.loop` oilist(
              `gang` `` custom&lt;GangClause&gt;($gangNum, type($gangNum), $gangStatic, type($gangStatic), $hasGang)
              | `worker` `` custom&lt;WorkerClause&gt;($workerNum, type($workerNum), $hasWorker)
              | `vector` `` custom&lt;VectorClause&gt;($vectorLength, type($vectorLength), $hasVector)
              | `private` `(` $privateOperands `:` type($privateOperands) `)`
              | `tile` `(` $tileOperands `:` type($tileOperands) `)`
              | `reduction` `(` $reductionOperands `:` type($reductionOperands) `)`
              )
              $region
              ( `(` type($results)^ `)` )?
              attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.loop&rdquo; operation represents the OpenACC loop construct.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>acc<span class=p>.</span>loop gang <span class=kt>vector</span> <span class=p>{</span>
  scf<span class=p>.</span>for <span class=nv>%arg3</span> <span class=p>=</span> <span class=nv>%c0</span> to <span class=nv>%c10</span> step <span class=nv>%c1</span> <span class=p>{</span>
    scf<span class=p>.</span>for <span class=nv>%arg4</span> <span class=p>=</span> <span class=nv>%c0</span> to <span class=nv>%c10</span> step <span class=nv>%c1</span> <span class=p>{</span>
      scf<span class=p>.</span>for <span class=nv>%arg5</span> <span class=p>=</span> <span class=nv>%c0</span> to <span class=nv>%c10</span> step <span class=nv>%c1</span> <span class=p>{</span>
        <span class=c>// ... body
</span><span class=c></span>      <span class=p>}</span>
    <span class=p>}</span>
  <span class=p>}</span>
  acc<span class=p>.</span>yield
<span class=p>}</span> attributes <span class=p>{</span> <span class=nl>collapse =</span> <span class=m>3</span> <span class=p>}</span>
</code></pre></div><p>Traits: AttrSizedOperandSegments, RecursiveMemoryEffects</p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>collapse</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td style=text-align:center><code>seq</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>independent</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>auto_</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>hasGang</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>hasWorker</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>hasVector</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>reductionOp</code></td><td style=text-align:center>::mlir::acc::ReductionOpAttr</td><td>built-in reduction operations supported by OpenACC</td></tr></tbody></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>gangNum</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>gangStatic</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>workerNum</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>vectorLength</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>tileOperands</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>privateOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>reductionOperands</code></td><td>any type</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>any type</td></tr></tbody></table><h3 id=accnocreate-mliraccnocreateop><code>acc.nocreate</code> (::mlir::acc::NoCreateOp)&nbsp;<a class=headline-hash href=#accnocreate-mliraccnocreateop>¶</a></h3><p>Represents acc no_create semantics.</p><p>Syntax:</p><pre><code>operation ::= `acc.nocreate` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dataClause</code></td><td style=text-align:center>::mlir::acc::DataClauseAttr</td><td>data clauses supported by OpenACC</td></tr><tr><td style=text-align:center><code>structured</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>implicit</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accparallel-mliraccparallelop><code>acc.parallel</code> (::mlir::acc::ParallelOp)&nbsp;<a class=headline-hash href=#accparallel-mliraccparallelop>¶</a></h3><p>parallel construct</p><p>Syntax:</p><pre><code>operation ::= `acc.parallel` oilist(
              `dataOperands` `(` $dataClauseOperands `:` type($dataClauseOperands) `)`
              | `attach` `(` $attachOperands `:` type($attachOperands) `)`
              | `async` `(` $async `:` type($async) `)`
              | `copy` `(` $copyOperands `:` type($copyOperands) `)`
              | `copyin` `(` $copyinOperands `:` type($copyinOperands) `)`
              | `copyin_readonly` `(` $copyinReadonlyOperands `:`
              type($copyinReadonlyOperands) `)`
              | `copyout` `(` $copyoutOperands `:` type($copyoutOperands) `)`
              | `copyout_zero` `(` $copyoutZeroOperands `:`
              type($copyoutZeroOperands) `)`
              | `create` `(` $createOperands `:` type($createOperands) `)`
              | `create_zero` `(` $createZeroOperands `:`
              type($createZeroOperands) `)`
              | `deviceptr` `(` $devicePtrOperands `:` type($devicePtrOperands) `)`
              | `firstprivate` `(` $gangFirstPrivateOperands `:`
              type($gangFirstPrivateOperands) `)`
              | `no_create` `(` $noCreateOperands `:` type($noCreateOperands) `)`
              | `num_gangs` `(` $numGangs `:` type($numGangs) `)`
              | `num_workers` `(` $numWorkers `:` type($numWorkers) `)`
              | `private` `(` $gangPrivateOperands `:` type($gangPrivateOperands) `)`
              | `present` `(` $presentOperands `:` type($presentOperands) `)`
              | `vector_length` `(` $vectorLength `:` type($vectorLength) `)`
              | `wait` `(` $waitOperands `:` type($waitOperands) `)`
              | `self` `(` $selfCond `)`
              | `if` `(` $ifCond `)`
              | `reduction` `(` $reductionOperands `:` type($reductionOperands) `)`
              )
              $region attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.parallel&rdquo; operation represents a parallel construct block. It has
one region to be executed in parallel on the current device.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>acc<span class=p>.</span>parallel num_gangs<span class=p>(</span><span class=nv>%c10</span><span class=p>)</span> num_workers<span class=p>(</span><span class=nv>%c10</span><span class=p>)</span>
    private<span class=p>(</span><span class=nv>%c</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>{</span>
  <span class=c>// parallel region
</span><span class=c></span><span class=p>}</span>
</code></pre></div><p>Traits: AttrSizedOperandSegments, RecursiveMemoryEffects</p><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncAttr</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>waitAttr</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>selfAttr</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>reductionOp</code></td><td style=text-align:center>::mlir::acc::ReductionOpAttr</td><td>built-in reduction operations supported by OpenACC</td></tr><tr><td style=text-align:center><code>defaultAttr</code></td><td style=text-align:center>::mlir::acc::ClauseDefaultValueAttr</td><td>DefaultValue Clause</td></tr></tbody></table><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>async</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitOperands</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>numGangs</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>numWorkers</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>vectorLength</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>selfCond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>reductionOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>copyOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>copyinOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>copyinReadonlyOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>copyoutOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>copyoutZeroOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>createOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>createZeroOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>noCreateOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>presentOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>devicePtrOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>attachOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>gangPrivateOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>gangFirstPrivateOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>dataClauseOperands</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accpresent-mliraccpresentop><code>acc.present</code> (::mlir::acc::PresentOp)&nbsp;<a class=headline-hash href=#accpresent-mliraccpresentop>¶</a></h3><p>Specifies that the variable is already present on device.</p><p>Syntax:</p><pre><code>operation ::= `acc.present` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dataClause</code></td><td style=text-align:center>::mlir::acc::DataClauseAttr</td><td>data clauses supported by OpenACC</td></tr><tr><td style=text-align:center><code>structured</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>implicit</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accserial-mliraccserialop><code>acc.serial</code> (::mlir::acc::SerialOp)&nbsp;<a class=headline-hash href=#accserial-mliraccserialop>¶</a></h3><p>serial construct</p><p>Syntax:</p><pre><code>operation ::= `acc.serial` oilist(
              `dataOperands` `(` $dataClauseOperands `:` type($dataClauseOperands) `)`
              | `attach` `(` $attachOperands `:` type($attachOperands) `)`
              | `async` `(` $async `:` type($async) `)`
              | `copy` `(` $copyOperands `:` type($copyOperands) `)`
              | `copyin` `(` $copyinOperands `:` type($copyinOperands) `)`
              | `copyin_readonly` `(` $copyinReadonlyOperands `:`
              type($copyinReadonlyOperands) `)`
              | `copyout` `(` $copyoutOperands `:` type($copyoutOperands) `)`
              | `copyout_zero` `(` $copyoutZeroOperands `:`
              type($copyoutZeroOperands) `)`
              | `create` `(` $createOperands `:` type($createOperands) `)`
              | `create_zero` `(` $createZeroOperands `:`
              type($createZeroOperands) `)`
              | `deviceptr` `(` $devicePtrOperands `:` type($devicePtrOperands) `)`
              | `firstprivate` `(` $gangFirstPrivateOperands `:`
              type($gangFirstPrivateOperands) `)`
              | `no_create` `(` $noCreateOperands `:` type($noCreateOperands) `)`
              | `private` `(` $gangPrivateOperands `:` type($gangPrivateOperands) `)`
              | `present` `(` $presentOperands `:` type($presentOperands) `)`
              | `wait` `(` $waitOperands `:` type($waitOperands) `)`
              | `self` `(` $selfCond `)`
              | `if` `(` $ifCond `)`
              | `reduction` `(` $reductionOperands `:` type($reductionOperands) `)`
              )
              $region attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.serial&rdquo; operation represents a serial construct block. It has
one region to be executed in serial on the current device.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>acc<span class=p>.</span>serial private<span class=p>(</span><span class=nv>%c</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>{</span>
  <span class=c>// serial region
</span><span class=c></span><span class=p>}</span>
</code></pre></div><p>Traits: AttrSizedOperandSegments, RecursiveMemoryEffects</p><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncAttr</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>waitAttr</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>selfAttr</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>reductionOp</code></td><td style=text-align:center>::mlir::acc::ReductionOpAttr</td><td>built-in reduction operations supported by OpenACC</td></tr><tr><td style=text-align:center><code>defaultAttr</code></td><td style=text-align:center>::mlir::acc::ClauseDefaultValueAttr</td><td>DefaultValue Clause</td></tr></tbody></table><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>async</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitOperands</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>selfCond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>reductionOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>copyOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>copyinOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>copyinReadonlyOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>copyoutOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>copyoutZeroOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>createOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>createZeroOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>noCreateOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>presentOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>devicePtrOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>attachOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>gangPrivateOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>gangFirstPrivateOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>dataClauseOperands</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accshutdown-mliraccshutdownop><code>acc.shutdown</code> (::mlir::acc::ShutdownOp)&nbsp;<a class=headline-hash href=#accshutdown-mliraccshutdownop>¶</a></h3><p>shutdown operation</p><p>Syntax:</p><pre><code>operation ::= `acc.shutdown` oilist(`device_type` `(` $deviceTypeOperands `:` type($deviceTypeOperands) `)`
              |`device_num` `(` $deviceNumOperand `:` type($deviceNumOperand) `)`
              |`if` `(` $ifCond `)`
              ) attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.shutdown&rdquo; operation represents the OpenACC shutdown executable
directive.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>acc<span class=p>.</span>shutdown
acc<span class=p>.</span>shutdown device_num<span class=p>(</span><span class=nv>%dev1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
</code></pre></div><p>Traits: AttrSizedOperandSegments</p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>deviceTypeOperands</code></td><td>integer</td></tr><tr><td style=text-align:center><code>deviceNumOperand</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=accterminator-mliraccterminatorop><code>acc.terminator</code> (::mlir::acc::TerminatorOp)&nbsp;<a class=headline-hash href=#accterminator-mliraccterminatorop>¶</a></h3><p>Generic terminator for OpenACC regions</p><p>Syntax:</p><pre><code>operation ::= `acc.terminator` attr-dict
</code></pre><p>A terminator operation for regions that appear in the body of OpenACC
operation. Generic OpenACC construct regions are not expected to return any
value so the terminator takes no operands. The terminator op returns control
to the enclosing op.</p><p>Traits: Terminator</p><h3 id=accupdate-mliraccupdateop><code>acc.update</code> (::mlir::acc::UpdateOp)&nbsp;<a class=headline-hash href=#accupdate-mliraccupdateop>¶</a></h3><p>update operation</p><p>Syntax:</p><pre><code>operation ::= `acc.update` oilist(
              `if` `(` $ifCond `)`
              | `async` `(` $asyncOperand `:` type($asyncOperand) `)`
              | `wait_devnum` `(` $waitDevnum `:` type($waitDevnum) `)`
              | `device_type` `(` $deviceTypeOperands `:`
              type($deviceTypeOperands) `)`
              | `wait` `(` $waitOperands `:` type($waitOperands) `)`
              | `host` `(` $hostOperands `:` type($hostOperands) `)`
              | `device` `(` $deviceOperands `:` type($deviceOperands) `)`
              )
              attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.udpate&rdquo; operation represents the OpenACC update executable
directive.
As host and self clauses are synonyms, any operands for host and self are
add to $hostOperands.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>acc<span class=p>.</span>update device<span class=p>(</span><span class=nv>%d1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;)</span> attributes <span class=p>{</span>async<span class=p>}</span>
</code></pre></div><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>async</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>wait</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>ifPresent</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>asyncOperand</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitDevnum</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitOperands</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>deviceTypeOperands</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>hostOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>deviceOperands</code></td><td>any type</td></tr></tbody></table><h3 id=accwait-mliraccwaitop><code>acc.wait</code> (::mlir::acc::WaitOp)&nbsp;<a class=headline-hash href=#accwait-mliraccwaitop>¶</a></h3><p>wait operation</p><p>Syntax:</p><pre><code>operation ::= `acc.wait` ( `(` $waitOperands^ `:` type($waitOperands) `)` )?
              oilist(`async` `(` $asyncOperand `:` type($asyncOperand) `)`
              |`wait_devnum` `(` $waitDevnum `:` type($waitDevnum) `)`
              |`if` `(` $ifCond `)`
              ) attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.wait&rdquo; operation represents the OpenACC wait executable
directive.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>acc<span class=p>.</span>wait<span class=p>(</span><span class=nv>%value1</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span>
acc<span class=p>.</span>wait<span class=p>()</span> async<span class=p>(</span><span class=nv>%async1</span><span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
</code></pre></div><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>async</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>waitOperands</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>asyncOperand</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitDevnum</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=accyield-mliraccyieldop><code>acc.yield</code> (::mlir::acc::YieldOp)&nbsp;<a class=headline-hash href=#accyield-mliraccyieldop>¶</a></h3><p>Acc yield and termination operation</p><p>Syntax:</p><pre><code>operation ::= `acc.yield` attr-dict ($operands^ `:` type($operands))?
</code></pre><p><code>acc.yield</code> is a special terminator operation for block inside regions in
acc ops (parallel and loop). It returns values to the immediately enclosing
acc op.</p><p>Traits: HasParent&lt;ParallelOp, LoopOp, SerialOp>, Terminator</p><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h2 id=attribute-definition>Attribute definition&nbsp;<a class=headline-hash href=#attribute-definition>¶</a></h2><h3 id=clausedefaultvalueattr>ClauseDefaultValueAttr&nbsp;<a class=headline-hash href=#clausedefaultvalueattr>¶</a></h3><p>DefaultValue Clause</p><p>Syntax:</p><pre><code>#acc.defaultvalue&lt;
  ::mlir::acc::ClauseDefaultValue   # value
&gt;
</code></pre><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::acc::ClauseDefaultValue</code></td><td>an enum of type ClauseDefaultValue</td></tr></tbody></table><h3 id=reductionopattr>ReductionOpAttr&nbsp;<a class=headline-hash href=#reductionopattr>¶</a></h3><p>built-in reduction operations supported by OpenACC</p><p>Syntax:</p><pre><code>#acc.reduction_op&lt;
  ::mlir::acc::ReductionOp   # value
&gt;
</code></pre><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::acc::ReductionOp</code></td><td>an enum of type ReductionOp</td></tr></tbody></table><h2 id=type-definition>Type definition&nbsp;<a class=headline-hash href=#type-definition>¶</a></h2><h3 id=databoundstype>DataBoundsType&nbsp;<a class=headline-hash href=#databoundstype>¶</a></h3><p>Type for representing acc data clause bounds information</p><p>Syntax: <code>!acc.data_bounds_ty</code></p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/TensorTransformOps/><i class="fas fa-arrow-left" aria-hidden=true></i>Prev -</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/Affine/ title="'affine' Dialect">Next - 'affine' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/AMDGPUPasses/></a></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/TensorTransformOps/></a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=https://mlir.llvm.org/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>